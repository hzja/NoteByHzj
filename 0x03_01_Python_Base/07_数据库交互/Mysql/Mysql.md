# Mysql

## 事务的四基本要素(ACID)

1. **原子性：**事务开始后所有操作，要么全部做完，要么全部不做。
2. **一致性：**数据的一致性不能被破坏 。比如A向B转账，不可能A扣了钱，B却没收到。
3. **隔离性：**同一时间，只允许一个事务请求同一数据。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。
4. **持久性：**事务完成后，所有更新会被保存到数据库，不能回滚。



## 事务的并发问题

1. **脏读：**比如A事务正在对数据修改，但是还没有提交，然后B事务此时读取数据。
2. **不可重复读：**事务A多次读取同一数据，而事务B在这个过程中，对数据作了更新并提交，导致事务A两次读取同一数据时，结果不一致。
3. **幻读：**事务A读取某一范围的数据时，事务B在这个范围内插入了新行，当事务A再次读取这个范围的数据时，会发现有新的“幻影” 行。

**总结：**不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要MVCC+间隙锁。

 

## MySQL四种事务隔离级别

| 事务隔离级别                         | 脏读   | 不可重复读 | 幻读   |
| ------------------------------------ | ------ | ---------- | ------ |
| **读未提交**（read-uncommitted）     | 可能   | 可能       | 可能   |
| **读取已提交内容**（read-committed） | 不可能 | 可能       | 可能   |
| **可重复读**（repeatable-read）默认  | 不可能 | 不可能     | 可能   |
| **串行化**（serializable）           | 不可能 | 不可能     | 不可能 |

- **读未提交**：所有事务都可以看到其他未提交事务的数据，但会产生脏读。
- **读取已提交内容**：只能读取到已经提交的数据。比如A开启事务但未修改，然后B开启事务修改库存，再然后A读取数据库会发现数据还是旧的，此时B提交事务，A再次查询发现库存数据已经被B修改了，**但会导致不可重复读**
- **可重复读**：一个事务内能查到的数据状态是由这个事务开始时刻决定的。比如A开启事务但未修改，然后B开启事务修改库存，再然后A读取数据库会发现数据还是旧的，此时B提交事务，A还是不会发现库存变化，这就说明这次可以重复读了，只要事务A不提交，那么他看到的就是事务开始前的状态。但是还存在幻读，事务A读取某一范围的数据时，事务B在这个范围内插入了新行，**InnoDB可以通过MVCC和间隙锁解决幻读的问题。**
- **串行读**：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞。



## MVCC（配合间隙锁解决幻读）

**MVCC也叫多版本并发控制，原理上其实就是保存了数据在某个时间的快照**，**以及在每行数据后面创建一个字段保存创建版本号和一个字段保存删除版本号。每开始一个新的事务，系统版本号都会自动递增。**



在MVCC并发控制中，读操作可以分成两类：

1. **快照读**：读SQL属于快照读，快照读是不存在幻读的，第一次读的时候会生成快照，后面的的每一次都是读这个现有的快照
2. **当前读**：写SQL属于当前读，在执行时会读取最新的记录，即使是别的事务提交的数据也可以查询到

**总结：**只解决了读SQL的问题，没有解决写SQL问题，因为写SQL的当前读，读取的是最新的数据。可以引入间隙锁，去保证被当前读读过的数据不能被增加、修改和删除。



### MyISAM与InnoDB区别

- InnoDB 支持事务，实现了四个隔离级别，默认级别是可重复读。在这个级别下可以通过MVCC+间隙锁解决幻读；MyISAM不支持事务，但是可以在service层通过写代码自己去实现事务
- MyISAM 只支持表级锁，而 InnoDB 还支持行级锁
- InnoDB 支持外键；外键其实降低了表的查询速度，但是增加了表之间的耦合度
- InnoDB使用聚簇索引，数据和索引放在一块，都位于B+数的叶子节点上
- MyIASM 中存储了表的行数，所以不需要全表扫描



## 锁

读锁：读锁是共享的，但是只能读不能写。

写锁：写锁是排他的，从颗粒度来区分，可以分为**表锁**和**行锁**。

- 表锁：表锁会锁定整张表，比如alter修改表结构的时候会锁表。
- 行锁：表锁会锁定一整行，表锁和行锁还可以分为**悲观锁和乐观锁。**

- - 悲观锁：顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，可以通过for update实现。
  - 乐观锁： 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是通过版本号判断是否被修改。



**自旋锁**：B进程会不停循环检测A进程是否释放锁。优点是反应灵敏，缺点是占用CPU资源。适合等待时间较短的场景。

**互斥锁**：B进程会直接休眠，等待系统唤醒，优点是不消耗资源，缺点是反应慢，适合等待时间较长的场景。

**间隙锁：**仅仅锁住一个区间，可以在两条数据记录之间的间隙加锁，或者在一条数据记录之前或者之后加锁。比如在 1、2中，间隙锁的可能值有 (∞, 1)，(1, 2)，(2, ∞)，间隙锁主要用来防止幻读。



### 死锁

两个事务都持有对方需要的锁，并且都在等待对方先释放。这个就好比你有一个人质，对方有一个人质。你让对面放人，对面让你放人。



解决办法:

1. 等待超时
2. 发起死锁检测，主动回滚一条事务



**死锁产生的四个必要条件**

1. **互斥使用：**在一段时间内某资源只能被一个进程占用。其他请求者只能等待，直至占有资源的进程用毕释放。
2. **不可抢占：**进程获得后资源，不能被剥夺，只能使用完时由自己释放。
3. **请求和保持：**指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对已获得的其它资源保持不放。
4. **循环等待：**指在发生死锁时，必然存在一个进程资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。



## 有多少种日志

- **查询日志（general log）**：记录所有数据库请求信息，不管这些请求是否正确执行，都会记录日志。
- **慢查询日志（slow query log）**：记录所有超出阈值时间的SQL日志。
- **二进制日志（bin log）**：记录所有SQL的原始逻辑，在主从复制中，是主产生给从使用的。
- **中继日志（relay log）**：在主从复制中，由binlog日志转化而来，用来给从库恢复数据的。
- **重做日志（redo log）：事务已经提交**，但是数据还没有写入磁盘，如果系统发生故障，在重启Mysql服务的时候，根据redo log进行重做。
- **回滚日志（undo log）：**它里面记录事务执行时的一些信息，如果发生回滚直接根据undo log撤销就行。



## 主从同步

从库生成两个线程，一个I/O线程，一个SQL线程； 主库会生成一个 log dump 线程；i/o线程去请求主库的binlog，并将得到的binlog日志写到relay log（中继日志）； 从库SQL线程，会读取relay log，并解析成具体操作，保存到自己库里，来实现主从的操作一致。



## 什么是索引

- 索引是存储在表中特定列上的数据结构
- 索引是有序的，可以二分查找快速确定位置
- 创建索引要耗费时间和空间



### 索引种类

- **主键索引(聚簇索引)：**加速查询 + 列值唯一，和唯一索引相同，只有一个区别：主键索引定义时使用PRIMARY（派末瑞）而不是UNIQUE（U尼克）
- **二级索引(非聚簇索引)：**

- - **普通索引：**加速查询 ，唯一作用是加快对数据的访问速度
  - **唯一索引：**加速查询 + 列值唯一，除了提高访问速度，还可以避免数据重复
  - **组合索引：**多列值组成一个索引，专门用于组合搜索，效率大于多个单列索引合并。

- **全文索引：**因为普通索引只能加快出现在内容开头的字符的检索操作，通过全文索引可以解决这个问题。

- **覆盖索引：**在一次查询中，如果一个索引包含所有需要查询的字段的值，而不再需要回表查询。



- **回表：**非聚簇索引无法直接查询出所有需要的数据，所以在定位到聚簇索引(主键ID)后，还需要再次查询到想要的数据
- **页分裂：**如果使用非自增的主键，当插入节点时，为满足平衡二叉树的结构，树结构会自动重组
- **页合并：**如果使用非自增的主键，当删除节点时，为满足平衡二叉树的结构，树结构会自动重组



- **聚簇索引：**它既是索引目录，又是真实数据，叶子节点保存的都是行的真实数据，非叶子结点只记录行的Key作为目录使用，聚簇索引一般使用表的主键ID构造，每张表里只能有一个聚簇索引

- - **优点：**

  1. 叶子节点是有序的，数据访问更快。


- - **缺点：**

  1. 如果主键使用UUID这种又长又难比较的数据，插入和查找的速度会很慢，因为B+树插入的时候会进行排序。
  2. 更新代价比较大。如果数据被修改，相应的索引也要修改。


- **非聚簇索引：**也叫二级索引，叶子节点记录当前行中聚簇索引的Key，而不记录其他内容，非叶子结点只记录行的Key作为目录使用，除了构成主键ID的索引叫聚簇索引，其他索引都是非聚簇索引

- - **优点：**

  1. 因为非聚集索引的叶子节点是不存放数据的，所以更新代价比聚集索引要小。


- - **缺点：**

  1. 跟聚集索引一样，非聚集索引也依赖于有序的数据，遇到UUID会很慢。

  2. 可能会二次查询(回表) ，当查到索引对应的主键ID后，还需要根据指针再到表中查询。

- - **不一定会回表**
  - 假如用户使用SQL查询用户名，而用户名字段建立了索引，如果这个索引的key本身就是要查询的name，那么直接返回就行了，无需回表查询
  - SELECT name FROM table WHERE username='zhang';



### 最左索引原则

顾名思义：最左优先，**以最左边的为起点任何连续的索引都能匹配上**

#### 组合索引

在查询时必须包含第一个索引否则不生效（ABC）必须包含A，不管A在哪里都生效

#### 单一索引

多个索引同时使用只有第一条生效（ABC）谁在前面谁生效，ABC只有A生效，CBA那么就只有C生效



#### 组合索引和单一索引怎么选择？

对索引所有列执行或前几列搜索时，组合索引非常有用，仅对后面的列执行搜索时，组合索引无效。比如组合索引的结构与电话簿类似，人名由姓和名构成，电话簿首先按姓氏对进行排序，然后按名字对有相同姓氏的人进行排序。如果您知道姓，电话簿将非常有用；如果您知道姓和名，电话簿则更为有用，但如果您只知道名不姓，电话簿将没有用处。

**面试题**

- 假如要查 A in () AND B in (), 怎么建索引?

- - 如果使用单一索引，给选择性高的一列建索引，这里因为两个都是范围查询所以另一个是走不到索引的
  - 如果使用联合索引，给两个都加，然SQL改成（A,B) in ((1,2),(3,4)) 

- 查 A in () AND B in () 时, MySQL 是怎么利用索引的?

- - 先走一个聚簇索引，查询出行数据后再用另一列回表做筛选



### 加索引有什么原则

**以下情况适合创建索引**

1. 频繁作为查询或范围查询的字段
2. 频繁作为连表查询的列，也就是外键
3. 频繁作为排序条件的字段



**以下情况不适合创建索引**

1. 表记录太少
2. 频繁更新的字段不适合创建索引，因为还要维护索引
3. 过滤性不好的就不要创建索引了，比如说，性别



### 索引什么时候会失效？

**口诀**：模糊匹配、隐式转换、最左匹配

1. 使用%模糊搜索时，使用前置的通配符，比如查询所有叫‘明’的人，那么只能是%明
2. 出现类型的隐式转换，比如查询比较时数字102和字符串'102'是不一样的
3. 没有满足最左匹配原则



## 主从同步

从库生成两个线程，一个I/O线程，一个SQL线程； 主库会生成一个 log dump 线程；i/o线程去请求主库的binlog，并将得到的binlog日志写到relay log（中继日志）； 从库SQL线程，会读取relay log，并解析成具体操作，保存到自己库里，来实现主从的操作一致。



## MySQL调优方式

MySQL的优化可以从这几个方面考虑：

1. **正确使用索引，避免索引失效，避免全表扫描**

2. **优先使用符合业务需要的最小数据类型**

3. **SQL优化**

   a. select * 要少用，需要什么字段查什么字段

   b. 谨慎使用多表查询，因为多表查询将计算压力放在了数据库上

   c. 给前端返回数据时，避免不了要返回总行数，也就是说得单独执行count(*)，当数据多的时候会很慢，如果条件允许可以单独使用一张表存放总行数

   d. 尽量使用limit分页，减少查询不必要的数据

   e. 尽量保证索引覆盖查询

4. **集群、主从、读写分离**

5. **分库分表**

+ **水平分表**

  **概念：**以订单号做（hash、取模），将一个表中的数据拆分到多个表中。

  **场景：**单表行数多。



+ **垂直分表**

**概念：**拆分主订单和子订单，设计列表页和详情页。

**场景：**字段多，查询时磁盘IO就多。



+ **水平分库**

**概念：**以订单号做（hash、取模），将一个库中的数据拆分到多个库中。

**场景：**系统绝对并发量上来了，分表难以根本上解决问题。



+ **垂直分库**

**概念：**一般到了垂直分库的地步，几乎就可以抽象出来单独的业务模块了，按照不同业务模块，将表拆分到不同的库中。

**场景：**系统绝对并发量上来了，并且可以抽象出单独的业务模块。



## 不停机迁移：

双写方案：首先对业务代码改造，新老库的数据要同时写入，基于性能考虑，可以异步写新库，同时最好将写入新库时的失败数据单独记录下来，方便后面做补偿；然后等双写功能部署线上后，用数据迁移工具，将老库数据同步到新库，如果读出来的数据在新库里没有，或者这条数据的最后修改时间比新库的新，那么就重写这条数据；迁移过后还需校验新老数据；没问题的话可以尝试灰度的方式将读请求切换到新库，比如10%、40%、70%、100%，并且由于有双写程序存在，即使出现问题，那么直接切回旧库也足以保障系统安全性；如果说全量上线一段时间后，没有问题就可以下掉双写程序了



## 数据库优化

1. **架构升级（1主1从-->多主多从、读写分离-->水平分表、垂直分表、 水平分库、垂直分库）**
2. 但是把数据库表拆的越多，系统的复杂度也会越来越高，不得不面对的就是订单查询问题
3. 买家查询订单

1. a. 订单成交后，如果买家需要查询订单，此时我们只能拿到userid去全部表都遍历一遍。所以还需要改进订单号，之前是雪花方案【时间戳+机器ID+自增序列】。现在是雪花方案【时间戳+机器ID+自增序列+userid后两位】。并且订单具体存储到那个数据库也是根据后两位取模而来，所以同一个买家的所有订单都会存入同一个表中，只需要去这表中查找就可以了。

4. 卖家查询订单

1. a. 卖家的订单可能分散在各个表中，查询起来很费劲，所以订单存储的同时，还需按照卖家维度再存入到别的库和表中，这个表专门提供卖家查



## 为什么MySQL索引要用B+Tree呢？

索引的常用结构有：二叉树、红黑树、Hash表、B-Tree、B+Tree

1. **为什么不采用二叉树呢？**

- 普通的二叉树可能由于节点排列问题退化成链表，这样查找效率就会很低
- 平衡二叉树和红黑树都可以通过旋转调节解决了退化成链表的问题，但是会损耗一定的性能，并且不管是平衡二叉树还是红黑树最大的缺点就是它的树的高度是不可控的，如果树的层级太高了，则读写磁盘I/O就会越多，性能就会越差

2. **为什么不采用Hash表呢？**

结论：Hash索引的随机查找的时间极快，也就是常数级别O（1），但是Hash索引不适用于范围查找。所以在Redis跳表中可以使用Hash表对查找优化，将查找的时间复杂度O（logn）由降为O（1）

3. **为什么不采用B树呢？**

1. a. B树在每个节点都存数据，**B+树**的内部节点只存放键，不存放值，所以每一次读取可以获取更多的键，随机查找时效率比较高

2. b. **B+树的**叶子节点通过一条双向链表相连，所以B+树范围查找效率高，而B树每个节点key和data在一起，范围查找效率差

3. c. **B+树的随机查询效率更加稳定**。因为数据都在叶子节点，近似于二分查找

结论：**B树**只适合随机检索，而**B+树**同时支持随机检索和范围检索