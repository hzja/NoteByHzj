# 查询

## QuerySet

Django中的QuerySet本质上是一个懒加载的对象，当产生数据库查询操作时，只是会返回一个QuerySet对象，等你真正用到它的时候才会执行查询（和迭代器功能很相似）。

通过模型类.objects属性可以调用如下函数，实现对模型类对应的数据表的查询。

| 函数名                                                       | 功能                                                         | 返回值                                                       |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **get**                                        UserProfile.objects.get(mobile='15830900798') | 返回结果只有一条                                             | 返回值是一个模型类对象<UserProfile: zhengzishuo>             |
| **all**                                                                                    UserProfile.objects.all() | 返回模型类对应表格中的所有数据                               | 返回值是QuerySet类型<QuerySet [<UserProfile: admin>, <UserProfile: zhengzishuo>]> |
| **filter**                                 UserProfile.objects.filter(mobile='15830900798') | 返回满足条件的所有数据                                       | 返回值是QuerySet类型<QuerySet [<UserProfile: zhengzishuo>]>  |
| **exclude**                      UserProfile.objects.exclude(mobile='15830900798') | 返回不满足条件的所有数据                                     | 返回值是QuerySet类型<QuerySet [<UserProfile: admin>]>        |
| **order_by** UserProfile.objects.exclude(mobile='15830900798').order_by('id') | 对查询结果进行排序                                           | 返回值是QuerySet类型                                         |
| **values**   UserProfile.objects.filter(mobile='15830900798').values('mobile') | 返回查询对象的值                                             | 返回值是QuerySet类型 <QuerySet [{'mobile': '15830900798'}]>  |
| **first**           UserProfile.objects.exclude(mobile='15830900798').first() | 返回queryset中匹配到的第一个对象，如果没有匹配到对象则为None，如果queryset没有定义排序，则按主键自动排序 | 返回值是一个模型类对象 <UserProfile: admin>                  |
| **exists**             UserProfile.objects.filter(mobile='15830900798').exists() | 判断查询的数据是否存在，存在时返回True，否则返回False        | 返回值是一个布尔值True                                       |
| **aggregate**                     UserProfile.objects.all().aggregate(Count('id')) | 对查询结果进行聚合操作                                       | **返回值是一个字典**{'id__count': 5}                         |
| **count **                                                    UserProfile.objects.all().count() | 统计满足条件数据的数目                                       | **返回值是一个数字5**                                        |



## filter模糊查询

~~~ python
语法格式：
	模型类属性名__条件名=值
~~~



### a)判断条件名 contains，endswith

~~~ python
例：查询书名包含'传'的图书 contains
	BookInfo.objects.filter(btitle__contains='传')
例：查询书名以'部'结尾的图书 endswith
	BookInfo.objects.filter(btitle__endswith='部')
~~~



### c)空查询 isnull

~~~ python 
例：查询书名不为空的图书。isnull 
	BookInfo.objects.filter(btitle__isnull=False)
~~~



### d)范围查询 in

~~~ python 
例：查询id为1或3或5的图书。
	BookInfo.objects.filter(id__in = [1,3,5])
~~~



### e)比较查询 

~~~ python 
大于gt
小于lt
大于等于 gte
小于等于 lte
例：查询id大于3的图书。
BookInfo.objects.filter(id__gt=3)
~~~



### f)日期查询

~~~ python 
例：查询1980年发表的图书。
	BookInfo.objects.filter(bpub_date__year=1980)
例：查询1980年1月1日后发表的图书。
	from datetime import date
	BookInfo.objects.filter(bpub_date__gt=date(1980,1,1))
~~~



## **F对象**

**作用：**用于类属性之间的比较。

**使用之前需要先导入**：

~~~python
	from django.db.models import F
例：查询图书阅读量大于评论量图书信息。
	BookInfo.objects.filter(bread__gt=F('bcomment'))
例：查询图书阅读量大于2倍评论量图书信息。
	BookInfo.objects.filter(bread__gt=F('bcomment')*2)
~~~



## **Q对象**

**作用：**用于查询时条件之间的逻辑关系。not and or，可以对Q对象进行&|~操作。

**使用之前需要先导入：**

~~~  python
	from django.db.models import Q

例：查询id大于3且阅读量大于30的图书的信息。
	BookInfo.objects.filter(id__gt=3, bread__gt=30)
	BookInfo.objects.filter(Q(id__gt=3)&Q(bread__gt=30))

例：查询id大于3或者阅读量大于30的图书的信息。
	BookInfo.objects.filter(Q(id__gt=3)|Q(bread__gt=30))

例：查询id不等于3图书的信息。
	BookInfo.objects.filter(~Q(id=3))
~~~



## 两大特性

- 惰性执行：创建查询集不会访问数据库，直到调用数据时，才会访问数据库，调用数据的情况包括迭代、序列化、与if合用。
- 缓存：使用同一个查询集，第一次使用时会发生数据库的查询，然后把结果缓存下来，再次使用这个查询集时会使用缓存的数据。



## 总结

![1580307204415-f82bf2df-c815-4921-9e3a-907fd2213b29](D:\Note\python\Django\图片\1580307204415-f82bf2df-c815-4921-9e3a-907fd2213b29.png)