# **事务**

## 数据库事务

> 保存订单数据中涉及到多张表（OrderInfo、OrderGoods、SKU）数据修改，对这些数据的修改应该是一个整体事务即要么一起成功要么一起失败；
>
> Django中对于数据库的事务，默认每执行一句数据库操作便会自动提交，需在保存订单中自己控制数据库事务执行流程；
>
> Django中可通过`django.db.transaction`模块提供的`atomic`定义一个事务；



### 悲观锁

最近做的一消耗能量型需求中因 Nginx 的重复转发或者客户端的连续点击，造成了同样的接口在极短时间内被调用两次，数据库中出现了重复记录。

~~~ python
from django.shortcuts import render
from django.http import HttpResponse
from django.views.generic import View
from django.db import transaction
from 应用名.models import 模型类名
 
 
# 类视图 (并发，悲观锁)
class MyView(View):
    
    @transaction.atomic
    def post(self, request):
        # select * from 表名 where id=1 for update;  
        # for update 就表示锁,只有获取到锁才会执行查询,否则阻塞等待。
        obj = 模型类名.objects.select_for_update().get(id=1)
        # 等事务提交后，会自动释放锁。
        return HttpResponse('ok')
    
    
    from django.db import IntegrityError, transaction

    
    # 这个例子中，即使generate_relationships()中的代码打破了数据完整性约束，你仍然可以在add_children()中执行数据库操作，并且create_parent()产生的更改也有效。需要注意的是，在调用handle_exception()之前，generate_relationships()中的修改就已经被安全的回滚了。因此，如果有需要，你照样可以在异常处理函数中操作数据库。
    @transaction.atomic
    def post(self, request):
        create_parent()
        try:
            with transaction.atomic():
                generate_relationships()
        except IntegrityError:
            handle_exception()

        add_children()
        # 此方法事务管理代码
        进入最外层atomic代码块时开启一个事务；
        进入内部atomic代码块时创建保存点；
        退出内部atomic时释放或回滚事务；注意如果有嵌套，内层的事务也是不会提交的，可以释放（正常结束）或者回滚
        退出最外层atomic代码块时提交或者回滚事务；
~~~



### 乐观锁

> 乐观锁其实并不真上锁而是通过SQL的where子句中的条件是否满足来判断是否满足更新条件来更新数据库，通过受影响行数判断是否更新成功，如果更新失败可以再次进行尝试，如果多次尝试失败就返回更新失败的结果。
>
> 使用乐观锁时，必须设置数据库的隔离级别是Read Committed(读取已提交内容，可以读到其他线程已提交的数据)。如果隔离级别是Repeatable Read(可重复读，读到的数据都是开启事务时刻的数据，即使其他线程提交更新数据，该线程读取的数据也是之前读到的数据)，乐观锁如果第一次尝试失败，那么不管尝试多少次都会失败。 (Mysql数据库的默认隔离级别是Repeatable Read，需要修改成Read Committed)。

~~~ python
from django.shortcuts import render
from django.http import JsonResponse
from django.views.generic import View
from django.db import transaction
from 应用名.models import GoodsSKU
 
 
# 类视图 (并发，乐观锁)
class MyView(View):
    
    @transaction.atomic
    def post(self, request):
        '''订单创建'''
        count = 3   # 订购3件商品
        
        # 设置事务保存点
        s1 = transaction.savepoint()
        
        # 乐观锁，最多尝试5次
        for i in range(5):
            # 查询商品的信息(库存)
            try:
                sku = GoodsSKU.objects.get(id=1)
            except:
                # 商品不存在
                transaction.savepoint_rollback(s1)
                return JsonResponse({'res': 1, 'errmsg': '商品不存在'})
 
            # 判断商品的库存
            if count > sku.stock:
                transaction.savepoint_rollback(s1)
                return JsonResponse({'res': 2, 'errmsg': '商品库存不足'})
 
            # 更新商品的库存和销量
            orgin_stock = sku.stock   # 原库存 (数据库隔离级别必须是Read Committed；如果是Repeatable Read,那么多次尝试读取的原库存都是一样的,读不到其他线程提交更新后的数据。)
            new_stock = orgin_stock - count   # 更新后的库存
            new_sales = sku.sales + count   # 更新后的销量
 
            # update 商品表 set stock=new_stock, sales=new_sales where id=1 and stock = orgin_stock
            # 通过where子句中的条件判断库存是否进行了修改。(并发，乐观锁)
            # 返回受影响的行数
            res = GoodsSKU.objects.filter(id=1, stock=orgin_stock).update(stock=new_stock, sales=new_sales)
            if res == 0:  # 如果修改失败
                if i == 4:
                    # 如果尝试5次都失败
                    transaction.savepoint_rollback(s1)
                    return JsonResponse({'res': 3, 'errmsg': '下单失败'})
                continue  # 再次尝试
 
            # 否则更新成功
            # 跳出尝试循环
            break
 
        # 提交事务
        transaction.savepoint_commit(s1)
 
        # 返回应答
        return JsonResponse({'res': 4, 'message': '创建成功'})
~~~

在Django中，还提供了保存点的支持，可以在事务中创建保存点来记录数据的特定状态，数据库出现错误时，可以恢复到数据保存点的状态

~~~python
from django.db import transaction

# 创建保存点
save_id = transaction.savepoint()  
# 回滚到保存点
transaction.savepoint_rollback(save_id)
# 提交从保存点到当前状态的所有数据库事务操作
transaction.savepoint_commit(save_id)
~~~



### 总结

并发较少时建议用乐观锁减少加锁、释放锁的开销；并发较高时建议用悲观锁。如乐观锁多次尝试的代价较大也建议用悲观锁。