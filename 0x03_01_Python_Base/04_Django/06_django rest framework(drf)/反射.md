# 反射

它可以把字符串映射成变量或方法然后可以去执行调用、修改等操作
它有四个重要的方法：
	●getattr 获取指定字符串名称的对象属性
	●setattr 为对象设置一个属性
	●hasattr 判断对象是否有对应的对象（字符串）
	●delattr 删除对象的属性
attr是属性英文的前几个字母，属性指的是类中类变量、实例变量和方法。但是要注意不能是私有的，如果你的变量是以“_”开头，那将无法获取。

**getattr()函数的使用方法：**接收2个参数，前面的是一个类或者模块，后面的是一个字符串，注意了！是个字符串！



## 反射到底有什么用？

考虑有这么一个场景：需要根据用户输入url的不同，调用不同的函数，实现不同的操作，也就是一个WEB框架的url路由功能。路由功能是web框架里的核心功能之一，例如Django的urls。

~~~ python
import commons 

def run():
    inp = input("请输入您想访问页面的url：  ").strip()
    func = getattr(commons, inp)
    func() 

if __name__ == '__main__':
    run()
~~~

**原理：**func = getattr(commons,inp)语句是关键，通过getattr()函数，从commons模块里，查找到和inp字符串“外形”相同的函数名，并将其返回，然后赋值给func变量。变量func此时就指向那个函数，func()就可以调用该函数。



## 应用场景

 1、View类的dispatch通过接收到的请求方法变为小写从而使用反射得到类中的相对应方法

~~~ python
class View(object):
     def dispatch(self, request, *args, **kwargs):
            
         if request.method.lower() in self.http_method_names:
             handler = getattr(self, request.method.lower(), self.http_method_not_allowed)
         else:
             handler = self.http_method_not_allowed
         return handler(request, *args, **kwargs)
~~~

 2、settings配置中心和中间件使用了反射

~~~ python 
import importlib

# 获取到settings文件的路径
self.SETTINGS_MODULE = settings_module

# 通过importlib.import_module获取到settings文件对象
mod = importlib.import_module(self.SETTINGS_MODULE) 


# 循环获取到settings文件对象里面的属性
for setting in dir(mod):
    # 得到大写的属性名
    if setting.isupper():
    	# 得到属性值比如中间件等其他配置属性
    	setting_value = getattr(mod, setting)
~~~



3、CMDB也使用了使用了反射

~~~ python 
import importlib
import settings


def get_server_info(ssh, hostname):
    server_info = {}

    for key, path in settings.PLUGIN_CLASS_DICT.items():
        module_path, class_name = path.rsplit('.', maxsplit=1)
        module = importlib.import_module(module_path)
        # cls可以获取到类
        cls = getattr(module, class_name)
        # 将cls类实例化，再创建对象
        plugin_object = cls()
        # 指定类对象中的方法
        info = plugin_object.process(ssh, hostname)

        server_info[key] = info
    return server_info
~~~



## 静态导入 import

一般而言，当我们需要某些功能的模块时（无论是内置模块或自定义功能的模块），可以通过import module 或者 from * import module的方式导入，这属于静态导入，很容易理解。



## 动态导入 importlib.import_module

而如果当我们需要在程序的运行过程时才能决定导入某个文件中的模块时，并且这些文件提供了同样的接口名字，上面说的方式就不适用了，这时候需要使用python 的动态导入。还有一种情况：我们有时希望从配置文件等地获取要被动态加载的 module，但是所读取的配置项通常为字符串类型，无法用 import 加载