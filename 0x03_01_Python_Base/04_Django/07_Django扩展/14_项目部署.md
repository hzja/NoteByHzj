# Supervisor项目部署

## 一、supervisor简介

我们在服务器上经常碰到要跑一些守护进程。平常我的做法是开一个screen或者nohup，然后启动软件。可是这种做法毕竟不是长久之计，机器重启或者不小心kill了某个进程，后台运行的这个进程可能就不小心死掉了。后来开源界的大牛建议我用supervisor。尝试之后，简直是如获至宝。

Supervisor 是一个客户端服务器系统，包含有两个程序

1. Supervisor的server部分称为supervisord。主要负责管理子进程，响应客户端的命令，log子进程的输出，创建和处理不同的事件
2. Supervisor的命令行客户端supervisorctl。它可以与不同的supervisord进程进行通信，获取子进程信息，管理子进程



### 简单

通常管理linux进程的时候，一般来说都需要自己编写一个能够实现进程start/stop/restart/reload功能的脚本，然后丢到/etc/init.d/下面。这么做有很多不好的地方，第一我们要编写这个脚本，这就很耗时耗力了。第二，当这个进程挂掉的时候，linux不会自动重启它的，想要自动重启的话，我们还要自己写一个监控重启脚本。而，supervisor则可以完美的解决这些问题。

### 进程组

supervisor可以对进程组统一管理，也就是说咱们可以把需要管理的进程写到一个组里面，然后我们把这个组作为一个对象进行管理，如启动，停止，重启等等操作。而linux系统则是没有这种功能的，我们想要停止一个进程，只能一个一个的去停止，要么就自己写个脚本去批量停止。

### 有效性

当supervisor的子进程挂掉的时候，操作系统会直接给supervisor发信号。而其他的一些类似supervisor的工具，则是通过进程的pid文件，来发送信号的，然后定期轮询来重启失败的进程。显然supervisor更加高效。



## 二、supervisor安装

1. 配置好yum源后，可以直接安装

~~~ shell
pip install supervisor

# 生成配置文件
echo_supervisord_conf > /etc/supervisord.conf
~~~



## 三、supervisor使用

supervisor配置文件：vim `/etc/supervisord.conf`

~~~ shell
[unix_http_server]
file=/tmp/supervisor.sock   ;UNIX socket 文件，supervisorctl 会使用
;chmod=0700                 ;socket文件的mode，默认是0700
;chown=nobody:nogroup       ;socket文件的owner，格式：uid:gid
 
[inet_http_server]         ;HTTP服务器，提供web管理界面
port=0.0.0.0:9001        ;Web管理后台运行的IP和端口，如果开放到公网，需要注意安全性
username=user              ;登录管理后台的用户名
password=123               ;登录管理后台的密码
 
[supervisord]
logfile=/tmp/supervisord.log ;日志文件，默认是 $CWD/supervisord.log
logfile_maxbytes=50MB        ;日志文件大小，超出会rotate，默认 50MB，如果设成0，表示不限制大小
logfile_backups=10           ;日志文件保留备份数量默认10，设为0表示不备份
loglevel=info                ;日志级别，默认info，其它: debug,warn,trace
pidfile=/tmp/supervisord.pid ;pid 文件
nodaemon=false               ;是否在前台启动，默认是false，即以 daemon 的方式启动
minfds=1024                  ;可以打开的文件描述符的最小值，默认 1024
minprocs=200                 ;可以打开的进程数的最小值，默认 200
 
[supervisorctl]
serverurl=unix:///tmp/supervisor.sock ;通过UNIX socket连接supervisord，路径与unix_http_server部分的file一致
;serverurl=http://127.0.0.1:9001 ; 通过HTTP的方式连接supervisord
        

# 以上东西都不需要改，就加下面这行
[include]
files=/etc/supervisor.d/*.conf  #若你本地无/etc/supervisor.d目录，请自建
~~~

注：supervisor的配置文件默认是不全的，不过在大部分默认的情况下，上面说的基本功能已经满足。



子进程配置文件路径：`/etc/supervisord.d/`

~~~ shell
mkdir /etc/supervisor.d
cd /etc/supervisor.d
vim django.conf # 这里的文件名称自定义
~~~



### Django的配置文件

~~~ shell
#项目名
[program:django]
#脚本目录
directory=/root/social_engineering/
#脚本执行命令
command=/root/anaconda3/bin/python manage.py runserver 0.0.0.0:8000

#supervisor启动的时候是否随着同时启动，默认True
autostart=true
#当程序exit的时候，这个program不会自动重启,默认unexpected，设置子进程挂掉后自动重启的情况，有三个选项，false,unexpected和true。如果为false的时候，无论什么情况下，都不会被重新启动，如果为unexpected，只有当进程的
退出码不在下面的exitcodes里面定义的
autorestart=true
#这个选项是子进程启动多少秒之后，此时状态如果是running，则我们认为启动成功了。默认值为1
startsecs=1

#脚本运行的用户身份 

#日志输出 
stderr_logfile=/tmp/django_stderr.log
stdout_logfile=/tmp/django_stdout.log
#把stderr重定向到stdout，默认 false
redirect_stderr = true
#stdout日志文件大小，默认 50MB
stdout_logfile_maxbytes = 20
#stdout日志文件备份数
stdout_logfile_backups = 20
~~~



### Celery的配置文件

~~~ shell
#项目名
[program:celery]
#脚本目录
directory=/root/social_engineering/
#脚本执行命令
command=/root/anaconda3/bin/celery -A tasks worker --loglevel=info

#supervisor启动的时候是否随着同时启动，默认True
autostart=true
#程序崩溃时自动重启
autorestart=true
#这个选项是子进程启动多少秒之后，此时状态如果是running，则我们认为启动成功了。默认值为1
startsecs=1

#脚本运行的用户身份 

#日志输出 
stderr_logfile=/tmp/celery_stderr.log
stdout_logfile=/tmp/celery_stdout.log
#把stderr重定向到stdout，默认 false
redirect_stderr = true
#stdout日志文件大小，默认 50MB
stdout_logfile_maxbytes = 20
#stdout日志文件备份数
stdout_logfile_backups = 20
~~~

注：默认子进程配置文件为ini格式，可在supervisor主配置文件中修改



### 多个进程管理

按照官方文档的定义，一个 [program:x] 实际上是表示一组相同特征或同类的进程组，也就是说一个 [program:x] 可以启动多个进程。这组进程的成员是通过 numprocs 和 process_name 这两个参数来确定的

~~~ shell
;设置进程的名称，使用 supervisorctl 来管理进程时需要使用该进程名
[program:foo] 

;若 numprocs 不为1，process_name 的表达式中一定要包含 process_num 来区分不同的进程
numprocs=2                   
process_name=%(program_name)s_%(process_num)02d; 
~~~

上面这个例子会启动两个进程，process_name 分别为 foo:foo_01 和 foo:foo_02。通过这样一种方式，就可以用一个 [program:x] 配置项，来启动一组非常类似的进程。



## 四、supervisor命令说明

### 启动服务

~~~ shell
supervisord -c /etc/supervisord.conf
~~~



### 常用命令

~~~tex
supervisorctl status        //查看所有进程的状态
supervisorctl stop django       //停止django
supervisorctl start django      //启动django
supervisorctl restart       //重启django
supervisorctl update        //配置文件修改后使用该命令加载新的配置
supervisorctl reload        //重新启动配置中的所有程序
~~~

注：把django换成all可以管理配置中的所有进程。直接输入`supervisorctl`进入supervisorctl的shell交互界面，此时上面的命令不带supervisorctl可直接使用。

![1589883163606-3848f22c-9087-4bb4-9c5b-7a9f5352df18](D:\Note\python\Django\图片\1589883163606-3848f22c-9087-4bb4-9c5b-7a9f5352df18.png)



## 五、访问Web界面

[http://IP:8000/](http://101.133.228.149:8000/)

![1589882918774-75c39d79-2407-4b18-89e1-0783c8f20ad7](D:\Note\python\Django\图片\1589882918774-75c39d79-2407-4b18-89e1-0783c8f20ad7.png)

**supervisorctl后台管理界面**

[http://IP:9001/](http://101.133.228.149:8000/)

![1589882526625-02cbe1e3-3db3-4cf3-956c-3afb19fdde57](D:\Note\python\Django\图片\1589882526625-02cbe1e3-3db3-4cf3-956c-3afb19fdde57.png)



## 六、可能会遇到的问题

解决unix:///tmp/supervisor.sock no such file的问题

在supervisor默认配置中，其启动的sock等都会放到tmp目录，而tmp目录会自动清理导致无法使用supervisorctl



1、打开配置文件

~~~ bash
vim /etc/supervisord.conf
~~~

这里把所有的/tmp路径改掉，/tmp/supervisor.sock 改成 /var/run/supervisor.sock，/tmp/supervisord.log 改成 /var/log/supervisor.log，/tmp/supervisord.pid 改成 /var/run/supervisor.pid 要不容易被linux自动清掉



2、修改权限

~~~ bash
sudo chmod 777 /run
sudo chmod 777 /var/log
~~~

如果没改，启动报错 IOError: [Errno 13] Permission denied: '/var/log/supervisord.log'



3、创建supervisor.sock

~~~ bash
sudo touch /var/run/supervisor.sock
sudo chmod 777 /var/run/supervisor.sock
~~~



4、启动supervisord，注意stop之前的实例或杀死进程

~~~ bash
supervisord -c /etc/supervisord.conf
~~~







# Docker+Nginx+uWSGI项目部署

## 使用Nginx+uWSGI部署Django项目

uWSGI实现了WSGI的所有接口，是一个快速、自我修复、开发人员和系统管理员友好的服务器。uWSGI代码完全用C编写，效率高、性能稳定



### uWSGI原理

1. 无论是Django自带的Web Server还是uWSGI，在启动时都会去加载你的Django项目下的wsgi.py文件，这个文件内部返回了一个application实例
2. application实例其实也是一个可调用对象，因为这个类中实现了call使得它能被像函数一样调用
3. 在uWSGI中，读取完application后，会起一个主进程去监听用户的请求，根据你的配置的进程数会产生相同数量的子进程，例如你配置2个进程，则产生2个子进程。一旦有请求过来，则会让子进程去执行请求
4. 假如有3个请求同时过来，而你只配置了2个进程去处理请求，那么第三个请求将会阻塞。例如一个请求需要执行10s，则第三个请求需要执行20s



### 目录结构

~~~ nginx
heelo/
├── app
│   ├── admin.py
│   ├── apps.py
│   ├── __init__.py
│   ├── migrations
│   │   ├── __init__.py
│   │   └── __pycache__
│   │       └── __init__.cpython-35.pyc
│   ├── models.py
│   ├── __pycache__
│   │   ├── admin.cpython-35.pyc
│   │   ├── admin.cpython-37.pyc
│   │   ├── apps.cpython-35.pyc
│   │   ├── apps.cpython-37.pyc
│   │   ├── __init__.cpython-35.pyc
│   │   ├── __init__.cpython-37.pyc
│   │   ├── models.cpython-35.pyc
│   │   ├── models.cpython-37.pyc
│   │   ├── urls.cpython-35.pyc
│   │   ├── urls.cpython-37.pyc
│   │   ├── views.cpython-35.pyc
│   │   └── views.cpython-37.pyc
│   ├── tests.py
│   ├── urls.py
│   └── views.py
├── db.sqlite3
├── heelo
│   ├── __init__.py
│   ├── __pycache__
│   │   ├── __init__.cpython-35.pyc
│   │   ├── __init__.cpython-37.pyc
│   │   ├── settings.cpython-35.pyc
│   │   ├── settings.cpython-37.pyc
│   │   ├── urls.cpython-35.pyc
│   │   ├── urls.cpython-37.pyc
│   │   └── wsgi.cpython-35.pyc
│   ├── settings.py
│   ├── urls.py
│   └── wsgi.py
├── manage.py
├── templates
├── uwsgi.ini
├── uwsgi.log
└── uwsgi.pid
~~~



### 安装uWSGI

~~~ BA
pip install uwsgi
ln -s /root/anaconda3/lib/libicui18n.so.58 /lib64/libicui18n.so.58
ln -s /root/anaconda3/lib/libicuuc.so.58 /lib64/libicuuc.so.58
ln -s /root/anaconda3/lib/libicudata.so.58 /lib64/libicudata.so.58
cp /root/anaconda3/lib/libstdc++.so.6 /lib64/
~~~



### 配置uWSGI

~~~ bash
[uwsgi]
# 如果使用nginx+uwsgi来部署Django项目时，就用这行
socket=127.0.0.1:8080
# 如果单独使用uwsgi来部署Django项目时，就用这一行
#http=127.0.0.1:8080
# 项目目录
chdir=/root/Django/heelo
# 项目中wsgi.py文件的目录，相对于项目目录
wsgi-file=heelo/wsgi.py
# 使用进程数
processes=4
# 服务器进程开启的线程数量
threads=2
# 开启master, 将会多开一个管理进程, 管理其他服务进程
master=True
# 指定进程号文件(会自动创建)。这个也很重要，如果要重启和关闭uwsgi，则需要这个文件，里面记录了进程号。
pidfile=uwsgi.pid
# 指定日志文件(会自动创建)。这个很重要，如果uwsgi出现错误，可以通过日志文件来查错
daemonize=uwsgi.log
~~~



### 启动

~~~ BASH
uwsgi --ini uwsgi.ini
~~~



### 查看

~~~ bash
ps ajx|grep uwsgi
~~~



### 停止

~~~ bash
uwsgi --stop uwsgi.pid
~~~



### 在浏览器中输入如下网址

~~~ bash
http://127.0.0.1:8080/
~~~



### 安装Nginx

~~~ bash
sudo yum install epel-release
sudo yum install python-devel nginx

service nginx start        //启动nginx服务

service nginx stop        //关闭nginx服务

service nginx restart     //重启nginx服务
~~~



### 配置Nginx

进入nginx的默认目录

~~~ bash
cd /etc/nginx/conf.d    //进入nginx默认目录
~~~

~~~nginx
server {
        listen 80;
        server_name localhost;
        charset UTF-8;
        #日志文件。如果nginx出现问题，都可以通过日志文件来查错。
        access_log /var/log/nginx/MyProject_access.log;  
        error_log /var/log/nginx/MyProject_error.log;
        client_max_body_size 75M;

        location / {
        		# 使用uwsgi服务器
            include uwsgi_params;
            # 把浏览器发来的请求转发到uwsgi的8080端口
            uwsgi_pass 127.0.0.1:8080;
            uwsgi_read_timeout 30;   #链接超时时间
        }
        location /static/{    # 处理静态文件，处理链接是以/static/开头的请求。即：如果是静态文件，就不用发给uwsgi了，nginx自己处理。
            alias /root/Django/heelo/static/;       # 项目静态文件的绝对路径。即：告诉nginx应该去哪里找静态文件。后面会介绍。
       }
   }
}
~~~



### 重启Nginx

~~~ bash
service nginx restart     //重启nginx服务
~~~



## 使用Docker+Nginx+uWSGI部署Django项目

之前一系列繁琐的部署步骤让我们感到痛苦。这些痛苦包括：

- 要去服务器上执行 n 条命令
- 本地环境和服务器环境不一致，明明本地运行没问题，一部署服务器上就挂，死活启动不起来
- 如果上面的情况发生了，又要去服务器上执行 n 条命令以解决问题
- 本地更新了代码，部署上线后，上述历史又重演一遍，想死的心都有了

那么我们有没有办法，让本地开发环境和线上环境保持一致？这样我们在部署上线前，就可以在本地进行验证，只要验证没问题，我们就有 99% 的把握保证部署上线后也没有问题（1%保留给程序玄学）

更多详细使用方法请参考我另一篇文章 https://www.yuque.com/keep_running/devops/ek8my4



### 环境要求

python3.5

django2.0.5

docker-1.13.1

docker-compose-1.18.0

**注意：**建议版本不要差距太大



### 目录结构

~~~ bash
heelo/
├── app
│   ├── admin.py
│   ├── apps.py
│   ├── __init__.py
│   ├── migrations
│   │   ├── __init__.py
│   │   └── __pycache__
│   │       └── __init__.cpython-35.pyc
│   ├── models.py
│   ├── __pycache__
│   │   ├── admin.cpython-35.pyc
│   │   ├── apps.cpython-35.pyc
│   │   ├── __init__.cpython-35.pyc
│   │   └── models.cpython-35.pyc
│   ├── tests.py
│   ├── urls.py
│   └── views.py
├── conf
│   └── uwsgi.ini
├── db.sqlite3
├── docker-compose.yml
├── Dockerfile
├── heelo
│   ├── __init__.py
│   ├── __pycache__
│   │   ├── __init__.cpython-35.pyc
│   │   ├── settings.cpython-35.pyc
│   │   ├── urls.cpython-35.pyc
│   │   └── wsgi.cpython-35.pyc
│   ├── settings.py
│   ├── urls.py
│   └── wsgi.py
├── manage.py
├── nginx
│   ├── Dockerfile
│   └── nginx.conf
├── requirements.txt
├── static
│   └── index.html
├── templates
└── uwsgi.log
~~~



### 编写Dockerfile

这里指定 Python 和Nginx是docker官方提供的

构建python3.5环境镜像，在里面解决了依赖库并把代码放进去

/root/heelo/Dockerfile

~~~ dockerfile
FROM python3.5
RUN mkdir /code
WORKDIR /code
COPY requirements.txt  /code
RUN pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple -r requirements.txt
RUN rm -f requirements.txt
RUN mkdir heelo
ADD . /code/heelo
~~~

**注意：**如果python3.5的镜像拉不下来，可以自己search并pull选择一个标准python镜像



构建nginx镜像，将配置文件替换

/root/heelo/nginx/Dockerfile

~~~ dockfile
FROM nginx
WORKDIR /etc/nginx/
RUN cp nginx.conf ./nginx.conf.bak
COPY nginx.conf ./
CMD ["nginx", "-g", "daemon off;"]
~~~



### 编写Nginx配置文件

/root/heelo/nginx/nginx.conf

~~~ nginx
events {
    worker_connections 1024;
}
http {
        sendfile  on;
        include  /etc/nginx/mime.types;
        default_type  application/octet-stream;

        server {
            listen 80;
            server_name localhost;
            location / {
      				 # 下面两行为核心
               include uwsgi_params;
               uwsgi_pass 10.127.2.3:8000;

            }
            location /static/ {
               alias /code/heelo/static/;
            }
        }
}
~~~



### 编写uwsgi文件

/root/heelo/conf/uwsgi.ini

~~~ bash
[uwsgi]
socket = 0.0.0.0:8000
chdir = /code/heelo
wsgi-file = heelo/wsgi.py
master = True
processes = 4
threads=2
~~~



### 编写模块依赖文件

/root/heelo/requirements.txt

~~~ bash
certifi==2018.8.24
Django==2.0.5
djangorestframework==3.11.0
pytz==2019.3
wincertstore==0.2
uWSGI==2.0.18
~~~



### 编写docker-compose启动文件

/root/heelo/docker-compose.yml

~~~ yaml
version: '3'

services:
  db:
    image: postgres
    restart: always
    environment:
      POSTGRES_PASSWORD: 12345
    networks:
      net-django:
        ipv4_address: 10.127.2.4

  web:
    build: .
    ports:
      - 8000:8000
    restart: always
    privileged: true
    depends_on:
      - db
    networks:
      net-django:
        ipv4_address: 10.127.2.3
    command: bash -c "uwsgi --ini /code/heelo/conf/uwsgi.ini"

  nginx:
    container_name: nginx-container
    restart: always
    depends_on:
      - web
    links:
      - "web:web"
    build: ./nginx
    # 将nginx监听端口映射到宿主机的8080端口
    ports:
      - 8080:80
    networks:
      net-django:
        ipv4_address: 10.127.2.2

networks:
  net-django:
    ipam:
      config:
        - subnet: 10.127.2.0/24
~~~



### 构建容器

~~~ bash
docker-compose build # 可以省略
docker-compose up -d
~~~

![1582723533601-4e5328e5-9dca-47a9-aae7-0213c468e456](D:\Note\python\Django\图片\1582723533601-4e5328e5-9dca-47a9-aae7-0213c468e456.png)

**注意：**此处务必确保三个容器都是up状态，可以使用docker logs <NAME> 查看容器日志



# Vue+Django项目部署

## 一、将代码搞到服务器上

~~~ bash
在linux上直接下载
wget https://files.cnblogs.com/files/pyyu/luffy_boy.zip
wget https://files.cnblogs.com/files/pyyu/07-luffy_project_01.zip
~~~



## 二、先从前端vue搞起

要在服务器上编译打包vue项目，必须得有node环境

~~~ bash
# 下载node二进制包，此包已经包含node，不需要再编译
wget https://nodejs.org/download/release/v8.6.0/node-v8.6.0-linux-x64.tar.gz

# 解压缩
tar -zxvf node-v8.6.0-linux-x64.tar.gz

# 进入node文件夹
[root@web02 opt]# cd node-v8.6.0-linux-x64/
[root@web02 node-v8.6.0-linux-x64]# ls
bin  CHANGELOG.md  etc  include  lib  LICENSE  README.md  share
[root@web02 node-v8.6.0-linux-x64]# ls bin
node  npm  npx
~~~



将node命令，添加至linux环境变量,修改vim /etc/profile，写入

~~~ bash
PATH=$PATH:/opt/node-v8.6.0-linux-x64/bin
~~~



读取文件，生效path

~~~ bash
source /etc/profile
~~~

 	

测试path

~~~bash
[root@web02 node-v8.6.0-linux-x64]# node -v
v8.6.0

[root@web02 node-v8.6.0-linux-x64]# npm -v
5.3.0 
~~~



node环境有了，安装node模块以及打包node项目

~~~ bash
# 进入vue源码目录
cd 07-luffy_project_01/

# 安装vue模块，默认去装package.json的模块内容，如果出现模块安装失败，手动再装
npm install 
此时注意，你本地写的vue代码，接口很可能连接的服务器地址有问题，注意Axios.POST提交的地址，一定得发送给django应用（如果用了nginx，就发送给nginx的入口端口）
这里为了试验方便，将vue项目和django项目放在了一台服务器，通过nginx反向代理功能(8000端口)，转发vue请求给django(9000)

# 准备编译打包vue项目，替换配置文件所有地址，改为服务器地址
sed -i 's/127.0.0.1/192.168.119.12/g' /opt/07-luffy_project_01/src/restful/api.js

# 此时打包vue项目，生成一个dist静态文件夹
npm run build

# 如果项目没有错误的话，就能够看到所有的组件、css、图片等都被webpack自动打包到dist目录下
[root@web02 07-luffy_project_01]# ls dist/
index.html static
~~~

至此vue代码结束，只需让nginx配置找到vue的index.html首页文件即可；

nginx这里不做解释，编译安装好即可



## 三、配置后端代码

解决虚拟环境，保证项目干净隔离

激活虚拟环境venv1，在虚拟环境下，安装项目所需的依赖模块

~~~ bash
[root@web02 opt]# cat requirements.txt
certifi==2018.11.29
chardet==3.0.4
crypto==1.4.1
Django==2.1.4
django-redis==4.10.0
django-rest-framework==0.1.0
djangorestframework==3.9.0
idna==2.8
Naked==0.1.31
pycrypto==2.6.1
pytz==2018.7
PyYAML==3.13
redis==3.0.1
requests==2.21.0
shellescape==3.4.1
urllib3==1.24.1
uWSGI==2.0.17.1
~~~



这个代码数据库用的是sqllite，不需要配置数据库了

购物车用都的是redis，因此要启动服务器的redis-server服务端

~~~ bash
redis-server /etc/redis.conf
ps -ef|grep redis
redis-server *:6379
~~~

~~~ bash
[uwsgi]
# Django-related settings
# the base directory (full path)
chdir = /opt/luffy_boy
# Django's wsgi file
module = luffy_boy.wsgi
# the virtualenv (full path)
home = /opt/venv1
# process-related settings
# master
master = true
# maximum number of worker processes
processes = 1
# the socket (use the full path to be safe
socket = 0.0.0.0:9000
# clear environment on exit
vacuum = true
~~~



启动后端

~~~ bash
(venv1) [root@web02 opt]# uwsgi --ini luffy_boy/uwsgi.ini
~~~



## 四、配置nginx，结合前后端

~~~ nginx
worker_processes  1;
events {
    worker_connections  1024;
}
http {
    include       mime.types;
    default_type  application/octet-stream;
    sendfile        on;
    keepalive_timeout  65;
    server {
        listen       80;
        server_name  192.168.119.12;
        location / {
        		root /opt/07-luffy_project_01/dist;
        		index index.html;
        }
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
        		root   html;
        }
    }
server {
listen       8000;
        server_name  192.168.119.12;
        location / {
        uwsgi_pass 0.0.0.0:9000;
        		include /opt/nginx/conf/uwsgi_params;
        }
        location /static {
        		alias /opt/static;
				}
}
}
~~~

![1586180964817-a3b7bd96-93b2-4f55-9d52-1d1fb3d86a81](D:\Note\python\Django\图片\1586180964817-a3b7bd96-93b2-4f55-9d52-1d1fb3d86a81.jpg)

![1586180970724-181f4539-bf9f-44fe-b9bc-7a4462b39802](D:\Note\python\Django\图片\1586180970724-181f4539-bf9f-44fe-b9bc-7a4462b39802.png)