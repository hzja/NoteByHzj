# base64模块

## 为何用base64模块

目前Base64已成为网络上常见传输8Bit字节代码的编码方式之一，做支付系统时系统间报文交互需Base64对明文转码后再进行签名或加密，之后（或再次Base64）传输。那Base64到底起到什么作用？

参数传输过程中常遇到一种情况：用全英文没问题但涉及到中文即出现乱码，与此类似，网络传输字符并非全是可打印字符，如二进制文件、图片等；Base64的出现即为解决此问题，其基于64个可打印字符表示二进制数据；

电子邮件刚问世时只传输英文，但随着用户增加，中文、日文等文字用户也有需求，但这些字符并不能被服务器或网关有效处理，因此Base64登场；随之Base64在URL、Cookie、网页传输少量二进制文件中也有相应使用；

~~~ python
import base64
a = "莫妮卡"
b = base64.b64encode(a.encode()).decode()
print(b)
6I6r5aau5Y2h
c = base64.b64decode(b.encode()).decode()
print(c)
莫妮卡

# 转ASCII 数值
print(ord('h'))
104

# 转二进制
print(bin(104))
0b1101000

# 转十进制
print(int('011010',2))
26
~~~

> b:bytes 字节流



## 图片存储和传输过程

图片 > 字节流 > base64字节流 > 二进制 > 存到电脑里

图片 > 字节流 > base64加密 > 对面base64解密 > 字节流 > 图片



## 转换步骤

1. 将待转换的字符串每三个字节分为一组，每个字节占8bit，那么共有24个二进制位。
2. 将上面的24个二进制位每6个一组，共分为4组。
3. 在每组前面添加两个0，每组由6个变为8个二进制位，总共32个二进制位，即四个字节。
4. 根据Base64编码对照表（见下图）获得对应的值。



## Base64编码原理

1. 将所有字符转化为ASCII码；
2. 将ASCII码转化为8位二进制；
3. 将二进制3个归成一组(不足3个在后边补0)共24位，再拆分成4组，每组6位；
4. 统一在6位二进制前补两个0凑足8位；
5. 将补0后的二进制转为十进制；
6. 从Base64编码表获取十进制对应的Base64编码。



+ 编码对照表：ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/

> hello > aGVsbG8=
>
> hel > ASCII码 > 转二进制
>
> h > 104 > 01101000
>
> e > 101 > 01100101
>
> l  > 108 > 01101100



~~~ python
011010000110010101101100
    每6个一组，转十进制，再按表转base64
    011010 > 26 > a
    000110 > 6   > G 
    010101 > 21 > V
    101100 > 44 > s
        > aGVs
    
lo
    l  > 108 > 01101100
    o > 111 > 01101111
    011011000110111100000000
    011011 > 27 > b
    000110 > 6   > G
    111100 > 60 > 8
    000000 > 0   > =
        > bG8=
                > aGVsbG8=
~~~



> 【1】不足三字节后面填充0；
>
> 【2】对于编码前的数据产生的6位，如果为0，则索引到的字符为‘A’；因不足3字节而填充的0，用’=’来替代， 如果最后剩下两个输入数据，在编码结果后加1个“=”；如果最后剩下一个输入数据，编码结果后加2个“=”



![1576330224526-11decbb9-b67a-4d95-9c49-5e62c3e32415](D:\Note\python\常用模块\图片\1576330224526-11decbb9-b67a-4d95-9c49-5e62c3e32415.png)
