# 语法基础

## 语法简写形式

### 三目运算符

~~~ python 
a = 30
b = 20


ret = a if a > b else b
print(ret)

# 在没有括号的情况下，and的优先级大于or的优先级
ret = a > b and a or b

# and 两个条件都为真，则结果为真
# and 左边的条件如果为假的话，右面条件没有机会执行
# and 左边的条件如果为真的话，右面的条件必须要执行
ret = (10 == 10 and 100)
print('aa:', ret)

# 有一个条件为真，则结果为真
# or 如果左边的条件为真，则右面条件不执行。
# or 如果左边的条件为假，则右面的条件执行.
ret = (10 == 10 or 100)
print(ret)
~~~



### 列表推导式

~~~ python
my_list = [ index for index in range(10) if index % 2 == 0 ]
print(my_list)

# 列表推导式书写多个for循环
my_list = [(x, y) for x in range(10) for y in range(10, 20)]
print(my_list)

# 写三目运算符
my_list = [ index if index % 2 == 0 else 100 for index in range(10) ]
print(my_list)
~~~



### 匿名函数 lambda

~~~ python
# 普通语法
def func_sum(num1, num2):
    return num1 + num2

result = func_sum(1, 3)
print(result)
4
~~~



调用匿名函数有两种方式：

~~~ python
# 方式1: 将函数赋值给变量, 以变量名进行调用
func = lambda num1, num2: num1 + num2
result = func(1, 3)
print(result)
4
~~~

~~~ python
# 方式2: 定义后直接调用
result = (lambda num1, num2: num1 + num2)(1, 3)
print(result)
4
~~~



### 递归函数

自己调用自己，该函数有次数限制

~~~ python
# 需求: 4的阶乘4*3*2*1 n的阶乘n*n-1的阶乘
def func_step(num):
    multi_result = 1
    for i in range(1, num+1):
        multi_result *= i
    return multi_result

result = func_step(5)
print(result)
>>> 120
~~~



## 实参和形参

### 实参(argument)

全称为"实际参数"是在调用时传递给函数的参数. 实参可以是常量、变量、表达式、函数等， 无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值， 以便把这些值传送给形参。 因此应预先用赋值，输入等办法使实参获得确定值。  



### 形参(parameter)

全称"形式参数" 由于其非实际存在变量，故称虚拟变量。在定义函数名和函数体时使用参数，目的是用于接收调用该函数时传入参数.调用函数时实参将赋值给形参。因而须注意实参个数及类型与形参一一对应且实参须有确定值；



### 区别

1. 形参出现在**函数定义**中，在整个函数体内都可以使用， 离开该函数则不能使用。
2. 实参出现在**主调函数中，进入被调函数后，实参变量也不能使用**。 
3. 形参和实参的功能是作数据传送。发生函数调用时， **主调函数把实参的值传送给被调函数的形参从而实现主调函数向被调函数的数据传送**。
4. 形参变量只有在被调用时才分配内存单元，**在调用结束时，** **即刻释放所分配的内存单元**。因此，形参只有在函数内部有效。 函数调用结束返回，主调函数后则不能再使用该形参变量。 
5. 实参可以是常量、变量、表达式、函数等， 无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值， 以便把这些值传送给形参。 因此应预先用赋值，输入等办法使实参获得确定值。 
6. 实参和形参在数量上，类型上，顺序上应严格一致， 否则会发生“类型不匹配”的错误。 
7. **函数调用中发生的数据传送是单向的**。 即只能把实参的值传送给形参，而不能把形参的值反向地传送给实参。 因此在函数调用过程中，形参的值发生改变，而实参中的值不会变化。
8. 当形参和实参不是指针类型时，在该函数运行时，**形参和实参是不同的变量，他们在内存中位于不同的位置，形参将实参的内容复制一份，在该函数运行结束的时候形参被释放，而实参内容不会改变**。而**如果函数的参数是指针类型变量**,在调用该函数的过程中，传给函数的是实参的地址，在函数体内部使用的也是实参的地址，即使用的就是实参本身**。所以在函数体内部可以改变实参的值。



## .py与.pyc文件区别

### 标准编程语言

对于 **C** 语言，代码一般要先编译，再执行。

~~~ tex
.c -> .exe
~~~



### 解释器语言

shell 脚本

~~~ tex
.sh -> interpreter
~~~



### Byte Code 编译

**Python, Java** 等语言先将代码编译为 byte code（不是机器码），然后再处理：

~~~ tex
.py -> .pyc -> interpreter
~~~



> Python程序中把原始程序代码放在.py文件里，而Python在执行.py文件时将.py形式的程序编译成中间式文件（byte-compiled）的.pyc文件，目的是为了加快下次执行文件的速度。
>
> 所以运行python文件时会自动首先查看是否具有.pyc文件，如果有且.py文件修改时间和.pyc修改时间一样就会读取.pyc文件，否则读原来的.py文件。
>
> 其实并非所有.py文件运行时都产生.pyc文件，只有import相应.py文件时才会生成相应.pyc文件