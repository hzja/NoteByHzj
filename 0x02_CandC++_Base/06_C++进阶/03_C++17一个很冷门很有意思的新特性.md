C++<br />void_t是C++17引入的一个新特性，它的定义很简单（有些编译器的实现可能不是这样，但也大体类似）：
```cpp
template< class... >
using void_t = void;
```
看着它很简单，但它搭配SFINAE却可以在模板元编程中发挥巨大作用。<br />比如在编译期判断类是否有某个类型`using`：
```cpp
template <class, class = std::void_t<>>
struct has_type : std::false_type {};

template <class T>
struct has_type<T, std::void_t<typename T::type>> : std::true_type {};
```
比如判断是否有某个成员：
```cpp
template <class, class = std::void_t<>>
struct has_a_member : std::false_type {};

template <class T>
struct has_a_member<T, std::void_t<decltype(std::declval<T>().a)>> : std::true_type {};
```
比如判断某个类是否可迭代：
```cpp
template <typename, typename = void>
constexpr bool is_iterable{};

template <typename T>
constexpr bool is_iterable<T, std::void_t<decltype(std::declval<T>().begin()), decltype(std::declval<T>().end())>> = true;
```
比如判断某个类是否有某个函数：
```cpp
template <class T, class = void>
struct has_hello_func : std::false_type {};

template <class T>
struct has_hello_func<T, std::void_t<decltype(std::declval<T>().hello())>> : std::true_type {};
```
测试结果：
```cpp
struct HasType {
	typedef int type;
};
struct NHasType {
	int hello;
};

struct Hasa {
	int a;
};
struct NHasa {
	int b;
};

struct HasHello {
	void hello();
};
struct NoHasHello {};

int main() {
	std::cout << has_type<HasType>::value << '\n';   // 1
	std::cout << has_type<NHasType>::value << '\n';  // 0
	
	std::cout << has_a_member<Hasa>::value << '\n';   // 1
	std::cout << has_a_member<NHasa>::value << '\n';  // 0
	
	std::cout << has_hello_func<HasHello>::value << '\n';    // 1
	std::cout << has_hello_func<NoHasHello>::value << '\n';  // 0
	
	std::cout << is_iterable<std::vector<double>> << '\n';  // 1
	std::cout << is_iterable<double> << '\n';               // 0
}
```
它的原理其实就是利用SFINAE和模板优先找特化去匹配的特性，估计大家应该看示例代码就能明白。
