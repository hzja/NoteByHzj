### vector.h
```cpp
#ifndef PRO1_VECTOR_H
#define PRO1_VECTOR_H

#include <iostream>

using namespace std;

namespace VECTOR{

    class Vector {
    private:
        double x;
        double y;
        double mag;
        double ang;
        char mode;

        // private methods for setting values
        void set_mag();
        void set_ang();
        void set_x();
        void set_y();

    public:
        Vector();
        Vector(double n1, double n2, char form = 'r');
        ~Vector();
        void set(double n1, double n2, char form = 'r');
        double xval()const { return x;}
        double yval()const { return y;}
        double magval()const { return mag;}
        double angval()const { return ang;}
        void polar_mode();
        void rect_mode();
        // operator overloading
        Vector operator+(const Vector & b)const ;
        Vector operator-(const Vector & b)const ;
        Vector operator-()const ;
        Vector operator*(double n)const ;
        // friends
        friend Vector operator*(double n, const Vector & a);
        friend ostream &operator << (ostream & os, const Vector & vector);
    };
}

#endif //PRO1_VECTOR_H
```
<a name="BjvE2"></a>
### vector.cpp
```cpp
#include "vector.h"
#include <cmath>

using std::sin;
using std::cos;
using std::atan2;
using std::cout;
using std::ostream;

namespace VECTOR{

    const double Rad_to_deg = 57.2957795130823;
    // private methods
    // calculates magnitude from x and y
    void Vector::set_mag() {mag - sqrt(x * x + y * y);}
    void Vector::set_ang() {
        if(x == 0.0 && y == 0.0){
            ang = 0.0;
        } else {
            ang = atan2(y, x);
        }
    }
    void Vector::set_x() {x = mag * cos(ang);}
    void Vector::set_y() {y = mag * sin(ang);}

    Vector::Vector() {
        x = y = mag = ang = 0.0;
        mode = 'r';
    }

    Vector::Vector(double n1, double n2, char form) {
        mode = form;
        if (form == 'r') {
            x = n1;
            y = n2;
            set_mag();
            set_ang();
        } else if (form == 'p'){
            mag = n1;
            ang = n2 / Rad_to_deg;
            set_x();
            set_y();
        } else{
            cout << "Incorrect 3rd argument to Vector()-- ";
            cout << "vector set to 0\n";
            x = y = mag = ang = 0.0;
            mode = 'r';
        }
    }

    void Vector::set(double n1, double n2, char form) {
        mode = form;
        if (form == 'r') {
            x = n1;
            y = n2;
            set_mag();
            set_ang();
        } else if (form == 'p'){
            mag = n1;
            ang = n2 / Rad_to_deg;
            set_x();
            set_y();
        } else{
            cout << "Incorrect 3rd argument to Vector()-- ";
            cout << "vector set to 0\n";
            x = y = mag = ang = 0.0;
            mode = 'r';
        }
    }

    Vector::~Vector() {}

    void Vector::polar_mode() {mode = 'p';}

    void Vector::rect_mode() {mode = 'r';}

    Vector Vector::operator+(const VECTOR::Vector &b) const { return Vector(x + b.x, y + b.y); }
    Vector Vector::operator-(const VECTOR::Vector &b) const { return Vector(x - b.x, y - b.y); }
    Vector Vector::operator-() const { return Vector(-x, -y); }
    Vector Vector::operator*(double n) const { return Vector(n * x, n * y); }
    Vector operator *(double n, const Vector & a){ return a * n; }

    ostream & operator<< (ostream & os, const Vector & vector){
        if (vector.mode == 'r') {
            os << "(x,y) = " << vector.x << ", " << vector.y ;
        } else if (vector.mode == 'p') {
            os << "(m, a) = " << vector.mag << ", " << vector.ang * Rad_to_deg ;
        } else
            os << "Vector object mode is invalid";
        return os;
    }
}
```
<a name="VVQFL"></a>
### 使用Vector类模拟随机行走
```cpp
#include <iostream>
#include <cstdlib>
#include "module4/vector.h"

using namespace std;

// 使用Vector类模拟随机行走
void randwalk(){
    using VECTOR::Vector;
    srand(time(0));
    double direction;
    Vector step;
    Vector result(0.0, 0.0);
    unsigned long steps = 0;
    double dstep;
    double target;
    cout << "Enter target distance(q to quit): ";
    while (cin >> target) {
        cout << "Enter step length: ";
        if (!(cin >> dstep)) {
            break;
        }
        while (result.magval() < target){
            direction = rand()%360;
            step.set(dstep, direction, 'p');
            result = result + step;
            steps++;
        }
        cout << "After " << steps << " steps, the subject has the following location: \n";
        cout << result << endl;
        result.polar_mode();
        cout << " or\n" << result << endl;
        cout << "Average outward distance per step = " << result.magval()/steps << endl;
        steps = 0;
        result.set(0.0, 0.0);
        cout << "Enter target distance (q to quit): ";
    }
    cout << "Bye!\n";
}

int main() {
    randwalk();
    return 0;
}
```
