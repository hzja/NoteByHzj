# C++ 模板类

### 定义模板类
#### [stacktp.h](https://github.com/Fcscanf/Pro1/commit/f99e56eeb3a64be9e1b62dfc674c106a42fe6fc2#diff-26e3f4d844ce9e8c1229869f0028481d8e753415fee08ac8fe2f320bc4c06dec)
```cpp
#ifndef PRO1_STACKTP_H
#define PRO1_STACKTP_H

template <class Type>


class Stack {
private:
    enum {MAX = 10};
    Type items[MAX];
    int top;
public:
    Stack();
    bool isempty();
    bool isfull();
    bool push(const Type &item);
    bool pop(Type &item);
};

template <class Type>
Stack<Type>::Stack() {
    top = 0;
}

template <class Type>
bool Stack<Type>::isempty() {
    return top == 0;
}

template <class Type>
bool Stack<Type>::isfull() {
    return top == MAX;
}

template <class Type>
bool Stack<Type>::push(const Type &item) {
    if (top < MAX) {
        items[top++] = item;
        return true;
    } else
        return false;
}

template <class Type>
bool Stack<Type>::pop(Type &item) {
    if (top > 0) {
        item = items[--top];
        return true;
    } else
        return false;
}

#endif //PRO1_STACKTP_H
```
<a name="Dwamg"></a>
#### [stacktp.cpp](https://github.com/Fcscanf/Pro1/commit/f99e56eeb3a64be9e1b62dfc674c106a42fe6fc2#diff-7ddc094be1583621e2d82c7c25d07e7d0ee85f7251e036d91301dbea9e4b1dd8)
```cpp
#include "stacktp.h"
```
<a name="074db50a"></a>
### 使用模板类
<a name="ESJ8N"></a>
#### [main.cpp](https://github.com/Fcscanf/Pro1/commit/f99e56eeb3a64be9e1b62dfc674c106a42fe6fc2#diff-608d8de3fba954c50110b6d7386988f27295de845e9d7174e40095ba5efcf1bb)
```cpp
#include <iostream>
#include <string>
#include <cstring>
#include <cctype>
#include "module11_class_template/stacktp.h"

using namespace std;

// 使用模板类
void useTemplateClass(){
    Stack<string> st;
    char ch;
    string po;
    cout << "Please enter A to add a purchase order, \n" << "P to process a PO, or to quit.\n";
    while (cin >> ch && toupper(ch) != 'Q') {
        while (cin.get() != '\n') {
            continue;
        }
        if (!isalpha(ch)) {
            cout << '\a';
            continue;
        }
        switch (ch){
            case 'A':
            case 'a': cout << "Enter a PO number to add: ";
            cin >> po;
            if (st.isfull())
                cout << "Stack already full\n";
            else
                st.push(po);
            break;
        case 'P':
        case 'p': if (st.isempty())
            cout << "Stack already empty\n";
            else{
                st.pop(po);
                cout << "PO #" << po << " popped\n";
                break;
            }
        }
        cout << "Please enter A to add a purchase order ,\n" << "P to process a PO , or Q to quit.\n";
    }
    cout << "Bye\n";
}

int main() {
    useTemplateClass();
    return 0;
}
```
<a name="y8eo7"></a>
### 模板类的非模板友元函数
<a name="PXXZV"></a>
#### [tempfriend.cpp](https://github.com/Fcscanf/Pro1/commit/9e414eab0c380ee90519dbe04a480bc06b193780#diff-00e5271f2858c368786fd0aa410c2cac39481d2c7bd4adcf56f043a623eb2d2b)
```cpp
#include <iostream>

using namespace std;

template <typename T>
class HasFriend{
private:
    T item;
    static int ct;
public:
    HasFriend(const T & i):item(i){ ct++; }
    ~HasFriend();
    friend void counts();
    friend void reports(HasFriend<T> &);
};

// each specialization has it's own static data member
template <typename T>
int HasFriend<T>::ct = 0;

// non-template friend to all HasFriend<T> classes
void counts(){
    cout << "int count: " << HasFriend<int >::ct << "; ";
    cout << "double count: " << HasFriend<double >::ct << endl;
}

// non-template friend to the HasFriend<int> class
void reports(HasFriend<int> & hf){
    cout << "HasFriend<int>: " << hf.item << endl;
}

// non-template friend to the HasFriend<double> class
void reports(HasFriend<double> & hf){
    cout << "HasFriend<double>: " << hf.item << endl;
}

void test(){
    cout << "No objects declared: ";
    counts();
    HasFriend<int > hfil(10);
    cout << "After hfil declared: ";
    counts();
    HasFriend<int > hfi2(20);
    cout << "After hfi2 declared: ";
    counts();
    HasFriend<double > hfdb(10.5);
    cout << "After hfdb declared: ";
    counts();
    reports(hfil);
    reports(hfi2);
    reports(hfdb);
}
```
<a name="GMvvh"></a>
### 模板类的约束模板友元函数
<a name="Gn4Rd"></a>
#### [tmp2tmp.cpp](https://github.com/Fcscanf/Pro1/commit/660e8a18142820a274e799c78e12a7a0feaa5449#diff-ffc9b14867251b0e50b37dd11c31d49b0a6aee6617a9efaec7678f44e3f29746)
```cpp
#include <iostream>

using namespace std;

template <typename T> void counts();
template <typename T> void report(T &);

template <typename TT>
class HasFriendT{
private:
    TT item;
    static int ct;
public:
    HasFriendT(const TT & i) : item(i){ ct++; }
    ~HasFriendT();
    friend void counts<TT>();
    friend void report<>(HasFriendT<TT> &);
};

template<typename T>
int HasFriendT<T>::ct = 0;

// template friend functions definitions
template <typename T>
void counts(){
    cout << "template size: " << sizeof(HasFriendT<T>) << "; ";
    cout << "template counts()" << HasFriendT<T>::ct << endl;
}

template <typename T>
void report(T & hf){
    cout << hf.item << endl;
}

void test(){
    counts<int>();
    HasFriendT<int> hfil(10);
    HasFriendT<int> hfi2(20);
    HasFriendT<double > hfdb(10.5);
    report(hfil);
    report(hfi2);
    report(hfdb);
    cout << "counts<int>() output:\n";
    counts<int>();
    cout << "counts<double >() output:\n";
    counts<double >();
}
```
<a name="XUw9N"></a>
### 模板类的非约束模板友元函数
<a name="06WhT"></a>
#### [manyfrnd.cpp](https://github.com/Fcscanf/Pro1/commit/a751c4aeab4a8c0be4be3ee021a1235c60a3baca#diff-c4c8d51fbc38bc9ba373924a740257502c4b7e8a6339f33787fe2f6d19589bdf)
```cpp
#include <iostream>

using namespace std;

template <typename T>
class ManyFriend{
private:
    T item;
public:
    ManyFriend(const T & i) : item(i) {}
    template <typename C, typename D> friend void show2(C &, D &);
};

template <typename C, typename D> void show2(C & c, D & d){
    cout << c.item << ". " << d.item << endl;
}

void run(){
    ManyFriend<int> hfi1(10);
    ManyFriend<int> hfi2(20);
    ManyFriend<double > hfdb(10.5);
    cout << "hfi1, hfi2: ";
    show2(hfi1, hfi2);
    cout << "hfdb, hfi2: ";
    show2(hfdb, hfi2);
}
```

