# C++ 队列类

### [queue.h](https://github.com/Fcscanf/Pro1/commit/e15976af76c7bc833c29a983607d98aa38a51226#diff-4d3429f21a2dae093fdddb82cde91188e71d862a9a5da20fae03c425f3c17b57)
```cpp
#ifndef PRO1_QUEUE_H
#define PRO1_QUEUE_H


class Customer {
private:
    long arrive;
    int processtime;
public:
    Customer(){ arrive = processtime = 0; }

    void set(long when);

    long when()const { return arrive; }

    int ptime()const { return processtime; }
};

typedef Customer Item;

class Queue{
private:
    struct Node {Item item; struct Node* next;};
    enum {Q_SIZE = 10};
    Node* front;
    Node* rear;
    int items;
    const int qsize;
    Queue(const Queue & q): qsize(0){}
    Queue &operator=(const Queue & q){ return *this;}

public:
    Queue(int qs = Q_SIZE);
    ~Queue();
    bool isempty()const ;
    bool isfull()const ;
    int queuecount()const ;
    bool enqueue(const Item &item);
    bool dequeue(Item &item);
};

#endif //PRO1_QUEUE_H
```
<a name="G0nm9"></a>
### [queue.cpp](https://github.com/Fcscanf/Pro1/commit/e15976af76c7bc833c29a983607d98aa38a51226#diff-a1a226c193194fc54583777bfec1ddb4a22752a378cabfdb65b71fd55a0b0a88)
```cpp
#include <cstdlib>
#include "queue.h"

using namespace std;

Queue::Queue(int qs): qsize(qs) {
    front = rear = NULL;
    items = 0;
}

Queue::~Queue() {
    Node * temp;
    while (front != NULL){
        temp = front;
        front = front -> next;
        delete temp;
    }
}

bool Queue::isempty() const {
    return items == 0;
}

bool Queue::isfull() const { return items == qsize; }

int Queue::queuecount() const {
    return items;
}

bool Queue::enqueue(const Item &item) {
    if (isfull())
        return false;
    Node* add = new Node;
    if (add == NULL)
        return false;
    add->item = item;
    add->next = NULL;
    items++;
    if (front == NULL)
        front = add;
    else
        rear->next = add;
    rear = add;
    return true;
}

bool Queue::dequeue(Item &item) {
    if (front == NULL)
        return false;
    item = front->item;
    items--;
    Node* temp = front;
    front = front->next;
    delete temp;
    if (items == 0)
        rear = NULL;
    return true;
}

//void Customer::set(long when) {
//    processtime = rand()%3 + 1;
//    arrive = when;
//} 
```
### [main.cpp](https://github.com/Fcscanf/Pro1/commit/e15976af76c7bc833c29a983607d98aa38a51226#diff-608d8de3fba954c50110b6d7386988f27295de845e9d7174e40095ba5efcf1bb)
```cpp
#include <iostream>
#include <ctime>
#include "module5/queue.h"

using namespace std;

// 队列类
const int MIN_PER_HR = 60;
bool newcustomer(double x);
bool newcustomer(double x){ return rand()*x / RAND_MAX < 1;}

void bank(){
    cout << "Case Study:Bank of Heather Automatic Teller\n";
    cout << "Enter maximum size of queue: ";
    int qs;
    cin >> qs;
    Queue line(qs);

    cout << "Enter the number of simulation hours: ";
    int hours;
    cin >> hours;
    long cyclelimit = MIN_PER_HR * hours;

    cout << "Enter the average number of customers per hour: ";
    double perhour;
    cin >> perhour;
    double min_per_cust;
    min_per_cust = MIN_PER_HR / perhour;

    Item temp;
    long turnaways = 0;
    long customers = 0;
    long served = 0;
    long sum_line = 0;
    int wait_time = 0;
    long line_wait = 0;

    for (int cycle = 0; cycle < cyclelimit; cycle ++){
        if (newcustomer(min_per_cust)){
            if (line.isfull())
                turnaways++;
            else{
                customers++;
                temp.set(cycle);
                line.enqueue(temp);
            }
        }
        if (wait_time <= 0 && !line.isempty()){
            line.dequeue(temp);
            wait_time = temp.ptime();
            line_wait += cycle = temp.when();
            served++;
        }
        if (wait_time > 0)
            wait_time--;
        sum_line += line.queuecount();
    }
    if (customers >0){
        cout << "customers accepted: " << customers << endl;
        cout << "customers served: " << served << endl;
        cout << "turnaways: " << turnaways << endl;
        cout << "average queue size: ";
        cout.setf(ios_base::fixed, ios_base::floatfield);
        cout.setf(ios_base::showpoint);
        cout << (double)sum_line/cyclelimit << endl;
        cout << "average wait time: " << (double)line_wait/served << " minutes\n";
    } else
        cout << "No customers!\n";
    cout << "Done!\n";
}

int main() {
    bank();
    return 0;
}
```

