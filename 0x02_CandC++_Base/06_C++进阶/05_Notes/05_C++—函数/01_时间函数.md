# C++ 时间函数

### C++标准中的chrono库
chrono是一个关于时间的库，起源于boost，现在是C++的标准，现在的C++标准好多都是源于boost，要进标准的特性似乎都会先在boost试验一番。<br />首先看一下使用chrono简单计时的示例代码
```cpp
void func() {  // 计时
   std::chrono::time_point<std::chrono::high_resolution_clock> begin = high_resolution_clock::now();
   std::this_thread::sleep_for(std::chrono::milliseconds(20));
   auto end = high_resolution_clock::now();
   cout << "time " << duration_cast<milliseconds>(end - begin).count() << endl;
}
```
chrono中有三个概念`duration`、`time_point`、`clock`
<a name="rq9yq"></a>
#### `duration`：表示一段时间，三分钟、三秒等
它的定义如下：
```cpp
template <class _Rep, class _Period = ratio<1>> class duration;
```
<a name="ScqAz"></a>
#### `ratio`的定义如下：
```cpp
template <intmax_t N, intmax_t D = 1> class ratio;
```
Rep表示数据类型，int，long等，Period表示时间单位，N是分子，D是分母，直接看例子：
```cpp
using atto  = ratio<1, 1000000000000000000LL>;
using femto = ratio<1, 1000000000000000LL>;
using pico  = ratio<1, 1000000000000LL>;
using nano  = ratio<1, 1000000000>;
using micro = ratio<1, 1000000>;
using milli = ratio<1, 1000>;
using centi = ratio<1, 100>;
using deci  = ratio<1, 10>;
using deca  = ratio<10, 1>;
using hecto = ratio<100, 1>;
using kilo  = ratio<1000, 1>;
using mega  = ratio<1000000, 1>;
using giga  = ratio<1000000000, 1>;
using tera  = ratio<1000000000000LL, 1>;
using peta  = ratio<1000000000000000LL, 1>;
using exa   = ratio<1000000000000000000LL, 1>;

using nanoseconds  = duration<long long, nano>;
using microseconds = duration<long long, micro>;
using milliseconds = duration<long long, milli>;
using seconds      = duration<long long>;
using minutes      = duration<int, ratio<60>>;
using hours        = duration<int, ratio<3600>>;

using hours2       = duration<int, ratio<3600, 1>>;
using hours2       = duration<int, ratio<7200, 2>>;
```
看完上述例子可以知道，ratio的默认的时间单位是1秒，以小时为例，一小时等于3600秒，3600 / 1 == 7200 / 2 == 3600，所以hours == hours2 == hours3。<br />标准库还提供了duration_cast用于转换各种duration。
```cpp
template <class _To, class _Rep, class _Period, enable_if_t<_Is_duration_v<_To>, int> = 0>
   constexpr _To duration_cast(const duration<_Rep, _Period>&) noexcept(
   is_arithmetic_v<_Rep>&& is_arithmetic_v<typename _To::rep>);

template <class _Ty>
   _INLINE_VAR constexpr bool _Is_duration_v = _Is_specialization_v<_Ty, duration>;

template <class _Ty>
_INLINE_VAR constexpr bool is_arithmetic_v = // determine whether _Ty is an arithmetic type
   is_integral_v<_Ty> || is_floating_point_v<_Ty>;
```
函数看着繁琐，直接看看示例代码：
```cpp
void func() {
   auto sec = std::chrono::seconds(10);
   auto mill = std::chrono::duration_cast<std::chrono::milliseconds>(sec);
   cout << sec.count() << endl; // 返回多少s
   cout << mill.count() << endl; // 返回多少ms
}
输出：
10
10000
```
<a name="Kw5VD"></a>
#### `time_point`：用来表示某个具体时间点。
定义如下：
```cpp
template <class _Clock, class _Duration = typename _Clock::duration>
   class time_point;
```
使用方式如下：
```cpp
void func() {
   std::chrono::time_point<std::chrono::system_clock, std::chrono::milliseconds> tp(std::chrono::seconds(12));
   cout << tp.time_since_epoch().count() << endl;
   std::time_t t = system_clock::to_time_t(tp);
   cout << "time " << ctime(&t) << endl;
}
输出：
12000
time Thu Jan  1 08:00:12 1970
```
这里有个函数time_since_epoch()，表示这个time_point距离元年也就是1970年1月1日所经过的duration。<br />time_point也有各种表示方式，类似于duration，也提供了转换函数time_point_cast()。
```cpp
void func() {
    time_point<system_clock, milliseconds> tp(seconds(12));
    cout << tp.time_since_epoch().count() << endl;
    time_point<system_clock, seconds> tp2 = time_point_cast<seconds>(tp);
    cout << tp2.time_since_epoch().count() << endl;
}
输出:
12000
12
```
<a name="IJnv1"></a>
### Clocks
这里的时钟大体有三种：<br />system_clock<br />steady_clock<br />high_resolution_clock
<a name="FhSr7"></a>
#### `system_clock`表示当前的系统时钟
system_clock有三个函数：
```cpp
now()：表示当前时间的time_point
to_time_t()：将time_point转换成time_t秒
from_time_t()：将time_t转换成time_point
```
源码如下：
```cpp
struct system_clock { // wraps GetSystemTimePreciseAsFileTime/GetSystemTimeAsFileTime
    using rep = long long;

    using period = ratio_multiply<ratio<_XTIME_NSECS_PER_TICK, 1>, nano>;

    using duration                  = chrono::duration<rep, period>;
    using time_point                = chrono::time_point<system_clock>;
    static constexpr bool is_steady = false;

    _NODISCARD static time_point now() noexcept { // get current time
        return time_point(duration(_Xtime_get_ticks()));
    }

    _NODISCARD static __time64_t to_time_t(const time_point& _Time) noexcept { // convert to __time64_t
        return static_cast<__time64_t>(_Time.time_since_epoch().count() / _XTIME_TICKS_PER_TIME_T);
    }

    _NODISCARD static time_point from_time_t(__time64_t _Tm) noexcept { // convert from __time64_t
        return time_point(duration(_Tm * _XTIME_TICKS_PER_TIME_T));
    }
};
```
<a name="riGZy"></a>
#### `steady_clock`表示稳定的时钟
它只有一个函数，就是now()，后一次调用now()肯定比上一次调用now()的返回值大，不受系统时间修改的影响。<br />源码如下：
```cpp
struct steady_clock { // wraps QueryPerformanceCounter
    using rep                       = long long;
    using period                    = nano;
    using duration                  = nanoseconds;
    using time_point                = chrono::time_point<steady_clock>;
    static constexpr bool is_steady = true;

    _NODISCARD static time_point now() noexcept { // get current time
        const long long _Freq = _Query_perf_frequency(); // doesn't change after system boot
        const long long _Ctr  = _Query_perf_counter();
        static_assert(period::num == 1, "This assumes period::num == 1.");
        const long long _Whole = (_Ctr / _Freq) * period::den;
        const long long _Part  = (_Ctr % _Freq) * period::den / _Freq;
        return time_point(duration(_Whole + _Part));
    }
};
```
使用方式和之前的都相同：
```cpp
void func() {  // 计时
    std::chrono::time_point<std::chrono::steady_clock> begin = steady_clock::now();
    std::this_thread::sleep_for(std::chrono::milliseconds(20));
    auto end = steady_clock::now();
    cout << "time " << duration_cast<milliseconds>(end - begin).count() << endl;
}
```
high_resolution_clock表示高精度时钟，是系统可用的最高精度的时钟，它其实就是system_clock或者steady_clock的别名：
```cpp
using high_resolution_clock = steady_clock;
```
<a name="x5tE6"></a>
### 再看C语言下各种时间相关的API
首先可以通过C语言的clock拿到程序执行时处理器所使用的时钟数来计时：
```cpp
clock_t clock(void);
```
该函数返回程序执行起（一般为程序的开头），处理器时钟所使用的时间。也获取 CPU 所使用的秒数，除以 CLOCKS_PER_SEC即可，返回的clock_t其实就是long类型的重命名。<br />使用方式如下：
```cpp
void func() {
    clock_t start_t = clock();
    cout << start_t << " 个时钟 \n";
    for (int i = 0; i < 100000000; i++) {
    }
    clock_t end_t = clock();
    cout << end_t << " 个时钟 \n";
    cout << "循环的秒数：" << (double)(end_t - start_t) / CLOCKS_PER_SEC << endl;
}
```
<a name="2ccdcb28"></a>
#### 获取当前时间戳，单位为秒
```cpp
void func() {  // 获取当前时间戳，单位为秒
    struct timeval time;
    gettimeofday(&time, NULL);
    cout << time.tv_sec << " s \n";
}
```
也可以使用time函数：
```cpp
time_t time(time_t *time);
```
该函数返回系统的当前日历时间，返回的是自1970年1月1日以来所经过的秒数。<br />time_t其实就是一个整数类型，是int64_t的重命名，该函数直接使用返回值就好，参数一般传空即可。<br />timer 存取结果的时间指针变量，类型为time_t，指针变量可以为null。<br />如果timer指针非null，则time()函数返回值变量与timer指针一样，都指向同一个内存地址；<br />否则如果timer指针为null，则time()函数返回一个time_t变量时间。
```cpp
void func() {  // 获取当前时间戳，单位为秒
    time_t now = time(NULL);
    cout << static_cast<int64_t>(now) << " s \n";
}
```
<a name="uz00E"></a>
#### 获取当前时间戳，单位为毫秒
```cpp
void func() {  // 获取当前时间戳，单位为毫秒
    struct timeval time;
    gettimeofday(&time, NULL);
    cout << time.tv_sec * 1000 + time.tv_usec / 1000 << " ms \n";
}
```
<a name="rQhUj"></a>
#### 显示当前的系统时间
可以使用ctime显示当前时间：
```cpp
char* ctime(const time_t* time);
```
该函数返回一个表示当地时间的字符串指针，输出内容格式如下：
```cpp
day month year hours:minutes:seconds year\n\0。
```
示例代码如下：
```cpp
void func() {
    time_t now = time(NULL);
    char* dt = ctime(&now);
    cout << "cur time is: " << dt;
}
输出：
Tue Sep 22 22:01:40 2020
```
可以使用tm结构自定义显示当前时间的格式：
```cpp
struct tm * localtime(const time_t * timer);
```
将日历时间转换为本地时间，从1970年起始的时间戳转换为1900年起始的时间数据结构<br />另一个类似的函数是gmtime函数：
```cpp
struct tm *gmtime(const time_t *time);
```
只是该函数返回的是UTC时间，协调世界时（UTC）也被称为格林尼治标准时间（GMT）。<br />tm结构如下：
```cpp
struct tm {
  int tm_sec;   // 秒，正常范围从 0 到 59，但允许至 61
  int tm_min;   // 分，范围从 0 到 59
  int tm_hour;  // 小时，范围从 0 到 23
  int tm_mday;  // 一月中的第几天，范围从 1 到 31
  int tm_mon;   // 月，范围从 0 到 11
  int tm_year;  // 自 1900 年起的年数
  int tm_wday;  // 一周中的第几天，范围从 0 到 6，从星期日算起
  int tm_yday;  // 一年中的第几天，范围从 0 到 365，从 1 月 1 日算起
  int tm_isdst; // 夏令时
};
```
tm_sec 在C89的范围是[0-61]，在C99更正为[0-60]。通常范围是[0-59]，貌似有些系统会出现60秒的跳跃。<br />tm_mon 是从零开始的，所以一月份为0，十二月份为11。<br />tm_year是从1900年开始计算，所以显示年份的时候需要加上1900
```cpp
void func() {
    time_t rawtime = time(NULL);
    struct tm* ptminfo = localtime(&rawtime);
    printf("cur time is: %02d-%02d-%02d %02d:%02d:%02d\n", ptminfo->tm_year + 1900, ptminfo->tm_mon + 1,
           ptminfo->tm_mday, ptminfo->tm_hour, ptminfo->tm_min, ptminfo->tm_sec);
    ptminfo = gmtime(&rawtime);
    printf("cur time is: %02d-%02d-%02d %02d:%02d:%02d\n", ptminfo->tm_year + 1900, ptminfo->tm_mon + 1,
           ptminfo->tm_mday, ptminfo->tm_hour, ptminfo->tm_min, ptminfo->tm_sec);
}
输出：
cur time is: 2020-09-23 21:27:37
cur time is: 2020-09-23 13:27:37
```
可以通过asctime显示tm结构的时间：
```cpp
char * asctime ( const struct tm * time );
```
和ctime类似，返回的都是一个固定时间格式的字符串，只是传入的参数不同。
```cpp
void func() {
    time_t rawtime = time(NULL);
    struct tm* info1 = localtime(&rawtime);
    cout << "正常 日期和时间：" << asctime(info1) << endl;
    info1 = gmtime(&rawtime);
    cout << "UTC 日期和时间：" << asctime(info1) << endl;
}
输出：
正常 日期和时间：Wed Sep 23 21:47:44 2020
UTC 日期和时间：Wed Sep 23 13:47:44 2020
```
也可以使用strftime()函数，该函数可用于格式化日期和时间为指定的格式，如果产生的 C 字符串小于 size 个字符（包括空结束字符），则会返回复制到 str 中的字符总数（不包括空结束字符），否则返回零。
```cpp
size_t strftime(
    char *str, // 指向目标数组的指针，用来复制产生的C字符串
    size_t maxsize, // 最多传出字符数量
    const char *format, // 格式化方式
    const struct tm *timeptr // tm指针
);
```
format格式如下：
```cpp
%a 星期几的缩写
%A 星期几的全称
%b 月份的缩写
%B 月份的全称
%c 标准的日期的时间串
%C 年份的前两位数字
%d 十进制表示的每月的第几天（值从1到31）
%D 月/天/年
%e 在两字符域中，十进制表示的每月的第几天
%F 年-月-日
%g 年份的后两位数字，使用基于周的年
%G 年份，使用基于周的年
%h 简写的月份名
%H 24小时制的小时（值从0到23）
%I 12小时制的小时（值从1到12）
%j 十进制表示的每年的第几天（值从1到366）
%m 十进制表示的月份（值从1到12）
%M 十时制表示的分钟数（值从0到59）
%n 换行符
%p 本地的AM或PM的等价显示
%r 12小时的时间
%R 显示小时和分钟：hh:mm
%S 十进制的秒数（值从0到61）
%t 水平制表符
%T 显示时分秒：hh:mm:ss
%u 每周的第几天，星期一为第一天 （值从1到7，星期一为1）
%U 第年的第几周，把星期日作为第一天（值从0到53）
%V 每年的第几周，使用基于周的年
%w 十进制表示的星期几（值从0到6，星期天为0）
%W 每年的第几周，把星期一做为第一天（值从0到53）
%x 标准的日期串
%X 标准的时间串
%y 不带世纪的十进制年份（值从0到99）
%Y 带世纪部分的十制年份
%Z 时区名称，如果不能得到时区名称则返回空字符。
%% 一个%符号
```
使用代码如下：
```cpp
void func() {
    time_t rawtime = time(NULL);
    char buf[256];
    strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", localtime(&rawtime));
    cout << buf << endl;
}
```
