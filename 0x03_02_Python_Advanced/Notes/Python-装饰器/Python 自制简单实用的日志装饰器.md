Python 日志 装饰器
<a name="ACUuU"></a>
## 1、简陋版装饰器
写一个装饰器非常简单，因为本质上装饰器就是一个返回函数的“高阶”函数而已：<br />1) 函数作为参数传递进装饰器。<br />2) 装饰器内定义一个函数，处理作为参数传递进来的函数。<br />3) 返回这个装饰器内定义的函数<br />![2021-07-28-21-45-42-824219.png](./img/1627479959284-eac15673-472b-49cc-8375-9561073dc2b0.png)<br />用一下试试看：<br />![2021-07-28-21-45-42-914221.png](./img/1627479968162-55bf841e-66aa-44c8-b278-b8042543157d.png)<br />效果如下：<br />![2021-07-28-21-45-43-050221.png](./img/1627479976700-1ebdfb67-b62c-41cd-b2ea-d8e77660b896.png)<br />虽然这样可以实现所需要的功能，但其实有很大的优化空间。
<a name="fBv9G"></a>
## 2、普通版装饰器
第一版代码中有一个显而易见的问题，装饰器内定义的处理函数不支持`kwargs`，而在装饰器中支持`kwargs`仅仅是举手之劳而已。<br />第二个问题是，生成时间戳的时候采用字符串截取的形式，这种形式过于粗暴。其实可以使用`strftime`做字符串转换。<br />修改如下：<br />![](./img/1627479844614-588e4e4b-19dc-4324-b771-fa30b123934e.webp)<br />似乎优化得差不多了，不过依然存在改进空间。
<a name="TfnH9"></a>
## 3、优化版装饰器
在前两版代码中，使用`print`进行日志输出，其实这种处理日志的方式并不标准。<br />使用`logging`模块控制日志输出是一个更好地选择。<br />为了使用`logging`模块记录日志，需要先配置好`logging`相关的选项。
<a name="dIdF6"></a>
### 1) 首先，生成一个日志记录器，并配置日志等级：
![](./img/1627479845024-b70a7936-529d-46e4-863f-878aecc2c7e3.png)
<a name="EWHLn"></a>
### 2) 配置日志格式、增加`handler`控制输出流：
![2021-07-28-21-45-43-784257.png](./img/1627480012389-77fad628-b382-4469-ac23-1e082ace499a.png)<br />此处可以设置`handler`所需要处理的日志等级，没有设置则默认使用`logger`自身的`Level`，即`DEBUG`等级。
<a name="fIGdO"></a>
### 3) 最后，将此`handler`加入到日志记录器内：
![](./img/1627479845151-1354c181-0a0c-49cb-895a-97bf4ae90c56.webp)<br />`logging`完整配置如下：<br />![](./img/1627479845220-7f8f735d-9965-4bef-a2f4-3d14e2892580.webp)<br />使用的时候非常简单，就是把`print`换成`logger.debug`即可：<br />![2021-07-28-21-45-44-318268.png](./img/1627480049485-d05dcfbe-0522-42e9-86f6-ab4e628908e3.png)

效果如下：<br />![](./img/1627479845725-ebc92772-884f-46a2-b3b6-d51a3c3de08b.png)<br />这样，一个比较完善的日志装饰器就完成了。<br />附常用的日志等级配置：<br />![](./img/1627479845879-8d805f60-5a57-475e-8bd4-efcf12101d2f.png)
