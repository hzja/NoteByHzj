Python NumPy<br />NumPy是Python的最重要的扩展程序库之一，也是入门机器学习编程的必备工具。然而对初学者来说，NumPy的大量运算方法非常难记。<br />![2021-05-02-00-08-55-210212.png](./img/1619885428296-7e8054f5-268f-46fb-a4fc-a27b4324b970.png)<br />最近，国外有位程序员讲NumPy的基本运算以图解的方式写下来，让学习过程变得轻松有趣。在Reddit机器学习社区发布不到半天就收获了500+赞。<br />![2021-05-02-00-08-55-427125.png](./img/1619885440233-767cde85-fc8b-4326-afdb-e13cf9ab80d8.png)<br />教程内容分为向量（一维数组）、矩阵（二维数组）、三维与更高维数组3个部分。
<a name="lUGni"></a>
## Numpy数组与Python列表
在介绍正式内容之前，先来了解一下Numpy数组与Python列表的区别。<br />乍一看，NumPy数组类似于Python列表。它们都可以用作容器，具有获取（getting）和设置（setting）元素以及插入和移除元素的功能。<br />两者有很多相似之处，以下是二者在运算时的一个示例：<br />![2021-05-02-00-08-55-640020.png](./img/1619885460596-454c67db-ac33-4951-90f2-49838bec4c14.png)<br />和Python列表相比，Numpy数组具有以下特点：<br />更紧凑，尤其是在一维以上的维度；向量化操作时比Python列表快，但在末尾添加元素比Python列表慢。<br />![2021-05-02-00-08-55-853947.png](./img/1619885473091-ed51636f-cf79-4be1-8048-b0da11a34e3c.png)
<a name="lUSgc"></a>
###### △在末尾添加元素时，Python列表复杂度为O(1)，NumPy复杂度为O(N)
<a name="FGIyn"></a>
## 向量运算
<a name="tCOc7"></a>
#### 向量初始化
创建NumPy数组的一种方法是从Python列表直接转换，数组元素的类型与列表元素类型相同。<br />![2021-05-02-00-08-56-026536.png](./img/1619885485336-37eb65cb-32cd-4a64-8289-e9f7c2ab084f.png)<br />NumPy数组无法像Python列表那样加长，因为在数组末尾没有保留空间。<br />因此，常见的做法是定义一个Python列表，对它进行操作，然后再转换为NumPy数组，或者用np.zeros和np.empty初始化数组，预分配必要的空间：<br />![2021-05-02-00-08-56-165892.png](./img/1619885496879-7f7e79c2-c813-4647-a515-23d6d019eb25.png)<br />有时需要创建一个空数组，大小和元素类型与现有数组相同：<br />![2021-05-02-00-08-56-356829.png](./img/1619885505600-425a9180-302a-4479-bf3b-785e4c24ae91.png)<br />实际上，所有用常量填充创建的数组的函数都有一个`_like`对应项，来创建相同类型的常数数组：<br />![2021-05-02-00-08-56-641224.png](./img/1619885517975-7f0c073e-78d8-41c7-bd2d-64edaeb912b8.png)<br />在NumPy中，可以用`arange`或者`linspace`来初始化单调序列数组：<br />![2021-05-02-00-08-56-974166.png](./img/1619885534976-493e90af-3d8a-4689-8e2e-80722fb987ac.png)<br />如果需要类似[0., 1., 2.]的浮点数组，可以更改`arange`输出的类型：`arange(3)`.`astype(float)`。<br />但是有更好的方法：`arange`函数对数据类型敏感，如果将整数作为参数，生成整数数组；如果输入浮点数（例如`arange(3.)`），则生成浮点数组。<br />但是arange在处理浮点数方面并不是特别擅长：<br />![2021-05-02-00-08-57-192602.png](./img/1619885560274-d1e2f345-56aa-4dfa-aaf7-6016e234d1f4.png)<br />这是因为0.1是一个有限的十进制数，但对计算机而言却不是。在二进制下，0.1是一个无穷小数，必须在某处截断。<br />这就是为什么将小数部分加到步骤`arange`通常是一个不太好的方法：可能会遇到一个bug，导致数组的元素个数不是想要的数，这会降低代码的可读性和可维护性。<br />这时候，`linspace`会派上用场。它不受舍入错误的影响，并始终生成要求的元素数。<br />出于测试目的，通常需要生成随机数组，NumPy提供随机整数、均匀分布、正态分布等几种随机数形式：<br />![2021-05-02-00-08-57-460455.png](./img/1619885591518-22177699-6680-4b9c-9029-d73b418c12d3.png)
<a name="tACzh"></a>
#### 向量索引
一旦将数据存储在数组中，NumPy便会提供简单的方法将其取出：<br />![2021-05-02-00-08-57-699085.png](./img/1619885603178-ba0fccfe-389c-4c53-a261-a87295f77f4c.png)<br />上面展示了各式各样的索引，例如取出某个特定区间，从右往左索引、只取出奇数位等等。<br />但它们都是所谓的view，也就是不存储原始数据。并且如果原始数组在被索引后进行更改，则不会反映原始数组的改变。<br />这些索引方法允许分配修改原始数组的内容，因此需要特别注意：只有下面最后一种方法才是复制数组，如果用其他方法都可能破坏原始数据：<br />![2021-05-02-00-08-57-897242.png](./img/1619885618555-245304e4-b93c-44b3-b6c4-b63324dff4a6.png)<br />从NumPy数组中获取数据的另一种超级有用的方法是布尔索引，它允许使用各种逻辑运算符，来检索符合条件的元素：<br />![2021-05-02-00-08-58-188788.png](./img/1619885654090-29d6e8ee-b948-4235-8e39-637267d69303.png)<br />注意：Python中的三元比较3<=a<=5在NumPy数组中不起作用。<br />如上所述，布尔索引也会改写数组。它有两个常见的函数，分别是`np.where`和`np.clip`：<br />![2021-05-02-00-08-58-409995.png](./img/1619885663588-c82d2074-65fc-4a35-85e9-8c644ad24a94.png)
<a name="SV8hu"></a>
#### 向量运算
算术运算是NumPy速度最引入注目的地方之一。NumPy的向量运算符已达到C++级别，避免了Python的慢循环。<br />NumPy允许像普通数字一样操作整个数组（加减乘除、整除、幂）：<br />![2021-05-02-00-08-58-596588.png](./img/1619885688101-3cdab9c5-67b3-4348-9e69-f6769a861d41.png)
<a name="wZUBy"></a>
###### △ 和Python中一样，a//b表示div b（整除），x**n表示xⁿ
向量还可以与标量进行类似的运算，方法相同：<br />![2021-05-02-00-08-58-726955.png](./img/1619885700889-2a9f3457-b875-4df4-892e-8c5f4bc70900.png)<br />大多数的数学函数都有NumPy对应项用于处理向量：<br />![2021-05-02-00-08-58-935617.png](./img/1619885712149-f890b410-6e56-4629-998b-26564c02c5eb.png)<br />向量的点积、叉积也有运算符：<br />![2021-05-02-00-08-59-200067.png](./img/1619885725537-686fd99d-0cb7-434e-a4e8-7bb9c9a9034b.png)<br />也可以进行三角函数、反三角函数、求斜边运算：<br />![2021-05-02-00-08-59-420139.png](./img/1619885739564-685f4efc-0129-4610-8e86-509d7abedcfe.png)<br />数组可以四舍五入为整数：<br />![2021-05-02-00-08-59-608662.png](./img/1619885751661-91757922-8c2d-492c-a14c-b73f82be1358.png)
<a name="GABsU"></a>
###### △ `floor`取下界；`ceil`取上界；`round`为四舍六入五取偶
NumPy还可以执行以下基本的统计运算（最大最小值、平均值、方差、标准差）：<br />![2021-05-02-00-08-59-818655.png](./img/1619885767039-b7bce1ad-3b96-493b-8029-4ed44dfdba5d.png)<br />不过排序函数的功能比Python列表对应函数更少：<br />![2021-05-02-00-09-00-035401.png](./img/1619885775512-11170f57-fe3d-47f4-9ede-b53821650209.png)
<a name="Pcoxl"></a>
#### 搜索向量中的元素
与Python列表相反，NumPy数组没有`index`方法。<br />![2021-05-02-00-09-00-259873.png](./img/1619885818744-c2b89c2b-77d9-4e35-ae3f-8de4b480a3e2.png)

- 查找元素的一种方法是`np.where(a==x)[0][0]`，它既不优雅也不快速，因为要查找的项需要从开头遍历数组的所有元素。
- 更快的方式是通过Numba中的`next((i[0] for i, v in np.ndenumerate(a) if v==x), -1)`来加速。
- 一旦对数组进行排序，情况就会变得更好：`v = np.searchsorted(a, x); return v if a[v]==x else -1`的复杂度为O(log N)，确实非常快，但是首先需要O(N log N)的排序时间。
<a name="S96Tj"></a>
#### 比较浮点数
函数`np.allclose(a, b)`用于比较具有给定公差的浮点数组：<br />![2021-05-02-00-09-00-548129.png](./img/1619885855721-bc061367-5759-4307-a397-3117183d4951.png)

- `np.allclose`假设所有的比较数字的等级是1个单位。例如在上图中，它就认为1e-9和2e-9相同，如果要进行更细致的比较，需要通过atol指定比较等级1：`np.allclose(1e-9, 2e-9, atol=1e-17) == False`。
- `math.isclose`进行比较没有假设前提，而是基于用户给出的一个合理abs_tol值：`math.isclose(0.1+0.2–0.3, abs_tol=1e-8) == True`。

除此之外np.allclose在绝对和相对公差公式中还存在一些小问题，例如，对某些数存在`allclose(a, b) != allclose(b, a)`。这些问题已在`math.isclose`函数中得到解决。
<a name="GiKER"></a>
## 矩阵运算
NumPy中曾经有一个专用的类`matrix`，但现在已弃用，因此下面将交替使用矩阵和2D数组两个词。<br />矩阵初始化语法与向量相似：<br />![2021-05-02-00-09-00-873257.png](./img/1619885905996-0042b463-7971-4173-8088-950d0c1e4860.png)<br />这里需要双括号，因为第二个位置参数是为dtype保留的。<br />随机矩阵的生成也类似于向量的生成：<br />![2021-05-02-00-09-01-176719.png](./img/1619885916411-dd0709bb-4081-4acf-8a08-4a406933a13c.png)<br />二维索引语法比嵌套列表更方便：<br />![2021-05-02-00-09-01-458029.png](./img/1619885924223-6a5b3309-f5ea-426d-8c92-36af26e31ecf.png)<br />和一维数组一样，上图的view表示，切片数组实际上并未进行任何复制。修改数组后，更改也将反映在切片中。
<a name="zkCVG"></a>
#### axis参数
在许多操作（例如求和）中，需要告诉NumPy是否要跨行或跨列进行操作。为了使用任意维数的通用表示法，NumPy引入了`axis`的概念：`axis`参数实际上是所讨论索引的数量：第一个索引是`axis=0`，第二个索引是`axis=1`，等等。<br />因此在二维数组中，如果axis=0是按列，那么`axis=1`就是按行。<br />![2021-05-02-00-09-01-682769.png](./img/1619885937908-7bf7a4a5-7f12-4a24-bbea-ecb0b05bfdfd.png)
<a name="Q70xZ"></a>
#### 矩阵运算
除了普通的运算符（如+，-，*，/，//和**）以元素方式计算外，还有一个`@`运算符可计算矩阵乘积：<br />![2021-05-02-00-09-01-970171.png](./img/1619885950590-d9ddb6f5-4c30-430b-bef6-4b1a8c3dd4ef.png)<br />在第一部分中，已经看到向量乘积的运算，NumPy允许向量和矩阵之间，甚至两个向量之间进行元素的混合运算：<br />![2021-05-02-00-09-02-292066.png](./img/1619885965040-2fe04357-6938-4d6a-ac1a-de3e4495ab4a.png)
<a name="jsGdP"></a>
#### 行向量与列向量
从上面的示例可以看出，在二维数组中，行向量和列向量被不同地对待。<br />默认情况下，一维数组在二维操作中被视为行向量。因此，将矩阵乘以行向量时，可以使用(n，)或(1，n)，结果将相同。<br />如果需要列向量，则有转置方法对其进行操作：<br />![2021-05-02-00-09-02-579729.png](./img/1619885976437-82be18b9-de40-469d-b0c6-b019b8b9d016.png)<br />能够从一维数组中生成二位数组列向量的两个操作是使用命令`reshape`重排和`newaxis`建立新索引：<br />![2021-05-02-00-09-02-797147.png](./img/1619885987381-97afa129-819c-4f42-9393-38239d5df9d6.png)<br />这里的-1参数表示`reshape`自动计算第二个维度上的数组长度，None在方括号中充当`np.newaxis`的快捷方式，该快捷方式在指定位置添加了一个空`axis`。<br />因此，NumPy中总共有三种类型的向量：一维数组，二维行向量和二维列向量。这是两者之间显式转换的示意图：<br />![2021-05-02-00-09-03-097668.png](./img/1619886006637-78d93429-f458-40e4-af23-08131f3ff6b8.png)<br />根据规则，一维数组被隐式解释为二维行向量，因此通常不必在这两个数组之间进行转换，相应区域用灰色标出。
<a name="M1cfb"></a>
#### 矩阵操作
连接矩阵有两个主要函数：<br />![2021-05-02-00-09-03-309087.png](./img/1619886017394-c06bdf43-a92e-4dc4-9664-1628d3750fe8.png)<br />这两个函数只堆叠矩阵或只堆叠向量时，都可以正常工作。但是当涉及一维数组与矩阵之间的混合堆叠时，`vstack`可以正常工作：`hstack`会出现尺寸不匹配错误。<br />因为如上所述，一维数组被解释为行向量，而不是列向量。解决方法是将其转换为列向量，或者使用`column_stack`自动执行：<br />![2021-05-02-00-09-03-516965.png](./img/1619886030911-7a4c0769-c3e9-41d5-872c-3a2478f5ae4e.png)<br />堆叠的逆向操作是分裂：<br />![2021-05-02-00-09-03-809506.png](./img/1619886069623-8c25e813-754a-4de7-ba64-72f06cb76c28.png)<br />矩阵可以通过两种方式完成复制：`tile`类似于复制粘贴，`repeat`类似于分页打印。<br />![2021-05-02-00-09-04-120132.png](./img/1619886094883-6b2f13b0-9373-4460-9dfe-72f987b5e11e.png)<br />特定的列和行可以用`delete`进行删除：<br />![2021-05-02-00-09-04-360517.png](./img/1619886115589-33bb09cb-49c5-473d-8b18-70c285bebddf.png)<br />逆运算为插入：<br />![2021-05-02-00-09-04-656774.png](./img/1619886125311-a59419ea-d5cc-4dbf-b451-fbfbb9b5be6f.png)<br />`append`就像`hstack`一样，该函数无法自动转置一维数组，因此再次需要对向量进行转置或添加长度，或者使用`column_stack`代替：<br />![2021-05-02-00-09-04-936355.png](./img/1619886151094-d8038b54-6410-460f-9899-889cc15409ab.png)<br />实际上，如果需要做的就是向数组的边界添加常量值，那么`pad`函数就足够了：<br />![2021-05-02-00-09-05-162991.png](./img/1619886178174-40e2627c-bcce-46da-b4d2-ace7485aca07.png)
<a name="VsgaY"></a>
#### Meshgrid
如果要创建以下矩阵：<br />![2021-05-02-00-09-05-357511.png](./img/1619886199884-e0e015af-72dc-43b9-bc9b-11ef3d3f2aa2.png)<br />两种方法都很慢，因为它们使用的是Python循环。在MATLAB处理这类问题的方法是创建一个`meshgrid`：<br />![2021-05-02-00-09-05-581061.png](./img/1619886226688-88808187-cd89-4cab-ad74-a28fd05b122a.png)<br />该`meshgrid`函数接受任意一组索引，`mgrid`仅是切片，`indices`只能生成完整的索引范围。`fromfunction`如上所述，仅使用I和J参数一次调用提供的函数。<br />但是实际上，在NumPy中有一种更好的方法。无需在整个矩阵上耗费存储空间。仅存储大小正确的矢量就足够了，运算规则将处理其余的内容：<br />![2021-05-02-00-09-05-795494.png](./img/1619886274834-e839a256-62a0-4e3d-abf9-885bbd726578.png)<br />在没有`indexing='ij'`参数的情况下，`meshgrid`将更改参数的顺序：`J, I= np.meshgrid(j, i)`—这是一种“ xy”模式，用于可视化3D图。<br />除了在二维或三维数组上初始化外，`meshgrid`还可以用于索引数组：<br />![2021-05-02-00-09-05-985697.png](./img/1619886249420-6a80ffe7-703a-4be5-9fae-0a0a2a26784c.png)
<a name="jZnqe"></a>
#### 矩阵统计
就像之前提到的统计函数一样，二维数组接受到`axis`参数后，会采取相应的统计运算：<br />![2021-05-02-00-09-06-273221.png](./img/1619886338519-20072dbf-b94d-4b57-bf4c-ec8be9394d21.png)<br />二维及更高维度中，`argmin`和`argmax`函数返回最大最小值的索引：<br />![2021-05-02-00-09-06-499111.png](./img/1619886345288-89080a6f-492e-4bb4-a118-5cf8adcea14c.png)<br />`all`和`any`两个函数也能使用`axis`参数：<br />![2021-05-02-00-09-06-791330.png](./img/1619886369831-38772a80-fd16-466e-a4ee-3c4cd9a742f6.png)
<a name="X1nFY"></a>
#### 矩阵排序
尽管`axis`参数对上面列出的函数很有用，但对二维排序却没有帮助：<br />![2021-05-02-00-09-07-022707.png](./img/1619886384411-20fbe7c8-9faa-4433-a5f9-7342027ac945.png)<br />`axis`绝不是Python列表key参数的替代。不过NumPy具有多个函数，允许按列进行排序：<br />1、按第一列对数组排序：`a[a[:,0].argsort()]`<br />![2021-05-02-00-09-07-310943.png](./img/1619886404546-c2ba872e-1189-46b0-b537-00371d41cdb7.png)<br />`argsort`排序后，此处返回原始数组的索引数组。<br />此技巧可以重复，但是必须小心，以免下一个排序混淆前一个排序的结果：
```python
a = a[a[:,2].argsort()]
a = a[a[:,1].argsort(kind='stable')]
a = a[a[:,0].argsort(kind='stable')]
```
![2021-05-02-00-09-07-505697.png](./img/1619886477263-fa825db9-6f82-4405-a736-ec2701e3fba9.png)<br />2、有一个辅助函数`lexsort`，该函数按上述方式对所有可用列进行排序，但始终按行执行，例如：

- `a[np.lexsort(np.flipud(a[2,5].T))]`：先通过第2列排序，再通过第5列排序；
- `a[np.lexsort(np.flipud(a.T))]`：按从左到右所有列依次进行排序。

![2021-05-02-00-09-07-633321.png](./img/1619886513436-633fc107-726b-4366-850b-e283d63dfcc4.png)<br />3、还有一个参数`order`，但是如果从普通（非结构化）数组开始，则既不快速也不容易使用。<br />4、因为这个特殊的操作方式更具可读性和它可能是一个更好的选择，这样做的pandas不易出错：

- `pd.DataFrame(a).sort_values(by=[2,5]).to_numpy()`：通过第2列再通过第5列进行排序。
- `pd.DataFrame(a).sort_values().to_numpy()`：通过从左向右所有列进行排序
<a name="HD8jH"></a>
## 高维数组运算
通过重排一维向量或转换嵌套的Python列表来创建3D数组时，索引的含义为（z，y，x）。<br />第一个索引是平面的编号，然后才是在该平面上的移动：<br />![2021-05-02-00-09-07-920565.png](./img/1619886543436-c61bf35b-b38d-4444-8329-d64752998634.png)<br />这种索引顺序很方便，例如用于保留一堆灰度图像：这a[i]是引用第i个图像的快捷方式。<br />但是此索引顺序不是通用的。处理RGB图像时，通常使用（y，x，z）顺序：前两个是像素坐标，最后一个是颜色坐标（Matplotlib中是RGB ，OpenCV中是BGR ）：<br />![2021-05-02-00-09-08-133990.png](./img/1619886563494-4bbc6933-aba9-41cf-a2a1-a7ce0c28a234.png)<br />这样，可以方便地引用特定像素：`a[i,j]`给出像素的RGB元组(i,j)。<br />因此，创建特定几何形状的实际命令取决于正在处理的域的约定：<br />![2021-05-02-00-09-08-460057.png](./img/1619886579075-3080c1a0-783d-467c-9d1f-966fd5e55768.png)<br />显然，NumPy函数像`hstack`、`vstack`或`dstack`不知道这些约定。其中硬编码的索引顺序是（y，x，z），RGB图像顺序是：<br />![2021-05-02-00-09-08-840283.png](./img/1619886593891-da3bd240-0150-41a5-9c98-78691e876e04.png)
<a name="bR1F1"></a>
###### △RGB图像数组（为简便起见，上图仅2种颜色）
如果数据的布局不同，则使用`concatenate`命令堆叠图像，并在axis参数中提供显式索引数会更方便：<br />![2021-05-02-00-09-09-131508.png](./img/1619886609388-1540ea99-7a26-4445-939f-750b746a271f.png)<br />如果不方便使用`axis`，可以将数组转换硬编码为`hstack`的形式：<br />![2021-05-02-00-09-10-197876.png](./img/1619886627064-0231f5f3-9c28-4f8b-912c-c335514cc3c7.png)<br />这种转换没有实际的复制发生。它只是混合索引的顺序。<br />混合索引顺序的另一个操作是数组转置。检查它可能会让我们对三维数组更加熟悉。<br />根据决定的`axis`顺序，转置数组所有平面的实际命令将有所不同：对于通用数组，它交换索引1和2，对于RGB图像，它交换0和1：<br />![2021-05-02-00-09-10-505734.png](./img/1619886641834-4c422173-7817-44e6-a608-fca2f69b361a.png)<br />有趣的是，（和唯一的操作模式）默认的`axis`参数颠倒了索引顺序，这与上述两个索引顺序约定都不相符。<br />最后，还有一个函数，可以在处理多维数组时节省很多Python循环，并使代码更简洁，这就是爱因斯坦求和函数`einsum`：![2021-05-02-00-09-10-772025.png](./img/1619886657920-fd1d2eea-7af6-430c-9562-ef28e9ea77c2.png)<br />它将沿重复索引的数组求和。
