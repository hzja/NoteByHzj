支持向量机将向量映射到一个更高维的空间里，在这个空间里建立有一个最大间隔超平面。在分开数据的超平面的两边建有两个互相平行的超平面，分隔超平面使两个平行超平面的距离最大化。假定平行超平面间的距离或差距越大，分类器的总误差越小。

![SVM1.png](./img/1592552509088-93e7dbcf-b497-4f00-9296-81a4c8ef7273.png)

在上面的图中，a和b都可以作为分类超平面，但最优超平面只有一个，最优分类平面使间隔最大化。那是不是某条直线比其他的更加合适呢？我们可以凭直觉来定义一条评价直线好坏的标准：距离样本太近的直线不是最优的，因为这样的直线对噪声敏感度高，泛化性较差。因此我们的目标是找到一条直线（图中的最优超平面），离所有点的距离最远。由此，SVM算法的实质是找出一个能够将某个值最大化的超平面，这个值就是超平面离所有训练样本的最小距离。这个最小距离用SVM术语来说叫做间隔(margin)。

<a name="3d84e332"></a>
## 线性可分支持向量机与硬间隔最大化

<a name="32f404e4"></a>
### 线性可分支持向量机

给定训练样本集![](./img/2345e3401b6007e4911583113b0a865f.svg)，分类学习最基本的想法就是基于训练集![](./img/f623e75af30e62bbd73d6df5b50bb7b5.svg)在样本空间中找到一个划分超平面，将不同类别的样本分开。但能将训练样本分开的划分超平面可能有很多<br />![SVM2.png](./img/1592552560750-e125bbff-d65c-44e1-8a13-26cab9d04271.png)<br />直观上看，应该去找位于两类训练样本“正中间”的划分超平面，即上图橘色那个，因为该划分超平面对训练样本局部扰动的“容忍”性最好。例如，由于训练集的局限性或噪声的因素，训练集外的样本可能比上图中的训练样本更接近两个类的分隔界，这将使许多划分超平面出现错误，而橘色的超平面受影响最小。换言之，这个超平面所产生的分类结果是最鲁棒的，对未见示例的泛化能力最强。

在样本空间中，划分超平面可通过如下线性方程来描述：

![](./img/218d0f5f2648188f92add9f7d9cce9c3.svg)

以及相应的分类决策函数：

![](./img/3c2fa8366091bad23c7f5937a8a9978e.svg)

其中![](./img/8977c8ffaeff029f1b83d75b490b6abb.svg)为法向量，决定了超平面的方向；![](./img/92eb5ffee6ae2fec3ad71c777531578f.svg)为位移项，决定了超平面与原点间的距离。显然，划分超平面可被法向量![](./img/f1290186a5d0b1ceab27f4e77c0c5d68.svg)和位移![](./img/92eb5ffee6ae2fec3ad71c777531578f.svg)确定，下面我们将其记为![](./img/aa3f29b7b082772dd2123a59e3f6a725.svg)。样本空间中任意点![](./img/9dd4e461268c8034f5c8564e155c67a6.svg)到超平面![](./img/aa3f29b7b082772dd2123a59e3f6a725.svg)的距离可写为：![](./img/46a520a692a7ccbd067c4d0e43bc2e10.svg)。（[点到直线距离：](https://baike.baidu.com/item/%E7%82%B9%E5%88%B0%E7%9B%B4%E7%BA%BF%E8%B7%9D%E7%A6%BB/8673346)![](./img/c55b017aaea423bcaf47427461c5721c.svg)）

<a name="9f93b002"></a>
### 函数间隔和几何间隔

<a name="56e3febd"></a>
#### 函数间隔(Functional margin)

一般来说，一个点距离分离超平面的远近可以表示分类预测的确信程度。在超平面![](./img/218d0f5f2648188f92add9f7d9cce9c3.svg)确定的情况下，![](./img/be725a23a21adea36a14348c076556fc.svg)能够相对地表示点![](./img/9dd4e461268c8034f5c8564e155c67a6.svg)距离超平面的远近。而![](./img/1db3a2ab7d619bc8454e4d3fcb41cfb0.svg)的符号标记与类标记![](./img/415290769594460e2e485922904f345d.svg)是否一致能够表示分类是否正确。所以可用量![](./img/22ca4a196febabbf4cce0c53c5a18089.svg)来表示分类的正确性及确信度，这就是函数间隔。

定义：对于给定的训练数据集![](./img/b9ece18c950afbfa6b0fdbfa4ff731d3.svg)和超平面![](./img/aa3f29b7b082772dd2123a59e3f6a725.svg)，定义超平面![](./img/aa3f29b7b082772dd2123a59e3f6a725.svg)关于样本点![](./img/e1b22a94bd6fb5e430efa18091a9b75d.svg)的函数间隔为：![](./img/e62d239822831122dd571c0d362408f7.svg)；超平面![](./img/aa3f29b7b082772dd2123a59e3f6a725.svg)关于训练数据集![](./img/b9ece18c950afbfa6b0fdbfa4ff731d3.svg)的函数间隔为超平面关于![](./img/b9ece18c950afbfa6b0fdbfa4ff731d3.svg)中所有样本点![](./img/e1b22a94bd6fb5e430efa18091a9b75d.svg)的函数间隔之最小值(离超平面最近的点都分对了，其他的点肯定也对)，即![](./img/657cf8859b3d5606261d8f53dadb1b54.svg)

<a name="0e0fe5c5"></a>
#### 几何间隔(Geometric margin)

函数间隔可以表示分类预测的正确性及确信度，但是选择分离超平面时，只有函数间隔还不够。因为只要成比例地改变![](./img/f1290186a5d0b1ceab27f4e77c0c5d68.svg)和![](./img/92eb5ffee6ae2fec3ad71c777531578f.svg)，例如将它们改为![](./img/ec9cbcbeaf6327c7d0b9f89df3df9423.svg)和![](./img/f8bc2fbe2c937ea5b5e8839cbea69491.svg)，超平面并没有改变，但函数间隔却成为原来的2倍。这一事实启示我们，可以对分离超平面法向量![](./img/f1290186a5d0b1ceab27f4e77c0c5d68.svg)加某些约束，如规范化，![](./img/d1ec435d47011556bdb5687c98fa4d8b.svg)，使间隔是确定的，这时函数间隔称为几何间隔。

下图给出了超平面![](./img/aa3f29b7b082772dd2123a59e3f6a725.svg)及其法向量![](./img/f1290186a5d0b1ceab27f4e77c0c5d68.svg)。点![](./img/7fc56270e7a70fa81a5935b72eacbe29.svg)表示某一实例![](./img/1ba8aaab47179b3d3e24b0ccea9f4e30.svg)，其类标记为![](./img/0e8bd73887634c838372eba68beb2848.svg)。点![](./img/7fc56270e7a70fa81a5935b72eacbe29.svg)与超平面![](./img/aa3f29b7b082772dd2123a59e3f6a725.svg)的距离由线段![](./img/b86fc6b051f63d73de262d4c34e3a0a9.svg)给出，记作![](./img/d2a75ebcf754b11a4af99348833d82b1.svg)：

![](./img/fff2494c27a94f781fc52f22204ee014.svg)

其中，![](./img/7ef51c4e37efd060f515144f5519c967.svg)为![](./img/f1290186a5d0b1ceab27f4e77c0c5d68.svg)的![](./img/07cbd6c155424e110559a84df364be5a.svg)范数。这是点![](./img/7fc56270e7a70fa81a5935b72eacbe29.svg)在超平面正的的一侧的情形。如果点![](./img/7fc56270e7a70fa81a5935b72eacbe29.svg)在超平面负的一侧，即![](./img/d9bd5067b209817adbd784b8d872e740.svg)，那么点与超平面的距离为(因为我们的超平面在两类的“正中央”，即距离相同)：

![](./img/2cc03839fae13cc0fd733acf9cb6a1b2.svg)

一般地，当样本点![](./img/e1b22a94bd6fb5e430efa18091a9b75d.svg)被超平面![](./img/aa3f29b7b082772dd2123a59e3f6a725.svg)正确分类时，点![](./img/1ba8aaab47179b3d3e24b0ccea9f4e30.svg)与超平面的距离是：

![](./img/fc82b8d413f11eabe22c82d3bf525b0a.svg)

![SVM3.png](./img/1592553920950-779d9bac-ef47-420c-9693-fd322bdd7eb5.png)

定义：对于给定的训练数据集![](./img/b9ece18c950afbfa6b0fdbfa4ff731d3.svg)和超平面![](./img/aa3f29b7b082772dd2123a59e3f6a725.svg)，定义超平面关于样本点![](./img/e1b22a94bd6fb5e430efa18091a9b75d.svg)的几何间隔为：![](./img/fc82b8d413f11eabe22c82d3bf525b0a.svg)；超平面![](./img/aa3f29b7b082772dd2123a59e3f6a725.svg)关于训练数据集![](./img/b9ece18c950afbfa6b0fdbfa4ff731d3.svg)的几何间隔为超平面关于![](./img/b9ece18c950afbfa6b0fdbfa4ff731d3.svg)中所有样本点![](./img/e1b22a94bd6fb5e430efa18091a9b75d.svg)的函数间隔之最小值(离超平面最近的点都分对了，其他的点肯定也对)，即![](./img/69305f6ba5132895f9c3dd89ff619660.svg)

<a name="2943759a"></a>
#### 两间隔关系

超平面![](./img/aa3f29b7b082772dd2123a59e3f6a725.svg)关于样本点![](./img/e1b22a94bd6fb5e430efa18091a9b75d.svg)的几何间隔一般是实例点到超平面的带符号的距离(signed distance)，当样本点被超平面正确分类时就是实例点到超平面的距离。从函数距离和几何距离的定义可知两者的关系(![](./img/7f435923480b8cbc67099f67cd5ab0cf.svg)为函数距离，![](./img/ae539dfcc999c28e25a0f3ae65c1de79.svg)为几何距离)：

![](./img/f3c9cc3786fb3196021dc9bbd9c02a9a.svg)

如果![](./img/d1ec435d47011556bdb5687c98fa4d8b.svg)，那么函数间隔和几何间隔相等。如果超平面参数![](./img/f1290186a5d0b1ceab27f4e77c0c5d68.svg)和![](./img/92eb5ffee6ae2fec3ad71c777531578f.svg)成比例地改变(超平面没有改变)，函数间隔也按此比例改变，而几何间隔不变。

<a name="6b129c37"></a>
### 间隔最大化

支持向量机学习的基本想法是求解能够正确划分训练数据集并且几何间隔最大的分离超平面。对线性可分的训练数据集而言，线性可分分离超平面有无穷多个(等价于感知机)，但是几何间隔最大的分离超平面是唯一的。这里的间隔最大化又称为硬间隔最大化(与将要讨论的训练数据集近似线性可分时的软间隔最大化相对应)。

<a name="889085c6"></a>
#### 最大间隔分离超平面

如何求得一个几何间隔最大的分离超平面，即最大间隔分离超平面。具体地，这个问题可以表示为下面的约束最优化问题：

![](./img/47127cbef1f29ad0fc87ece52deb9f62.svg)

我们希望最大化超平面![](./img/aa3f29b7b082772dd2123a59e3f6a725.svg)关于训练数据集的几何间隔![](./img/ae539dfcc999c28e25a0f3ae65c1de79.svg)，约束条件表示的是超平面关于每个训练样本点的几何间隔至少是![](./img/ae539dfcc999c28e25a0f3ae65c1de79.svg)，结合几何间隔与函数间隔的关系式，可将上式改写为：

![](./img/d3cec82f45c4a69ee7a8028f6ab0b229.svg)

函数间隔![](./img/7f435923480b8cbc67099f67cd5ab0cf.svg)的取值并不影响最优化问题的解。实际上，假设将![](./img/f1290186a5d0b1ceab27f4e77c0c5d68.svg)和![](./img/92eb5ffee6ae2fec3ad71c777531578f.svg)按比例改变为![](./img/7a2e28c0eabdc152681321acac643482.svg)和![](./img/9ebcddd6fbaa404505d7da1faf2c38df.svg)，这时函数间隔成为![](./img/e873074806ae857800fd843faa1f79c0.svg)。函数间隔的这一改变对上面最优化问题的不等式约束并没产生影响，对目标函数的优化也没有影响，也就是说，它产生一个等价的优化问题。这样，就可以取![](./img/535679a736b8e86aa4b9893f7e713c29.svg)。将![](./img/535679a736b8e86aa4b9893f7e713c29.svg)代入上面的最优化问题，就是最大化![](./img/9a193515cad0327a9992bee599c7cb3b.svg)，为方便计算，我们转化为最小化![](./img/41301a26c3f4bd803a89a7ef8fa92d5c.svg)(两者等价，因为求最大化![](./img/9a193515cad0327a9992bee599c7cb3b.svg)即最小化![](./img/7ef51c4e37efd060f515144f5519c967.svg)，即![](./img/41301a26c3f4bd803a89a7ef8fa92d5c.svg))，于是就得到下面的线性可分支持向量机学习的最优化问题：

![](./img/64bfdc429baa10665c8670c56026266e.svg)

所以求解出最优解![](./img/1a50db4fe39a79074fcd888dc092fca1.svg)，![](./img/5c171fc50367685463f9b315b4f113ce.svg)就可以得到分离超平面

![](./img/4ae8cf97d74be081a2a2ff545362f364.svg)

从而得到分类决策函数

![](./img/305c8bb4a50b5144a4bc461193f4fbac.svg)

<a name="d859347b"></a>
### 对偶问题

我们希望求解![](./img/64bfdc429baa10665c8670c56026266e.svg)来得到最大间隔超平面所对应的模型。对其使用拉格朗日乘子法可得其“对偶问题”。具体来说，对上式的每条约束添加拉格朗日乘子![](./img/dda0716a1035cd95e656690c48740fbc.svg)，则该问题的拉格朗日函数可写为

![](./img/818547bd37b1b30cdbc81c449d71a7e2.svg)

其中![](./img/f4318460381a2c3a17329cb95d0f3fd9.svg)。令![](./img/a6ce154e4163bad73fe51eeda0b8543e.svg)对![](./img/f1290186a5d0b1ceab27f4e77c0c5d68.svg)和![](./img/92eb5ffee6ae2fec3ad71c777531578f.svg)的偏导为零可得

![](./img/22a6cd4cd7c061332d440dae6e98b145.svg)    ![](./img/c6c0d220330d6a1947f369aff065a3ee.svg)

将![](./img/22a6cd4cd7c061332d440dae6e98b145.svg)代入拉格朗日函数，再考虑约束![](./img/c6c0d220330d6a1947f369aff065a3ee.svg)，就得到原问题

![](./img/64bfdc429baa10665c8670c56026266e.svg)

的对偶问题

![](./img/72f681c8741b8f87f40a27801efe05f2.svg)

解出![](./img/7b7f9dbfea05c83784f8b85149852f08.svg)后，求出![](./img/f1290186a5d0b1ceab27f4e77c0c5d68.svg)与![](./img/92eb5ffee6ae2fec3ad71c777531578f.svg)即可得到模型

![](./img/958f6d57446015bc9371f91dfdb07003.svg)

从对偶问题解出的![](./img/cd0f1069db14b3485b705eb04d3e58a4.svg)是拉格朗日函数中的拉格朗日乘子，它恰对应着训练样本![](./img/e1b22a94bd6fb5e430efa18091a9b75d.svg)。原问题中有不等式约束![](./img/e1b079cd07386847045d52f484385fbd.svg)，因此上述过程需满足KKT条件，即要求

![](./img/cafe58397211051a366580a4684cb4b2.svg)

于是，对任意训练样本![](./img/e1b22a94bd6fb5e430efa18091a9b75d.svg)，总有![](./img/19a0a9d5131253d45925e6514ce5a4e6.svg)或![](./img/5027c2c2075aa8c83dba0d044a319460.svg)(即需要满足最上面最后一个等式约束)。若![](./img/19a0a9d5131253d45925e6514ce5a4e6.svg)，则该样本将不会在![](./img/958f6d57446015bc9371f91dfdb07003.svg)的求和中出现，也就不会对![](./img/50bbd36e1fd2333108437a2ca378be62.svg)有任何影响；若![](./img/cfa211928f1bbfd46d614463bcb0b954.svg)，则必有![](./img/5027c2c2075aa8c83dba0d044a319460.svg)，所对应的样本点位于最大间隔边界上，是一个支持向量。这显示出支持向量的一个重要性质：训练完成后，大部分的训练样本都不需要保留，最终模型仅与支持向量有关。

那么，如何求解![](./img/72f681c8741b8f87f40a27801efe05f2.svg)呢？不难发现，这是一个二次规划问题，可使用通用的二次规划算法来求解；然而，该问题的规模正比于训练样本数，这会在实际任务中造成很大的开销。为了避免这个障碍，人们提出利用问题本身的特性，提出了很多高效的算法，SMO（Sequential Minimal Optimization）是其中一个著名的代表。

<a name="78308094"></a>
## 线性支持向量机与软间隔最大化

<a name="21368cab"></a>
### 线性支持向量机

线性可分问题的支持向量机学习方法对线性不可分训练数据是不适用的，因为这时上述方法中的不等式约束不能成立。为了扩展到线性不可分问题，就需要修改硬间隔最大化，使其成为软间隔最大化。

线性不可分意味着某些样本点![](./img/e1b22a94bd6fb5e430efa18091a9b75d.svg)不能满足函数间隔大于等于1的约束条件。为了解决这个问题，可以对每个样本点引进一个松弛变量![](./img/f4c45c18bdd91141b6e74277bc0636c0.svg)，使函数间隔加上松弛变量大于等于1这样，约束条件变为：

![](./img/977a68586d6463961df8f35887c66c39.svg)

同时，对每个松弛变量![](./img/9ea888f58114108ed02fea555f01fe8c.svg)，支付一个代价![](./img/9ea888f58114108ed02fea555f01fe8c.svg)。目标函数由原来的![](./img/41301a26c3f4bd803a89a7ef8fa92d5c.svg)变成

![](./img/ed994bcfca96e46bf75c344d0f3b73c8.svg)

这里，![](./img/d5d86d712b9871e01d3a8ec699221864.svg)称为惩罚参数，一般由应用问题决定，![](./img/0d61f8370cad1d412f80b84d143e1257.svg)值大时对误分类的惩罚增大，![](./img/0d61f8370cad1d412f80b84d143e1257.svg)值小时对误分类的惩罚减小。最小化目标函数包含两层含义：使![](./img/41301a26c3f4bd803a89a7ef8fa92d5c.svg)尽量小即间隔尽量大，同时使误分类点的个数尽量小，![](./img/0d61f8370cad1d412f80b84d143e1257.svg)是调和两者的系数。

有了上面的思路，可以和训练数据集线性可分时一样来考虑训练数据集线性不可分时的线性支持向量机学习问题。相应于硬间隔最大化，它成为软间隔最大化。线性不可分的线性支持向量机的学习问题变成如下凸二次规划问题：

![](./img/f845d7b94dbedacdf7d62f2661a20d7a.svg)

问题是一个凸二次规划问题，因而关于![](./img/d233746db2e2457fa5d162de0e505d3f.svg)的解是存在的。可以证明![](./img/f1290186a5d0b1ceab27f4e77c0c5d68.svg)的解是唯一的，但![](./img/92eb5ffee6ae2fec3ad71c777531578f.svg)的解可能不唯一，而是存在于一个区间。设问题的解是![](./img/1a50db4fe39a79074fcd888dc092fca1.svg)，![](./img/5c171fc50367685463f9b315b4f113ce.svg)。于是可以得到分离超平面![](./img/77194d70a365207a3c523934d7ec663f.svg)及分类决策函数![](./img/67715ca0228e8e109258c06bdb2b1e03.svg)，称这样的模型为训练样本线性不可分时的线性支持向量机，简称线性支持向量机。显然，线性支持向量机包含线性可分支持向量机。由于现实中训练数据集往往是线性不可分的，线性支持向量即具有更广的适用性。优化目标函数可写为

![](./img/f37a9cae8969a6f4a3be65aabb503409.svg)

其中![](./img/d5d86d712b9871e01d3a8ec699221864.svg)是一个常数，![](./img/ee947eb219fd22b8b5d18470965cc38d.svg)是“0/1损失函数”

![](./img/26c73f7ec178b7599975c33c288f6879.svg)

显然，![](./img/0d61f8370cad1d412f80b84d143e1257.svg)为无穷大时，优化目标函数迫使所有样本均满足约束![](./img/02c777cbd82e1bef4df80c120be14353.svg)；当![](./img/0d61f8370cad1d412f80b84d143e1257.svg)取有限值时，优化目标函数允许一些样本不满足约束。然而，![](./img/ee947eb219fd22b8b5d18470965cc38d.svg)非凸、非连续，数学性质不太好，使得优化目标函数不易直接求解。于是，通常用其他一些函数来代替![](./img/ee947eb219fd22b8b5d18470965cc38d.svg)称为“替代损失”。替代损失函数一般具有较好的数学性质，如通常它们是凸的连续函数且是![](./img/ee947eb219fd22b8b5d18470965cc38d.svg)的上界。常用三种替代损失函数：

1. hinge损失：![](./img/954ba0327acca153530ebda49140e30e.svg)
2. 指数损失：![](./img/80ab3186bb8c3dfbc8a3d09500b97f23.svg)
3. 对率损失：![](./img/028775d503dd91d69ee2ea01d9b8a437.svg)

![SVM4.png](./img/1592556977405-e2a8f8b2-e61a-4207-8b51-837e47f501aa.png)

<a name="d859347b-1"></a>
### 对偶问题

每个样本都有一个对应的松弛变量，用以表征该样本不满足约束的程度。但是仍是一个二次规划问题.于是，通过拉格朗日乘子法可得到拉格朗日函数

![](./img/9c2fc28b226ff7469e82118515f90f3d.svg)

其中![](./img/b6e5086e7de011bfa94a1259d3d971bb.svg)，![](./img/35e999a421ab1c3ad380420e0525e835.svg)是拉格朗日乘子

令![](./img/80b3b08aa243de99ff2bd198b7bb958b.svg)对![](./img/79e9bfbede1fc1768f403093bb7405d5.svg)的偏导为零可得

![](./img/3301fab4f1a0919a2fb242bdb4bef452.svg)

将上面三式代入拉格朗日函数即可得对偶问题

![](./img/5cbda2e373a61d0a7cb639d3076404a3.svg)

可以看出软间隔和硬间隔唯一的差别就在于对偶变量的约束不同：前者是![](./img/b50ca841bc2375228b0d74210a55441d.svg)，后者是![](./img/52c685a739ddc1ae1825b420c7029434.svg)。于是，可采用同样的算法求解上式。对软间隔支持向量机，KKT条件要求

![](./img/10dde04a273c79302b2c77fcc437d982.svg)

于是，对任意训练样本![](./img/e1b22a94bd6fb5e430efa18091a9b75d.svg)，总有![](./img/19a0a9d5131253d45925e6514ce5a4e6.svg)或![](./img/a7354667e0277e2a1de73a011eb30b09.svg)，且![](./img/4c90c6bd4f3e69854980cba3da6b9271.svg)所以参数含义：

1. 若![](./img/19a0a9d5131253d45925e6514ce5a4e6.svg)，则该样本不会对![](./img/50bbd36e1fd2333108437a2ca378be62.svg)有任何影响。
2. 若![](./img/cfa211928f1bbfd46d614463bcb0b954.svg)，则必有![](./img/a7354667e0277e2a1de73a011eb30b09.svg)，即该样本是支持向量。
3. 若![](./img/b110f6c2ec5333172a1bda28961cd2aa.svg)，则![](./img/433da8e35a413b2b8107f57960635d1a.svg)，进而有![](./img/9a4c285b6e7e8485d1ddce096bddef1d.svg)，即该样本恰在最大间隔边上。
4. 若![](./img/34bc15ce04b91765f5ce43dba1f25087.svg)，则![](./img/495dddddfa68ad3c1babcba730e7f998.svg)，此时若![](./img/45633ca574c5b8784330ec2e542561a5.svg)，即该样本落在最大间隔内部。
5. 若![](./img/5666174177868059d1840f4c428e1f91.svg)，则该样本被错误分类。

由此可看出，软间隔支持向量机的最终模型仅与支持向量有关，即通过采用hinge损失函数仍保持了稀疏性

<a name="c174b6cc"></a>
## 非线性支持向量机与核函数

对解线性分类问题，线性支持向量机是一种非常有效的方法。但是，有时分类问题是非线性的，这时可以使用非线性支持向量机。本节叙述非线性支持向量机，其主要特点是利用核技巧。

<a name="72161505"></a>
### 核技巧

非线性分类问题是指通过利用非线性模型才能很好地进行分类的问题。比如下图

![核技巧.png](./img/1592553316094-b0da78f8-fa2c-47cd-8597-61371ab60e38.png)

非线性问题往往不好求解，所采取的方法是进行一个非线性变换，将非线性问题变换为线性问题，通过解变换后的线性问题的方法求解原来的非线性问题。用线性分类方法求解非线性分类问题分为两步：

1. 1、首先使用一个变换将原空间的数据映射到新空间
2. 2、然后在新空间里用线性分类学习方法从训练数据中学习分类模型

核技巧应用到支持向量机，其基本想法就是通过一个非线性变换将空间(欧氏空间或离散集合)对应于一个特征空间(希尔伯特空间)，使得在输入空间中的超曲面模型对应特征空间中的超平面模型。这样，分类问题的学习任务通过在特征空间中求解线性支持向量机就可以完成。

<a name="ccc17688"></a>
#### [核函数的作用](https://www.zhihu.com/question/24627666/answer/28440943)

下面这张图位于第一、二象限内。我们关注红色的门，以及“北京四合院”这几个字下面的紫色的字母。我们把红色的门上的点看成是“+”数据，紫色字母上的点看成是“-”数据，它们的横、纵坐标是两个特征。显然，在这个二维空间内，“+”“-”两类数据不是线性可分的。

![](./img/1592553256474-0c6a1bdf-807e-4908-bfca-9f8acd81e3d2.jpeg)

我们现在考虑核函数![](./img/fa2a2773254252384680c103e0d16939.svg)，即“内积平方”。这里面![](./img/785423d15c2ac9f04dd0ff7dc47b7b1f.svg)是二维空间中的两个点。

这个核函数对应着二维到三维空间的映射，它的表达式是：![](./img/b4a820aa66a5c0efe3e3a12822956fcd.svg)，可以验证：

![](./img/99dac7c2442d9b3a2bd4215018d7f752.svg)<br />![](./img/049808be728067079d2f87a2178ce3e1.svg)

在P这个映射下，原来二维空间中的图在三维空间中的像是这个样子：![](./img/1592553256506-f8629783-6111-4f3b-8fe8-58aa38e65517.jpeg)

![](./img/1592553256492-946b7c92-917d-4e2c-9f74-aa712f2b888f.jpeg)

注意到绿色的平面可以完美地分割红色和紫色，也就是说，两类数据在三维空间中变成线性可分的了。

而三维中的这个判决边界，再映射回二维空间中是这样的：<br />![](./img/1592553256489-6d4d593c-8a81-451e-9881-836089df9ffb.jpeg)

这是一条双曲线，它不是线性的。核函数的作用就是隐含着一个从低维空间到高维空间的映射，而这个映射可以把低维空间中线性不可分的两类点变成线性可分的。它们映射到的高维空间的维数也比例子（三维）高得多，甚至是无穷维的。这样，就可以期待原来并不线性可分的两类点变成线性可分的了。

在机器学习中常用的核函数，一般有这么几类，也就是LibSVM中自带的这几类：

1. 线性：![](./img/6c06ec9acc9e9704dcd1ddfb4faf62c9.svg)
2. 多项式：![](./img/a644750d64c6df40bccab913d346b9cb.svg)
3. Radial basis function：![](./img/01ae917e2508e0b2378018b1effe277f.svg)
4. Sigmoid：![](./img/f81277dc0ad91d27292007e0a9c0cb03.svg)

上面的例子是2.多项式核函数中![](./img/28f4b274c320f4de672169b0ac5cd32d.svg)的情况。

核函数要满足的条件称为[Mercer's condition](https://link.zhihu.com/?target=http%3A//www.svms.org/mercer/)。在实用中，基本是试验各种核函数，并扫描其中的参数，选择效果最好的。所以说，至于什么样的核函数适用于什么样的问题还有待讨论。

<a name="634ee779"></a>
#### 核技巧在支持向量机中的应用

我们注意到在线性支持向量机的对偶问题中，无论是目标函数还是决策函数(分离超平面)都只涉及输入实例与实例之间的内积。在对偶问题的目标函数中的内积![](./img/fc81cc470a5d3c4b462cdbce130c084b.svg)可以用核函数![](./img/d92db1dc216111cfdbd2e424d237baf0.svg)来代替。此时对偶问题的目标函数称为

![](./img/48f1a7bd11f2a43a05c1b03e91fc29b2.svg)

同样，分类决策函数中的内积也可以用核函数代替，而分类决策函数式成为

![](./img/bc52b726f10bde2612ce0e5701e8cea6.svg)

这等价于经过映射函数![](./img/1ed346930917426bc46d41e22cc525ec.svg)将原来的输入空间变换到一个新的特征空间，将输入空间中的内积![](./img/fc81cc470a5d3c4b462cdbce130c084b.svg)变换为特征空间中的内积![](./img/179f247591e3748808e45afe27bbf03c.svg)，在新的特征空间里从训练样本中学习线性支持向量机。当映射函数是非线性函数时，学习到的含有核函数的支持向量机是非线性分类模型。

也就是说，在核函数![](./img/55047c95ee76eef4e928a4197562a05a.svg)给定的条件下，可以利用解线性分类问题的方法求解非线性分类问题的支持向量机。学习是隐式地在特征空间进行的，不需要显式地定义特征空间和映射函数。这样的技巧称为核技巧，它是巧妙地利用线性分类学习方法与核函数解决非线性问题的技术。在实际应用中，往往依赖领域知识直接选择核函数，核函数选择的有效性需要通过实验验证。

<a name="1e7dbe28"></a>
### 非线性支持向量分类机

如上所述，利用核技巧，可以将线性分类的学习方法应用到非线性分类问题中去。将线性支持向量机扩展到非线性支持向量机，只需将线性支持向量机对偶形式中的内积换成核函数。

从非线性分类训练集，通过核函数与软间隔最大化，或凸二次规划，学习得到的分类决策函数

![](./img/f1e05bb8c7fd58a61a32e818ad89f160.svg)

称为非线性支持向量，![](./img/55047c95ee76eef4e928a4197562a05a.svg)是正定核函数。

具体算法如下

输入：![](./img/b31f82d41a2695292974a67e540c75e3.svg)，其中![](./img/0b7afb95cade2d4b1118ddff00f8577d.svg)，![](./img/444096605851fb496be3a6b123373d26.svg)，![](./img/278a3fdadaae5c80e85ba69fb4f45874.svg)<br />输出：分类决策函数

1. 选取适当的核函数![](./img/55047c95ee76eef4e928a4197562a05a.svg)和适合的参数![](./img/0d61f8370cad1d412f80b84d143e1257.svg)，构造并求解最优化问题![](./img/fda270d705648f00172c5db8e0c68f0b.svg)

得到最优解![](./img/429b8d5a865270f6dd8c9ee5f85b8512.svg)

2. 选择![](./img/a26705b37fe0181c18770ae999082337.svg)的一个正分量![](./img/aaa48e674e8838378a9ca1aec5f9222d.svg)，计算![](./img/d10d31b4f8b768c8eae3cf236095ad3b.svg)
3. 构造决策函数![](./img/cd6fd38d5a043e67f2daaa2e8a300a46.svg)

<a name="91a299a0"></a>
## 序列最小最优化算法(SMO)

支持向量机的学习问题可以形式化求解凸二次规划问题。这样的凸二次规划问题具有全局最优解，并且有许多最优化算法可以用于这一问题的求解。但是当训练样本容量很大时，这些算法往往变得非常低效，以致无法使用。序列最小最优化算法(Sequential Minimal Optimization, SMO)为高效地实现支持向量机学习提供一个解决途径。

SMO算法要解如下凸二次规划的对偶问题：

![](./img/23442361abb1c7b468aae1086c7791ea.svg)

在这个问题中，变量是拉格朗日乘子，一个变量![](./img/cd0f1069db14b3485b705eb04d3e58a4.svg)对应于一个样本点![](./img/e1b22a94bd6fb5e430efa18091a9b75d.svg)；变量的总数等于训练样本总量![](./img/8d9c307cb7f3c4a32822a51922d1ceaa.svg)

SMO算法是一种启发式算法，其基本思路是：如果所有变量的解都满足此最优化问题的KKT条件，那么这个最优化问题的解就得到了。因为KKT条件是该优化问题的充分必要条件。否则，选择两个变量，固定其他变量，针对这两个变量构建一个二次规划问题。这个二次规划问题关于这两个变量的解应该更接近原始二次规划问题的解，因为这会使得原始二次规划问题的目标函数值变得更小。重要的是，这时子问题可以通过解析方法求解，这样就可以大大提高整个算法的计算速度。子问题有两个变量，一个是违反KKT条件最严重的那一个，另一个由约束条件自动确定。如此，SMO算法将原问题不断分解成子问题并对子问题求解，进而达到求解原问题的目的。

注意，子问题的两个变量中只有一个是自由变量。假设![](./img/26edac09bc64d341c7f2b0e3652e3bc8.svg)，![](./img/4caa5cd5a30e11c909ff2b3594e2dab6.svg)为两个变量，![](./img/fecbcfb7941ccc1c513214dec5b0f612.svg)固定，那么由等式约束![](./img/7e3b6004d68dfef5695fe0b23d260232.svg)可知

![](./img/f87dc3e971d81d41619ea902385f3885.svg)

如果![](./img/4caa5cd5a30e11c909ff2b3594e2dab6.svg)确定，那么![](./img/26edac09bc64d341c7f2b0e3652e3bc8.svg)也随之确定。所以子问题中同时更新两个变量。

整个SMO算法包括两个部分：求解两个变量二次规划的解析方法和选择变量的启发式方法。

<a name="0d41a260"></a>
### 两个变量二次规划的求解方法

SMO算法之所以高效，恰由于在固定其他参数后，仅优化两个参数的过程能做到非常高效。具体来说，仅考虑![](./img/cd0f1069db14b3485b705eb04d3e58a4.svg)，![](./img/2c25f9a26ae1b0a9a4977cd481af22e2.svg)时，约束![](./img/003b762300b0966cf9153b321ade94d0.svg)可重写为

![](./img/65610b9d4e5ac8d16f9db074c9f62da5.svg)

设![](./img/3759366b0b0dff7adbff8a29147dc7ba.svg)，就变成了

![](./img/d0b1e90348e87707584bcadf75b93945.svg)

代入对偶问题![](./img/b8564a868f5b15179b2213094aabe27f.svg)中消去变量![](./img/2c25f9a26ae1b0a9a4977cd481af22e2.svg)，则得到一个关于![](./img/cd0f1069db14b3485b705eb04d3e58a4.svg)的单变量二次规划问题，仅有的约束是![](./img/dda0716a1035cd95e656690c48740fbc.svg)。不难发现，这样的二次规划问题具有闭式解，于是不必调用数值优化算法即可高效地计算出更新后的![](./img/cd0f1069db14b3485b705eb04d3e58a4.svg)，![](./img/2c25f9a26ae1b0a9a4977cd481af22e2.svg)

如何确定偏移项![](./img/92eb5ffee6ae2fec3ad71c777531578f.svg)呢？注意到对任意支持向量![](./img/f60de60db1caffb2b8faf8d7b405f85b.svg)都有![](./img/2507325e40aeda8adb803f9d05675e47.svg)，即

![](./img/f62d5096e469ab2a2b1550d100a64b88.svg)

其中![](./img/7c55c11d94712ad060e3ea7bd034d038.svg)为所有支持向量的下标集。理论上，可选任意支持向量并通过求解上式获得![](./img/92eb5ffee6ae2fec3ad71c777531578f.svg)，但现实任务中常采用一种更鲁棒的做法：使用所有支持向量求解平均值

![](./img/8ac7ea847e170ac3d035dc4b4f7b145d.svg)

<a name="a471a7bf"></a>
### 变量的选择方法

注意到只需选取的![](./img/26edac09bc64d341c7f2b0e3652e3bc8.svg)，![](./img/4caa5cd5a30e11c909ff2b3594e2dab6.svg)中有一个不满足KKT条件，目标函数就会在迭代后增大。直观来看，KKT条件违背的程度越大，则变量更新后可能导致的目标函数值增幅越大。于是，SMO先选取违背KKT条件程度最大的变量。第二个变量应选择一个使目标函数值增长最快的变量，但由于比较各变量所对应的目标函数值增幅的复杂度过高，因此SMO采用了一个启发式：使选取的两变量所对应样本之间的间隔最大。一种直观的解释是，这样的两个变量有很大的差别，与对两个相似的变量进行更新相比，对它们进行更新会带给目标函数值更大的变化。

<a name="a6e40a50"></a>
## 支持向量回归

传统回归模型通常直接基于模型输出![](./img/50bbd36e1fd2333108437a2ca378be62.svg)与真实输出![](./img/415290769594460e2e485922904f345d.svg)之间的差别来计算损失，当且仅当![](./img/50bbd36e1fd2333108437a2ca378be62.svg)与![](./img/415290769594460e2e485922904f345d.svg)完全相同时，损失才是令零。与此不同，支持向量回归(Support Vector Regression, SVR)假设我们能容忍![](./img/50bbd36e1fd2333108437a2ca378be62.svg)与![](./img/415290769594460e2e485922904f345d.svg)之间最多有![](./img/92e4da341fe8f4cd46192f21b6ff3aa7.svg)的偏差，即仅当![](./img/50bbd36e1fd2333108437a2ca378be62.svg)与![](./img/415290769594460e2e485922904f345d.svg)之间的差别绝对值大于![](./img/92e4da341fe8f4cd46192f21b6ff3aa7.svg)时才计算损失。如下图所示，这相当于以![](./img/50bbd36e1fd2333108437a2ca378be62.svg)为中心，构建了一个宽度为![](./img/15ba5c2c4de89fbb2a2873e771b895ef.svg)的隔离带，若训练样本落入此间隔带，则认为是被预测正确的

![SVM5.png](./img/1592558281265-dd9e3106-2686-4be9-bfd8-b5762d713f50.png)

于是，SVR问题可形式化为

![](./img/530cb730ac00e558bb54890cae7a19c1.svg)

其中![](./img/0d61f8370cad1d412f80b84d143e1257.svg)为正则化常数，![](./img/bf31836db990cfb1d4d1e7715666599c.svg)是上图所示不敏感损失函数

![](./img/cba63ca3d335c7a6297e20315a304484.svg)

![SVM6.png](./img/1592558346701-e13f6e63-2106-4539-8ec1-2529bbf219dd.png)

引入松弛变量![](./img/9ea888f58114108ed02fea555f01fe8c.svg)和![](./img/e4184e523001ae5929899e7d9021b044.svg)，可将问题重写为

![](./img/c76bc4efb154902ab8c70c5e00686187.svg)<br />![](./img/26a3c4738bb52f6cb8c8cbec7655fdb5.svg)

引入拉格朗日乘子![](./img/d8918e03c6e0df6c0f29d6b65e84c8ea.svg)，由拉格朗日乘子法可得到拉格朗日函数

![](./img/2e020b25b324a5c557af438f72a7e5c4.svg)<br />![](./img/640a7ff26234751e837bab941faa35ce.svg)

将![](./img/49a934b4a3479f2ca12dda17d621757d.svg)代入，再令![](./img/2e020b25b324a5c557af438f72a7e5c4.svg)对![](./img/f1697e28541949270e1d8ceb17d1f276.svg)的偏导为零

![](./img/e8e26dac9a664125c3026df15c5aba27.svg)    ![](./img/19dccf527982e57d561f3c6a0128ccd5.svg)    ![](./img/2b9f078a26736f7216d068a0242d82af.svg)    ![](./img/be835315b486f47e59aef93e59b268d2.svg)

代入拉格朗日函数，即可得到SVR的对偶问题

![](./img/2c91e0d321ee194ccf42c8de1e22dff3.svg)<br />![](./img/cd4f9c4b477eecfc4e88f24476a9f034.svg)

上述过程中需满足KKT条件，即要求

![](./img/a4fd32b5b7777e2af9dfa8f7726c5872.svg)

可以看出，当且仅当![](./img/bf75c44430d7445046fe20dc11767b98.svg)时![](./img/cd0f1069db14b3485b705eb04d3e58a4.svg)能取非零值，当且仅当![](./img/af20301d6b2a0c13b196141c3913e463.svg)时![](./img/392563a03ecec8cfc5cb65f56b51954e.svg)能取非零值。换言之，仅当样本不落入![](./img/92e4da341fe8f4cd46192f21b6ff3aa7.svg)区间隔带中，相应的![](./img/cd0f1069db14b3485b705eb04d3e58a4.svg)和![](./img/392563a03ecec8cfc5cb65f56b51954e.svg)才能取非零值。此外，约束![](./img/bccb95fdb122e6f88849292f29814882.svg)和 ![](./img/af20301d6b2a0c13b196141c3913e463.svg)不能同时成立，因此![](./img/cd0f1069db14b3485b705eb04d3e58a4.svg)和![](./img/392563a03ecec8cfc5cb65f56b51954e.svg)中至少有一个为零。SVR的解形如

![](./img/cb49bd98fb18e37f6703bf413dba356e.svg)

能使上式中的![](./img/6b2a4e456b27e72fd40461cbdebfb90e.svg)的样本即为SVR的支持向量，它们必落在![](./img/92e4da341fe8f4cd46192f21b6ff3aa7.svg)间隔带之外。显然，SVR的支持向量仅是训练样本的一部分，即其解仍具有稀疏性。

由KKT条件可看出，对每个样本都有![](./img/4d81b9f2c3ce9a399d4722734329d133.svg)且![](./img/6323c646c4ddaeaeafde56f276875039.svg)。于是，在得到![](./img/cd0f1069db14b3485b705eb04d3e58a4.svg)后，若![](./img/4438561e3913ee52856bcdd0b1c56fa7.svg)，则必有![](./img/9a4c285b6e7e8485d1ddce096bddef1d.svg)，进而有

![](./img/3d6a53ddf5cd30219719992273487222.svg)

因此，在求解式子得到![](./img/cd0f1069db14b3485b705eb04d3e58a4.svg)后，理论上来说，可任意选取满足![](./img/4438561e3913ee52856bcdd0b1c56fa7.svg)的样本通过上式求得![](./img/92eb5ffee6ae2fec3ad71c777531578f.svg)。实践中常采用一种更鲁棒的方法：选取多个(或所有)满足条件![](./img/4438561e3913ee52856bcdd0b1c56fa7.svg)的样本求解![](./img/92eb5ffee6ae2fec3ad71c777531578f.svg)后取均值。

若考虑特征映射形式，则式形如![](./img/b87724731e547be792dce7f1e8e7df13.svg)，则SVR可表示为![](./img/2f82e8cae50aaa5b7e59958dce7c5b18.svg)，其中![](./img/5fd293d62fcffdbf7832fe69df40890d.svg)为核函数。

<a name="618c6a57"></a>
## [Code实现](https://github.com/fengdu78/lihang-code/blob/master/code/%E7%AC%AC7%E7%AB%A0%20%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%28SVM%29/support-vector-machine.ipynb)

<a name="0d830788"></a>
### 数据

```python
import numpy as np
import pandas as pd
from sklearn.datasets import load_iris
from sklearn.model_selection import  train_test_split
import matplotlib.pyplot as plt
%matplotlib inline

# data
def create_data():
    iris = load_iris()
    df = pd.DataFrame(iris.data, columns=iris.feature_names)
    df['label'] = iris.target
    df.columns = ['sepal length', 'sepal width', 'petal length', 'petal width', 'label']
    data = np.array(df.iloc[:100, [0, 1, -1]])
    for i in range(len(data)):
        if data[i,-1] == 0:
            data[i,-1] = -1
    # print(data)
    return data[:,:2], data[:,-1]

X, y = create_data()
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25)

plt.scatter(X[:50,0],X[:50,1], label='0')
plt.scatter(X[50:,0],X[50:,1], label='1')
plt.legend()
```

![SVM7.png](./img/1592558904506-8aa21ec8-6ca4-498d-887c-11f39ade2551.png)

<a name="6f8f142d"></a>
### 手写实现

```python
class SVM:
    def __init__(self, max_iter=100, kernel='linear'):
        self.max_iter = max_iter
        self._kernel = kernel
    
    def init_args(self, features, labels):
        self.m, self.n = features.shape
        self.X = features
        self.Y = labels
        self.b = 0.0
        
        # 将Ei保存在一个列表里
        self.alpha = np.ones(self.m)
        self.E = [self._E(i) for i in range(self.m)]
        # 松弛变量
        self.C = 1.0
        
    def _KKT(self, i):
        y_g = self._g(i)*self.Y[i]
        if self.alpha[i] == 0:
            return y_g >= 1
        elif 0 < self.alpha[i] < self.C:
            return y_g == 1
        else:
            return y_g <= 1
    
    # g(x)预测值，输入xi（X[i]）
    def _g(self, i):
        r = self.b
        for j in range(self.m):
            r += self.alpha[j]*self.Y[j]*self.kernel(self.X[i], self.X[j])
        return r
    
    # 核函数
    def kernel(self, x1, x2):
        if self._kernel == 'linear':
            return sum([x1[k]*x2[k] for k in range(self.n)])
        elif self._kernel == 'poly':
            return (sum([x1[k]*x2[k] for k in range(self.n)]) + 1)**2
    
        return 0
    
    # E（x）为g(x)对输入x的预测值和y的差
    def _E(self, i):
        return self._g(i) - self.Y[i]
    
    def _init_alpha(self):
        # 外层循环首先遍历所有满足0<a<C的样本点，检验是否满足KKT
        index_list = [i for i in range(self.m) if 0 < self.alpha[i] < self.C]
        # 否则遍历整个训练集
        non_satisfy_list = [i for i in range(self.m) if i not in index_list]
        index_list.extend(non_satisfy_list)
        
        for i in index_list:
            if self._KKT(i):
                continue
            
            E1 = self.E[i]
            # 如果E2是+，选择最小的；如果E2是负的，选择最大的
            if E1 >= 0:
                j = min(range(self.m), key=lambda x: self.E[x])
            else:
                j = max(range(self.m), key=lambda x: self.E[x])
            return i, j
        
    def _compare(self, _alpha, L, H):
        if _alpha > H:
            return H
        elif _alpha < L:
            return L
        else:
            return _alpha      
    
    def fit(self, features, labels):
        self.init_args(features, labels)
        
        for t in range(self.max_iter):
            # train
            i1, i2 = self._init_alpha()
            
            # 边界
            if self.Y[i1] == self.Y[i2]:
                L = max(0, self.alpha[i1]+self.alpha[i2]-self.C)
                H = min(self.C, self.alpha[i1]+self.alpha[i2])
            else:
                L = max(0, self.alpha[i2]-self.alpha[i1])
                H = min(self.C, self.C+self.alpha[i2]-self.alpha[i1])
                
            E1 = self.E[i1]
            E2 = self.E[i2]
            # eta=K11+K22-2K12
            eta = self.kernel(self.X[i1], self.X[i1]) + self.kernel(self.X[i2], self.X[i2]) - 2*self.kernel(self.X[i1], self.X[i2])
            if eta <= 0:
                # print('eta <= 0')
                continue
                
            alpha2_new_unc = self.alpha[i2] + self.Y[i2] * (E1 - E2) / eta#此处有修改，根据书上应该是E1 - E2，书上130-131页
            alpha2_new = self._compare(alpha2_new_unc, L, H)
            
            alpha1_new = self.alpha[i1] + self.Y[i1] * self.Y[i2] * (self.alpha[i2] - alpha2_new)
            
            b1_new = -E1 - self.Y[i1] * self.kernel(self.X[i1], self.X[i1]) * (alpha1_new-self.alpha[i1]) - self.Y[i2] * self.kernel(self.X[i2], self.X[i1]) * (alpha2_new-self.alpha[i2])+ self.b 
            b2_new = -E2 - self.Y[i1] * self.kernel(self.X[i1], self.X[i2]) * (alpha1_new-self.alpha[i1]) - self.Y[i2] * self.kernel(self.X[i2], self.X[i2]) * (alpha2_new-self.alpha[i2])+ self.b 
            
            if 0 < alpha1_new < self.C:
                b_new = b1_new
            elif 0 < alpha2_new < self.C:
                b_new = b2_new
            else:
                # 选择中点
                b_new = (b1_new + b2_new) / 2
                
            # 更新参数
            self.alpha[i1] = alpha1_new
            self.alpha[i2] = alpha2_new
            self.b = b_new
            
            self.E[i1] = self._E(i1)
            self.E[i2] = self._E(i2)
        return 'train done!'
            
    def predict(self, data):
        r = self.b
        for i in range(self.m):
            r += self.alpha[i] * self.Y[i] * self.kernel(data, self.X[i])
            
        return 1 if r > 0 else -1
    
    def score(self, X_test, y_test):
        right_count = 0
        for i in range(len(X_test)):
            result = self.predict(X_test[i])
            if result == y_test[i]:
                right_count += 1
        return right_count / len(X_test)
    
    def _weight(self):
        # linear model
        yx = self.Y.reshape(-1, 1)*self.X
        self.w = np.dot(yx.T, self.alpha)
        return self.w

svm = SVM(max_iter=200)
svm.fit(X_train, y_train)
svm.score(X_test, y_test)
```

<a name="904b59e8"></a>
### sklearn实现

[https://scikit-learn.org/stable/modules/generated/sklearn.svm.SVC.html](https://scikit-learn.org/stable/modules/generated/sklearn.svm.SVC.html)

```python
from sklearn.svm import SVC
clf = SVC()
clf.fit(X_train, y_train)

clf.score(X_test, y_test)
```

<a name="Source"></a>
## Source

[https://www.zhihu.com/question/24627666/answer/28440943](https://www.zhihu.com/question/24627666/answer/28440943)
