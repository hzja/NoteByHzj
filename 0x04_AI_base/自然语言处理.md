<a name="d1c2799b"></a>
## 自然语言处理基础

<a name="f89dc76e"></a>
### 通用应用

1. 机器翻译：计算机具备将一种语言翻译成另一种语言的能力
2. 情感分析：计算机能够判断用户评论的情感色彩
3. 智能问答：计算机能够正确的回答输入的问题
4. 文摘生成：计算机能够准确归纳、总结并生成文本摘要
5. 文本分类：计算机能够采集各种文章，进行主题分析，从而进行自动分类
6. 舆论分析：计算机能够判断目前的舆论的导向
7. 知识图谱：知识点相互连接而形成的语义网络

<a name="60657fa7"></a>
### 基本术语

1、分词(Segment)：将文本分割成最小的能够独立活动的有意义的语言成分。对中文来说十分重要。例如：“美国/会/通过对台售武法案”又可“美/国会/通过对台售武法案”

2、词性标注(Part-of-speech Tagging)：将词性(动词、名词、形容词等)标注，目的是表征词的一种隐藏状态，隐藏状态的转移就构成了状态转移序列。例如：我/r 爱/v 北京/ns 天安门/ns

3、命名实体识别(NER, Named Entity Recognition)：从文本中识别具有特定类别的实体(通常是名词)，例如人名、地名、机构名、专有名词等。例如：山东鲁能泰山

4、句法分析(Syntax Parsing)：最初利用语言学家的只是来构建的。目的是解析句子中各个成分的依赖关系，往往最终生成的结果是一颗句法分析树。句法分析可以解决传统词袋模型不考虑上下文的问题。

5、指代消除(Anaphora Resolution)：他她它，这里...等代词到底代表前文的什么内容

6、情感识别(Emotion Recognition)：情感识别本质是分类问题，一般可分为正面、负面、中性等。

7、纠错(Correction)：自动纠错在搜索技术以及输入法中利用的多。由于用户单词拼错等等...

8、问答系统(QA System)：类似机器人的人工智能系统

<a name="c4118439"></a>
### 知识结构

1、句法语义分析：针对目标句子，进行各种句法分析，如分词、词性标记、命名实体识别及链接、句法分析、语义角色和多义词消歧等。

2、关键词抽取：抽取目标文本的主要信息，比如从一条新闻中抽取关键信息。主要是了解是谁、于何时、为何、对谁、做了何事、产生了有什么结果。涉及实体识别、时间抽取、因果关系抽取等多项关键技术。

3、文本挖掘：主要包含了对文本的聚类、分类、信息抽取、摘要、情感分析以及对挖掘的信息和知识的可视化、交互式的呈现界面

4、机器翻译：将输入的源语言通过自动翻译转化为另一种语言的文本。根据输入的数据类型的不同，可细分为文本翻译、语音翻译、手语翻译、图形翻译等。

5、信息检索：对大规模的文档进行索引。可简单对文档中的词汇，赋以不同的权重来建立索引，也可使用算法模型来建立更加深层次的索引。查询时，首先对输入来进行分析，然后在索引里面查找匹配的候选文档，再根据一个排序机制把候选文档排序，最后输出排序得分较高的文档。

6、问答系统：针对某个自然语言表达的问题，由问答系统给出一个精准的答案。需要对自然语言查询语句进行语义分析，包括实体链接、关系识别，形成逻辑表达式，然后到知识库中查找可能的候选答案并通过一个排序机制找出最佳的答案。

7、对话系统：系统通过多回合对话，跟用户进行聊天、回答、完成某项任务。主要涉及用户意图理解、通用聊天引擎、问答引擎、对话管理等技术。此外，为了体现上下文相关，要具备多轮对话能力。同时，为了体现个性化，对话系统还需要基于用户画像做个性化回复。

<a name="69416cee"></a>
### 三个层面

1、词法层面：包括分词和词性标注两部分。

2、句法分析：对输入的文本以句子为单位，进行分析得到句子的句法结构的处理过程。

3、语义分析：理解句子表达的真实语义。

<a name="2ea167dd"></a>
## 自然语言处理发展

前期分为两个阶段：人类学习语言的方式（基于规则）、基于数学模型和统计方法（基于统计）；

时至今日，大家在使用深度学习解决问题，探索知识图谱在自然语言处理领域的方法。

<a name="c661bb9c"></a>
#### 人类学习语言的方式（基于规则）

20世纪50至70年代，对计算机处理自然语言的认识基本都基于人类学习语言的方式，也就是说，想方设法用电脑模拟人脑。当时，学术界认为要让机器完成翻译或者语音识别等人类才能做得事，必须要让计算机拥有类似人类这样的智能。

<a name="604660a0"></a>
#### 基于数学模型和统计方法（基于统计）

20世纪70年代，基于统计的方法的核心模型是**通信系统**加**隐马尔可夫模型**。之后随着计算能力的提高和数据量的不断增加，通过统计得到的句法规则甚至比语言学家总结的更具说服力。

<a name="680373fd"></a>
#### 基于深度学习的方法

![Deep Learning for NLP.png](./img/1598336453704-7b95b352-f969-4c0a-a1f4-5004cadcdc11.png)

<a name="5beb5cb5"></a>
#### 基于知识图谱的方法

To be continued

<a name="d549fc7b"></a>
## 通信模型

一个典型的通信系统：发送者（人或者机器）发送信息时，需要采取一种能在媒体中（比如空气、电线）传播的信号（语音或电话线的调制信号），这个过程就是广义上的编码。然后通过媒体传播到接收方，这个过程就是信道传输。在接收方，接受者（人或者机器）根据事先约定好的方法，将这些信号还原成发送者的信息，这个过程就是广义上的解码。

![通信模型.png](./img/1598336480369-31e65e96-774a-4a87-89cc-f62fb8f00a2a.png)

其中![](./img/ccfae785abd1c7e753978236e8e6ff64.svg)表示信息源发出的信号（比如手机发送的信号）。![](./img/4b03af8cd9cd57bbaeaa8b44ab61b2c2.svg)是接收器（比如另一部手机）接收到的信号。通信中的解码就是根据接收到的信号![](./img/4b03af8cd9cd57bbaeaa8b44ab61b2c2.svg)还原发送的信号![](./img/ccfae785abd1c7e753978236e8e6ff64.svg)。在通信中，如何根据接收端的观测信号来推测信号源发送的信息呢？只需要从所有的源信息中找到最可能产生出观测信号的那一个信息。用概率论的语言来描述，就是在已知![](./img/4b03af8cd9cd57bbaeaa8b44ab61b2c2.svg)的情况下，求得令条件概率

![](./img/c4ec19816f095a65e496532fbe347e81.svg)达到最大值的那个信息串![](./img/e19b0c700838f01fbdf137d4fdbf3a12.svg)，即

![](./img/11b64ec11d8bc7663bfb6201aaf46318.svg)

上面的概率不容易直接求出，不过可以间接地计算它。利用贝叶斯公式可以把上述公式等价变换成

![](./img/8856e4854349726ef143b537c759557b.svg)

其中![](./img/353c7d9d496aa732fbb2c9e993cb7f4a.svg)表示信息![](./img/e19b0c700838f01fbdf137d4fdbf3a12.svg)在传输后变成接收的信号![](./img/85064e2bb1731dafb08a00f37546fb00.svg)的可能性；而![](./img/0ae616161f6cdfda636bc13c9229184e.svg)表示![](./img/e19b0c700838f01fbdf137d4fdbf3a12.svg)本身是一个在接收端合乎情理的信号（比如一个合乎情理的句子）的可能性；最后![](./img/51c0e09ff10271f088a8413744cabcb9.svg)表示在发送端（比如说话的人）产生信息![](./img/85064e2bb1731dafb08a00f37546fb00.svg)的可能性，因为一旦信息![](./img/85064e2bb1731dafb08a00f37546fb00.svg)产生了，它就不会改变了，这时![](./img/51c0e09ff10271f088a8413744cabcb9.svg)就是一个可以忽略的常数。因此，上面的公式可等价成

![](./img/ed530e1a1b8795ade6e4ef740a2f7c12.svg)

虽然多了一项，但这个公式完全可以用隐马尔可夫模型来估计。

<a name="a58a08e6"></a>
## 隐马尔可夫模型

更详细可见机器学习概率图模型部分。

<a name="006c9daa"></a>
### 马尔可夫链

假设随机过程中各个状态![](./img/86ad9159785a8f6f1c1a74c4eac26365.svg)的概率分布，只与它之前的一个状态![](./img/cc50d8301ddb3d833f2168022ebb1c67.svg)有关，即![](./img/344f920483f0466d09a6394313dcdec7.svg)。比如硬性规定今天的气温只跟昨天有关，跟前天或之前的天气无关。这种假设未必适用所有的应用，但是至少对以前很多不好解决的问题给出了近似解。这个假设后来被命名为马尔可夫假设，而符合这个假设的随机过程则称为马尔可夫过程，也称为马尔可夫链。

![马尔可夫链.jpg](./img/1598603756143-b2ae4c1d-5201-408f-acd0-de45dfd328f0.jpeg)

上图中，四个圈表示四个状态，每条边表示一个可能的状态转换，边上的权值为转移概率。例如，状态![](./img/377b1a53b01e907138040867edc7cac2.svg)到状态![](./img/a4e435d4d078e7df1fa07e13d4a32ebb.svg)之间只有一条边，且边上的权重为1.0。这表示从状态![](./img/377b1a53b01e907138040867edc7cac2.svg)只可能转换到状态![](./img/a4e435d4d078e7df1fa07e13d4a32ebb.svg)，转移概率为1.0。从![](./img/a4e435d4d078e7df1fa07e13d4a32ebb.svg)出发的有两条边：到![](./img/7068ce0a09670fa0de05318019a7a44a.svg)和到![](./img/b5d338975faf94db214094f2008a10b0.svg)。其中权值0.6表示：如果某个时刻![](./img/e358efa489f58062f10dd7316b65649e.svg)的状态![](./img/86ad9159785a8f6f1c1a74c4eac26365.svg)是![](./img/a4e435d4d078e7df1fa07e13d4a32ebb.svg)，则下一个时刻的状态![](./img/a7f13f3c2a9458be062e9ae65bf0c5b5.svg)的概率是60%。如果用数学符号表示是![](./img/451327444b9562cda2b77a7746b20fc4.svg)。类似的，有![](./img/7fb23f095d8f8a975cd69fbfc0a6fdde.svg)。随机选择一个状态作为初始状态，随后按照上述规则随机选择后续状态。这样运行一段时间![](./img/b9ece18c950afbfa6b0fdbfa4ff731d3.svg)后，就会产生一个状态序列：![](./img/8d0e7fc13bd2bfece1c43f0d590fad74.svg)。

<a name="a58a08e6-1"></a>
### 隐马尔可夫模型

隐马尔可夫模型是马尔可夫链的一个扩展：任一时刻![](./img/e358efa489f58062f10dd7316b65649e.svg)的状态![](./img/86ad9159785a8f6f1c1a74c4eac26365.svg)是不可见的。观察者没法通过观察到一个状态序列![](./img/1462b55a711fd73d7b31bd5d3276299a.svg)来推测转移概率等参数。但是，隐马尔可夫模型在每个时刻![](./img/e358efa489f58062f10dd7316b65649e.svg)会输出一个符号![](./img/2b2a0a4b3fbc78a61cec549a40912932.svg)，而且![](./img/2b2a0a4b3fbc78a61cec549a40912932.svg)跟![](./img/86ad9159785a8f6f1c1a74c4eac26365.svg)相关且仅跟![](./img/86ad9159785a8f6f1c1a74c4eac26365.svg)相关。即，我们观测不到状态变化，只能观测到输出符号。

![隐马尔可夫模型.png](./img/1598603774787-39be23c5-895e-4547-8e31-38c58cb7d9fb.png)

基于马尔可夫假设和独立输出假设，我们可以计算出某个特定的状态序列![](./img/f8a317ff7a0454fcced9aaf4e87cd38c.svg)产生输出符号![](./img/62105f989f430ded6fc4ccb155b89ff1.svg)的概率

![](./img/616c929a5447f3a29cfa39d53a2c6b2e.svg)

现在我们把马尔可夫假设和独立输出假设用于通信编码问题（上一节最后一个公式），即把

![](./img/797e09e861c46a2d782f1fa9028a4bbd.svg)<br />![](./img/4149025b9df810b04d377227889ce836.svg)

这样通信的解码问题就可以用隐马尔可夫模型来解决了。至于如何找出上面式子的最大值，进而找出识别的句子![](./img/f8a317ff7a0454fcced9aaf4e87cd38c.svg)，可以利用维特比算法来解决。

针对不同的应用，![](./img/33cee5a64df92b31ca33ec86490dd517.svg)的名称也各不相同，在语音识别中它称为“声学模型”，机器翻译中是“翻译模型”，在拼写矫正中是“纠错模型”。

<a name="a33da386"></a>
## 隐马尔可夫模型的训练

围绕着隐马尔可夫模型有三个基本问题：

1、给定模型，如何计算某个特定的输出序列的概率 ->  前向与后向（Forward-Backward）算法

2、给定模型和特定的输出序列，找到最能产生这个输出序列的状态序列 -> 维特比（Viterbi Algorithm）算法

3、给定足够量的观测数据，如何估计隐马尔可夫模型的参数 -> 鲍姆-韦尔奇算法

<a name="b86c7215-1"></a>
### 给定一个模型，如何计算某个特定的输出序列的概率

使用前向与后向（Forward-Backward）算法。现实任务中，许多任务需要根据以往的观测序列来推测当前时刻最有可能的观测值，这显然可转化为这个计算特定输出序列的概率的问题。

<a name="8ad8e60f"></a>
#### 前向算法

给定隐马尔可夫模型![](./img/c6a6eb61fd9c6c913da73b3642ca147d.svg)，定义到时刻![](./img/e358efa489f58062f10dd7316b65649e.svg)部分观测序列为![](./img/d30b73104a572bc4d0331a31990694c3.svg)且状态为![](./img/da326f7200e158a864695985b2e2f095.svg)的概率为**前向概率**，记作：![](./img/5ab9e8f0dfd9164a1ba25674c414fc94.svg)可以递推地求得前向概率![](./img/72a38afb28584e909938b240ab4d27d1.svg)及观测序列概率![](./img/6f9122ed89c22df2e6263ed956b37a63.svg)

- 输入：隐马尔可夫模型![](./img/c6a6eb61fd9c6c913da73b3642ca147d.svg)，观测序列![](./img/f186217753c37b9b9f958d906208506e.svg)
- 输出：观测序列概率![](./img/6f9122ed89c22df2e6263ed956b37a63.svg)
- （1）初值：![](./img/75a80805e645f1f0efd04acb5fb93f81.svg)
- （2）递推：对![](./img/339c2a1c3bf7cd4cd0e8132f177436b1.svg)：![](./img/aea14520e57fe2dfe61afe61d9c2f34c.svg)
- （3）终止：![](./img/27bc94b6dbf2ba955d775a72a7d96e0f.svg)

递推部分就是上个状态转移到当前状态的所有可能乘上当前状态出现对应观测的概率；终止部分即把所有可能出现这种观测的可能加起来，即![](./img/6f9122ed89c22df2e6263ed956b37a63.svg)

**举例如下**

考虑盒子和球模型![](./img/c97cf758ccaab2fce0bd106636e46bea.svg)，状态集合![](./img/4e66464b36b4e885d3294f70c41dcd41.svg)，观测集合![](./img/c2f13d8361173700171329ef81e83dcd.svg)，

![](./img/a37c29e90e8dce7d80268a456b847e39.svg)，![](./img/a1e2a42c147557da8f2e009d3ab07c68.svg)，![](./img/b202c6b2e4d217592f053e25afe681d9.svg)

设![](./img/3e0db748cdfc1dc10642d37a8df8be00.svg)，![](./img/b1b00cfe91c0023643719e431ea0464a.svg)，用前向算法计算![](./img/6f9122ed89c22df2e6263ed956b37a63.svg)

- （1）初值：
   - ![](./img/4a8be452a49f9e58cb52726b6693c36f.svg)
   - ![](./img/a57e186fff666b35c6350d0e7bc0d90a.svg)
   - ![](./img/83a7c8f6e5bb299753ed49c6d85d84cb.svg)
- （2）迭代：
   - ![](./img/64243cc2c02b4dcdd6740aaefef86fb8.svg)
   - ![](./img/871ebc9654769f0cf5fa9fec6135e31b.svg)
   - ![](./img/9bddcfea41dc7e553f576b1fc04bbe04.svg)
   - ![](./img/3e96ae580bfb10767c68b82d2d6201c9.svg)
   - ![](./img/066f5fddeb701a62bf097478016c859d.svg)
   - ![](./img/44f36ae4db28c1d1476b4d1d007d0dd1.svg)
- （3）终止：
   - ![](./img/28fed09d9184fd5373dc581b5e8922bb.svg)

<a name="6fb815d9"></a>
#### 后向算法

给定隐马尔可夫模型![](./img/c6a6eb61fd9c6c913da73b3642ca147d.svg)，定义在时刻![](./img/e358efa489f58062f10dd7316b65649e.svg)状态为![](./img/da326f7200e158a864695985b2e2f095.svg)的条件下，从![](./img/43c98a64bcde4857b095743482e04281.svg) 到![](./img/b9ece18c950afbfa6b0fdbfa4ff731d3.svg)的部分观测序列为![](./img/5799dab2d3328f8f5d97a830d01015b5.svg)的概率为**后向概率**，记作：![](./img/4f785ba4b3deea847d5c57d380f82bfa.svg)可以用递推地方法求得后向概率![](./img/e2cf72393f4a898513a0bda08d1b1e22.svg)及观测序列概率![](./img/6f9122ed89c22df2e6263ed956b37a63.svg)

- 输入：隐马尔可夫模型![](./img/c6a6eb61fd9c6c913da73b3642ca147d.svg)，观测序列![](./img/f186217753c37b9b9f958d906208506e.svg)
- 输出：观测序列概率![](./img/6f9122ed89c22df2e6263ed956b37a63.svg)
- （1）![](./img/cb63847d872480259352a619e2cbcbda.svg)
- （2）对![](./img/fb409df6274cbda6bf9e99a69ab3f8a0.svg)：![](./img/a0cc86178deeb0c4c747ece5b06dd641.svg)
- （3）![](./img/e422e4b8ebf39f5d6a5ff090016eb1d3.svg)

<a name="c21d82ed"></a>
### 给定一个模型和某个特定的输出序列，找到最能产生这个输出序列的状态序列

使用维特比（Viterbi Algorithm）算法。在语音识别等任务中，观测值为语音信号，隐藏状态为文字，目标就是根据观测信号来推断最有可能的状态序列（即对应的文字）。

维特比算法是一种动态规划方法，核心思想是：如果最终的最优路径经过某个![](./img/c02c4a71b77353b6618d5fb75c880ad7.svg)，那么从初始节点到![](./img/df9a2c91fd0411f6c942b10cacc80370.svg)点的路径必然也是一个最优路径，因为每一个节点![](./img/c02c4a71b77353b6618d5fb75c880ad7.svg)只会影响前后两个![](./img/be803de30bf8ae4bec9733689774321c.svg)和![](./img/8e268d819650aa91b5d34fdd3f129cc2.svg)

维特比算法实际上是用动态规划解隐马尔可夫模型预测问题，即用动态规划求概率最大路径。这时一条路径对应着一个状态序列。根据动态规划原理，最优路径具有这样的特性：如果最优路径在时刻![](./img/e358efa489f58062f10dd7316b65649e.svg)通过结点![](./img/70991df5c5bd2bed18661eb397aa1984.svg)，那么这一路径从结点![](./img/70991df5c5bd2bed18661eb397aa1984.svg)到终点![](./img/24506a10c0292ba503e694bc0b23fdec.svg)的部分路径，对于从![](./img/70991df5c5bd2bed18661eb397aa1984.svg)到![](./img/24506a10c0292ba503e694bc0b23fdec.svg)的所有可能的部分路径来说，必须是最优的。因为假如不是这样，那么从![](./img/70991df5c5bd2bed18661eb397aa1984.svg)到![](./img/24506a10c0292ba503e694bc0b23fdec.svg)就有另一条更好的部分路径存在，如果把它和从![](./img/5e432c91623ca672a563c58b83ba6247.svg)到![](./img/70991df5c5bd2bed18661eb397aa1984.svg)的部分路径连接起来，就会形成一条比原来的路径更优的路径，这是矛盾的。依据这一原理，我们只需从时刻![](./img/3f3d5118e374c670258e6e2b2cfb1b0c.svg)开始，递推地计算在时刻![](./img/e358efa489f58062f10dd7316b65649e.svg)状态为![](./img/865c0c0b4ab0e063e5caa3387c1a8741.svg)的各条部分路径的最大概率，直至得到时刻![](./img/66528de02779ea199e6274ffaa3a8c02.svg)状态为![](./img/865c0c0b4ab0e063e5caa3387c1a8741.svg) 的各条路径的最大概率。

- 输入：模型![](./img/73b5677a7472fd948c275c8b601b07b5.svg)和观测![](./img/230ad45fd7d82411b46c080e69f66fa8.svg)
- 输出：最优路径![](./img/da9e60ecc3561de7eeec627d67daac96.svg)
- （1）初始化：![](./img/8965cfe6b64f6cef7a7caa802a94f7c7.svg)
- （2）递推：对![](./img/8d721fdf1274f1f5c19a3192d7d37a10.svg)
   - ![](./img/b4dd6382e0260f3a27f9ef9c6210a1d0.svg)
   - ![](./img/f8001a7da11452052d3d09a8d33323fa.svg)
- （3）终止：![](./img/d9cf2f309f948ff375f779578ed05361.svg)   ![](./img/e78fa7e4445151f13609fd80d29aacda.svg)
- （4）最优路径回溯：对![](./img/fb409df6274cbda6bf9e99a69ab3f8a0.svg)
   - ![](./img/e9770f0483fb88e627357a2e0b4309d6.svg)

**举例如下**

考虑盒子和球模型![](./img/c97cf758ccaab2fce0bd106636e46bea.svg)，状态集合![](./img/4e66464b36b4e885d3294f70c41dcd41.svg)，观测集合![](./img/c2f13d8361173700171329ef81e83dcd.svg)，

![](./img/a37c29e90e8dce7d80268a456b847e39.svg)，![](./img/a1e2a42c147557da8f2e009d3ab07c68.svg) ，![](./img/b202c6b2e4d217592f053e25afe681d9.svg)

已知观测序列![](./img/b1b00cfe91c0023643719e431ea0464a.svg)，求最优状态序列，即最优路径![](./img/0b6b4f76c6a55e368b9a91999de4a439.svg)

（1）初始化。在![](./img/3f3d5118e374c670258e6e2b2cfb1b0c.svg)时，对每一个状态![](./img/41cab9292dedca932e9741a7a84f64a6.svg)，求状态![](./img/865c0c0b4ab0e063e5caa3387c1a8741.svg)观测![](./img/2857b4fd34e4e5eb74c88b872110da5f.svg)为红的概率，记此概率为![](./img/6bb83ddb1c89ccb257062e6eee589699.svg)，则

![](./img/cf6ad40ac9230c29485a1af599471b2c.svg)

代入实际数据

![](./img/a84cd96d9ada935e60661b25f091551c.svg)        ![](./img/ad66112919bdd28a46bb03bc0db91dd5.svg)        ![](./img/89d002163a2cd2c846ca086f0d867dc9.svg)

记![](./img/abcd927d70ce9c5aabd5ab2da40189ac.svg)

（2）在![](./img/a048559662d4b59eb8308cf4f404c163.svg)时，对每个状态![](./img/41cab9292dedca932e9741a7a84f64a6.svg)，求在![](./img/3f3d5118e374c670258e6e2b2cfb1b0c.svg)时状态为![](./img/363b122c528f54df4a0446b6bab05515.svg)观测为红并在![](./img/a048559662d4b59eb8308cf4f404c163.svg)时状态为![](./img/865c0c0b4ab0e063e5caa3387c1a8741.svg)观测![](./img/0a5da2e5220730129349ea549d1b3982.svg)为白的路径的最大概率，记此最大概率为![](./img/6a5e11780902298017cb93f95c78f791.svg)，则

![](./img/33a4b9f10ba0b42a781f9565c73f4c65.svg)

同时，对每个状态![](./img/41cab9292dedca932e9741a7a84f64a6.svg)，记录概率最大路径的前一个状态![](./img/363b122c528f54df4a0446b6bab05515.svg)

![](./img/6f176c18c9855fa1d18ed66fba185cdd.svg)

计算：

    ![](./img/7bdabb9bd438d04d24504c48748da326.svg)，![](./img/5ec899e788ffeaf5e928391984b449ff.svg)<br />    ![](./img/cd8d93070841d4c9192d4bc4c932c2f5.svg)，        ![](./img/41d1d8f11b6b06f2da3d2d5ad65e5995.svg)<br />    ![](./img/967d2f16e3f350e061eebb450bd4a400.svg)，          ![](./img/f220e097cfe9f0f670ac26c639c9b382.svg)

同样，在![](./img/8537377fdd5f3d3367c25fbcd8693925.svg)时，

![](./img/a201e853e44d6334227d349e1dc8fc54.svg)，    ![](./img/d50d6c66f53c127eae1d9c3cff1ea9b4.svg)<br />     ![](./img/5eb973eaac8016af34e3061b2340a31b.svg)，        ![](./img/323a5fabfd32846dcd403eaad3151853.svg)<br />     ![](./img/5eb974180beb52f817f2a735fa2879a4.svg)，        ![](./img/0fb20e0121ea65cd4796f9b618b8f121.svg)<br />     ![](./img/55d5030ec77dac30ea9c19fd1eced34c.svg) ，         ![](./img/3e544f09a3df7544096ba048ed818e9a.svg)<br />![求最优路径.png](./img/1598842128947-e68794e4-51ce-4720-9bbc-c3d2f1d7c0cf.png)

（3）以![](./img/7247767256f5aef95a2147aceb81abcc.svg)表示最优路径的概率，则

![](./img/ce687ad932349494501833a414670460.svg)

最优路径的终点是![](./img/9b46971900f0f561562ecec63d26495e.svg)

![](./img/99d575ffceb12727af6400559bef953e.svg)

（4）由最优路径的终点![](./img/9b46971900f0f561562ecec63d26495e.svg)，逆向找到![](./img/6ab09c4995629fc943d7f50d8e987ad5.svg)，![](./img/5e432c91623ca672a563c58b83ba6247.svg)

              在![](./img/a048559662d4b59eb8308cf4f404c163.svg)时，![](./img/ba61c616e5a4a151d522400d07bca7fa.svg)<br />              在![](./img/b73c3280b6f85a6ac520af103083f535.svg)时，![](./img/7be6fcf4386938afd7c472c2499c3be3.svg)

于是求得最优路径，即最优状态序列![](./img/b8a4cdc9faa45fe51fc7e2a7b66e0de0.svg)

<a name="2c1a58a8-1"></a>
### 给定足够量的观测数据，如何估计隐马尔可夫模型的参数

使用鲍姆-韦尔奇(Baum-Welch)算法，也就是EM算法。在大多数现实应用中，人工指定模型参数已变得越来越不可行，如何根据训练样本学得最优的模型参数，正好就是本问题。

在利用隐马尔可夫模型解决实际问题中，需要先知道每个状态![](./img/86ad9159785a8f6f1c1a74c4eac26365.svg)产生相应输出符号![](./img/2b2a0a4b3fbc78a61cec549a40912932.svg)的概率![](./img/6f24fa3732f535a8123023bbebfe39a8.svg)，也称为生成概率；和转移概率，即从前一个状态![](./img/cc50d8301ddb3d833f2168022ebb1c67.svg)进入当前状态![](./img/86ad9159785a8f6f1c1a74c4eac26365.svg)的概率![](./img/a3c68fa5826e9071b179d5077accfaad.svg)。这些概率被称为马尔可夫模型的参数，而计算或者估计这些参数的过程称为模型的训练。

我们从条件概率的定义出发，知道：

![](./img/5f1e4945720441152af5854d03ae563b.svg)<br />![](./img/50ae094672d2b4e57da5bd11f854bc72.svg)

对于上面第一个概率公式（生成概率），状态输出概率，如果有足够多人工标记的数据，知道经过状态![](./img/86ad9159785a8f6f1c1a74c4eac26365.svg)有多少次![](./img/5b01cbefcdbb7359ae9151c2cf6d3794.svg)，每经过这个状态时，分别产生的输出![](./img/2b2a0a4b3fbc78a61cec549a40912932.svg)是什么，而且分别有多少次![](./img/1ee258f8fde354ab94e09641d50afd29.svg)就可以算出（比如语音识别中，符号即每个词对应声波；中英翻译中，中文字为状态，英文字为输出符号）。上述第二个概率公式（转移概率），与前文提到的训练统计语言模型的条件概率完全相同，因此可以依照统计语言模型的训练方法，即数一下出现前一个词后出现这个词的次数（同上文例子，出现“联想”这个词后，出现“公司”的概率是多少，即数一下“联想”的次数，数一下“联想公司”的次数）

![](./img/2712a6ba45fb306205cf7644190d384e.svg)<br />![](./img/5b8046f1a237276ed511f6296a26a501.svg)

然而，像语音识别等这种应用大量人工标注不现实，所以这个方法只适用于一部分应用。因此，训练隐马尔可夫模型更实用的方法是仅仅通过大量观测到的信号![](./img/62105f989f430ded6fc4ccb155b89ff1.svg)就能推算模型参数的![](./img/9062942742031b0c192f99829448048c.svg)和![](./img/6f24fa3732f535a8123023bbebfe39a8.svg)的方法，主要是使用 鲍姆-韦尔奇算法

两个不同的隐马尔可夫模型可以产生同样的输出信号，因此，仅仅通过观察到的输出信号来倒推它的隐马尔可夫模型可能会得到多个合适的模型，但总会有一个模型![](./img/b74e69910b0a81b4a3cb5306e038a30d.svg)比其他的![](./img/c32257a1afceed0c4a50eec3d906c45c.svg)更有可能产生观测到的输出，其中![](./img/2554a2bb846cffd697389e5dc8912759.svg)是隐马尔科夫模型的参数（可理解为最大似然）。鲍姆-韦尔奇算法就是来寻找这个最可能的模型![](./img/75a0e4e40acd1f553b343e49aad85dfc.svg)

鲍姆-韦尔奇算法思想：

鲍姆-韦尔奇算法使用的就是EM算法原理。首先找到一组能够产生输出序列![](./img/f186217753c37b9b9f958d906208506e.svg)的模型参数（显然它们是一定存在的，因为转移概率![](./img/44c29edb103a2872f519ad0c9a0fdaaa.svg)和输出概率![](./img/f09564c9ca56850d4cd6b3319e541aee.svg)为均匀分布时，模型可以产生任何输出，当然包括我们观测到的输出![](./img/f186217753c37b9b9f958d906208506e.svg)）现在，有了这样一个初始模型![](./img/bfdbb4a3f27f9c40111dc8a9a59d2d05.svg)，根据上文提到的![](./img/5f1e4945720441152af5854d03ae563b.svg)和![](./img/d9a7a30f0f120cbcc2b85994fb97e5d4.svg)公式计算出一组新的模型参数![](./img/7672d625e9a2492987c50d3b87c04349.svg)，为一次迭代，可以证明![](./img/c9089f5c697168bb7980fa836a411795.svg)。经过不断迭代![](./img/e358efa489f58062f10dd7316b65649e.svg)轮，直到模型的质量不再有显著提高，得到的![](./img/2d2eca8e3c91543f842d75169a89dd0d.svg)即我们所求参数。

<a name="Source"></a>
## Source

[https://mp.weixin.qq.com/s/J3ot3BGg6fyjdSt0mW7mCA](https://mp.weixin.qq.com/s/J3ot3BGg6fyjdSt0mW7mCA)
