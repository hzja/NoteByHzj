<a name="InWxa"></a>
# 实际应用方法
在纵向联邦学习中，需要进行用户对齐，即交集计算。比如公司A有用户集合![](./img/d125675f3628262437d056a8b5cbfbad.svg)，公司B有用户集合![](./img/60de9e9fdc97886b4abc356eef11d750.svg)，这里![](./img/75c525fa340ab796b388e5fcd200291b.svg)，我们需要在不泄漏各个参与方(公司A和B)输入信息下，协同计算输入集合的交集，即参与方只能获得交集部分的ID，而不会获得或泄漏非交集的ID。

在实际的业务中，现在很难直接拿到设备号等数据锁定唯一用户，因为IOS禁掉了UDID和IDFA，Android在Android 11后也基本拿不到用户唯一识别ID，所以现在大家基本都采用多维度加某一算法唯一确定用户，比如取手机型号/系统版本/版本更新时间/手机用户名....等![](./img/7b8b965ad4bca0e41ab51de7b31363a1.svg)个维度，代入比如[md5算法](https://baike.baidu.com/item/MD5/212708)，最后输出一个值作为这个用户的唯一识别ID，如果有维度数据变化了，会重新计算更新之前计算的值。由于md5算法具有不可逆性(根据 MD5 值计算不出原始数据)，所以数据是安全的。

但在实际操作中，我们即使获取尽可能多的用户特征维度，也无法百分之百保证锁定的用户是唯一的，即有两个或至少两个用户![](./img/7b8b965ad4bca0e41ab51de7b31363a1.svg)个维度是相同的，我们代入算法后输出值也一致，这两个或至少两个用户就共享了同一个唯一识别ID。由于现在业界还没有一套标准解决方案(由于大家选择的维度和算法不一致，导致现在市面上有多套唯一识别ID，比如阿里有一套，京东有一套...)，而且也不可能会出现一套标准解决方案(如果某一方案应用特别广，利益涉及公司比如苹果公司会对这个方案使用公司发律师函，毕竟这是苹果手机厂商天然的护城河)。所以在实现纵向联邦学习时，各合作方间会商量好唯一识别码的计算方式，通过唯一识别码进行交集计算。

联邦学习交集计算，即隐私保护交集计算，主要分为三类：基于公钥加密、基于混淆电路和基于不经意传输的方法，这里分别进行介绍。
<a name="fUhFR"></a>
# 交集计算算法
<a name="SZRz8"></a>
## 基于公钥加密
在这类方法中，公钥加密方法被用于对集合中的元素进行加密，然后通过对密文的处理实现交集计算。
<a name="dOhrP"></a>
### 基于指数
一种简单的思想是，利用![](./img/1b44b6f5dead37df641c49032c3ec181.svg)这一性质，对于分别由双方所持有的元素![](./img/0d5fa3f335333b23d4aaf795d1336587.svg)和![](./img/e209e24a3d42a840c21481572570342f.svg)，双方分别产生![](./img/57cec4137b614c87cb4e24a3d003a3e0.svg)和![](./img/21c2e59531c8710156d34a3c30ac81d5.svg)，并共同验证![](./img/644c32c77db03e498c21b8361fde32ab.svg)和![](./img/86480b4450f37c5945cca98980dade99.svg)是否相等。具体来讲，持有![](./img/0d5fa3f335333b23d4aaf795d1336587.svg)的一方计算![](./img/8c63fa4a6a9a3b9388ea77241dbdfc95.svg)并且把结果发送给另一方，而另一方计算![](./img/b4f6290feed2bdbf249e776e933ef90b.svg)并且把结果发送给对方。双发得以计算![](./img/644c32c77db03e498c21b8361fde32ab.svg)和![](./img/86480b4450f37c5945cca98980dade99.svg)并且把结果发送给对方，从而验证两个元素![](./img/0d5fa3f335333b23d4aaf795d1336587.svg)和![](./img/e209e24a3d42a840c21481572570342f.svg)是否相等。为了防止另一方通过对数运算推出明文，这里的所有指数运算的结果都对![](./img/44c29edb103a2872f519ad0c9a0fdaaa.svg)进行取模运算，其中![](./img/44c29edb103a2872f519ad0c9a0fdaaa.svg)为双方共同选取的质数。双方将各自集合的元素两两组合，计算并验证是否相等，获得交集。
<a name="Qiapw"></a>
### 基于多项式
Freedman等人提出了基于公钥加密体制的隐私保护交集计算方法。它的具体过程如下。客户端对于其集合![](./img/e8c76f1664548660a7d288a9e588e587.svg)构造多项式，并且用同态加密算法加密多项式系数![](./img/250bf1f559b7a9a806588f4f9e65a2b7.svg)，然后发给服务端<br />![](./img/8bf0bbc187628f78862ea3bcbdadcc8a.svg)<br />服务端对于其集合![](./img/f6e4b89b915ecd5abbe54e9f53b9a450.svg)中每个元素![](./img/437f7046cb463518a28b277a85b47a5c.svg)计算<br />![](./img/46361fe64810fec8cf27dad5e0156a40.svg)<br />并且发送给客户端。式中，![](./img/1271f0f93bfc3a817435c93479112fc9.svg)表示密文；![](./img/4b43b0aee35624cd95b910189b3dc231.svg)为服务端产生的随机数。显然，如果![](./img/fd0649eb8663703ecd05b99de45a5d25.svg)，即![](./img/374bf7e55178ac77e54321c9c227b90e.svg)，则![](./img/b8cbd4dd85670a6d292a27688791b74f.svg)，从而![](./img/169bfce3c195f11f97f1963fd68bc780.svg)。因此，当客户端收到![](./img/46361fe64810fec8cf27dad5e0156a40.svg)并解密后，如果发现该结果在集合![](./img/02129bb861061d1a052c592e2dc6b383.svg)中，那么它为交集元素。

这种方法对于长度为![](./img/8ce4b16b22b58894aa86c421e8759df3.svg)的序列占用了![](./img/18bfba88133de0dabea899170b5e687b.svg)的传输负荷和![](./img/bcb3624c59e3f00348c1614883e9c3ef.svg)的计算量。它在半诚实环境下的标准模型下是安全的，在恶意环境中的随机预言机模型(Random Oracle Model，ROM)下也是安全的。其中随机预言机模型是一个“黑箱”。它类似于哈希函数。对于某个输入数据，它可以在多项式时间内计算输出数据；对于相同的输入数据可产生相同的输出数据，且输出数据在输入数据的取值空间内均匀分布，没有碰撞。随机预言机模型是构造搞笑密码学方案的有效工具。然而，它只是一个理想化的原型，在实际应用中可能被哈希函数，例如SHA所取代。
<a name="LKdDO"></a>
### 基于RSA
De Cristofaro等人基于RSA公钥体系，提出了一种效率更高的方法。设客户端持有集合![](./img/ec18624b6ca3cc0d10344ce48ad5337b.svg)，服务端持有集合![](./img/3dc503b4953ffe1ac310af0545569e3e.svg)，并且双方知道两个哈希函数![](./img/c1d9f50f86825a1a2302ec2449c17196.svg)和![](./img/8c3ad15b1369570a17f7e7ea6e561497.svg)，则步骤如下：

1. 在离线阶段，服务端对各个元素计算![](./img/3aceb577b7e3ceaf1c511cd63f510ad2.svg)和![](./img/5cfa5a1dca72aedafa2a8aa070a0643f.svg)
2. 客户端对各个元素选取![](./img/aa757b3c4c2ed763f6a98d0f9fd55029.svg)，并计算![](./img/8d46f6335c773ec55ddb2b988257a68c.svg)
3. 进入在线阶段，客户端向服务端发送各个![](./img/8d62e469fb30ed435a668eb5c035b1f6.svg)
4. 服务端对各个![](./img/865c0c0b4ab0e063e5caa3387c1a8741.svg)计算![](./img/d6f84cd4c4319856f4e9b262d39a16a5.svg)，并将各个![](./img/458b6dd300f5ce0396b32f4f301a23d4.svg)与![](./img/e81cfd62d282334e315e27a783b578cd.svg)发送给客户端
5. 客户端计算![](./img/97814527a0ce6a3ea269425c98438354.svg)和![](./img/5624fea2d6774e1776605fa5681e218e.svg)，并计算出![](./img/e9ab7df662b726e59b0f21ac40df0941.svg)

此后，Chen等人实现了效率的进一步提升。该方法基于全同态加密，先给出了基础协议，而后进行了种种优化。其中，基础协议如下：

1. 接收者输入集合![](./img/57cec4137b614c87cb4e24a3d003a3e0.svg)，其大小为![](./img/3900d4485bda4d38010f0b6ba7208842.svg)；发送者输入集合![](./img/02129bb861061d1a052c592e2dc6b383.svg)，其大小为![](./img/9b4c4743a39d54ace8cff4fee55f4a4e.svg)
2. 双方商定一个全同态加密方案。接收者产生一个公钥-私钥对，其中私钥保密
3. 接收者加密其集合![](./img/57cec4137b614c87cb4e24a3d003a3e0.svg)中的所有元素![](./img/8d62e469fb30ed435a668eb5c035b1f6.svg)，并发送![](./img/3900d4485bda4d38010f0b6ba7208842.svg)个密文![](./img/197e0f8e6eaa5c6c2f8133a656764688.svg)给发送者
4. 对于每个![](./img/96fafac0c054b9eb47d3f630ed02c289.svg)，发送者随机产生一个非零明文![](./img/af2593b49488f8bc44396795792c2d79.svg)，并且同态地计算![](./img/df22a7ffbbe08e4511c8e941aa3216bc.svg)。发送者返回密文![](./img/99da85f917a599f372dab23b0936a3ec.svg)给接收者
5. 接收者解密密文![](./img/99da85f917a599f372dab23b0936a3ec.svg)，并输出![](./img/8a3682c29f790225d14c0ed529b966f2.svg)

它结合全同态加密中的批量化(Batching)技术、哈希函数和窗口化(Windowing)技术等，实现了对该基础协议的优化。不失一般性，假设![](./img/52f6de46ba507b43cad248fd851d4173.svg)，则优化后的协议的通信复杂度为![](./img/755795525fa488046c3fa5b70575c365.svg)

基于公钥加密体制的方法每一步仅处理一个元素，因此内存占用量小，则容易实现并行计算；如果双方集合的大小相差甚远，那么计算量很大的公钥加密操作可以集中在一方进行
<a name="XqpCr"></a>
## 基于混淆电路
假设在双方集合中的元素都是![](./img/a2ab7d71a0f07f388ff823293c147d21.svg)位的元素，即取自![](./img/a71a332e5a26665b1802fb2695f42d3e.svg)。当![](./img/a2ab7d71a0f07f388ff823293c147d21.svg)很小时，可以利用两个长度为![](./img/34a78a0e74c42f1f226fe12f38058990.svg)的位向量分别表示双方集合中的元素，然后利用逐位与运算(bitwise-and，BWA)进行比较。

当![](./img/a2ab7d71a0f07f388ff823293c147d21.svg)较大时，这个![](./img/34a78a0e74c42f1f226fe12f38058990.svg)时间复杂度的方法不再适用，此时可采用逐位比较(pairwise-comparisons，PWC)方案。逐位比较方案即对来自双方集合的两两元素判断是否相等，而判断相等的电路通过对它们进行异或运算之后再进行非运算来实现。这一方案的复杂度为双方集合大小的乘积，并且与![](./img/a2ab7d71a0f07f388ff823293c147d21.svg)呈线性关系。

假设双方的集合大小都是![](./img/7b8b965ad4bca0e41ab51de7b31363a1.svg)，则这个复杂度就是![](./img/6595d679e306a127a3fe53268bcaddb2.svg)。而排序-比较-洗牌(sort-compare-shuffle)方案将这一复杂度降至![](./img/f0c8ee6db8c0db9c91eb9c12225c3ade.svg)。在这个方案中，

1. 双方首先对其集合进行排序
2. 然后，通过不经意合并网络(Oblivious Merging Network)，双方合并排序后的集合，并排序
3. 双方再通过混淆电路比较相邻元素，从而得出集合
4. 最后，双方不经意地打乱交集的顺序，以避免信息泄漏
| A | B |
| --- | --- |
| 2，1，4，3(A的原始数据) | -1，3，2，5(B的原始数据) |
| 1，2，3，4(各自排序后) | -1，2，3，5(各自排序后) |
| -1，1，2，2，3，3，4，5(合并排序后) |  |
| 2，3(在相邻元素中找到相等元素) |  |

计算交集的电路连接到其他电路，就能够进行一些其他计算，如计算集合大小、元素求和等。这种易扩展性时基于公钥加密体制的方法和基于不经意传输协议的方法所不具备的。但是，再基于混淆电路的方法中，电路方案占据了大量的内存，其计算复杂度与电路中的与门的数量成正比，而并行化能否实现取决于电路的结构
<a name="Zdkxc"></a>
## 基于不经意传输
得益于不经意传输协议的发展和不经意传输扩展协议(Oblivious Transfer Extensions)的提出，一种隐私保护交集计算技术能够在300秒内计算百万量级集合的交集。经过效率和安全方面的不断改进，基于不经意传输协议的隐私保护交集计算方法已经将这一时间缩减到60秒。

如何具体描述不经意传输协议的定义呢？它可以分为![](./img/c81e728d9d4c2f636f067f89cc14862c.svg)选![](./img/c4ca4238a0b923820dcc509a6f75849b.svg)不经意传输协议和![](./img/8d9c307cb7f3c4a32822a51922d1ceaa.svg)选![](./img/c4ca4238a0b923820dcc509a6f75849b.svg)不经意传输协议。在2选1不经意传输协议的![](./img/6f8f57715090da2632453988d9a1501b.svg)次调用中，发送者持有![](./img/6f8f57715090da2632453988d9a1501b.svg)个元素对![](./img/c99a38b4dfc58cba0547b1801f319506.svg)，式中，![](./img/761eef8333c28463742899e56435b9fd.svg)，接收者持有![](./img/6f8f57715090da2632453988d9a1501b.svg)位向量![](./img/92eb5ffee6ae2fec3ad71c777531578f.svg)。在协议完成后，接收者获得各个被选择的元素![](./img/49560c4ed12319c00f3954fc0f664f77.svg)，但是不会知道另外的元素![](./img/c60de123b0f6bfa1cdc0e2806225eaae.svg)，而发送者则不会知道![](./img/92eb5ffee6ae2fec3ad71c777531578f.svg)。这里把这个不经意传输协议记作![](./img/2a998bbbf47d09da99ea377025ae7f6b.svg)。相应地，![](./img/2a998bbbf47d09da99ea377025ae7f6b.svg)表示对于![](./img/2db95e8e1a9267b7a1188556b2013b33.svg)位元素的、![](./img/6f8f57715090da2632453988d9a1501b.svg)次调用的![](./img/8d9c307cb7f3c4a32822a51922d1ceaa.svg)选![](./img/c4ca4238a0b923820dcc509a6f75849b.svg)不经意传输协议。结合不经意传输协议和随机预言机，Ishai等人和Kolesnikov等人分别给出了高效的![](./img/c81e728d9d4c2f636f067f89cc14862c.svg)选![](./img/c4ca4238a0b923820dcc509a6f75849b.svg)不经意传输扩展协议和![](./img/8d9c307cb7f3c4a32822a51922d1ceaa.svg)选![](./img/c4ca4238a0b923820dcc509a6f75849b.svg)不经意传输扩展协议。
<a name="DfbBL"></a>
## 其他方法
此外，还有一种不完全安全的协议可以用于交集计算，也是实际操作中最常用的方法。在该协议中，双方共同确定一个密码学哈希函数，比如md5，然后一方将自己的各个元素的哈希值发送给另一方，另一方计算交集。这种方法在输入域很小的情况下是不安全的，但在输入域很大的情况下是安全的。不安全的方法和基于公钥加密体制的方法每一步仅处理一个元素，因此内存占用量小，且容易实现并行计算。

另外，基于全同态加密的方法也可用于交集计算。全同态加密允许电路直接对密文进行计算。一方将数据加密后发送给另一方，另一方计算后将结果返回，该方再进行解密。随着两个集合的元素数量之和和电路深度增加，基于全同态加密的方法的计算是一种比较低效的方案。
