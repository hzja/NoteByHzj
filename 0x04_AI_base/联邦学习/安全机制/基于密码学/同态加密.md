同态加密算法是一种具有特殊性质的加密算法，其特殊性质主要表现在对密文的可操作性上。具体来说，使用同一个同态加密算法得到的两个密文，可以在不解密的情况下，进行加法或乘法操作，其结果与直接在明文状态下进行加法或乘法之后再进行加密的结果是相同的。如果使用传统的加密算法(如AES)直接讲敏感数据加密后发给合作方，那么在失去了统计特征的密文上，机器学习将无法有效地学习，同态加密算法很好地解决了这个问题。

更具体的说，同态加密又可分为

- 半同态加密(Partial Homomorphic Encryption, PHE)：只能在一种运算上(加或乘法)保持同态性
- 全同态加密(Full Homomorphic Encryption, FHE)：加法和乘法两种运算上均满足同态性
<a name="pa3z9"></a>
# 半同态加密
半同态加密算法是指乘法同态加密算法或加法同态加密算法，即只能保证在密文上进行加法或乘法的其中一种操作的结果，与在明文上进行相同操作的结果是相同的。
<a name="Vstmz"></a>
## 加法同态加密算法
对于满足以下要求的算法![](./img/5cdb670953734c56c6f22272f7cd4a80.svg)，可以称之为加法同态加密算法，即<br />![](./img/5e0bf7b204a4c9b341f2428f98e7f3ae.svg)<br />![](./img/128926866904c6b67131fa7b1dc9fb16.svg)<br />![](./img/694a4a6a76de896f32d42c0349f186ba.svg)<br />式中，![](./img/377b1a53b01e907138040867edc7cac2.svg)和![](./img/a4e435d4d078e7df1fa07e13d4a32ebb.svg)代表明文；![](./img/576f1dacd615219d9f8bea06b26d5fdc.svg)和![](./img/71f0427a673c14326195285a092cc63a.svg)代表密文；![](./img/61a41642d26f221806dcbccfcebc2ef8.svg)可能与实数域上的加法不同，需要根据具体的加密算法进行调整
<a name="rpNTK"></a>
## 乘法同态加密算法
对于满足以下要求的算法![](./img/ac6c9a54d47edbad8da9d9ef0f8b2a4f.svg)，可以称之为加法同态加密算法，即<br />![](./img/9b4324c4596e4affda08e779f9b0df4d.svg)<br />![](./img/524b09deb4d75f85e51e1c661a18a825.svg)<br />![](./img/0aa4a40de461df8ade5b48b8dcd18bec.svg)<br />式中，![](./img/377b1a53b01e907138040867edc7cac2.svg)和![](./img/a4e435d4d078e7df1fa07e13d4a32ebb.svg)代表明文；![](./img/576f1dacd615219d9f8bea06b26d5fdc.svg)和![](./img/71f0427a673c14326195285a092cc63a.svg)代表密文；![](./img/790c76ceb13e928d08edc53d7ac4bb5c.svg)可能与实数域上的乘法不同，需要根据具体的加密算法进行调整
<a name="sbSHn"></a>
## 常用半同态加密
在机器学习中，半同态加密算法的应用场景主要是计算类型单一的机器学习算法，或者计算类型偏向某一种的机器学习算法。比如，在多方的强化学习算法中，迭代过程的大多数操作均可以用加法同态加密算法来实现。

常用的半同态加密算法主要有：Paillier加法同态加密算法、ElGamal乘法同态加密算法、Goldwasser-Micali加法同态加密算法和RSA乘法同态加密算法。这里以Paillier加法同态加密算法为例介绍加/解密过程。

1. 密钥生成
   1. 选择两个大的素数![](./img/83878c91171338902e0fe0fb97a8c47a.svg)，![](./img/7694f4a66316e53c8cdd9d9954bd611d.svg)
   2. 计算![](./img/b318303973a001c25c17d80cbcf683f6.svg)，以及![](./img/f9fb4ed6e859e803e3c68359626497f9.svg)
   3. 选择一个整数![](./img/be93f7746738ccb1feec2e4b746138b6.svg)，使得![](./img/fff2a40cc94a4fab926691ed12bb76f7.svg)即二者互素，其中![](./img/67d709aac719e4bde7d49fb703ef9808.svg)
   4. 公钥为![](./img/f995bd9db5006286a1b231cb3ef93856.svg)，私钥为![](./img/c6a6eb61fd9c6c913da73b3642ca147d.svg)
2. 加密(使用公钥)
   1. 选择一个随机数![](./img/4bc2700a87681319e47a47002b2393aa.svg)作为概率性加密的随机源
   2. 明文![](./img/6f8f57715090da2632453988d9a1501b.svg)对应密文为![](./img/61bd62cb58bb396c9ca5eee69c171dfd.svg)
3. 解密(使用私钥)
   1. 密文![](./img/4a8a08f09d37b73795649038408b5f33.svg)对应的明文为![](./img/f07b2a27a2b6be1055e05fc3ed5acf1a.svg)

以上便是利用Paillier加法同态加密算法生成密钥、加密和解密的具体过程，其中![](./img/6b8a19d3dd42e22fa45d1aeeddce72cb.svg)是指![](./img/0cc175b9c0f1b6a831c399e269772661.svg)和![](./img/92eb5ffee6ae2fec3ad71c777531578f.svg)的最小公倍数，![](./img/c94707363ee77818baa53f6efd065f5e.svg)是指![](./img/0cc175b9c0f1b6a831c399e269772661.svg)和![](./img/92eb5ffee6ae2fec3ad71c777531578f.svg)的最大公约数。该算法的安全性建立在大整数分解问题的困难性上，即我们无法将大整数![](./img/8d9c307cb7f3c4a32822a51922d1ceaa.svg)进行分解得到两个素数因子![](./img/83878c91171338902e0fe0fb97a8c47a.svg)、![](./img/7694f4a66316e53c8cdd9d9954bd611d.svg)。该算法的正确性是由有限域中元素的众多性质决定的。
<a name="YByXE"></a>
# 全同态加密
半同态加密算法仅支持密文上的某一种运算，但机器学习场景的计算过程是相当复杂的，比如某些非线性激活函数。如果想在数据的密文状态上完成非线性激活函数的运算，那么半同态加密算法无法保证结果的正确性，因此便产生了对全同态加密算法的需求。

全同态加密算法是指在不解密的情况下，可以进行任意次的加法和乘法操作，同时保证在解密后与明文做相同的结果是相等的。从理论上讲，能够进行任意次的加法和乘法操作，便意味着可以使用电路等方法实现其他任意复杂的运算。但由于这个过于理想的属性，从半同态加密算法到全同态加密算法的发展道路不是一帆风顺的，目前同态加密的实际应用依然以半同态加密为主。
