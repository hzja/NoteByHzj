理解GCN重点的点是理解如何将卷积运算推广到图上。卷积运算推广到图上利用了卷积定理，而为了利用卷积定理，我们需要先计算傅立叶变换，而拉普拉斯矩阵是计算傅里叶变换的一步。所以，这篇基于这个思路，先解释拉普拉斯矩阵再到傅立叶变换然后将卷积运算推广到图上，自下而上的讲述GCN的相关细节。
<a name="InooF"></a>
# 通过热传播模型引入拉普拉斯算子
众所周知，没有外接干预的情况下，热量从温度高传播到温度低的地方并且不可逆，根据著名的牛顿冷却定律（Newton Cool's Law），热量传递的速度正比于温度梯度，直观上也就是某个地方A温度高，另外一个B地方温度低，这两个地方接触，那么温度高的地方的热量会以正比于他们俩温度差的速度从A流向B。

我们先建立一个一维的温度传播的模型，假设有一个均匀的铁棒，不同位置温度不一样，现在我们刻画这个铁棒上面温度的热传播随着时间变化的关系。预先说明一下，一个连续的铁棒的热传播模型需要列**温度对时间和坐标的偏微分方程**来解决，我们不想把问题搞这么复杂，我们把**空间离散化**，假设铁棒是一个**一维链条**，链条上每一个单元拥有一致的温度，温度在相邻的不同的单元之间传播，如下图：<br />![一维离散链条上的热传播.jpg](./img/1602662482599-ea533a22-fd0a-467b-a002-1f22b6de4af6.jpeg)<br />对于第![](./img/865c0c0b4ab0e063e5caa3387c1a8741.svg)个单元，它只和![](./img/800ba394e806c049c98cf4b570d04c72.svg)与![](./img/15ab2d2b0b92c13f328635e5c4bdbe64.svg)两个单元相邻，接受它们传来的热量（或者向它们传递热量，只是正负号的差异而已），假设它当前的温度为![](./img/83c4a0f64b5c308332e71b11e874d4cc.svg)，那么就有：

![](./img/81d9d583cfdc1c9df8ec65e0772a5bee.svg)

![](./img/8ce4b16b22b58894aa86c421e8759df3.svg)和单元的比热容、质量有关，是个常数。右边第一项是下一个单元向本单元的热量流入导致温度升高，第二项是本单元向上一个单元的热量流出导致温度降低。做一点微小的数学变换可以得到：

![](./img/ff5c901dc71d0cde87b1a3e36c98441e.svg)

注意观察第二项，它是两个差分的差分，在离散空间中，相邻位置的差分推广到连续空间就是**导数**，那么差分的差分，就是**二阶导数**！所以，我们可以反推出铁棒这样的连续一维空间的热传导方程就是：

![](./img/50ba88c232f27d2b6a785ca0c6dc932a.svg)

同理，在高维的欧氏空间中，一阶导数就推广到**梯度**，二阶导数就是我们今天讨论的主角——**拉普拉斯算子**：

![](./img/e2177ebe54ffd5f38e13e3987f9796e1.svg)

其中![](./img/967878d1da852d4b07a961e3168b0fff.svg)这个符号代表的是对各个坐标二阶导数的加和，现在的主流写法也可以写作![](./img/683590a0c6a1c3a77515ee29d578dbb9.svg)。

综上所述，我们发现这样两个事实：

1. 在欧氏空间中，某个点温度升高的速度正比于该点周围的温度分布，用拉普拉斯算子衡量
2. 拉普拉斯算子，是二阶导数对高维空间的推广
<a name="sAANB"></a>
# 图(Graph)上热传播模型的推广
现在，我们依然考虑热传导模型，只是这个事情不发生在欧氏空间了，发生在一个Graph上面。这个图上的每个节点（Node）是一个单元，且这个单元只和与这个节点相连的单元，也就是有边（Edge）连接的单元发生热交换。例如下图中，节点1只和节点0、2、4发生热交换，更远的例如节点5的热量要通过4间接的传播过来而没有直接热交换。<br />![图上的热传播.jpg](./img/1602663352641-1f77616f-5a3c-480f-8b10-d40a9c990d81.jpeg)<br />我们假设热量流动的速度依然满足牛顿冷却定律，研究任一节点![](./img/865c0c0b4ab0e063e5caa3387c1a8741.svg)，它的温度随着时间的变化可以用下式来刻画：

![](./img/c7aa187603ca8d56431bd3dba952af33.svg)

其中![](./img/7fc56270e7a70fa81a5935b72eacbe29.svg)是这个图的邻接矩阵（Adjacency Matrix），定义非常直观： 对于这个矩阵中的每一个元素![](./img/6781228e0a0a6072d89c076e9a5ab4db.svg)，如果节点![](./img/865c0c0b4ab0e063e5caa3387c1a8741.svg)和节点![](./img/363b122c528f54df4a0446b6bab05515.svg)相邻(直接相连)，那么![](./img/7fb781eb98fd48687da35391cb09c578.svg)，否则![](./img/0dd2e35a061713b2330ed5c41598c147.svg)。在这里，我们只讨论简单情况：

1. 这张图是无向图，![](./img/865c0c0b4ab0e063e5caa3387c1a8741.svg)和![](./img/363b122c528f54df4a0446b6bab05515.svg)相邻那么![](./img/363b122c528f54df4a0446b6bab05515.svg)和![](./img/865c0c0b4ab0e063e5caa3387c1a8741.svg)也相邻，所以![](./img/612313b79dd42d4a2755fb575235bf63.svg)，![](./img/7fc56270e7a70fa81a5935b72eacbe29.svg)是个实对称矩阵
2. 节点自己到自己没有回环边，也就是![](./img/7fc56270e7a70fa81a5935b72eacbe29.svg)对角线上元素都是![](./img/cfcd208495d565ef66e7dff9f98764da.svg)

所以不难理解上面这个公式恰好表示了只有相邻的边才能和本结点发生热交换且热量输入（输出）正比于温度差

我们不妨用乘法分配律稍微对上式做一个推导：

![](./img/4337ee037da9720901faa0f0fb7bf9f9.svg)

先看右边括号里面第一项，![](./img/57db88322219280df2f57b8e4f10571d.svg)代表对这个顶点求度（degree），一个顶点的度被定义为这个顶点有多少条边连接出去，很显然，根据邻接矩阵的定义，第一项的求和正是在计算顶点![](./img/865c0c0b4ab0e063e5caa3387c1a8741.svg)的度。再看右边括号里面的第二项，这可以认为是邻接矩阵的第![](./img/865c0c0b4ab0e063e5caa3387c1a8741.svg)行对所有顶点的温度组成的向量做了个内积。

为什么要作上述变化呢，我们只看一个点的温度不太好看出来，我们把所有点的温度写成向量形式再描述上述关系就一目了然了。首先可以写成这样：

![](./img/774d0dbf88e029e899e5dff896dc2788.svg)

然后我们定义向量![](./img/d17c9a3ffa0b1d093d7e500f05d0991d.svg)，那么就有：

![](./img/422012d0157552a3e7d4f0d102613432.svg)

其中，![](./img/a5f6bb5ac9be0c9f5bbe4980f28e5d44.svg)被称为度矩阵，只有对角线上有值，且这个值表示对应的顶点度的大小。整理整理，我们得到：

![](./img/571f74e3cd72698b9f43e59e53ad098a.svg)

回顾刚才在连续欧氏空间的那个微分方程：

![](./img/ee8ee970329c425488e3b5a135e44571.svg)

二者具有一样的形式！我们来对比一下二者之间的关系：

相同点：刻画空间温度分布随时间的变化，且这个变化满足一个相同形式的微分方程。<br />不同点：**前者刻画拓扑空间有限结点**，用向量![](./img/1ed346930917426bc46d41e22cc525ec.svg)来刻画当前状态，单位时间状态的变化正比于线性变换![](./img/3f9df9336d464ece6989396d54e649e3.svg)算子作用在状态![](./img/1ed346930917426bc46d41e22cc525ec.svg)上。**后者刻画欧氏空间的连续分布**，用函数![](./img/1deeca0bf079b2938a04f3d2320e4710.svg)来刻画当前状态，单位时间状态变化正比于拉普拉斯算子![](./img/967878d1da852d4b07a961e3168b0fff.svg)作用在状态![](./img/1ed346930917426bc46d41e22cc525ec.svg)上。

不难发现，这就是**同一种变换、同一种关系在不同空间上面的体现**，实质上是一回事！

于是我们自然而然，可以把连续空间中的热传导，推广到图（Graph）上面去，我们把图上面和欧氏空间地位相同变换，以矩阵形式体现的叫做拉普拉斯（Laplacian）矩阵

![](./img/e4ade126cf9eebe72b791053b0fdcdd8.svg)<br />![拉普拉斯矩阵.png](./img/1602669345082-7abdcb78-c293-424c-8e66-ca466f59d501.png)<br />这里要说明的是：常用的拉普拉斯矩阵实际有三种：

1. ![](./img/e4ade126cf9eebe72b791053b0fdcdd8.svg) 定义的Laplacian矩阵，更专业的名称叫Combinatorial Laplacian
2. ![](./img/15035a4704619addbebe84f4e279e01a.svg) 定义的叫Symmetric normalized Laplacian，很多GCN的论文中应用的这种
3. ![](./img/1c95e0c42e07c8d92c178b1504e77878.svg) 定义的叫Random walk normalized Laplacian

现在问题已经很明朗了，只要你给定了一个空间，给定了空间中存在一种东西可以在这个空间上流动，两邻点之间流动的强度正比于它们之间的状态差异，那么**何止是热量可以在这个空间流动，任何东西都可以！**

![](./img/422012d0157552a3e7d4f0d102613432.svg)

自然而然，假设在图中各个结点流动的东西不是**热量**，而是**特征（Feature）**，而是**消息（Message）**，那么问题自然而然就被推广到了GCN。简而言之，即将上面我们得到的公式中温度转移常量![](./img/8ce4b16b22b58894aa86c421e8759df3.svg)和热量![](./img/1ed346930917426bc46d41e22cc525ec.svg)，换成我们的特征和消息。**所以GCN的实质是什么，是在一张Graph Network中特征（Feature）和消息（Message）中的流动和传播！这个传播最原始的形态就是状态的变化正比于相应空间（这里是Graph空间）拉普拉斯算子作用在当前的状态。**

抓住了这个实质，剩下的问题就是怎么去更加好的建模和解决这个问题。建模方面就衍生出了各种不同的算法，你可以在这个问题上面复杂化这个模型，不一定要遵从牛顿冷却定律，你可以引入核函数、引入神经网络等方法把模型建得更非线性更能刻画复杂关系。

解决方面，因为很多问题在频域解决更加好算，你可以通过Fourier变换把空域问题转化为频域问题，解完了再变换回来，于是便有了所有Fourier变换中的那些故事。

扯了这么多，总结一下，问题的本质就是：

1. 我们有张图，图上每个结点刻画一个实体，物理学场景下这个实体是某个有温度的单元，它的状态是温度，广告和推荐的场景下这个实体是一个user，一个item，一个ad，它的状态是一个embedding的向量。
2. 相邻的结点具有比不相邻结点更密切的关系，物理学场景下，这个关系是空间上的临近、接触，广告和推荐场景下这个是一种逻辑上的关系，例如用户购买、点击item，item挂载ad。
3. 结点可以传播热量/消息到邻居，使得相邻的结点在温度/特征上面更接近。

**本质上，这是一种Message Passing，是一种Induction，卷积、傅立叶都是表象和解法。**

Laplacian矩阵/算子不仅表现的是一种二阶导数的运算，另一方面，它表现了一种加和性，这个从图上热/消息传播方程最原始的形态就能一目了然：

![](./img/432ed127f43ace717ebb1d8bf615f597.svg)

可见，每个结点每个时刻的状态变化，就是所有邻居对本结点差异的总和，也就是所有的邻居把message pass过来，然后再Aggregate一下，这正是GraphSage等空域算法的关键步骤**Aggregate思想**的滥觞。

在实际建模中，我们的Aggregate不一定是加和，作为一个熟练的机器学习搬砖工，我们懂得可以把Aggregate推广成各种操作例如Sum Pooling，例如LSTM，例如Attention，以求刷效果，发paper :)
<a name="ghbln"></a>
# 拉普拉斯矩阵的谱分解

GCN的核心是基于拉普拉斯矩阵的谱分解。矩阵的谱分解，特征分解，对角线化都是同一个[概念](https://www.yuque.com/angsweet/machine-learning/shu-xue-ji-chu_shu-xue-ji-chu_xian-xing-dai-shu#2d255d85)。当然，不是所有的矩阵都可以进行特征分解，其充要条件为![](./img/7b8b965ad4bca0e41ab51de7b31363a1.svg)阶方阵存在![](./img/7b8b965ad4bca0e41ab51de7b31363a1.svg)个[线性无关](https://baike.baidu.com/item/%E7%BA%BF%E6%80%A7%E7%8B%AC%E7%AB%8B?fromtitle=%E7%BA%BF%E6%80%A7%E6%97%A0%E5%85%B3&fromid=4705660)的[特征向量](https://baike.baidu.com/item/%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F)。

拉普拉斯矩阵是半正定实对称矩阵(具体可见[数学基础-线性代数章节半正定矩阵](https://www.yuque.com/angsweet/machine-learning/shu-xue-ji-chu_shu-xue-ji-chu_xian-xing-dai-shu#M2959)解释)，有如下三个性质：

- 实对称矩阵一定有![](./img/7b8b965ad4bca0e41ab51de7b31363a1.svg)个线性无关的特征向量
- 半正定矩阵的特征值一定非负
- 实对称矩阵的特征向量总是可以化成两两相互正交的正交矩阵

由上面性质可以知道拉普拉斯矩阵一定可以谱分解，且分解后有特殊形式。对于拉普拉斯矩阵，其谱分解为：

![](./img/19867db2c4ec900f787c5c67abbdb802.svg)

其中![](./img/95c1075a0f1935e3aa845064b557aec5.svg)，是列向量为单位特征向量的矩阵，也就说![](./img/3e7b2f2e92782d71c7fc4e1db720595d.svg)是列向量。![](./img/23ee8a9525dd61634bbfdc8c6dd2eea0.svg)是![](./img/7b8b965ad4bca0e41ab51de7b31363a1.svg)个特征值构成的对角矩阵。由于![](./img/4c614360da93c0a041b22e537de151eb.svg)是正交矩阵，即![](./img/8d2ea4330e6bf9c8befe13be563b5c29.svg)。所以特征分解又可以写成：

![](./img/8bdef17e14b40aa35cbd61efc71992e6.svg)

文献中都是最后导出的这个公式，但大家不要误解，特征分解最右边的是特征矩阵的逆，只是拉普拉斯矩阵的性质才可以写成特征矩阵的转置。
<a name="tKxus"></a>
# [傅立叶变换类比到Graph上](https://arxiv.org/abs/1211.0053)
<a name="4wTPx"></a>
#### 
<a name="FAJgl"></a>
### 傅立叶变换

传统的[傅立叶变换](https://www.yuque.com/angsweet/machine-learning/shu-xue-ji-chu_shu-xue-ji-chu_shi-jian-xu-lie#f67aac3d)定义为：

![](./img/efceb4fa4a91e2bbf68d61de56f5671f.svg)

信号![](./img/d6e3af948a34fd5f432cb9d377a98ef0.svg)与基函数![](./img/afd5453e1907c3bd6049c5b93086b120.svg)的积分，那么为什么要找![](./img/afd5453e1907c3bd6049c5b93086b120.svg)作为基函数呢？从数学上看，![](./img/afd5453e1907c3bd6049c5b93086b120.svg)是拉普拉斯算子的特征函数(满足特征方程)，![](./img/260b57b4fdee8c5a001c09b555ccd28d.svg)就和特征值有关。

广义的特征方程定义为：

![](./img/84442b1d7cba6ecce99d93553d50a2ab.svg)

其中![](./img/7fc56270e7a70fa81a5935b72eacbe29.svg)是一种变换，![](./img/5206560a306a2e085a437fd258eb57ce.svg)是特征向量或者特征函数(无穷维的向量)，![](./img/c6a6eb61fd9c6c913da73b3642ca147d.svg)是特征值。![](./img/afd5453e1907c3bd6049c5b93086b120.svg)满足：

![](./img/dba1247a7a6ad546deafa6eaa205f243.svg)

当然![](./img/afd5453e1907c3bd6049c5b93086b120.svg)就是变换![](./img/967878d1da852d4b07a961e3168b0fff.svg)的特征函数，![](./img/260b57b4fdee8c5a001c09b555ccd28d.svg)和特征值密切相关。

**那么，可以联想了，处理Graph问题的时候，用到拉普拉斯矩阵，自然就去找拉普拉斯矩阵的特征向量了(拉普拉斯矩阵就是**[**离散拉普拉斯算子**](https://en.wikipedia.org/wiki/Discrete_Laplace_operator)**)，也就是我们费劲理解的上三个章节的用处了。**

![](./img/d20caec3b48a1eef164cb4ca81ba2587.svg)是拉普拉斯矩阵，![](./img/5206560a306a2e085a437fd258eb57ce.svg)是其特征向量，自然满足下式：

![](./img/0c14882ab68b6a2fa93ad7e981538db1.svg)

离散积分就是一种内积形式，仿照上面定义Graph上的傅立叶变换：

![](./img/bfffba0e2af747cf8811f5efb62940ce.svg)

![](./img/8fa14cdd754f91cc6554c9e71929cce7.svg)**是Graph上的**![](./img/8d9c307cb7f3c4a32822a51922d1ceaa.svg)**维向量，**![](./img/16ced14ad381d0c55f46a750367db2ed.svg)**与Graph的顶点一一对应，**![](./img/3f3e69d358e03a5207ff804c0350d9b1.svg)**表示第**![](./img/2db95e8e1a9267b7a1188556b2013b33.svg)**个特征向量的第**![](./img/865c0c0b4ab0e063e5caa3387c1a8741.svg)**个分量。那么特征值(频率)**![](./img/284bfddfe5da28a9b94d7b45bf0880d3.svg)**下的，**![](./img/8fa14cdd754f91cc6554c9e71929cce7.svg)**的Graph傅立叶变换就是与**![](./img/284bfddfe5da28a9b94d7b45bf0880d3.svg)**对应的特征向量**![](./img/7c07f5c20f6657de45730f14ed082615.svg)**进行内积计算。**注：上述的内积运算是在复数空间中定义的，所以采用了![](./img/f24a921fb528edabea6c5a0d74fac2cb.svg)，也就是特征向量![](./img/7c07f5c20f6657de45730f14ed082615.svg)的共轭。

利用矩阵乘法将Graph上的傅立叶变换推广到矩阵形式：

![](./img/6170902441703f0f7b0a6f6dfa9d8f08.svg)

即![](./img/8fa14cdd754f91cc6554c9e71929cce7.svg)在Graph上的傅立叶变换的矩阵形式为：

![](./img/e6b6389c234c11418623e5df4e2fa021.svg)

这里的![](./img/15c783510d846d78881719caccb3f9bd.svg)即拉普拉斯矩阵的谱分解中我们推导出的单位特征向量的矩阵的转置。

<a name="zYtg6"></a>
### 傅立叶逆变换

类似地，传统的傅立叶逆变换是对频率![](./img/260b57b4fdee8c5a001c09b555ccd28d.svg)求积分：

![](./img/a95b3e3de3248cfb44f157b1178160d9.svg)

迁移到Graph上变为对特征值![](./img/284bfddfe5da28a9b94d7b45bf0880d3.svg)求和：

![](./img/7f00386bcaeadfeecb9926eaad1957f1.svg)

利用矩阵乘法将Graph上的傅立叶逆变换推广到矩阵形式：

![](./img/34f604983c431656fa6e1c6e1695fcde.svg)

即![](./img/8fa14cdd754f91cc6554c9e71929cce7.svg)在Graph上傅立叶逆变换的矩阵形式为：

![](./img/19e3c3ef369bdeda719aba9639bdcff2.svg)

这里的![](./img/4c614360da93c0a041b22e537de151eb.svg)即拉普拉斯矩阵的谱分解中我们推导出的单位特征向量的矩阵。

<a name="Z96e0"></a>
# 卷积类比到Graph上
卷积的数学定义是

![](./img/4769c24af8ddd929f2bdefa8a5c89cdb.svg)

一般称![](./img/b2f5ff47436671b6e533d8dc3614845d.svg)(下面我用![](./img/2510c39011c5be704182423e3a695e91.svg)表示，这里因为找的图是用的![](./img/b2f5ff47436671b6e533d8dc3614845d.svg))为作用在![](./img/8fa14cdd754f91cc6554c9e71929cce7.svg)上的filter或kernel，下面为一维和大家常见的CNN二维卷积图。<br />![一维卷积.gif](./img/1602750912416-70e2d930-795e-43f8-93c9-99f70f7417da.gif)<br />![二维卷积.gif](./img/1602751061121-49f5bf60-6970-43e7-a6be-49172f3ea7c5.gif)<br />在上面的基础上，利用[卷积定理](https://baike.baidu.com/item/%E5%8D%B7%E7%A7%AF%E5%AE%9A%E7%90%86)类比来将卷积运算推广到Graph上。**卷积定理：函数卷积的傅立叶变换是函数傅立叶变换的乘积，即对于函数**![](./img/d6e3af948a34fd5f432cb9d377a98ef0.svg)**与**![](./img/6ece45e3f78470bcf0e7db1d3c539a09.svg)**两者的卷积是其函数傅立叶变换乘积的逆变换。**

![](./img/f64ea20e4c1e989b3319464f14a6ab8f.svg)

类比到Graph上并把傅立叶变换的定义代入，![](./img/8fa14cdd754f91cc6554c9e71929cce7.svg)与卷积核![](./img/2510c39011c5be704182423e3a695e91.svg)在Graph上的卷积可按下列步骤求出：

![](./img/8fa14cdd754f91cc6554c9e71929cce7.svg)的傅立叶变换为![](./img/e6b6389c234c11418623e5df4e2fa021.svg)

卷积核![](./img/2510c39011c5be704182423e3a695e91.svg)的傅立叶变换写成对角矩阵的形式为：![](./img/21fa11060bcaecea6ea13553ef99a16e.svg)

![](./img/2a0fbe0e7dbe6ae2aea78d5e20549035.svg)是**根据需要设计的卷积核**![](./img/2510c39011c5be704182423e3a695e91.svg)**在Graph上的傅立叶变换。**

两者的傅立叶变换乘积即为：![](./img/540f6757f781065750854c288b92bbb6.svg)

再乘以![](./img/4c614360da93c0a041b22e537de151eb.svg)求两者傅立叶变换乘积的逆变换，则求出卷积：

![](./img/713dbc676cd748c9307671f26c5780cd.svg)

式中的![](./img/4c614360da93c0a041b22e537de151eb.svg)即拉普拉斯矩阵的谱分解中我们推导出的单位特征向量的矩阵，![](./img/15c783510d846d78881719caccb3f9bd.svg)即拉普拉斯矩阵的谱分解中我们推导出的单位特征向量的矩阵的转置。注：很多论文中的Graph卷积公式(下式与上式等价，证明见[链接](https://zhuanlan.zhihu.com/p/121090537))：

![](./img/3d6b112dbc9dc0cd2fc4fa8a9ce89ac6.svg)

![](./img/319d584a4a5166ee6c51f4b8348856ea.svg)表示Hadamard product(哈达马积)，对于两个维度相同的向量、矩阵、张量进行对应位置的逐元素乘积运算
<a name="gzYOL"></a>
# 为什么拉普拉斯矩阵的特征向量做傅立叶变换的基？特征表示频率？
<a name="PRL31"></a>
### 拉普拉斯矩阵的特征向量为什么可作为傅立叶变换的基
傅立叶变换的一个本质理解就是：**把任意一个函数表示成若干个正交函数(由sin，cos构成)的线性组合。**

![傅立叶逆变换图示.jpg](./img/1602814694632-8481dd96-c3e1-4df8-aee2-1b3b5d6479c7.jpeg)<br />通过上面推导的![](./img/8fa14cdd754f91cc6554c9e71929cce7.svg)在Graph上傅立叶逆变换的矩阵形式![](./img/19e3c3ef369bdeda719aba9639bdcff2.svg)，即

![](./img/34f604983c431656fa6e1c6e1695fcde.svg)

能看出，Graph傅立叶变换也把Graph上定义的任意向量![](./img/8fa14cdd754f91cc6554c9e71929cce7.svg)，表示成了拉普拉斯矩阵特征向量的线性组合，即

![](./img/fd9f0c08c9a1f4aebaee8a80339a4324.svg)

那么：为什么Graph上任意的向量![](./img/8fa14cdd754f91cc6554c9e71929cce7.svg)都可以表示成这样的线性组合？

原因在于![](./img/fd79618d0d792c9b7d8c65f97288675e.svg)是Graph上![](./img/7b8b965ad4bca0e41ab51de7b31363a1.svg)维空间中的![](./img/7b8b965ad4bca0e41ab51de7b31363a1.svg)个线性无关的正交向量，由线性代数的知识可以知道：![](./img/7b8b965ad4bca0e41ab51de7b31363a1.svg)维空间中![](./img/7b8b965ad4bca0e41ab51de7b31363a1.svg)个线性无关的向量可以构成空间的一组基，而且拉普拉斯矩阵的特征向量还是一组正交基。

<a name="yfyGK"></a>
### 怎么理解拉普拉斯矩阵的特征值表示频率
在Graph空间上无法可视化展示“频率”这个概念，那么从特征方程上来抽象理解。

将拉普拉斯矩阵![](./img/d20caec3b48a1eef164cb4ca81ba2587.svg)的![](./img/7b8b965ad4bca0e41ab51de7b31363a1.svg)个非负实特征值，从小到大排列为![](./img/6e3abd6c5bfd4ed28a20ebc35bd0b7f2.svg)，而且最小的特征值![](./img/a08b824197a4d2afcfab270a4ef91ae3.svg)，因为![](./img/7b8b965ad4bca0e41ab51de7b31363a1.svg)维的全1向量对应的特征值为0(由![](./img/d20caec3b48a1eef164cb4ca81ba2587.svg)的定义就可以得出)：

![](./img/4d4ab74d97848094fb742fa95823fe60.svg)

从特征方程的数学理解来看：

![](./img/ad9ff3f09a8d6abebd2196ec95bff693.svg)

在由Graph确定的![](./img/7b8b965ad4bca0e41ab51de7b31363a1.svg)维空间中，越小的特征值![](./img/284bfddfe5da28a9b94d7b45bf0880d3.svg)表明：拉普拉斯矩阵![](./img/d20caec3b48a1eef164cb4ca81ba2587.svg)其所对应的基![](./img/7c07f5c20f6657de45730f14ed082615.svg)上的分量“信息”越少，那么当然就是可以忽略的低频部分了。

其实图像压缩就是这个原理，把像素矩阵特征分解后，把小的特征值(低频部分)全部变成0，PCA降维也是同样的，把协方差矩阵特征分解后，按从大到小取出前![](./img/a5f3c6a11b03839d46af9fb43c97c188.svg)个特征值对应的特征向量作为新的“坐标轴”。
<a name="myi0j"></a>
# GCN迭代
任何一个图卷积层都可以写成这样一个非线性函数：

![](./img/92f517f052b491c42a9e85a9d578108d.svg)

![](./img/9938c90049b6b3aa643c9e17726914b0.svg)为第一层的输入，![](./img/71ba338eeedc11623225af3b1542a0af.svg)，![](./img/8d9c307cb7f3c4a32822a51922d1ceaa.svg)为图的节点个数，![](./img/f623e75af30e62bbd73d6df5b50bb7b5.svg)为每个节点特征向量的维度，![](./img/7fc56270e7a70fa81a5935b72eacbe29.svg)为邻接矩阵，不同模型的差异点在于函数![](./img/8fa14cdd754f91cc6554c9e71929cce7.svg)的实现不同。现在主流的框架如下图所示<br />![GCN.png](./img/1603251939676-d0c182ee-48ab-4a52-a1e9-7b5dbcbeb6d1.png)
<a name="Py8pa"></a>
### 第一版
最初的思路最简单直接，采用邻接矩阵，级节点与其所有邻居节点有关。邻接矩阵![](./img/7fc56270e7a70fa81a5935b72eacbe29.svg)与特征![](./img/c1d9f50f86825a1a2302ec2449c17196.svg)相乘，等价于，某节点的邻居节点的特征相加。这样多层隐含层叠加，能利用多跳邻居的信息。

![](./img/1c43701ed34ceda5cc4f8f2bc4e08bc8.svg)

其中，![](./img/5e95de488fc446fbe29319c68dfb26aa.svg)为第![](./img/2db95e8e1a9267b7a1188556b2013b33.svg)层的权重参数矩阵，![](./img/cfebe6957f3fb318957b3a68c63f02ef.svg)为非线性激活函数，比如ReLU等。<br />但是这样存在两个问题：

- 未考虑节点自身的影响
- 邻接矩阵![](./img/7fc56270e7a70fa81a5935b72eacbe29.svg)没有被标准化，这在提取图特征时可能存在问题，比如邻居节点多的节点会更有影响力

<a name="CeZL0"></a>
### 第二版
第二版考虑了节点自身的影响，引入了度矩阵计算拉普拉斯矩阵，

![](./img/330a70f0d1e3154634007f6ef01d480b.svg)

其中![](./img/e4ade126cf9eebe72b791053b0fdcdd8.svg)，如下图<br />![拉普拉斯矩阵.png](./img/1602669345082-7abdcb78-c293-424c-8e66-ca466f59d501.png)
<a name="YPVvj"></a>
### 第三版
第三版采用了标准化的拉普拉斯矩阵

![](./img/4f0dce631be9236bbbc299ba188466cb.svg)

其中，![](./img/648b22453c5a4fd91d8410a9ec8f0756.svg)。都是一样的，只不过不同的论文或博客表述方式不一样，本质上还是解决两个问题进行的针对性改进

- 引入自身度矩阵，解决自传递问题
- 对邻接矩阵的归一化操作，通过对邻接矩阵两边乘以节点的度开方然后取逆得到

这里解释一下归一化操作。具体到每一个节点对![](./img/865c0c0b4ab0e063e5caa3387c1a8741.svg)和![](./img/363b122c528f54df4a0446b6bab05515.svg)，矩阵中的元素由下面的式子给出(无向无权图)：

![](./img/49bec56396de599f2bbaf25568b6fc5f.svg)

单个节点运算来说，做归一化就是除以它节点的度，这样每一条邻接边信息传递的值就被规范化了，不会因为某一个节点有10条边而另一个只有1条边导致前者的影响力比后者大，因为做完归一化前者的权重只有0.1了，从单个节点上升到二维矩阵的运算，就是对矩阵求逆了，乘以矩阵的逆的本质，就是做矩阵除法完成归一化。但左右分别乘以节点![](./img/865c0c0b4ab0e063e5caa3387c1a8741.svg)和![](./img/363b122c528f54df4a0446b6bab05515.svg)度的开方，就是考虑一条边的两边的点的度。

其物理意义很好理解，比如学校里的教授合作网络，一篇论文通常有多个作者，而每个作者又有多篇论文，行和列都是作者，值是合作过论文的篇数。对于某两位教授![](./img/865c0c0b4ab0e063e5caa3387c1a8741.svg)和![](./img/363b122c528f54df4a0446b6bab05515.svg)的相互影响，需要按各其一共发过多少篇paper进行归一化。

<a name="mNkfY"></a>
# Source
[图神经网络必读的5个基础模型: GCN, GAT, GraphSAGE, GAE, DiffPool.](https://mp.weixin.qq.com/s/t6n7wfov1fMj-QstKzN2Ow)<br />[如何理解 Graph Convolutional Network（GCN）？ - 知乎](https://www.zhihu.com/question/54504471)<br />[一文读懂图卷积GCN](https://zhuanlan.zhihu.com/p/89503068)<br />[Deep Graph Learning](https://ai.tencent.com/ailab/ml/KDD-Deep-Graph-Learning.html)
