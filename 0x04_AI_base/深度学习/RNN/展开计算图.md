计算图是形式化一组计算结构的方式，如那些涉及将输入和参数映射到输出和损失的计算。我们对展开递归或循环计算得到的重复结构进行解释，这些重复结构通常对应于一个事件链。展开这个计算图将导致深度网络结构中的参数共享。例如，考虑动态系统的经典形式：

![](./img/fc9a57da46a333c0436c4d69499e0832.svg)

其中![](./img/989312cadc6e3cd50503c7f6becff6be.svg)称为系统的状态。![](./img/03c7c0ace395d80182db07ae2c30f034.svg)在时刻![](./img/e358efa489f58062f10dd7316b65649e.svg)的定义需要参考时刻![](./img/f3e90ce87a25538f5a4be79a0a7c0fa5.svg)时同样的定义。因此上式是循环的。对有限时间步![](./img/a6f317b268ae825d94f832f970af607c.svg)，![](./img/b422096623c385dafd2646e55ecc1f44.svg)次应用这个定义可以展开这个图。例如![](./img/d3427a4c6e39f5c8b97636090b485de9.svg)，我们对上式展开，可以得到

![](./img/2fbbb4c60babe1037754517a5c77269d.svg)

以这种方式重复应用定义，展开等式，就能得到不涉及循环的表达。现在我们可以使用传统的有向无环图呈现这样的表达，如下图

![展开计算图1.png](./img/1594090178825-d74360a3-0801-48fb-a229-cf2901a83e91.png)

作为另一个例子，让我们考虑由外部信号![](./img/df9ed87e836e463cd086106035aef441.svg)驱动的动态系统。

![](./img/7cd23744a29caea50d7cf26e82d4a0c6.svg)

我们可以看到，当前状态包含了整个过去序列的信息。

循环神经网络可以通过许多不同的方式建立。就像几乎所有函数都可以被认为是前馈网络，本质上任何涉及循环的函数都可以视为一个循环神经网络。很多循环神经网络使用下式或类似的公式定义隐藏单元的值。为了表明状态是网络的隐藏单元，我们使用变量![](./img/2510c39011c5be704182423e3a695e91.svg)代表状态重写式![](./img/e5d8218b319d5ddfea38e15da280339c.svg)：

![](./img/b5c3457be5f6eea99615538650abce07.svg)

如下图所示，典型RNN会增加额外的架构特性，如读取状态信息![](./img/2510c39011c5be704182423e3a695e91.svg)进行预测的输出层。

![展开计算图2.png](./img/1594090334291-e24bdbe2-fbbd-420a-ac05-a421d17e5d92.png)

当训练循环网络根据过去预测未来时，网络通常要学会使用![](./img/7ddb4d2d45df22e2e98e6cc504f84787.svg)作为过去序列（直到![](./img/e358efa489f58062f10dd7316b65649e.svg)）与任务相关方面的有损摘要。此摘要一般而言一定是有损的，因为其映射任意长度的序列![](./img/4853841121d3f2ddb9d9efd1bf614d48.svg)到一固定长度的向量![](./img/7ddb4d2d45df22e2e98e6cc504f84787.svg)。根据不同的训练准则，摘要可能选择性地精确保留过去序列的某些方面。例如，如果在统计语言模型中使用RNN，通常给定前一个词预测下一个词，可能没有必要存储时刻![](./img/e358efa489f58062f10dd7316b65649e.svg)前输入序列中的所有信息；而仅仅存储足够预测句子其余部分的信息。最苛刻的情况是我们要求![](./img/7ddb4d2d45df22e2e98e6cc504f84787.svg)足够丰富，并能大致恢复输入序列，如自编码器框架。

展开图的大小取决于序列长度，我们可以用一个函数![](./img/ededcb90b8071069a783dea14b4aad14.svg)代表经![](./img/e358efa489f58062f10dd7316b65649e.svg)步展开后的循环：

![](./img/9aa21cc488466ffa8dba8a2863717e82.svg)

函数![](./img/ededcb90b8071069a783dea14b4aad14.svg)将全部的过去序列![](./img/4853841121d3f2ddb9d9efd1bf614d48.svg)作为输入来生成当前状态，但是展开的循环架构允许我们将![](./img/ededcb90b8071069a783dea14b4aad14.svg)分解为函数![](./img/8fa14cdd754f91cc6554c9e71929cce7.svg)的重复应用。因此，展开过程引入两个主要优点：

- 无论序列的长度，学成的模型始终具有相同的输入大小，因此它指定的是从一种状态到另一种状态的转移，而不是在可变长度的历史状态上操作。
- 我们可以在每个时间步使用相同参数的相同转移函数![](./img/8fa14cdd754f91cc6554c9e71929cce7.svg)。

这两个因素使得学习在所有时间步和所有序列长度上操作单一的模型![](./img/8fa14cdd754f91cc6554c9e71929cce7.svg)是可能的，而不需要在所有可能时间步学习独立的模型![](./img/ededcb90b8071069a783dea14b4aad14.svg)。学习单一的共享模型允许泛化到没有见过的序列长度（没有出现在训练集中），并且估计模型所需的训练样本远远少于不带参数共享的模型。

无论是循环图和展开图都有其用途。循环图简洁。展开图能够明确描述其中的计算流程。展开图还通过显式的信息流动路径帮助说明信息在时间上向前（计算输出和损失）和向后（计算梯度）的思想。
