什么样的数据才是频繁项集呢？也许你会说，这还不简单，肉眼一扫，一起出现次数多的数据集就是频繁项集吗！的确，这也没有说错，但是有两个问题，第一是当数据量非常大的时候，我们没法直接肉眼发现频繁项集，这催生了关联规则挖掘的算法，比如Apriori，PrefixSpan等。第二是我们缺乏一个频繁项集的标准。比如10条记录，里面A和B同时出现了三次，我们能不能说A和B构成频繁项集呢？因此我们需要一个评估频繁项集的标准。


## 评估标准

常用的频繁项集的评估标准有支持度，置信度和提升度三个。

### 支持度

支持度就是几个关联的数据在数据集中出现的次数占总数据集的比重。或者说几个数据关联出现的概率。如果我们有两个想分析关联性的数据![](./img/02129bb861061d1a052c592e2dc6b383.svg)和![](./img/57cec4137b614c87cb4e24a3d003a3e0.svg)，则对应的支持度为：

![](./img/dc452e72bad0adf2900043e0cb2f0a9b.svg)

以此类推，如果我们有三个想分析关联性的数据![](./img/02129bb861061d1a052c592e2dc6b383.svg)，![](./img/57cec4137b614c87cb4e24a3d003a3e0.svg)和![](./img/21c2e59531c8710156d34a3c30ac81d5.svg)，则对应的支持度为：

![](./img/ca8f378dc51f1999cece815cbf2ff877.svg)

一般来说，支持度高的数据不一定构成频繁项集，但是支持度太低的数据肯定不构成频繁项集。

<a name="8f3599b6"></a>
### 置信度

置信度体现了一个数据出现后，另一个数据出现的概率，或者说数据的条件概率。如果我们有两个想分析关联性的数据![](./img/02129bb861061d1a052c592e2dc6b383.svg)和![](./img/57cec4137b614c87cb4e24a3d003a3e0.svg)，![](./img/02129bb861061d1a052c592e2dc6b383.svg)对![](./img/57cec4137b614c87cb4e24a3d003a3e0.svg)的置信度为

![](./img/77448af525b9787de6d5ae22d7908495.svg)

以此类推到多个数据的关联置信度，比如对于三个数据![](./img/02129bb861061d1a052c592e2dc6b383.svg)，![](./img/57cec4137b614c87cb4e24a3d003a3e0.svg)和![](./img/21c2e59531c8710156d34a3c30ac81d5.svg)，则![](./img/02129bb861061d1a052c592e2dc6b383.svg)对于![](./img/57cec4137b614c87cb4e24a3d003a3e0.svg)和![](./img/21c2e59531c8710156d34a3c30ac81d5.svg)的置信度为：

![](./img/203599f3a82c823582be32b22f90a180.svg)

举个例子，在购物数据中，纸巾对应鸡爪的置信度为40%，支持度为1%。则意味着在购物数据中，总共有1%的用户既买鸡爪又买纸巾；同时买鸡爪的用户中有40%的用户购买纸巾。

<a name="e4792cca"></a>

### 提升度

提升度表示含有![](./img/57cec4137b614c87cb4e24a3d003a3e0.svg)的条件下，同时含有![](./img/02129bb861061d1a052c592e2dc6b383.svg)的概率，与![](./img/02129bb861061d1a052c592e2dc6b383.svg)总体发生的概率之比，即：

![](./img/a62e8d3263f840b118598876b56db8c6.svg)

---


## 项集挖掘
### Apriori

Apriori算法是常用的用于挖掘出数据关联规则的算法，它用来找出数据值中频繁出现的数据集合，找出这些集合的模式有助于我们做一些决策。比如在常见的超市购物数据集，或者电商的网购数据集中，如果我们找到了频繁出现的数据集，那么对于超市，我们可以优化产品的位置摆放，对于电商，我们可以优化商品所在的仓库位置，达到节约成本，增加经济效益的目的。下面我们就对Apriori算法做一个总结。 [文本挖掘](..\文本挖掘) 

找到支持度大于![](./img/dfe7bc58f03ca02cd979d0ef549d52cb.svg)的项集，若![](./img/ccebd416518f2c43be73680cf190d9e3.svg)了，那![](./img/2907b6c90f3db967b14ec2cecb8c3549.svg)更小，所以![](./img/61387437566c024c911e4099fb69c76a.svg)不可能是频繁项集，所以就不用计算了。反之，![](./img/a35ac2bea0d4c5ec27fdeb4b5f1c4ae0.svg)那肯定![](./img/a01739ec5facf95f6a72ab1567f9eb4a.svg)。Apriori就基于此思想迭代和剪枝

```
扫描数据库，生成高频1-项集(只有1项的)
while:
     根据上一轮k-项集生成(k+1)-项集作为候选集
     扫描数据库测试生成的(k+1)-项集候选集是否高频(这里构造时，新加的项必须也满足支持度)
     k = k+1
     Until: 没有大于阈值的 或 没有新候选集可生成
return: 返回所有满足频繁项集
```

![](./img/1592023522278-387a3f6c-c3e7-44ae-9ef7-02ec3ba88d02.png)


Code实现：[https://spark.apache.org/docs/2.3.0/mllib-frequent-pattern-mining.html](https://spark.apache.org/docs/2.3.0/mllib-frequent-pattern-mining.html)


### FP-Growth

也基于了若k-项集都不满足支持度，那含k-项集的(k+1)项集也不满足的思想。

算法思想如下图：

1. 扫第一遍数据库，统计出所有满足最低支持度的单项的支持度；把不满足最低支持度的单项去掉（如果单项都不满足支持度，此单项和其他组合支持度肯定更低更不满足，所以直接去掉即可）
2. 每笔交易中的商品按支持度高低排序。
3. 再扫一遍数据库，建立FP-tree。这里FP-tree使用链表保存，注意这里非一棵树但相同元素也有指针指向(比如p：2（最左下）指向了p：1（最右下）)，这样是为了寻找p的频繁项集时，方便全找到FP-tree中的p。
4. 查询时从对应叶节点往上找就好。

![](./img/1592023522531-cc8d5a28-8f9d-4dce-877f-2236647451a1.png)<br />![FPGrowth2.png](./img/1592293880210-71b8adba-d5b8-4aa3-a0e9-a06164b0e573.png)![FPGrowth3.png](./img/1592293893905-411797a8-27d9-4107-b1d2-23d644dc93b7.png)

Code实现：[https://spark.apache.org/docs/2.3.0/mllib-frequent-pattern-mining.html](https://spark.apache.org/docs/2.3.0/mllib-frequent-pattern-mining.html)

---


## 项集衡量
![项集衡量.png](./img/1592293933112-318e039d-5813-49fa-80ca-3f08b5dad1e2.png)

---


## 基于约束的频繁项集

有时我们并不关心所有的频繁项集，只想了解我们关心的。加约束条件去挖掘既灵活又可加快速度。

### 模式空间剪枝约束
#### Anti-monotonic
![模式空间剪枝约束1.png](./img/1592294155928-616ef95d-9f0e-413d-9b61-10b258e9366a.png)
<a name="Cgl5l"></a>
#### Monotonic
![模式空间剪枝约束2.png](./img/1592294177414-fffd2459-84f7-48ff-a741-320de8e306d4.png)
<a name="H2DpY"></a>
#### Succinct
![模式空间剪枝约束3.png](./img/1592294218129-3cad2f64-843f-4671-9861-415c68b6555d.png)
<a name="jZwCY"></a>
#### Convertible
![模式空间剪枝约束4.png](./img/1592294227092-e609a678-28c3-4547-9059-09c7b52c1d0b.png)

<a name="VORFV"></a>

### 数据空间剪枝约束

#### Data succinct
![数据空间剪枝约束1.png](./img/1592294048917-d1cdb0d3-7ee4-48d9-9fb6-37efbd5db3ad.png)
<a name="ggURg"></a>
#### Data anti-monotonic<br />
![anti-monotonic.png](./img/1592379046790-08338914-e4aa-4175-be81-46b2ec5d830c.png)
