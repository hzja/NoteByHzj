
# 方法特性与流形介绍

## 方法特性

**缺失值比率：**如果数据集的缺失值太多，我们可以用这种方法减少变量数。

**低方差滤波：**这个方法可从数据集中识别和删除常量变量，方差小的变量对目标变量影响不大，可以放心删去。

**高相关滤波：**具有高相关性的一对变量会增加数据集中多重共线性，所以用这种方法删去其中一个是有必要的。

**随机森林：**这是最常用的降维方法之一，它会明确算出数据集中每个特征的重要性。前向特征选择和反向。

**特征消除：**这两种方法耗时较久，计算成本也都很高，所以只适用于输入变量较少的数据集。

**因子分析：**这种方法适合数据集中存在高度相关的变量集的情况。

**PCA：**这是处理线性数据最广泛使用的技术之一。

**ICA：**ICA非降低维度，而是将数据转换为独立的分量，使用更少的分量来描述数据。

**kPCA：**适合非线性数据，将数据映射至高维可分后再用PCA。

**MDS：**原始高维空间中样本距离在低维中继续保持。

**ISOMAP：**适合非线性数据处理，流形学习，试图保持近邻样本之间的距离不同。

**LLE：**适合非线性数据处理，流形学习，试图保持邻域内样本之间的线性关系。

**t-SNE：**适合非线性数据处理，可将数据降至2维或3维度方便可视化。


## [流形介绍](https://www.zhihu.com/question/24015486)

流形学习(manifold learning)是一类借鉴拓扑流形概念的降维方法。“流形”是在局部与欧氏空间同胚的空间，换言之，它在局部具有欧氏空间的性质，能用欧氏距离来进行距离计算。这给降维方法带来了很大的启发：若低维流形嵌入到高维空间中，则数据样本在高维度空间的分布虽然看上去非常复杂，但在局部上仍具有欧氏空间的性质。因此，可以容易地在局部建立降维映射关系，然后再设法将局部映射关系推广到全局。当维数被降至二维或三维时，能对数据进行可视化展示，因此流形学习也可以被用于可视化。

流形（英语：Manifolds），是局部具有欧几里得空间性质的空间，是欧几里得空间中的曲线、曲面等概念的推广。欧几里得空间就是最简单的流形的实例。地球表面这样的球面则是一个稍微复杂的例子。一般的流形可以通过把许多平直的片折弯并粘连而成。比如下图，地球是三维的，我们可以想象成多个极小二维纸片（地图）拼接而成。

![1024px-Triangles_(spherical_geometry).jpg](./img/1592311374019-540536b7-9a44-422d-af32-ccdba8e21330.jpeg)

流形学习的观点是认为，我们所能观察到的数据实际上是由一个低维流形映射到高维空间上的。由于数据内部特征的限制，一些高维中的数据会产生维度上的冗余，实际上只需要比较低的维度就能唯一地表示。

举个例子，比如说我们在平面上有个圆，如何表示这个圆呢？如果我们把圆放在一个平面直角坐标系中，那一个圆实际上就是由一堆二维点构成的。比如一个单位圆：![](./img/b6dbc33006b907f2db1855810abfce98.svg)是一个在圆上的点，![](./img/ec6014ffc3d92709aa6a4fea11bb3788.svg)也是一个在圆上的点，但![](./img/5c16f757233856dcf311176b7410d2d5.svg)和![](./img/52053dc3ca4218b698d115408e557a44.svg)等等很多点是不在这个圆上的。显然如果用二维坐标来表示，我们没有办法让这个二维坐标系的所有点都是这个圆上的点。也就是说，用二维坐标来表示这个圆其实是有冗余的。我们希望，如果能建立某一种描述方法，让这个描述方法所确定的所有点的集合都能在圆上，甚至能连续不间断地表示圆上的点，那就好了！有没有这种方法呢？对于圆来说，当然有！那就是用极坐标。在极坐标的表示方法下，圆心在原点的圆，只需要一个参数就能确定：半径。当你连续改变半径，就能产生连续不断的“能被转换成二维坐标表示”的圆。

所以说，实际上二维空间中的圆就是一个一维流形。与之相似的，三维空间中一个球面，用x, y, z三个坐标轴确定时会产生冗余（很多在三维空间中的数据点并不在球面上）。但其实只需要用两个坐标就可以确定了，比如经度和维度。只要给定任何合法的经度和维度，我们就都能保证这个点肯定在球面上！

---


# [常用方法](https://zhuanlan.zhihu.com/p/43225794)

## 缺失值比率(Missing Value Ratio)

当缺失值在数据集中的占比过高时，一般会选择直接删除这个变量，因为它包含的信息太少了。但具体删不删、怎么删需要视情况而定，我们可以设置一个阈值，如果缺失值占比高于阈值，删除它所在的列。阈值越高，降维方法越积极。


## 低方差滤波(Low Variance Filter)

如果我们有一个数据集，其中某列的数值基本一致，也就是它的方差非常低，那么这个变量还有价值吗？和上一种方法的思路一致，我们通常认为低方差变量携带的信息量也很少，所以可以把它直接删除。

放到实践中，就是先计算所有变量的方差大小，然后删去其中最小的几个。需要注意的一点是：方差与数据范围相关的，因此在采用该方法前需要对数据做归一化处理。


## 高相关滤波(High Correlation filter)

如果两个变量之间是高度相关的，这意味着它们具有相似的趋势并且可能携带类似的信息。同理，这类变量的存在会降低某些模型的性能（例如线性和逻辑回归模型）。为了解决这个问题，我们可以计算独立数值变量之间的相关性。如果相关系数超过某个阈值，就删除其中一个变量。


## 随机森林(Random Forest)

随机森林是一种广泛使用的特征选择算法，它会自动计算各个特征的重要性，所以无需单独编程。这有助于我们选择较小的特征子集。

在开始降维前，我们先把数据转换成数字格式，因为随机森林只接受数字输入。同时，ID这个变量虽然是数字，但它目前并不重要，所以可以删去。


## 反向特征消除(Backward Feature Elimination)

以下是反向特征消除的主要步骤：

1. 先获取数据集中的全部n个变量，然后用它们训练一个模型。
2. 计算模型的性能。
3. 在删除每个变量（n次）后计算模型的性能，即我们每次都去掉一个变量，用剩余的n-1个变量训练模型。
4. 确定对模型性能影响最小的变量，把它删除。
5. 重复此过程，直到不再能删除任何变量。


## 前向特征选择(Forward Feature Selection)

前向特征选择其实就是反向特征消除的相反过程，即找到能改善模型性能的最佳特征，而不是删除弱影响特征。它背后的思路如下所述：

1. 选择一个特征，用每个特征训练模型n次，得到n个模型。
2. 选择模型性能最佳的变量作为初始变量。
3. 每次添加一个变量继续训练，重复上一过程，最后保留性能提升最大的变量。
4. 一直添加，一直筛选，直到模型性能不再有明显提高。


## 因子分析(Factor Analysis)

因子分析是一种常见的统计方法，它能从多个变量中提取共性因子，并得到最优解。假设我们有两个变量：收入和教育。它们可能是高度相关的，因为总体来看，学历高的人一般收入也更高，反之亦然。所以它们可能存在一个潜在的共性因子，比如“能力”。

在因子分析中，我们将变量按其相关性分组，即特定组内所有变量的相关性较高，组间变量的相关性较低。我们把每个组称为一个因子，它是多个变量的组合。和原始数据集的变量相比，这些因子在数量上更少，但携带的信息基本一致。

---


# 线性降维方法

![线性降维1.png](./img/1592311415388-18aced4e-19a3-4713-a858-531a92ec1c58.png)

线性降维的方法可以应对像下图这样简单的数据(比如PCA找方差大的维度进行保留)

![线性降维2.png](./img/1592311430352-1238261d-56e2-443f-b5f7-fb3b160428c9.png)![线性降维3.png](./img/1592311451832-7a5473ab-df51-4474-a943-f99636132084.png)


## 主成分分析(PCA)

主成分分析(Principal Component Analysis，PCA)是最常用的一种降维方法，旨在找到数据中的主成分，并利用这些主成分表征原始数据，从而达到降维的目的。它属于一种线性、非监督、全局的降维算法

![PCA1.jpg](./img/1592311480736-fa7a5bfb-c9f7-4680-93d5-fba83b3109f4.jpeg)

在介绍PCA之前，不妨先考虑这样一个问题：对于正交属性空间中的样本点，如何用一个超平面对所有样本进行恰当的表达？容易想到，若存在这样的超平面，那么它大概应该有这样的性质：

1. 最大可分性：样本点在这个超平面上的投影能尽可能分开（最大方差理论）
2. 最近重构性：样本点到这个超平面的距离都足够近（最小平方误差理论）

基于这两个性质都可以推导出PCA，这里以最大可分性来推导。


### [最大可分思想](https://zhuanlan.zhihu.com/p/32412043)

​	主成分分析顾名思义，就是找出数据里最主要的方面，用数据里最主要的方面来代替原始数据。具体的，假如我们的数据集是![](./img/7b8b965ad4bca0e41ab51de7b31363a1.svg)维的，共有![](./img/6f8f57715090da2632453988d9a1501b.svg)个数据![](./img/eeda20fc974bc6901384793bfc1e01fc.svg)。我们希望将这![](./img/6f8f57715090da2632453988d9a1501b.svg)个数据的维度从![](./img/7b8b965ad4bca0e41ab51de7b31363a1.svg)维降到![](./img/8b072dc4ba86c6008887fd8004865c61.svg)维，希望这![](./img/6f8f57715090da2632453988d9a1501b.svg)个![](./img/8b072dc4ba86c6008887fd8004865c61.svg)维的数据集尽可能的代表原始数据集。我们知道数据从![](./img/7b8b965ad4bca0e41ab51de7b31363a1.svg)维降到![](./img/8b072dc4ba86c6008887fd8004865c61.svg)维肯定会有损失，但是我们希望损失尽可能的小。那么如何让这![](./img/8b072dc4ba86c6008887fd8004865c61.svg)维的数据尽可能表示原来的数据呢？

​	我们先看看最简单的情况，也就是![](./img/c303081f7a16f603112b0375bdc84883.svg)，![](./img/a54e017b88e2487b7d11876c50c76e2f.svg)，也就是将数据从二维降维到一维。数据如下图。我们希望找到某一个维度方向，它可以代表这两个维度的数据。图中列了两个向量方向，![](./img/d33def0eb4933f91b88eb4e784adaf05.svg)和![](./img/89ae78be880a004aa5404ac874a01bff.svg)，那么哪个向量可以更好的代表原始数据集呢？例如下图，从直观上也可以看出，![](./img/d33def0eb4933f91b88eb4e784adaf05.svg)比![](./img/89ae78be880a004aa5404ac874a01bff.svg)好，这就是我们所说的**最大可分性**

![PCA2.jpg](./img/1592311503496-0c6f9ffa-8805-4176-b488-71ca0c6e91cf.jpeg)

​	上图是二维空间中经过中心化的一组数据，我们很容易看出主成分所在的轴(以下称为主轴)的大致方向，即上图中![](./img/d33def0eb4933f91b88eb4e784adaf05.svg)所在的轴。因为![](./img/d33def0eb4933f91b88eb4e784adaf05.svg)所处的轴上，数据分布的更为分散，这也意味着数据在这个方向上方差更大。在信号处理领域，我们认为信号具有较大方差，噪声具有较小方差，信号与噪声之比称为信噪比。信噪比越大意味着数据的质量越好，反之，信噪比越小意味着数据的质量越小。由此我们不难引出PCA的目标，即**最大化投影方差**，也就是让数据在主轴上投影的方差最大。

​	给一组数据点![](./img/220e60de2071bcd755da5b6f2ee3346a.svg)，所有向量均为列向量，中心化后为![](./img/5117e9b8debc78ba2325cec1f5b7cc78.svg)，其中![](./img/f4b6093de1e1b5d9f72320f46b5c17e7.svg)，即每个数据点减样本集均值。我们知道，向量内积在几何上表示为第一个向量投影到第二个向量上的长度，因此向量![](./img/1ba8aaab47179b3d3e24b0ccea9f4e30.svg)在![](./img/f1290186a5d0b1ceab27f4e77c0c5d68.svg)(单位方向向量)上的投影坐标可以表示为![](./img/2150ce0d28d58f318d65233359c168d9.svg)。所以目标是找到一个投影方向![](./img/f1290186a5d0b1ceab27f4e77c0c5d68.svg)，使![](./img/555cd1621a55204bccb1729027075f5b.svg)在![](./img/f1290186a5d0b1ceab27f4e77c0c5d68.svg)上的投影方差尽可能大。易知，投影之后均值为0(因为![](./img/bad01c354066649a483f6a2e5344d42d.svg)，这也是我们进行中心化的意义)，因此投影后的方差可以表示为：

![](./img/43d3452c573ba8bf980cc5c3764154a6.svg)

![](./img/a0fe1a05605026eaad34921ddcc08e64.svg)其实就是样本的协方差矩阵，我们将其写作![](./img/7231fa806691800f095133f6fb720d82.svg)，且由于![](./img/f1290186a5d0b1ceab27f4e77c0c5d68.svg)是单位方向向量，即![](./img/75d71e114cdcf904700235d716e36742.svg)。所以，我们要解决的最大化问题可表示为：

![](./img/6a54b714d0316b0e739d02f815450657.svg)

引入拉格朗日乘子，并对![](./img/f1290186a5d0b1ceab27f4e77c0c5d68.svg)求导令其等于0，便可以推出![](./img/354baaca87b74921d36dcba33b68c44b.svg)，此时：

![](./img/1ea71cfa7e6f8712c7d359d90732a195.svg)

熟悉线性代数的马上会发现，原来![](./img/9dd4e461268c8034f5c8564e155c67a6.svg)投影后的方差就是协方差矩阵的特征值。我们要找到最大的方差也就是协方差矩阵最大的特征值，最佳投影方向就是最大特征值对应的特征向量。次佳投影方向位于最佳投影方向的正交空间中，是第二大特征值对应的特征向量，以此类推。所以有以下PCA求解方法：

1. 对样本数据进行中心化处理
2. 求样本协方差矩阵
3. 对协方差矩阵进行特征值分解(SVD)，将特征值从大到小排列
4. 取特征值前![](./img/8277e0910d750195b448797616e091ad.svg)大对应的特征向量![](./img/ab6d9dd9163916f6e47e7775d4348a99.svg)，通过以下映射将![](./img/7b8b965ad4bca0e41ab51de7b31363a1.svg)维样本映射到![](./img/8277e0910d750195b448797616e091ad.svg)维：
5. ![](./img/c8ece221287821ee961f2bc39c316904.svg)

新的![](./img/6e88fda817872745579e0187978e3d2a.svg)的第![](./img/8277e0910d750195b448797616e091ad.svg)维就是![](./img/1ba8aaab47179b3d3e24b0ccea9f4e30.svg)在第![](./img/8277e0910d750195b448797616e091ad.svg)个主成分![](./img/977622ef17f1b626b74f6005e2c33762.svg)方向上的投影，通过选取最大的![](./img/8277e0910d750195b448797616e091ad.svg)个特征值对应的特征向量，我们将方差较小的特征(噪声)抛弃，使得每个![](./img/7b8b965ad4bca0e41ab51de7b31363a1.svg)维列向量![](./img/1ba8aaab47179b3d3e24b0ccea9f4e30.svg)被映射为![](./img/8277e0910d750195b448797616e091ad.svg)维列向量![](./img/a8bd142ff50c917129b5088c2bc62fbe.svg)，定义降维后的信息占比为：![](./img/914f29cf479ac4325cf45bdb83107a6f.svg)


### code实现

[https://github.com/chmx0929/UIUCclasses/tree/master/598MachLrngforSignalProcessng/homework/homework2](https://github.com/chmx0929/UIUCclasses/tree/master/598MachLrngforSignalProcessng/homework/homework2)


## 线性判别分析(LDA)

线性判别分析(Linear Discriminant Analysis，LDA)是一种监督学习的降维技术也可以做分类任务，也就是说它的数据集的每个样本是有类别输出的，这点和PCA不同。PCA是不考虑样本类别输出的无监督降维技术。LDA的思想可以用一句话概括，就是“投影后类内方差最小，类间方差最大”，如下图所示。我们要将数据在低维度上进行投影，我们投影后希望

1. 每一种类别数据的投影点尽可能的接近
2. 不同类别的数据的类别中心之间的距离尽可能的大

![LDA1.jpg](./img/1592357095608-9141f127-81f7-4eef-91d1-9b8728f6abb0.jpeg)

给定数据集![](./img/40657e03d633c9844a065da6a9b06d10.svg)，![](./img/45e67b4d75808108cbec2c9056372fbd.svg)

第![](./img/865c0c0b4ab0e063e5caa3387c1a8741.svg)类的集合![](./img/a97118fb9e8d7e006a466bfc0771f888.svg)，第![](./img/865c0c0b4ab0e063e5caa3387c1a8741.svg)类的均值向量![](./img/262d5ec61d4727236470a56c2e8433ef.svg)，第![](./img/865c0c0b4ab0e063e5caa3387c1a8741.svg)类的协方差矩阵![](./img/bf39fad9b345154b4c34dff898ddf84c.svg)，![](./img/6635c7ab52ea0b42bd4444e2e9443816.svg)即一共就两类

两类样本的中心在直线![](./img/f1290186a5d0b1ceab27f4e77c0c5d68.svg)上的投影，即直线与原均值向量的内积![](./img/03338381cd4b680e1b9c99744040a1c7.svg)和![](./img/56c5686a0a1c5aaff2375408a7c691ef.svg)。所有样本点都投影到直线上，则两类样本的协方差为![](./img/04337f8a8654b3ade3985ce8494f9b1e.svg)和![](./img/8616fb93479b732dcbd7a621aa7a3072.svg)

1. 投影后类内方差最小，即![](./img/72047ae0186bc827810c95136e9c3317.svg)尽可能小
2. 类间方差最大，即![](./img/31ccbc23a3057f46d67967bbb390fd81.svg)尽可能大

同时考虑优化二者，则可得到欲最大化的目标：

![](./img/1638fbc707f537c99ddb0a47a5ea4964.svg)

定义“类内散度矩阵”：![](./img/745f09278a44a34e9ae7ccf7ab5ef5b9.svg)

定义“类间散度矩阵”：![](./img/70cefba82728c8a679ee3fa4cbb9ab31.svg)

所以，我们可将最大化目标函数![](./img/ff44570aca8241914870afbc310cdb85.svg)写为：

![](./img/3ec53fa88bcca8b04eda8c5747465777.svg)

这就是LDA欲最大化的目标，即![](./img/2fd22de2d8a771b1f5f80c4594883552.svg)与![](./img/782327bc4029959665e7ca501030028c.svg)的“广义瑞利商”(Generalized Rayleigh Quotient)

如何确定![](./img/f1290186a5d0b1ceab27f4e77c0c5d68.svg)呢？注意到上式的分子和分母都是关于![](./img/f1290186a5d0b1ceab27f4e77c0c5d68.svg)的二次项，因此上式的解![](./img/f1290186a5d0b1ceab27f4e77c0c5d68.svg)的长度无关，只与其方向有关。不失一般性，令![](./img/9c32a3a9d5d798d4abdc7be4a6404e97.svg)，上式等价于

![](./img/90a453c856d1cc9ed950fa5834a8d7d0.svg)

由拉格朗日乘子法，上式等价于

![](./img/61f0ae6697bd6baf0f0650091d325ca8.svg)

其中![](./img/c6a6eb61fd9c6c913da73b3642ca147d.svg)是拉格朗日乘子。注意到![](./img/11bbaa84e2b58ddf56ad10487eb14739.svg)的方向恒为![](./img/88a8fb3566d3f70731a567c4cad1538a.svg)，不妨令![](./img/be17e12a0244cc598de0c10629e01971.svg)代入上式

![](./img/e1190e98950fd11b204b637e253ee4ab.svg)

考虑到数值解的稳定性，在实践中通常是对![](./img/782327bc4029959665e7ca501030028c.svg)进行奇异值分解，即![](./img/c4f880b95d94c5b9b41fcc0ac0564070.svg)，这里![](./img/7231fa806691800f095133f6fb720d82.svg)是一个对角矩阵，其对角线上的元素是![](./img/782327bc4029959665e7ca501030028c.svg)的奇异值，然后再由![](./img/52a38270ba7437cc3120183eda3e88a0.svg)得到![](./img/f98d7ccd2e7b3e312d1c02ea0a804ab8.svg)。值得一提的是，LDA可从贝叶斯决策理论的角度来阐述，并可证明，当两类数据同先验，满足高斯分布且协方差相等时，LDA可达到最优分类。


### 多类别映射(分类)

若有很多类别，还是基于LDA基本思想，每个类间距离最大，类内距离最小。假定存在![](./img/8d9c307cb7f3c4a32822a51922d1ceaa.svg)个类，且第![](./img/865c0c0b4ab0e063e5caa3387c1a8741.svg)类示例数为![](./img/342e772474b691ac87dac30aeef596c0.svg)，我们先定义“全局散度矩阵”：

![](./img/645a0db9431bc7933ea4aa540c2af0ce.svg)

其中![](./img/c9faf6ead2cd2c2187bd943488de1d0a.svg)是所有示例的均值向量，将类内散度矩阵![](./img/782327bc4029959665e7ca501030028c.svg)重新定义为每个类别的散度矩阵之和，即

![](./img/94d0b5fc768c6f40aa0b530b5b1b3479.svg)

整理上面两式可得

![](./img/22709d51103768ff2fa45f52f385c701.svg)

显然，多分类LDA可以有多种实现方法：使用![](./img/2fd22de2d8a771b1f5f80c4594883552.svg)，![](./img/782327bc4029959665e7ca501030028c.svg)，![](./img/963123d6ba15e531cac42d449320e07c.svg)三者中的任何两个即可，常见的一种实现是采用优化目标：

![](./img/8afc6273c3f5194f4b31b26337374c42.svg)

其中![](./img/6f850f1de6a8b798c4d6f7219b1d8684.svg)，上式可通过广义特征值问题求解：![](./img/5e2980f6ca1e9285ffb8d1d4ea5053de.svg)。![](./img/61e9c06ea9a85a5088a499df6458d276.svg)的闭式解则是![](./img/12df612eb750886c12892dc4cf7c4665.svg)的![](./img/131f04ef3dd102f4156afe21bc2f5028.svg)个最大非零广义特征值所对应的特征向量组成的矩阵，![](./img/01451ddc98bf37f82e558858a6eeff24.svg)。

将![](./img/61e9c06ea9a85a5088a499df6458d276.svg)视为一个投影矩阵，则多分类LDA将样本投影到![](./img/131f04ef3dd102f4156afe21bc2f5028.svg)维空间。![](./img/131f04ef3dd102f4156afe21bc2f5028.svg)通常远小于数据原有的属性数![](./img/8277e0910d750195b448797616e091ad.svg)于是，可通过这个投影来减少样本点的维数，且投影过程中采用了类别信息，因此LDA也常被视为一种经典的监督降维技术。

<a name="b82Fg"></a>
### PCA vs. LDA


#### **相同点**

1. 两者均可以对数据进行降维。
2. 两者在降维时均使用了矩阵特征分解的思想。
3. 两者都假设数据符合高斯分布。


#### **不同点**

1. LDA是有监督的降维方法，而PCA是无监督的降维方法。
2. LDA降维最多降到类别数k-1的维数，而PCA没有这个限制。
3. LDA除了可以用于降维，还可以用于分类。
4. LDA选择分类性能最好的投影方向，而PCA选择样本点投影具有最大方差的方向。这点可以从下图形象的看出，在某些数据分布下LDA比PCA降维较优。

![PCA vs LDA.jpg](./img/1592359623431-8bdd2458-d49a-449c-a0a4-ec188f76a8cc.jpeg)


## [独立分量分析(ICA)](http://danieljyc.github.io/2014/06/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A015-3--%E7%8B%AC%E7%AB%8B%E6%88%90%E5%88%86%E5%88%86%E6%9E%90ica%EF%BC%88independent-component-analysis%EF%BC%89/)

独立分量分析**(**Independent Component Analysis, ICA)的最重要的假设就是信号源统计独立，将数据转换为独立的分量，使用更少的分量来描述数据。这个假设在大多数盲信号分离的情况中符合实际情况。即使当该假设不满足时，仍然可以用独立成分分析来把观察信号统计独立化，从而进一步分析数据的特性。独立成分分析的经典问题是“鸡尾酒会问题”（Cocktail Party Problem）。该问题描述的是给定混合信号，如何分离出鸡尾酒会中同时说话的每个人的独立信号。当有![](./img/8d9c307cb7f3c4a32822a51922d1ceaa.svg)个信号源时，通常假设观察信号也有![](./img/8d9c307cb7f3c4a32822a51922d1ceaa.svg)个（例如![](./img/8d9c307cb7f3c4a32822a51922d1ceaa.svg)个麦克风或者录音机）。该假设意味着混合矩阵是个方阵，即![](./img/86309e7b49f15a1355ee144337ab175b.svg)，其中![](./img/f623e75af30e62bbd73d6df5b50bb7b5.svg)是输入数据的维数，![](./img/ff44570aca8241914870afbc310cdb85.svg)是系统模型的维数。对于![](./img/90378853dc51c495e017affc738c3503.svg)和![](./img/79b925d276896931e2630b9e8086e344.svg)的情况，学术界也分别有不同研究。

PCA和ICA之间的主要区别在于，PCA寻找不相关的因素，而ICA寻找独立因素。如果两个变量不相关，它们之间就没有线性关系。如果它们是独立的，它们就不依赖于其他变量。例如，一个人的年龄和他吃了什么/看了什么电视无关。该算法假设给定变量是一些未知潜在变量的线性混合。它还假设这些潜在变量是相互独立的，即它们不依赖于其他变量，因此它们被称为观察数据的独立分量。

经典的鸡尾酒宴会问题（cocktail party problem）。假设在party中有![](./img/7b8b965ad4bca0e41ab51de7b31363a1.svg)个人，他们可以同时说话，我们也在房间中一些角落里共放置了![](./img/7b8b965ad4bca0e41ab51de7b31363a1.svg)个声音接收器（Microphone）用来记录声音。宴会过后，我们从![](./img/7b8b965ad4bca0e41ab51de7b31363a1.svg)个麦克风中得到了一组数据![](./img/18c694cd080989412761eb5bc1c60e7f.svg)，![](./img/865c0c0b4ab0e063e5caa3387c1a8741.svg)表示采样的时间顺序，也就是说共得到了![](./img/6f8f57715090da2632453988d9a1501b.svg)组采样，每一组采样都是![](./img/7b8b965ad4bca0e41ab51de7b31363a1.svg)维的。我们的目标是单单从这![](./img/6f8f57715090da2632453988d9a1501b.svg)组采样数据中分辨出每个人说话的信号。有![](./img/7b8b965ad4bca0e41ab51de7b31363a1.svg)个人说话，就是有![](./img/7b8b965ad4bca0e41ab51de7b31363a1.svg)个信号源![](./img/75b996258522e599964b80d19c9f35f8.svg)每一维都是一个人的声音信号，每个人发出的声音信号独立。![](./img/7fc56270e7a70fa81a5935b72eacbe29.svg)是一个未知的混合矩阵（mixing matrix），用来组合叠加信号![](./img/03c7c0ace395d80182db07ae2c30f034.svg)，那么

![](./img/0bc5f9828e5ddaf8a380aa12c91ef8b7.svg)

这里的![](./img/9dd4e461268c8034f5c8564e155c67a6.svg)不是一个向量，是一个矩阵。其中每个列向量是![](./img/42c3196681f613618a26016845ad9515.svg)，即下图

![ICA1.jpg](./img/1592359997235-668ab540-c6fe-4adc-b6ff-83c5b2846cc3.jpeg)

![](./img/e8fa5b806940d1b4d0059fba40646506.svg)的每个分量都由![](./img/6e12ba28602acf77e8132bb5696255c9.svg)的分量线性表示。![](./img/7fc56270e7a70fa81a5935b72eacbe29.svg)和![](./img/03c7c0ace395d80182db07ae2c30f034.svg)都是未知的，![](./img/9dd4e461268c8034f5c8564e155c67a6.svg)是已知的，我们要想办法根据![](./img/9dd4e461268c8034f5c8564e155c67a6.svg)来推出![](./img/03c7c0ace395d80182db07ae2c30f034.svg)。这个过程也称作盲信号分离。令![](./img/48f5c1150ac1fb5a23fabcae9085e6fa.svg)，则

![](./img/782134c648c4b1afdfb11d201df47f0a.svg)![](./img/2840c18ac30eb2853b57963e2847e61d.svg)

最终得到

![](./img/5e216956e3ddeb985acc668574383bf2.svg)，其![](./img/53e1686f9af1cf3f3b6ec4e4990f4908.svg)即说话人![](./img/363b122c528f54df4a0446b6bab05515.svg)在![](./img/865c0c0b4ab0e063e5caa3387c1a8741.svg)时刻发出的信号

我们需要知道两个量才能求出另外一个，下面我们进一步分析，先预处理(中心化、漂白)一下数据

**中心化：**求出![](./img/9dd4e461268c8034f5c8564e155c67a6.svg)均值，然后所有![](./img/9dd4e461268c8034f5c8564e155c67a6.svg)减去均值

**漂白：**目的是为了让![](./img/9dd4e461268c8034f5c8564e155c67a6.svg)相互独立。将![](./img/9dd4e461268c8034f5c8564e155c67a6.svg)乘以一个矩阵变成![](./img/5100d03cf3bcef8ed87dbc7f96fad7fb.svg)(其协方差矩阵是![](./img/865c0c0b4ab0e063e5caa3387c1a8741.svg))

![](./img/988798045d9b3f9e5c13c67a679dfe5e.svg)，其中![](./img/445929117489d389b15e2dd3d15a35ee.svg)

使用特征值分解来得到![](./img/3a3ea00cfc35332cedf6e5e9a32e94da.svg)（特征向量矩阵）和![](./img/f623e75af30e62bbd73d6df5b50bb7b5.svg)（特征值对角矩阵），公式为![](./img/6bae99a664599cadbd118c14b0f40668.svg)


### ICA算法

我们假设每![](./img/e406ac4d7c470823a8619c13dd7101be.svg)有概率密度![](./img/ef2b689bf206cae2b46bcb216a24e358.svg)，那么给定时刻原信号的联合分布就是

![](./img/de3983d20fcaca6024f371233c759411.svg)，每个人发出的声音信号![](./img/03c7c0ace395d80182db07ae2c30f034.svg)各自独立

然后，我们就可以求得![](./img/4130c89f2d12c3ac81aba3adbff28685.svg)

![](./img/2b38d211a29249c0b90ba4d50d7eda03.svg)

现在，我们需要知道![](./img/aac63bcf5efd117a9292731f83788017.svg)和![](./img/f1290186a5d0b1ceab27f4e77c0c5d68.svg)，才能求得![](./img/4130c89f2d12c3ac81aba3adbff28685.svg)，首先我们假设![](./img/03c7c0ace395d80182db07ae2c30f034.svg)的累积分布函数符合sigmoid函数

![](./img/e72d1247d3ebd589a09c09b8aa168936.svg)，求导后![](./img/646cd9a2ddfd30aed2dabb4640a54734.svg)，这就是![](./img/03c7c0ace395d80182db07ae2c30f034.svg)的密度函数

然后，我们就剩下![](./img/61e9c06ea9a85a5088a499df6458d276.svg)需要求解了，使用最大似然估计的方法求解，使用前面得到的![](./img/9dd4e461268c8034f5c8564e155c67a6.svg)的概率密度函数

![](./img/bdf9655c9efdd2da643c54f10de1cf70.svg)

上式括号里的其实就是![](./img/7b19c6dcab35285e76ac92008020f39b.svg)，最终，我们可求得

![](./img/9cfb48e62827140c341eeefe1e8eae8d.svg)，其中![](./img/7b7f9dbfea05c83784f8b85149852f08.svg)是梯度上升速率，人为指定

迭代求出![](./img/61e9c06ea9a85a5088a499df6458d276.svg)后，我们就可以还原出原始信号

![](./img/d3f88c222fb41d406f4bb0c368cddffb.svg)

### code实现

[https://github.com/chmx0929/UIUCclasses/tree/master/598MachLrngforSignalProcessng/homework/homework2](https://github.com/chmx0929/UIUCclasses/tree/master/598MachLrngforSignalProcessng/homework/homework2)


---


# 非线性降维方法

对于像下图这样复杂一些的数据(比如我们有些"curvy"数据)，线性降维的方法就解决不了

![非线性降维1.png](./img/1592361058198-6e6ceb8d-04e5-4530-b875-467876a2db25.png)![非线性降维2.png](./img/1592361068638-d24df329-95ac-4d42-8405-50ce2de5758b.png)

<a name="rRZ2k"></a>
## [核主成分分析(Kernel PCA)](https://blog.csdn.net/qianhen123/article/details/40863753)

假设我们有![](./img/8d9c307cb7f3c4a32822a51922d1ceaa.svg)个![](./img/f623e75af30e62bbd73d6df5b50bb7b5.svg)维线性不可分的数据![](./img/801d9d56cbcb4d46ffaf0dbb8b46cf51.svg)。我们引入一个非线性映射函数![](./img/06e38faa0845589fe2b664a60f68843b.svg)，通过这个非线性映射函数可以将原来的线性不可分的样本映射到更高维度，在这个高维空间中，本来在原空间中线性不可分的样本现在线性可分了

![kPCA.png](./img/1592362124517-d982166f-afee-47cf-91f3-c1e2acaff574.png)

数据在这个高维度空间中线性可分了，这时候我们再用PCA，问题解决。即

![kPCA2.png](./img/1592362144372-ee9115fb-6ef3-4984-b1a1-91f4dd7933f1.png)

每个特征值向量![](./img/1df181eaa1bb40a0067c06ead197170d.svg)都能从输入数据的线性组合得到：![](./img/3f226a2b65e263375be130999640ff70.svg)，代入上式得高维度特征分解的表达式：

![](./img/f15e1be4476094939851248bd48c8835.svg)

两边同时左乘![](./img/7643a5b7b520bd06f242862590a954fd.svg)，并引入一个![](./img/395a9af17f8642e02a32af8637542947.svg)的核函数![](./img/a5f3c6a11b03839d46af9fb43c97c188.svg)，即可得低维度特征分解表达式：

![](./img/0f62cd96c7af06c7237cb3377fc334e5.svg)![](./img/1d1679746348b52f5d5548420559cc5b.svg)，其中![](./img/a5f3c6a11b03839d46af9fb43c97c188.svg)是![](./img/395a9af17f8642e02a32af8637542947.svg)维核矩阵，![](./img/2aecb1dc57e87620a373d19b0a889efb.svg)是![](./img/8d9c307cb7f3c4a32822a51922d1ceaa.svg)维列向量

求解公式的含义就是求![](./img/a5f3c6a11b03839d46af9fb43c97c188.svg)最大的几个特征值所对应的特征向量，由于![](./img/a5f3c6a11b03839d46af9fb43c97c188.svg)为对称矩阵，所得的解向量彼此之间肯定是正交的。请注意，这里的![](./img/0cc175b9c0f1b6a831c399e269772661.svg)只是![](./img/a5f3c6a11b03839d46af9fb43c97c188.svg)的特征向量，但是其不是高维空间中的特征向量，回看![](./img/3f226a2b65e263375be130999640ff70.svg)公式，高维空间中的特征向量![](./img/9e3669d19b675bd57058fd4664205d2a.svg)应该是由![](./img/0cc175b9c0f1b6a831c399e269772661.svg)进一步求出。


### [核函数](https://www.zhihu.com/question/24627666/answer/28440943)

下面这张图位于第一、二象限内。我们关注红色的门，以及“北京四合院”这几个字下面的紫色的字母。我们把红色的门上的点看成是“+”数据，紫色字母上的点看成是“-”数据，它们的横、纵坐标是两个特征。显然，在这个二维空间内，“+”“-”两类数据不是线性可分的。

![](https://pic2.zhimg.com/80/19fa4052ea4f20651d25a1249f1e372d_hd.jpg#height=342&id=o3ucQ&originHeight=342&originWidth=720&originalType=binary&ratio=1&status=done&style=none&width=720)

我们现在考虑核函数![](./img/fa2a2773254252384680c103e0d16939.svg)，即“内积平方”。这里面![](./img/785423d15c2ac9f04dd0ff7dc47b7b1f.svg)是二维空间中的两个点。

这个核函数对应着二维到三维空间的映射，它的表达式是：![](./img/b4a820aa66a5c0efe3e3a12822956fcd.svg)，可以验证：

![](./img/99dac7c2442d9b3a2bd4215018d7f752.svg)<br />![](./img/049808be728067079d2f87a2178ce3e1.svg)

在P这个映射下，原来二维空间中的图在三维空间中的像是这个样子：![](https://pic2.zhimg.com/c5a7b1b83b844fc5fff033c9a0d5d601_b.jpg#height=304&id=a6Ej8&originHeight=304&originWidth=640&originalType=binary&ratio=1&status=done&style=none&width=640)

![](https://pic2.zhimg.com/80/c5a7b1b83b844fc5fff033c9a0d5d601_hd.jpg#height=342&id=enl0H&originHeight=342&originWidth=720&originalType=binary&ratio=1&status=done&style=none&width=720)

注意到绿色的平面可以完美地分割红色和紫色，也就是说，两类数据在三维空间中变成线性可分的了。

而三维中的这个判决边界，再映射回二维空间中是这样的：![](https://pic3.zhimg.com/8f4a0d456fd9daf934c373024bf15a32_b.jpg#height=329&id=H0tKC&originHeight=329&originWidth=720&originalType=binary&ratio=1&status=done&style=none&width=720)

这是一条双曲线，它不是线性的。核函数的作用就是隐含着一个从低维空间到高维空间的映射，而这个映射可以把低维空间中线性不可分的两类点变成线性可分的。它们映射到的高维空间的维数也比例子（三维）高得多，甚至是无穷维的。这样，就可以期待原来并不线性可分的两类点变成线性可分的了。

在机器学习中常用的核函数，一般有这么几类，也就是LibSVM中自带的这几类：

1. 线性：![](./img/6c06ec9acc9e9704dcd1ddfb4faf62c9.svg)
2. 多项式：![](./img/a644750d64c6df40bccab913d346b9cb.svg)
3. Radial basis function：![](./img/01ae917e2508e0b2378018b1effe277f.svg)
4. Sigmoid：![](./img/f81277dc0ad91d27292007e0a9c0cb03.svg)

上面的例子是2.多项式核函数中![](./img/28f4b274c320f4de672169b0ac5cd32d.svg)的情况。

核函数要满足的条件称为[Mercer's condition](https://link.zhihu.com/?target=http%3A//www.svms.org/mercer/)。在实用中，基本是试验各种核函数，并扫描其中的参数，选择效果最好的。所以说，至于什么样的核函数适用于什么样的问题还有待讨论。

<a name="xKWnp"></a>

## 多维缩放(MDS)

![MDS1.png](./img/1592362756406-5b0c6b16-c033-4002-b16e-02ba024f030b.png)

若要求原始空间中样本的距离在低维空间中得以保持，如上图所示，即得到多维缩放(Multiple Dimensional Scaling，MDS)。假定![](./img/6f8f57715090da2632453988d9a1501b.svg)个样本在原始空间的距离矩阵为![](./img/b731ebdba1e0b2735bf68e8bfc387eff.svg)，其第![](./img/865c0c0b4ab0e063e5caa3387c1a8741.svg)行![](./img/363b122c528f54df4a0446b6bab05515.svg)列的元素![](./img/faebf03087ca612fd134de6deb483e98.svg)为样本![](./img/1ba8aaab47179b3d3e24b0ccea9f4e30.svg)到![](./img/1f89889020cdc84d9e1c35237cb62f65.svg)的距离。我们的目标是获得样本在![](./img/131f04ef3dd102f4156afe21bc2f5028.svg)维空间的表示![](./img/b3e022de4b265ceef2c13092d5868c18.svg)，且任意两个样本在![](./img/131f04ef3dd102f4156afe21bc2f5028.svg)维空间中欧氏距离等于原始空间中的距离，即![](./img/67a0e8981b29cb2c9b948937cc836985.svg)

令![](./img/16a7e0573e79ca4090a489e438e86af8.svg)，其中![](./img/9d5ed678fe57bcca610140957afab571.svg)为降维后样本的内积矩阵，![](./img/f97ddc4c7c641c253263fec2ddad1d44.svg)，有

![](./img/16c117a217e3c1abaf7d98f8f69fcc7e.svg)

令降维后的样本![](./img/21c2e59531c8710156d34a3c30ac81d5.svg)被中心化，即![](./img/5b6cc1e4b123aa1276576abbb900d578.svg)。显然，矩阵![](./img/9d5ed678fe57bcca610140957afab571.svg)的行与列之和均为零，即![](./img/96bd7e46be9784a41fd96d922cd4a37f.svg)，易知

![](./img/8888eaf048f91b94090912ad3d110b45.svg)    ![](./img/70d75b8423e789dd402d60454ea8e847.svg)    ![](./img/5fd30c442c033329e9bb5d5377c411c4.svg)

其中![](./img/ce0507cd5229e888670e788802ce3e4a.svg)表示矩阵的迹(trace)，![](./img/8403e5bc82d6caf6806de454e7dd2fed.svg)，令

![](./img/c7f3024b05576d1f1c1b7d9fe13e6f2f.svg)    ![](./img/65eb4f9d13bfb65fe7d3b4b79fdbd2bd.svg)    ![](./img/12b031d497f10820da328b17d63eb663.svg)

由上面所有式子可得

![](./img/47e6e4010a4c5b21b491a4f1c765850e.svg)

由此即可通过降维前后保持不变的距离矩阵![](./img/f623e75af30e62bbd73d6df5b50bb7b5.svg)求取内积矩阵![](./img/9d5ed678fe57bcca610140957afab571.svg)

对矩阵![](./img/9d5ed678fe57bcca610140957afab571.svg)做特征值分解，![](./img/2febcbe9afa042f39d95845e03f0f535.svg)，其中![](./img/41dcb1780f7df7b453d2cced65ac106d.svg)为特征值构成的对角矩阵，![](./img/1a405bf3ed844e0e4f61f4f01e5fca0e.svg)，![](./img/5206560a306a2e085a437fd258eb57ce.svg)为特征向量矩阵。假定其中有![](./img/5c4a1215e6cb04217e1cc85c19b535dc.svg)个非零特征值，它们构成的对角矩阵![](./img/b98bc1777b8adf4468968e248a5d4595.svg)，令![](./img/b515ef3e4c30e9ed19c2a7a49085312e.svg)表示相应的特征向量矩阵，则![](./img/21c2e59531c8710156d34a3c30ac81d5.svg)可表达为

![](./img/d6979201edd52e7bb5696fb161b3509b.svg)

在现实应用中为了有效降维，往往仅需降维后的距离与原始空间中的距离尽可能接近，而不必严格相等。此时可取![](./img/43fa494b39c7bbfa93bf05b07fa40b0e.svg)个最大特征值构成的对角矩阵![](./img/433eb6f7ead4fcbc5b226200aee290d9.svg)，令![](./img/cb5f0eef0491e95b550b4aa05b4b3d5d.svg)表示相应特征向量矩阵，则![](./img/21c2e59531c8710156d34a3c30ac81d5.svg)可表达为

![](./img/4145b42e3c9bf88afcd55cdecff88aee.svg)

<a name="oD0JC"></a>
### 算法步骤

**输入：**距离矩阵![](./img/b731ebdba1e0b2735bf68e8bfc387eff.svg)，其元素![](./img/faebf03087ca612fd134de6deb483e98.svg)，为样本![](./img/1ba8aaab47179b3d3e24b0ccea9f4e30.svg)到![](./img/1f89889020cdc84d9e1c35237cb62f65.svg)的距离；低维空间维数![](./img/131f04ef3dd102f4156afe21bc2f5028.svg)<br />**过程：**

1. 根据上面公式计算![](./img/a0462ae54020c8db5c6e88e3787f699c.svg)，![](./img/dc4b917d153aa9516d6fd7160d5e1179.svg)，![](./img/221577687f8ebeb54855fb9751ba98cf.svg)
2. 计算内积矩阵![](./img/9d5ed678fe57bcca610140957afab571.svg)
3. 对矩阵![](./img/9d5ed678fe57bcca610140957afab571.svg)做特征分解
4. 取![](./img/49a2e92b97093480b3a4e07035a5f5e6.svg)为![](./img/131f04ef3dd102f4156afe21bc2f5028.svg)个最大特征所构成的对角矩阵，![](./img/cb5f0eef0491e95b550b4aa05b4b3d5d.svg)为相应的特征向量矩阵

**输出：**矩阵![](./img/dc874e31c0f4db961d6959a6717c40c5.svg)，每行是一个样本的低维坐标

<a name="uHLcH"></a>
## 等度量映射(ISOMAP)

等度量映射(Isometric Mapping，Isomap)的基本出发点，是认为低维流形嵌入到高维空间之后，直接在高维空间中计算直线距离具有误导性，因为高维空间中的直线距离在低维嵌入流形上是不可达的。我们利用流形在局部上与欧氏空间同胚这个性质，对每个点基于欧氏距离找出其近邻点，然后就能建立一个近邻连接图，图中近邻之间存在连接，而非近邻点之间不存在连接，于是，计算两点之间测地线距离的问题，就转变为计算近邻连接图上两点之间的最短路径问题。

在近邻连接图上计算两点间的最短路径，可采用著名Dijkstra算法或Floyd算法，在得到任意两点的距离之后，就可以通过MDS来获得样本点在低维空间中的坐标。

<a name="4YCgl"></a>
### 算法步骤

**输入：**样本集![](./img/e98a8286276dc0909a0bbd8751c634e4.svg)；近邻参数![](./img/8ce4b16b22b58894aa86c421e8759df3.svg)；低维空间维数![](./img/131f04ef3dd102f4156afe21bc2f5028.svg)<br />**过程：**

1. ![](./img/bb6e3d8e02c17f986f37ba12c926f886.svg)
   1. 确定![](./img/1ba8aaab47179b3d3e24b0ccea9f4e30.svg)的![](./img/8ce4b16b22b58894aa86c421e8759df3.svg)近邻
   2. ![](./img/1ba8aaab47179b3d3e24b0ccea9f4e30.svg)与![](./img/8ce4b16b22b58894aa86c421e8759df3.svg)近邻点之间的距离设置为欧氏距离，与其他店的距离设置为无穷大
2. ![](./img/5aa4e91425ac10529d7e90f6c4243f4f.svg)
3. 调用最短路径算法(eg.Dijkstra)计算任意两样本点之间距离![](./img/389235d73e52895e7a66f00b1825b96b.svg)
4. 将![](./img/389235d73e52895e7a66f00b1825b96b.svg)作为MDS算法的输入
5. 返回MDS算法的输出

**输出：**样本集![](./img/f623e75af30e62bbd73d6df5b50bb7b5.svg)在低维空间的投影![](./img/28696d4b144ce72bfe4dfd564cae4a44.svg)

<a name="W1rt7"></a>
## [局部线性嵌入(LLE)](https://www.cnblogs.com/pinard/p/6266408.html)

局部线性嵌入(Locally Linear Embedding，LLE)与Isomap试图保持近邻样本之间的距离不同，LLE试图保持邻域样本之间的线性关系。

![LLE.png](./img/1592364311258-d464d9be-657f-416e-a5cc-d3a09e5fa3d0.png)

即样本点![](./img/1ba8aaab47179b3d3e24b0ccea9f4e30.svg)的坐标能通过它的领域样本![](./img/1f89889020cdc84d9e1c35237cb62f65.svg)，![](./img/83b08453f4197d78025b7af0f4b71186.svg)，![](./img/d5f6e701f0601f0c83079c089133c207.svg)的坐标通过线性组合而重构出来，而这里的权值参数在低维和高维空间是一致的，即

![](./img/4174886b9229877a0a973ff755fa2d16.svg)

第一步，先为每个样本![](./img/1ba8aaab47179b3d3e24b0ccea9f4e30.svg)找到其近邻下标集合![](./img/52dbc3fd7d34cbe6ae695944dca0004d.svg)，然后计算出基于![](./img/52dbc3fd7d34cbe6ae695944dca0004d.svg)中的所有的样本点对![](./img/1ba8aaab47179b3d3e24b0ccea9f4e30.svg)进行线性重构系数![](./img/aa38f107289d4d73d516190581397349.svg)，也就是找出每一个样本和其领域内的样本之间的线性关系

![](./img/6bc84ec23c195b31547ce5d5a24967ed.svg)

其中![](./img/1ba8aaab47179b3d3e24b0ccea9f4e30.svg)和![](./img/1f89889020cdc84d9e1c35237cb62f65.svg)均为已知，令![](./img/e8e4f4d5430916275434349b33ea0fff.svg)，![](./img/322b227441558f0ed48aba836d0caf6f.svg)有闭式解

![](./img/52470f0b3821249273f27571d5a74d4a.svg)

第二步，在低维空间领域重构系数![](./img/aa38f107289d4d73d516190581397349.svg)不变，去求每个样本在低维空间的坐标

![](./img/ded9b36fd5df9974c1ddcd31b91f8ccf.svg)令![](./img/b290adc6812f31cc6a27fa700560f4f8.svg)

利用M矩阵，可以将问题写成

![](./img/b89242a3f20d1b17cada7ccca2686851.svg)

问题就成了对![](./img/69691c7bdcc3ce6d5d8a1361f22d04ac.svg)矩阵进行特征分解，然后取最小的![](./img/131f04ef3dd102f4156afe21bc2f5028.svg)个特征值对应的特征向量组成低维空间的坐标![](./img/21c2e59531c8710156d34a3c30ac81d5.svg)

![LLE2.png](./img/1592364393246-c916e1d8-cd21-44b2-8958-d68f39b5e370.png)![LLE3.jpeg](./img/1592364411423-fca5604e-44c1-4ef0-ad09-c154f5e657e6.jpeg)


<a name="tfxLe"></a>
## [t-分布随机近邻嵌入(t-SNE)](http://www.datakit.cn/blog/2017/02/05/t_sne_full.html)

t-SNE(t-distributed stochastic neighbor embedding)是一种非线性降维算法，非常适用于高维数据降维到2维或者3维，进行可视化。我们看到t-SNE模型是非监督的降维，他跟kmeans等不同，他不能通过训练得到一些东西之后再用于其它数据(比如kmeans可以通过训练得到k个点，再用于其它数据集，而t-SNE只能单独的对数据做操作，也就是说他只有fit_transform，而没有fit操作)。t-SNE是由SNE(Stochastic Neighbor Embedding，SNE)发展而来。我们先介绍SNE的基本原理，之后再扩展到t-SNE。

<a name="yazia"></a>
### SNE(Stochastic Neighbor Embedding)

SNE是通过仿射(affinitie)变换将数据点映射到概率分布上，主要包括两个步骤：

1. SNE构建高维对象之间的概率分布，使得相似对象有更高的概率被选择，而不相似对象有较低的概率被选择
2. SNE在低维空间里在构建这些点的概率分布，使得这两个概率分布之间尽可能的相似

SNE先将欧氏距离转换为条件概率来表达点与点之间的相似度。具体来说，给定![](./img/8d9c307cb7f3c4a32822a51922d1ceaa.svg)个高维数据![](./img/d455996cd67938636fb72ad1e9c4cf85.svg)，先计算概率![](./img/8df1758f4aff31cf9827dacce0c0819a.svg)，正比于![](./img/1ba8aaab47179b3d3e24b0ccea9f4e30.svg)和![](./img/1f89889020cdc84d9e1c35237cb62f65.svg)之间的相似度(这种概率是我们自己构建的)，即

![](./img/3722a445e7cff7f3228cffbe23054e10.svg)

![](./img/65445646e7a531a2185d03b58b4d60e1.svg)依据不同的![](./img/1ba8aaab47179b3d3e24b0ccea9f4e30.svg)取值不同，此外因为我们关注的是两两之间的相似度，所以设置![](./img/506e32780c3a7a7ede2dd2cb1cdd93a7.svg)。对于低维度下的![](./img/8d62e469fb30ed435a668eb5c035b1f6.svg)，我们可以指定高斯分布的方差为![](./img/534794e9a27ee3cc674ca6a962dc60a2.svg)，因此它们之间的相似度如下

![](./img/9415e2f04f0a5565ecdf3ccab6200961.svg)，同样设定![](./img/817c2e07e21b1467829d919a9dd2ad48.svg)

如果姜维的效果比较好，局部特征保留完整，那么![](./img/dd19a7f18209d89e0a6f085d6cd6ee9b.svg)，因此我们优化两个分布之间的距离KL散度，那么目标函数如下

![](./img/b57c70bd6bbf61c932a31398facb7e98.svg)

这里的![](./img/08b0104e514f16d489cc743b6f66d906.svg)表示了给定![](./img/1ba8aaab47179b3d3e24b0ccea9f4e30.svg)下，其他所有数据点的条件概率分布。需要注意的是KL散度具有不对称性，在低维映射中不同距离对应的惩罚权重是不同的，具体来说：距离较远的两个点来表达距离较近的两个点会产生更大的cost，相反，用较近的两个点来表达较远的两个点产生的cost相对较小，即用较小的![](./img/b67bfd2a363dfbc83d75eae5067b3b39.svg)来建模较大的![](./img/cc2b443f8c4e37bbf090cb0715634e7f.svg)，cost为![](./img/be389387d4a12e4ff01e9b937084dc8f.svg)，同样用较大的![](./img/f147326075bcf6523d7d75dc03d82513.svg)来建模较大的![](./img/ab24e101287b03750e3512c2339407ab.svg)，cost为![](./img/10099c0e162fc01e868b0f68724d3411.svg)，因此，SNE会倾向于保留数据中的局部特征。

首先，不同的点具有不同的![](./img/65445646e7a531a2185d03b58b4d60e1.svg)，![](./img/08b0104e514f16d489cc743b6f66d906.svg)的熵会随着![](./img/65445646e7a531a2185d03b58b4d60e1.svg)的增加而增加。SNE使用[困惑度](https://baike.baidu.com/item/%E5%9B%B0%E6%83%91%E5%BA%A6/22742666?fr=aladdin)的概念，用二分搜索的方式来寻找一个最佳的![](./img/a2ab7d71a0f07f388ff823293c147d21.svg)。

困惑度：![](./img/7439d9614cc17e0bc974736f042da60e.svg)，熵：![](./img/18bc8521a2275138abeb83adab24e478.svg)

困惑度可以解释为一个点附近的有效近邻点个数。SNE对困惑度的调整比较有鲁棒性，通常选在5至50之间，给定之后，使用二分搜索的方式寻找合适的![](./img/a2ab7d71a0f07f388ff823293c147d21.svg)

那么核心问题就是如何求解梯度了，目标函数等价于![](./img/c3eee5bdb34d29b739c5b7adce66e575.svg)这个式子与softmax非常相似，我们知道softmax的目标函数是![](./img/e8e3d54015ad1bb736e82c2f614b82e0.svg)，对应的梯度是![](./img/89641cd5e7607aa3abe7b55ac0f41937.svg)(注：这里的softmax中y表示label，p表示预估值)。同样我们可以推导SNE的目标函数中的![](./img/865c0c0b4ab0e063e5caa3387c1a8741.svg)在![](./img/363b122c528f54df4a0446b6bab05515.svg)下的条件概率情况的梯度是![](./img/f3660857abc993613a2b871ead72e560.svg)，同样j在i下的条件概率的梯度是![](./img/b1e5e3496fa29e0c8393c58ff09ab220.svg)，最后得到完整的梯度公式如下：

![](./img/73ac6ffac12557d18c192d673dcd81c2.svg)

在初始化中，可以用较小的![](./img/a2ab7d71a0f07f388ff823293c147d21.svg)下的高斯分布来进行初始化。为了加速优化过程和避免陷入局部最优解，梯度中需要使用一个相对较大的动量。即参数更新中除了当前梯度，还要引入之前的梯度累加的指数衰退项，如下：

![](./img/7cebe4cd68e92a071c7b3d67e62e6e8b.svg)

这里的![](./img/626343cb96bdf9ee8429b7d5d8f4607a.svg)表示迭代![](./img/e358efa489f58062f10dd7316b65649e.svg)次的解，![](./img/ffe9f913124f345732e9f00fa258552e.svg)表示学习速率，![](./img/e18e4c578456836988c3a85f3578708f.svg)表示迭代![](./img/e358efa489f58062f10dd7316b65649e.svg)次的动量。

此外，在初始优化的阶段，每次迭代中可以引入一些高斯噪声，之后像模拟退火一样逐渐减小该噪声，可以用来避免陷入局部最优解。因此，SNE在选择高斯噪声，以及学习速率，什么时候开始衰减，动量选择等等超参数上，需要跑多次优化才可以。

<a name="hT8ni"></a>
### t-SNE

尽管SNE提供了很好的可视化方法，但是他很难优化，而且存在”crowding problem”(拥挤问题)，t-SNE在低维空间下使用更重长尾分布的t分布来避免crowding问题和优化问题。t-SNE与SNE不同主要如下：

1. 使用对称版的SNE，简化梯度公式
2. 低维空间下，使用![](./img/e358efa489f58062f10dd7316b65649e.svg)分布代替高斯分布表达两点之间的相似度

对称版SNE使用联合概率分布来替换条件概率分布，即![](./img/44c29edb103a2872f519ad0c9a0fdaaa.svg)是高维空间里各个点的联合概率分布，![](./img/f09564c9ca56850d4cd6b3319e541aee.svg)是低维空间下的，目标函数为：

![](./img/a1bab06a820aeaafed5082dafd8856b2.svg)

这里的![](./img/6b0c63cb607bac1b732231ab2ebe8c06.svg)和![](./img/d6e9916e4d2ea2e8cf948f1a23dddea6.svg)我们依旧设置为0，我们将这种SNE称之为对称SNE，因为假设了对于任意![](./img/865c0c0b4ab0e063e5caa3387c1a8741.svg)，![](./img/b94d9671c30a42784509e4ce24756457.svg)，![](./img/247df2b15d87b29123dd61b332a3a55d.svg)，因此概率分布可以改写为：

![](./img/50539f54cc1eda3c039e4b29bf792b76.svg)    ![](./img/56a5d2ab14cba514f414197260637887.svg)

这种表达方式使得整体简洁了很多，但是会有引入异常值的问题。比如![](./img/1ba8aaab47179b3d3e24b0ccea9f4e30.svg)是异常值，那么![](./img/0ba2929694af3a884e1bdfb1151b3291.svg)很会大，对应的所有的![](./img/1f89889020cdc84d9e1c35237cb62f65.svg)，![](./img/8df1758f4aff31cf9827dacce0c0819a.svg)都会很小，导致低维映射下的![](./img/8d62e469fb30ed435a668eb5c035b1f6.svg)对cost影响很小。为了解决这个问题，我们将联合分布修正为：![](./img/8cf0f926f37cd2aa9964a7ca7cdf6097.svg)，这保证了![](./img/0cabbd13321c5f768aaf912eb603225b.svg)，使得每个点对于cost都会有一定的贡献。对称SNE的最大优点是梯度计算变得简单，如下：

![](./img/c7487b3d937e3cace6515e07b3e0749d.svg)

拥挤问题就是说各个簇聚集在一起，无法区分。比如有一种情况，高维度数据在降维到10维下，可以有很好的表达，但是降维到两维后无法得到可信映射，比如降维如10维中有11个点之间两两等距离的，在二维下就无法得到可信的映射结果(最多3个点)。进一步的说明，假设一个以数据点![](./img/1ba8aaab47179b3d3e24b0ccea9f4e30.svg)为中心，半径为![](./img/4b43b0aee35624cd95b910189b3dc231.svg)的![](./img/6f8f57715090da2632453988d9a1501b.svg)维球(三维空间就是球)，其体积是按![](./img/e0c57d901ddcc72b08b05c24cc744a97.svg)增长的，假设数据点是在![](./img/6f8f57715090da2632453988d9a1501b.svg)维球中均匀分布的，我们来看看其他数据点与![](./img/1ba8aaab47179b3d3e24b0ccea9f4e30.svg)的距离随维度增大而产生的变化。

![sne_crowding.png](./img/1592366273468-efd3c4f0-8ac4-4bd6-aefb-ae6de91d71db.png)

从上图可以看到，随着维度的增大，大部分数据点都聚集在![](./img/6f8f57715090da2632453988d9a1501b.svg)维球的表面附近，与点![](./img/1ba8aaab47179b3d3e24b0ccea9f4e30.svg)的距离分布极不均衡。如果直接将这种距离关系保留到低维，就会出现拥挤问题。为了解决拥挤问题， Cook et al.(2007) 提出一种slight repulsion的方式，在基线概率分布(uniform background)中引入一个较小的混合因子![](./img/d2606be4e0cd2c9a6179c8f2e3547a85.svg)，这样![](./img/3ddcdf404af466223de21c043ceb7fab.svg)就永远不会小于![](./img/7fb1a305f1f1ec46849bc3196ef1671a.svg)(因为一共了![](./img/1e329fd14bfc1dbca6de9d44ef95c8fe.svg)个pairs)，这样在高维空间中比较远的两个点之间的![](./img/3ddcdf404af466223de21c043ceb7fab.svg)总是会比![](./img/8df1758f4aff31cf9827dacce0c0819a.svg)大一点。这种称之为UNI-SNE，效果通常比标准的SNE要好。优化UNI-SNE的方法是先让![](./img/d2606be4e0cd2c9a6179c8f2e3547a85.svg)为0，使用标准的SNE优化，之后用模拟退火的方法的时候，再慢慢增加![](./img/d2606be4e0cd2c9a6179c8f2e3547a85.svg)。直接优化UNI-SNE是不行的(即一开始![](./img/d2606be4e0cd2c9a6179c8f2e3547a85.svg)不为0)，因为距离较远的两个点基本是一样的![](./img/3ddcdf404af466223de21c043ceb7fab.svg)(等于基线分布)，即使![](./img/8df1758f4aff31cf9827dacce0c0819a.svg)很大，一些距离变化很难在![](./img/3ddcdf404af466223de21c043ceb7fab.svg)中产生作用。也就是说优化中刚开始距离较远的两个聚类点，后续就无法再把他们拉近了。

对称SNE实际上在高维度下另外一种减轻”拥挤问题”的方法：在高维空间下，在高维空间下我们使用高斯分布将距离转换为概率分布，在低维空间下，我们使用更加偏重长尾分布的方式来将距离转换为概率分布，使得高维度下中低等的距离在映射后能够有一个较大的距离。

![norm_t_dict.png](./img/1592366304893-1ec9fd5f-0cb3-415b-b7ea-4aed4cbfb283.png)

我们对比一下高斯分布和t分布(如上图)，t分布受异常值影响更小，拟合结果更为合理，较好的捕获了数据的整体特征。使用了t分布之后的q变化，如下：

![](./img/93b90c0f2ae1e304535606cbce4bcfa4.svg)

此外，t分布是无限多个高斯分布的叠加，计算上不是指数的，会方便很多。优化的梯度如下：

![](./img/9c8de6575c549cd27bd2030379451c54.svg)<br />![sne_norm_t_dist_cost.png](./img/1592366322947-b05c19c6-e7aa-465e-acdb-5020ee078550.png)

t-sne的有效性，也可以从上图中看到：横轴表示距离，纵轴表示相似度，可以看到，对于较大相似度的点，t分布在低维空间中的距离需要稍小一点；而对于低相似度的点，t分布在低维空间中的距离需要更远。这恰好满足了我们的需求，即同一簇内的点(距离较近)聚合的更紧密，不同簇之间的点(距离较远)更加疏远。总结一下，t-SNE的梯度更新有两大优势：

1. 1、对于不相似的点，用一个较小的距离会产生较大的梯度来让这些点排斥开来。
2. 2、这种排斥又不会无限大(梯度中分母)，避免不相似的点距离太远。

<a name="2pjlq"></a>
### 算法过程

![t-SNE算法.png](./img/1592366366057-62eb057b-061f-41c8-a78e-e62cf98486c8.png)

优化过程如下

![t-sne_optimise.gif](./img/1592366343825-7d4523e9-b8ac-41f0-b0ad-0f598f6c9d2f.gif)

主要不足：

主要用于可视化，很难用于其他目的。比如测试集合降维，因为他没有显式的预估部分，不能在测试集合直接降维；比如降维到10维，因为t分布偏重长尾，1个自由度的t分布很难保存好局部特征，可能需要设置成更高的自由度。

t-SNE倾向于保存局部特征，对于本征维数(intrinsic dimensionality)本身就很高的数据集，是不可能完整的映射到2-3维的空间。

t-SNE没有唯一最优解，且没有预估部分。如果想要做预估，可以考虑降维之后，再构建一个回归方程之类的模型去做。但是要注意，t-sne中距离本身是没有意义，都是概率分布问题。

训练太慢。有很多基于树的算法在t-sne上做一些改进


# Source

[https://github.com/chmx0929/UIUCclasses/tree/master/598MachLrngforSignalProcessng/Slide](https://github.com/chmx0929/UIUCclasses/tree/master/598MachLrngforSignalProcessng/Slide)<br />[https://zhuanlan.zhihu.com/p/43225794](https://zhuanlan.zhihu.com/p/43225794)
