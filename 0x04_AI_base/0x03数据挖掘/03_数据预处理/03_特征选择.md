我们能用很多属性描述一个西瓜，例如色泽、根蒂、敲声、纹理等，但有经验的恶人往往只看根蒂、听听敲声就知道是否好瓜。换言之，对一个学习任务来说，给定属性集，其中有些属性可能很关键、很有用，另一些属性则可能没什么用。我们将属性称为“特征”，对当前学习任务有用的属性称为“相关特征”、没什么用的属性称为“无关特征”。从给定的特征集合中选择出相关特征子集的过程，称为“特征选择”。

进行“特征选择”有两个重要原因：

1. 我们在现实任务中经常会遇到维数灾难问题，这是由于属性过多而造成的，若能从中选择出重要的特征，使得后续学习过程仅需一部分特征上构建模型，则维数灾难问题会大为减轻。
2. 去除不相关特征往往会降低学习任务的难度，这就像侦探破案一样，若将纷繁复杂的因素抽丝剥茧，只留下关键因素，则真相往往更易看清。


## 子集搜索与评价

特征选择过程必须确保不丢失重要特征，否则后续学习过程会因为重要信息的缺失而无法获得好的性能。欲从初始的特征集合中选取一个包含了所有重要信息的特征子集，若没有任何领域知识作为先验假设，那就只好遍历所有可能的子集了；然而这在计算上却是不可行的，因为这样会遭遇组合爆炸，特征个数稍微多就无法进行了。可行的做法是产生一个“候选子集”，评价出它的好坏，基于评价结果产生下一个候选子集，再对其进行评价。这个过程持续下去，直至无法找到更好的候选子集为止。这里涉及两个关键环节：

1. 如何根据评价结果获取下一个候选特征子集
2. 如何评价候选子集的好坏


### 子集搜索

给定特征集合![](./img/2edf611c047c473bb8957d9d49c24798.svg)，我们可将每个特征看作一个候选子集，对这![](./img/8277e0910d750195b448797616e091ad.svg)个候选单特正子集进行评价，假定![](./img/393c751474c52ddfccdc3ac13e522671.svg)最优，于是将![](./img/393c751474c52ddfccdc3ac13e522671.svg)作为第一轮的候选集；然后，在上一轮的选定集中加入一个特征，构成包含两个特征的候选子集，假定在这![](./img/1987a88fc39f6b7f2fdf571395212e68.svg)个候选两特征子集中![](./img/571dcf11befc95e4d1bf190d9e0e7270.svg)最优，且优于![](./img/393c751474c52ddfccdc3ac13e522671.svg)，于是将![](./img/571dcf11befc95e4d1bf190d9e0e7270.svg)作为本轮的选定集；……假定第![](./img/a31a860e7a59c7616c1515ec3ae652a6.svg)轮时，最优的候选![](./img/6f3ec104936b341125c802538d2ed552.svg)特征子集不如上一轮的选定集，则停止生成候选子集，并将上一轮选定的![](./img/8ce4b16b22b58894aa86c421e8759df3.svg)特征集合作为特征选择结果。这样逐渐增加相关特征的策略称为“前向”搜索。类似的，若我们从完整的特征集开始，每次尝试去掉一个无关特征，这样逐渐减少特征的策略称为“后向”搜索。还可将前向与后向搜索结合起来，每一轮逐渐增加选定的相关特征（这些特征在后续轮中将确定不会被去除)、同时减少无关特征，这样的策略称为“双向”搜索

### 子集评价

给定数据集![](./img/f623e75af30e62bbd73d6df5b50bb7b5.svg)，假定![](./img/f623e75af30e62bbd73d6df5b50bb7b5.svg)中第![](./img/865c0c0b4ab0e063e5caa3387c1a8741.svg)类样本所占的比例为![](./img/a4a4c6ccda3c439f82e84b15ff1519bc.svg)。假定样本属性均为离散型。对属性子集![](./img/7fc56270e7a70fa81a5935b72eacbe29.svg)，假定根据其取值将![](./img/f623e75af30e62bbd73d6df5b50bb7b5.svg)分成![](./img/5206560a306a2e085a437fd258eb57ce.svg)个子集![](./img/9486add6605b6932021ff6c3b454f789.svg)，每个子集中的样本在![](./img/7fc56270e7a70fa81a5935b72eacbe29.svg)上取值相同，于是我们可计算属性子集![](./img/7fc56270e7a70fa81a5935b72eacbe29.svg)的信息增益

![](./img/4a0fdfa072649be1aa677c6560ec6c1c.svg)

其中信息熵定义为

![](./img/d67df299fb5b15f737b6248f7a4087af.svg)

信息增益![](./img/189021af168dd71824303598c49fae0e.svg)越大，意味着特征子集![](./img/7fc56270e7a70fa81a5935b72eacbe29.svg)包含的有助于分类的信息越多。于是，对每个候选特征子集，我们可基于训练数据集![](./img/f623e75af30e62bbd73d6df5b50bb7b5.svg)来计算其信息增益，以此作为评价准则。

将特征子集搜索机制与子集评价机制相结合，即可得到特征选择方法。例如将前向搜索与信息熵相结合，这显然与决策树算法非常相似。事实上，决策树可用于特征选择，树结点的划分属性所组成的集合就是选择出的特征子集。其他的特征选择方法未必像决策树特征选择这么明显，但它们在本质上都是显式或隐式地结合了某种（或多种）子集搜索机制和子集评价机制。

常见的特征选择方法大致可分为三类：过滤式(Filter)、包裹式(Wrapper)和嵌入式(Embedding)


## 过滤式选择

过滤式方法先对数据集进行特征选择，然后再训练学习器，特征选择过程与后续学习器无关。这相当于先用特征选择过程对初始特征进行“过滤”，再用过滤后的特征来训练模型。

Relief(Relevant Features)是一种著名的过滤式特征选择方法，该方法设计了一个“相关统计量”来度量特征的重要性。该统计量是一个向量，其每个分量分别对应一个初始特征，而特征子集的重要性则由子集中每个特征所对应的相关统计量分量之和来确定。于是，最终只需指定一个阈值![](./img/a6f317b268ae825d94f832f970af607c.svg)，然后选择比![](./img/a6f317b268ae825d94f832f970af607c.svg)大的相关统计量分量所对应的特征即可；也可指定欲选取的特征个数![](./img/8ce4b16b22b58894aa86c421e8759df3.svg)，然后选择相关统计量分量最大的![](./img/8ce4b16b22b58894aa86c421e8759df3.svg)个特征。

显然，Relief的关键是如何确定相关统计量。给定训练集![](./img/7a3aa2a0c5e443befe7a92dbcaa77952.svg)，对每个示例![](./img/1ba8aaab47179b3d3e24b0ccea9f4e30.svg)，Relief先在![](./img/1ba8aaab47179b3d3e24b0ccea9f4e30.svg)的同类样本中寻找其最近邻![](./img/9cf329f688eb343ca8a9e1a2d6926fad.svg)，称为“猜中近邻”，再从![](./img/1ba8aaab47179b3d3e24b0ccea9f4e30.svg)的异类样本中寻找其最近邻![](./img/4c28bfb6702a4590f6d0e45adf48d429.svg)称为“猜错近邻”，然后，相关统计量对应属性![](./img/363b122c528f54df4a0446b6bab05515.svg)的分量为

![](./img/6fa1ef7d71013d7c095670c9f5750fcd.svg)

其中![](./img/fa9db3e96c27904758c8596d45b85733.svg)表示样本![](./img/901c520f5edf0f008e70afc192a856ef.svg)在属性![](./img/363b122c528f54df4a0446b6bab05515.svg)上的取值，![](./img/aef9ce166342de54ec5070b0e48bd354.svg)取决于属性![](./img/363b122c528f54df4a0446b6bab05515.svg)的类型：若属性![](./img/363b122c528f54df4a0446b6bab05515.svg)为离散型，则![](./img/d3a0562b435b4217e83229f74ad76953.svg)时![](./img/a98e603ead0d88ac2e93569b52ef2529.svg)，否则为![](./img/c4ca4238a0b923820dcc509a6f75849b.svg)；若属性![](./img/363b122c528f54df4a0446b6bab05515.svg)为连续型，则![](./img/5feef2937e290c5b43c2d060ee5393aa.svg)，注意![](./img/84c940423c532ff6fecb219ee809da8a.svg)已规范化到![](./img/ccfcd347d0bf65dc77afe01a3306a96b.svg)区间

从![](./img/6fa1ef7d71013d7c095670c9f5750fcd.svg)可以看出，若![](./img/1ba8aaab47179b3d3e24b0ccea9f4e30.svg)与其猜中近邻![](./img/9cf329f688eb343ca8a9e1a2d6926fad.svg)在属性![](./img/363b122c528f54df4a0446b6bab05515.svg)上的距离小于![](./img/1ba8aaab47179b3d3e24b0ccea9f4e30.svg)与其猜错近邻![](./img/4c28bfb6702a4590f6d0e45adf48d429.svg)的距离，则说明属性![](./img/363b122c528f54df4a0446b6bab05515.svg)对区分同类与异类样本是有益的，于是增大属性![](./img/363b122c528f54df4a0446b6bab05515.svg)所对应的统计分量；反之，则减小所对应的统计分量。最后，对基于不同样本得到的估计结果进行平均，就得到各属性的相关统计量分量，分量值越大，则对应属性的分类能力就越强。

Relief是为二分类问题设计的，其扩展变体Relief-F为处理多分类问题，相关统计量对应于属性![](./img/363b122c528f54df4a0446b6bab05515.svg)的分量

![](./img/cca546d615caad7116dea47c88d5f1cf.svg)

其中![](./img/48ae2150ca2fce13199ae2a21e44764e.svg)为第![](./img/2db95e8e1a9267b7a1188556b2013b33.svg)类样本在数据集![](./img/f623e75af30e62bbd73d6df5b50bb7b5.svg)中所占的比例。

<a name="cff3f9ac"></a>
## 包裹式选择

与过滤式特征选择不考虑后续学习器不同，包裹式特征选择直接把最终将要适用的学习器的性能作为特征子集的评价标准。换言之，包裹式特征选择的目的就是为给定学习器学者最有利于性能、“量身定做”的特征子集。

LVW(Las Vegas Wrapper)是一个典型的包裹式特征选择方法。它在[拉斯维加斯方法(Las Vegas method)](https://www.zhihu.com/question/20254139/answer/33572009)框架下使用随机策略来进行子集搜索，并以最终分类器的误差为特征子集评价准则。算法描述：

输入：数据集![](./img/f623e75af30e62bbd73d6df5b50bb7b5.svg)，特征集![](./img/7fc56270e7a70fa81a5935b72eacbe29.svg)，学习算法![](./img/8fa14cdd754f91cc6554c9e71929cce7.svg)，停止条件控制参数![](./img/b9ece18c950afbfa6b0fdbfa4ff731d3.svg)

过程：

1. 初始化：![](./img/1c64c5767c10803d1e92833608c42b89.svg)，![](./img/432bf21acabd2ed3afd0aa3e394e3fe6.svg)，![](./img/d81f2c8decebcbc8c03cb6b47dd7a284.svg)，![](./img/1f48e973d6a9075dbaaf41a9e85f034e.svg)
2. while ![](./img/691d13d3ca2872b923e11f2e4d341925.svg)：
   1. 随机生成特征子集![](./img/37a12b78a9ca96989ad7ceceacb37ea2.svg)，![](./img/6d321a9a33339a47a190c7964819cf69.svg)
   2. ![](./img/f70c5b51d541c79aed8cf6dc03125961.svg)
   3. if ![](./img/e7f4d79e0f0907dc4c4a84c3b219d1a5.svg)：
      1. ![](./img/b1927aa9035b574e5e0679a246e71a86.svg)
   4. else：
      1. ![](./img/9e3e7414c34cdac0b55cc937479e58a4.svg)

通过在数据集![](./img/f623e75af30e62bbd73d6df5b50bb7b5.svg)上使用交叉验证来估计学习器的误差，注意这个误差是在仅考虑特征子集![](./img/37a12b78a9ca96989ad7ceceacb37ea2.svg)时得到的，即特征子集![](./img/37a12b78a9ca96989ad7ceceacb37ea2.svg)上的误差。然后if判断若它比当前特征子集![](./img/7fc56270e7a70fa81a5935b72eacbe29.svg)上的误差更小，或者误差相当但![](./img/37a12b78a9ca96989ad7ceceacb37ea2.svg)中包含的特征数更少，则将![](./img/37a12b78a9ca96989ad7ceceacb37ea2.svg)保留下来。

<a name="b95d8e0c"></a>
## 嵌入式选择与正则化

在过滤式和包裹式特征选择方法中，特征选择过程与学习器训练过程有明显的分别；与此不同，嵌入式特征选择是将特征选择过程与学习器过程融为一体，两者在同一个优化过程中完成，即在学习器训练过程中自动地进行了特征选择。

给定数据集![](./img/d18838f9596a6b5b4916bb2875686b48.svg)我们考虑最简单的线性回归模型，以平方误差为损失函数，则优化目标为

![](./img/c5199ee1489b7e4995d97988c1f94e78.svg)

当样本特征很多，而样本数相对较少时，上式很容易过拟合，为了缓解过拟合问题，可引入正则化项。若使用![](./img/07cbd6c155424e110559a84df364be5a.svg)范数正则化，则有

![](./img/64ec59d12a069690b1935de3216b7011.svg)

其中正则化参数![](./img/ca5d039bfe11aa061287e5de5ea6fc3e.svg)。上式“岭回归”(ridge regression)，通过![](./img/07cbd6c155424e110559a84df364be5a.svg)范数正则化，确能显著降低过拟合的风险。

当然也可以将正则化项中的![](./img/07cbd6c155424e110559a84df364be5a.svg)范数替换为![](./img/e31aeb46004f6cfc700ce85946e26967.svg)范数，若令![](./img/5ae4cb0503e9561f1d0de4a67b65f656.svg)，即采用![](./img/2c6f3b6c16df97a1b00e04ff17e4906e.svg)范数，则有

![](./img/c23efaf6f64d41babc44b1ae14f2560e.svg)

其中正则化参数![](./img/ca5d039bfe11aa061287e5de5ea6fc3e.svg)。上式称为LASSO(Least Absolute Shrinkage and Selection Operator)。

![](./img/2c6f3b6c16df97a1b00e04ff17e4906e.svg)范数和![](./img/07cbd6c155424e110559a84df364be5a.svg)范数正则化都有助于降低过拟合风险，但前者还会带来一个额外的好处：![](./img/2c6f3b6c16df97a1b00e04ff17e4906e.svg)比![](./img/07cbd6c155424e110559a84df364be5a.svg)更易获得“稀疏”解，即它求得的![](./img/f1290186a5d0b1ceab27f4e77c0c5d68.svg)会有更少的非零分量。比如如下例子：假定![](./img/9dd4e461268c8034f5c8564e155c67a6.svg)仅有两个属性，于是无论岭回归还是LASSO解出的![](./img/f1290186a5d0b1ceab27f4e77c0c5d68.svg)都只有两个分量，即![](./img/8a05791ab51622f4ad5ab310bcdfc16c.svg)，我们将其作为两个坐标轴，然后在图中绘制出第一项的“等值线”，即在![](./img/6672243c435114163b0aacdfd6903cb1.svg)空间中平方误差取值相同的点的连线，再分别绘制出![](./img/2c6f3b6c16df97a1b00e04ff17e4906e.svg)范数与![](./img/07cbd6c155424e110559a84df364be5a.svg)范数的等值线，即在![](./img/6672243c435114163b0aacdfd6903cb1.svg)空间中![](./img/2c6f3b6c16df97a1b00e04ff17e4906e.svg)范数取值相同的点的连线，以及![](./img/07cbd6c155424e110559a84df364be5a.svg)范数取值相同的点的连线。

![正则化.png](./img/1592378210658-fa084a9c-1989-4a61-971e-537ba708a532.png)

岭回归和LASSO的解要在平方误差项与正则化项之间折中，即出现在图中平方误差项等值线与正则化等值线相交处。由上图可看出，采用![](./img/2c6f3b6c16df97a1b00e04ff17e4906e.svg)范数时平方误差项等值线与正则化项等值线的焦点经常出现在坐标轴上，即![](./img/db007d6a923c2909d42c4292bffca5f0.svg)或![](./img/c172e309535f6ff639b845bddf5e5319.svg)为![](./img/cfcd208495d565ef66e7dff9f98764da.svg)，而采用![](./img/07cbd6c155424e110559a84df364be5a.svg)范数时，两者的交点常出现在某个象限中，即![](./img/db007d6a923c2909d42c4292bffca5f0.svg)和![](./img/c172e309535f6ff639b845bddf5e5319.svg)为![](./img/cfcd208495d565ef66e7dff9f98764da.svg)；换言之，采用![](./img/2c6f3b6c16df97a1b00e04ff17e4906e.svg)范数比![](./img/07cbd6c155424e110559a84df364be5a.svg)范数更易于得到稀疏解。


## Source

[https://www.zhihu.com/question/20254139/answer/33572009](https://www.zhihu.com/question/20254139/answer/33572009)
