机器学习<br />在机器学习领域，有种说法叫做“世上没有免费的午餐”，简而言之，它是指没有任何一种算法能在每个问题上都能有最好的效果，这个理论在监督学习方面体现得尤为重要。<br />举个例子来说，不能说神经网络永远比决策树好，反之亦然。模型运行被许多因素左右，例如数据集的大小和结构。<br />因此，应该根据问题尝试许多不同的算法，同时使用数据测试集来评估性能并选出最优项。<br />当然，尝试的算法必须和问题相切合，其中的门道便是机器学习的主要任务。打个比方，如果想打扫房子，可能会用到吸尘器、扫帚或者拖把，但肯定不会拿把铲子开始挖坑吧。<br />对于渴望了解机器学习基础知识的机器学习新人来说，这儿有份数据科学家使用的十大机器学习算法，介绍这十大算法的特性，便于大家更好地理解和应用，快来看看吧。
<a name="syFQz"></a>
## 1、线性回归
线性回归可能是统计学和机器学习中最知名和最易理解的算法之一。<br />由于预测建模主要关注最小化模型的误差，或者以可解释性为代价来做出最准确的预测。会从许多不同领域借用、重用和盗用算法，其中涉及一些统计学知识。<br />线性回归用一个等式表示，通过找到输入变量的特定权重（B），来描述输入变量（x）与输出变量（y）之间的线性关系。<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1672100376895-1f34f05e-63e7-4f1d-9d4c-3e72e86dbff3.png#averageHue=%23faf9f9&clientId=udcad5855-1461-4&from=paste&id=u0f031f85&originHeight=431&originWidth=821&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u79053edd-8d5e-4fcc-8bd0-13a242eafae&title=)<br />**举例：y = B0 + B1 * x**<br />给定输入x，将预测y，线性回归学习算法的目标是找到系数B0和B1的值。<br />可以使用不同的技术从数据中学习线性回归模型，例如用于普通最小二乘和梯度下降优化的线性代数解。<br />线性回归已经存在了200多年，并且已经进行了广泛的研究。如果可能的话，使用这种技术时的一些经验法则是去除非常相似（相关）的变量并从数据中移除噪声。这是一种快速简单的技术和良好的第一种算法。
<a name="EJ12Q"></a>
## 2、逻辑回归
逻辑回归是机器学习从统计领域借鉴的另一种技术。这是二分类问题的专用方法（两个类值的问题）。<br />逻辑回归与线性回归类似，这是因为两者的目标都是找出每个输入变量的权重值。与线性回归不同的是，输出的预测值得使用称为逻辑函数的非线性函数进行变换。<br />逻辑函数看起来像一个大S，并能将任何值转换为0到1的范围内。这很有用，因为可以将相应规则应用于逻辑函数的输出上，把值分类为0和1（例如，如果IF小于0.5，那么 输出1）并预测类别值。<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1672100376997-d5d46e71-6775-417e-9323-706c6633eb0e.png#averageHue=%23f0f4ed&clientId=udcad5855-1461-4&from=paste&id=u9970c8bc&originHeight=647&originWidth=815&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8728e57a-77b6-45dd-9c49-f8815a8ed02&title=)<br />由于模型的特有学习方式，通过逻辑回归所做的预测也可以用于计算属于类0或类1的概率。这对于需要给出许多基本原理的问题十分有用。<br />与线性回归一样，当移除与输出变量无关的属性以及彼此非常相似（相关）的属性时，逻辑回归确实会更好。这是一个快速学习和有效处理二元分类问题的模型。
<a name="brAFz"></a>
## 3、线性判别分析
传统的逻辑回归仅限于二分类问题。如果有两个以上的类，那么线性判别分析算法（Linear Discriminant Analysis，简称LDA）是首选的线性分类技术。<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1672100376933-e01a789b-e6c4-44a2-8945-9b07a86b906c.png#averageHue=%23f8f7f7&clientId=udcad5855-1461-4&from=paste&id=u46a11483&originHeight=633&originWidth=822&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u4861602e-bcb8-4500-a6e4-a2c52bf2c67&title=)<br />LDA的表示非常简单。它由数据的统计属性组成，根据每个类别进行计算。对于单个输入变量，这包括：

- 每类的平均值。
- 跨所有类别计算的方差。

LDA通过计算每个类的判别值并对具有最大值的类进行预测来进行。该技术假定数据具有高斯分布（钟形曲线），因此最好先手动从数据中移除异常值。这是分类预测建模问题中的一种简单而强大的方法。
<a name="ScWm0"></a>
## 4、分类和回归树
决策树是机器学习的一种重要算法。<br />决策树模型可用二叉树表示。对，就是来自算法和数据结构的二叉树，没什么特别。每个节点代表单个输入变量（x）和该变量上的左右孩子（假定变量是数字）。<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1672100376941-196bf72e-0a91-4968-9208-741920681e00.png#averageHue=%23f0efed&clientId=udcad5855-1461-4&from=paste&id=u3910e5d7&originHeight=444&originWidth=822&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ufaa8ed08-53e9-48b0-9865-0faa3374322&title=)<br />树的叶节点包含用于进行预测的输出变量（y）。预测是通过遍历树进行的，当达到某一叶节点时停止，并输出该叶节点的类值。<br />决策树学习速度快，预测速度快。对于许多问题也经常预测准确，并且不需要为数据做任何特殊准备。
<a name="IJc1p"></a>
## 5、朴素贝叶斯
朴素贝叶斯是一种简单但极为强大的预测建模算法。<br />该模型由两种类型的概率组成，可以直接从训练数据中计算出来：1）每个类别的概率; 2）给定的每个x值的类别的条件概率。一旦计算出来，概率模型就可以用于使用贝叶斯定理对新数据进行预测。当你的数据是数值时，通常假设高斯分布（钟形曲线），以便可以轻松估计这些概率。<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1672100376951-39c78a75-238d-4a1b-9336-83ab7d492f7b.png#averageHue=%23f4f4f4&clientId=udcad5855-1461-4&from=paste&id=uc8e07f84&originHeight=490&originWidth=814&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ud5cfd1e0-b9f5-480e-b632-361df622367&title=)<br />朴素贝叶斯被称为朴素的原因，在于它假设每个输入变量是独立的。这是一个强硬的假设，对于真实数据来说是不切实际的，但该技术对于大范围内的复杂问题仍非常有效。
<a name="tUWvF"></a>
## 6、K近邻
KNN算法非常简单而且非常有效。KNN的模型用整个训练数据集表示。是不是特简单？<br />通过搜索整个训练集内K个最相似的实例（邻居），并对这些K个实例的输出变量进行汇总，来预测新的数据点。对于回归问题，新的点可能是平均输出变量，对于分类问题，新的点可能是众数类别值。<br />成功的诀窍在于如何确定数据实例之间的相似性。如果你的属性都是相同的比例，最简单的方法就是使用欧几里德距离，它可以根据每个输入变量之间的差直接计算。<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1672100377388-e79bf252-2fca-4a98-9e3e-0be87c564f72.png#averageHue=%23eae7e4&clientId=udcad5855-1461-4&from=paste&id=u220f1bc0&originHeight=613&originWidth=816&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u9baac68b-0b71-49a6-8ad4-b20e1eecb89&title=)<br />KNN可能需要大量的内存或空间来存储所有的数据，但只有在需要预测时才会执行计算（或学习）。还可以随时更新和管理你的训练集，以保持预测的准确性。<br />距离或紧密度的概念可能会在高维环境（大量输入变量）下崩溃，这会对算法造成负面影响。这类事件被称为维度诅咒。它也暗示了应该只使用那些与预测输出变量最相关的输入变量。
<a name="vtfGg"></a>
## 7、学习矢量量化
K-近邻的缺点是需要维持整个训练数据集。学习矢量量化算法（或简称LVQ）是一种人工神经网络算法，允许你挂起任意个训练实例并准确学习他们。<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1672100377707-6e01d0d5-3a8a-44dc-b76b-f000e5ce41eb.png#averageHue=%23eeeeee&clientId=udcad5855-1461-4&from=paste&id=uf1c12b6b&originHeight=354&originWidth=824&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u7f710ee3-92c9-4aae-93d9-daaef06e095&title=)<br />LVQ用codebook向量的集合表示。开始时随机选择向量，然后多次迭代，适应训练数据集。在学习之后，codebook向量可以像K-近邻那样用来预测。通过计算每个codebook向量与新数据实例之间的距离来找到最相似的邻居（最佳匹配），然后返回最佳匹配单元的类别值或在回归情况下的实际值作为预测。如果把数据限制在相同范围（如0到1之间），则可以获得最佳结果。<br />如果发现KNN在数据集上给出了很好的结果，请尝试使用LVQ来减少存储整个训练数据集的内存要求。
<a name="sY9fg"></a>
## 8、支持向量机
支持向量机也许是最受欢迎和讨论的机器学习算法之一。<br />超平面是分割输入变量空间的线。在SVM中，会选出一个超平面以将输入变量空间中的点按其类别（0类或1类）进行分离。在二维空间中可以将其视为一条线，所有的输入点都可以被这条线完全分开。SVM学习算法就是要找到能让超平面对类别有最佳分离的系数。<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1672100377681-d5e7d783-086e-45fe-b4d8-f9f69962a521.png#averageHue=%23f3f7f5&clientId=udcad5855-1461-4&from=paste&id=ub7d3bdd1&originHeight=474&originWidth=818&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uc10fce3e-7cda-4005-82ba-c1c58b787ff&title=)<br />超平面和最近的数据点之间的距离被称为边界，有最大边界的超平面是最佳之选。同时，只有这些离得近的数据点才和超平面的定义和分类器的构造有关，这些点被称为支持向量，他们支持或定义超平面。在具体实践中，会用到优化算法来找到能最大化边界的系数值。<br />SVM可能是最强大的即用分类器之一，在数据集上值得一试。
<a name="TA9ae"></a>
## 9、bagging和随机森林
随机森林是最流行和最强大的机器学习算法之一。它是一种被称为Bootstrap Aggregation或Bagging的集成机器学习算法。<br />bootstrap是一种强大的统计方法，用于从数据样本中估计某一数量，例如平均值。它会抽取大量样本数据，计算平均值，然后平均所有平均值，以便更准确地估算真实平均值。<br />在bagging中用到了相同的方法，但最常用到的是决策树，而不是估计整个统计模型。它会训练数据进行多重抽样，然后为每个数据样本构建模型。当需要对新数据进行预测时，每个模型都会进行预测，并对预测结果进行平均，以更好地估计真实的输出值。<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1672100377649-d66116b1-bee0-489d-a76f-18377ac95c05.png#averageHue=%23eae7e3&clientId=udcad5855-1461-4&from=paste&id=u5db898a2&originHeight=498&originWidth=820&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u05d0ee88-c098-472a-a449-eca62db4f20&title=)<br />随机森林是对决策树的一种调整，相对于选择最佳分割点，随机森林通过引入随机性来实现次优分割。<br />因此，为每个数据样本创建的模型之间的差异性会更大，但就自身意义来说依然准确无误。结合预测结果可以更好地估计正确的潜在输出值。<br />如果使用高方差算法（如决策树）获得良好结果，那么加上这个算法后效果会更好。
<a name="mo8Hn"></a>
## 10、Boosting和AdaBoost
Boosting是一种从一些弱分类器中创建一个强分类器的集成技术。它先由训练数据构建一个模型，然后创建第二个模型来尝试纠正第一个模型的错误。不断添加模型，直到训练集完美预测或已经添加到数量上限。<br />AdaBoost是为二分类开发的第一个真正成功的Boosting算法，同时也是理解Boosting的最佳起点。目前基于AdaBoost而构建的算法中最著名的就是随机梯度boosting。<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1672100377996-c7070187-e4f9-4ff1-9b36-b4b2ee8c7e39.png#averageHue=%23efd1c7&clientId=udcad5855-1461-4&from=paste&id=u616ccbe9&originHeight=458&originWidth=817&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u10d3cdbd-2726-49fe-abc5-33b70017448&title=)<br />AdaBoost常与短决策树一起使用。在创建第一棵树之后，每个训练实例在树上的性能都决定了下一棵树需要在这个训练实例上投入多少关注。难以预测的训练数据会被赋予更多的权重，而易于预测的实例被赋予更少的权重。模型按顺序依次创建，每个模型的更新都会影响序列中下一棵树的学习效果。在建完所有树之后，算法对新数据进行预测，并且通过训练数据的准确程度来加权每棵树的性能。<br />因为算法极为注重错误纠正，所以一个没有异常值的整洁数据十分重要。<br />初学者在面对各种各样的机器学习算法时提出的一个典型问题是“我应该使用哪种算法？”问题的答案取决于许多因素，其中包括：

- 数据的大小，质量和性质;
- 可用的计算时间;
- 任务的紧迫性;
- 想要对数据做什么。

即使是一位经验丰富的数据科学家，在尝试不同的算法之前，也无法知道哪种算法会表现最好。虽然还有很多其他的机器学习算法，但这些算法是最受欢迎的算法。如果是机器学习的新手，这是一个很好的学习起点。
