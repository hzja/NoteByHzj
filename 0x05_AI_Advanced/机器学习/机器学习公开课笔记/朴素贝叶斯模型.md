数据科学
<a name="SHN1a"></a>
## 朴素贝叶斯模型
基本原理：概率论中的贝叶斯定理。
<a name="kIVa4"></a>
### 贝叶斯定理
![](https://cdn.nlark.com/yuque/__latex/6c97ec8ca329ab597a92b298ce168a0e.svg#card=math&code=P%28C%7CX%29%3D%5Cfrac%7BP%28x%7CC%29P%28C%29%7D%7BP%28x%29%7D&id=jHkYm)<br />x：观察变量<br />C：一个潜在特性<br />P(C|x)：后验概率<br />P(C)：先验概率<br />P(xIC)：似然性likelihood<br />对于具备n个特征的观测值x=(x1,x2,…,xn)，属于第k个分类的概率记为：<br />P(Ck|x) = P(Cklx1,x2,… ,xn)<br />贝叶斯公式：![](https://cdn.nlark.com/yuque/__latex/c130377ff8cae14e9b49d87c31be1e6a.svg#card=math&code=P%28C%7Cx%29%3D%5Cfrac%7BP%28x%7CC%29P%28C%29%7D%7BP%28x%29%7D&id=L1K2S)   ![](https://cdn.nlark.com/yuque/__latex/ed8ee4e3200455d336ea2a93ace4fe56.svg#card=math&code=P%28x%7CC%29P%28C%29%20%3D%20P%28x%2CC%29&id=y1cnn)<br />若特征间相互独立，则<br />![](https://cdn.nlark.com/yuque/__latex/6b5d0ee85d10db8a697afd74b4a2e3db.svg#card=math&code=%5Cbegin%7Baligned%7D%0A%26P%5Cleft%28x_%7Bi%7D%20%5Cmid%20x_%7Bi%2B1%7D%2C%20%5Ccdots%2C%20x_%7Bn%7D%2C%20C_%7Bk%7D%5Cright%29%3DP%5Cleft%28x_%7Bi%7D%20%5Cmid%20C_%7Bk%7D%5Cright%29%0A%5Cend%7Baligned%7D&id=VXX0f)<br />![](https://cdn.nlark.com/yuque/__latex/1071fc5f499a1875c86d9c902bd52a29.svg#card=math&code=P%5Cleft%28%5Cmathbf%7Bx%7D%20%5Cmid%20C_%7Bk%7D%5Cright%29%20P%5Cleft%28C_%7Bk%7D%5Cright%29%3DP%5Cleft%28x_%7B1%7D%20%5Cmid%20C_%7Bk%7D%5Cright%29%20P%5Cleft%28x_%7B2%7D%20%5Cmid%20C_%7Bk%7D%5Cright%29%20%5Ccdots%20P%5Cleft%28x_%7Bn%7D%20%5Cmid%20C_%7Bk%7D%5Cright%29%20P%5Cleft%28C_%7Bk%7D%5Cright%29&id=UtL9s)<br />贝叶斯公式的分子：<br />![](https://cdn.nlark.com/yuque/__latex/4d19783664f8b47ffec368238269a3ba.svg#card=math&code=P%5Cleft%28%5Cmathbf%7Bx%7D%20%5Cmid%20C_%7Bk%7D%5Cright%29%20P%5Cleft%28C_%7Bk%7D%5Cright%29%3DP%5Cleft%28C_%7Bk%7D%5Cright%29%20%5Cprod_%7Bi%3D1%7D%5E%7Bn%7D%20P%5Cleft%28x_%7Bi%7D%20%5Cmid%20C_%7Bk%7D%5Cright%29&id=b9GF7)<br />P(Ck)：第K类在总体中的先验概率<br />P(xi|Ck):第K类中观察到X时的条件概率
<a name="YR0zu"></a>
#### 1、高斯模型
X——在每一类中都是服从高斯分布的连续值。<br />![](https://cdn.nlark.com/yuque/__latex/e29037ccc97d700992fae82a02c137df.svg#card=math&code=P%5Cleft%28%5Cmathbf%7Bx%7D%3Dv%20%5Cmid%20C_%7Bk%7D%5Cright%29%3D%5Cfrac%7B1%7D%7B%5Csqrt%7B2%20%5Cpi%20%5Csigma_%7Bk%7D%5E%7B2%7D%7D%7D%20e%5E%7B-%5Cfrac%7B%5Cleft%28v-%5Cmu_%7Bk%7D%5Cright%29%5E%7B2%7D%7D%7B2%20%5Csigma_%7Bk%7D%5E%7B2%7D%7D%7D&id=Ybuqu)
:::info
`sklearn.naive_bayes.GaussianNB`对象可以构建朴素贝叶斯的高斯模型。只要把训练数据代入到`fit`函数即可完成模型训练。再将待分类的特征数据代入`predict`函数即可以获得分类结果。
:::
<a name="O23iQ"></a>
#### 2、Multinomial(多项式）模型
xi——特征i发生的频次<br />x——n个特征的直方图
:::info
`sklearn.naive_bayes.MultinomialNB`对象中的`fit`函数和`predict`函数分别用来训练和预测。
:::
<a name="rtFEg"></a>
#### 3、Bernoulli(伯努利)模型
xi——特征i发生/不发生<br />x——n个特征发生与否的二进制序列
:::info
`sklearn.naive_bayes.BernoulliNB`对象可以构建伯努利模型。
:::
<a name="bhuYu"></a>
## Logistic回归——朴素贝叶斯
分类问题的评价指标多数可由混淆矩阵得出。
<a name="pqf7s"></a>
### 混淆矩阵
将数据按待分的类别分组后，统计各组中模型分类或预测结果的矩阵。<br />二分类问题：阳性或阴性

|  |  | 真实分类 |  |
| --- | --- | --- | --- |
|  |  | 阳性 | 阴性 |
| 模型分类 | 阳性 | TP（真阳性）[正确] | FP（假阳性） |
|  | 阴性 | FN（假阴性） | TN（真阴性）[正确] |

总例数Total：TP+FP+FN+TN<br />准群率：![](https://cdn.nlark.com/yuque/__latex/77e06d3bba590ffaad327f37ad6d8f76.svg#card=math&code=ACC%3D%5Cfrac%7BTP%2BTN%7D%7BTotal%7D&id=qI1jG)<br />![](https://cdn.nlark.com/yuque/__latex/5ae62835667e581bbeb4c023b89eaf47.svg#card=math&code=%5Ctext%7BTPR%20or%20Sen%7D%3D%5Cfrac%7BTP%7D%7BTP%2BFN%7D&id=U4mVQ)   取值：[0,1]  (真阳性、召回率、敏感性、检出率)<br />![](https://cdn.nlark.com/yuque/__latex/090e69433be3f8a57847a21088c66f2f.svg#card=math&code=%5Ctext%7BTNR%20or%20Spe%7D%3D%5Cfrac%7BTN%7D%7BFP%2BTN%7D&id=Q0yyj)  取值：[0,1]  (真阴性、特异性、选择性)<br />精度（阳性预测值)：![](https://cdn.nlark.com/yuque/__latex/cb215c5906ba4b92a58a92a7ca02b46a.svg#card=math&code=%5Ctext%7BPPV%20or%20precision%7D%3D%5Cfrac%7BTP%7D%7BTP%2BFP%7D&id=MeNF9)   取值：[0,1]<br />阴性预测值：![](https://cdn.nlark.com/yuque/__latex/5f83d35c07581f9ef39093a9a0871afe.svg#card=math&code=NPV%3D%5Cfrac%7BTN%7D%7BTN%2BFN%7D&id=VFZNu)   取值：[0,1]<br />![](https://cdn.nlark.com/yuque/__latex/d98850c4345891bfd40039cc0bfa937e.svg#card=math&code=%5Cbegin%7Baligned%7D%0A%5Cmathrm%7BF%7D%201%3D%5Cfrac%7B2%7D%7B%5Cfrac%7B1%7D%7B%5Cmathrm%7BTPR%7D%7D%2B%5Cfrac%7B1%7D%7B%5Ctext%20%7B%20precision%20%7D%7D%7D%20%26%20%5Ctext%20%7B%20%E5%8F%96%E5%80%BC%20%7D%3A%5B0%2C1%5D%0A%5Cend%7Baligned%7D&id=rxssG)<br />![](https://cdn.nlark.com/yuque/__latex/8482fd71d85c90aa77cad571919ca105.svg#card=math&code=%5Ctext%20%7B%20TPR%20or%20Sen%20%7D%3D%5Cfrac%7B%5Cmathrm%7BTP%7D%7D%7B%5Cmathrm%7BTP%7D%2B%5Cmathrm%7BFN%7D%7D&id=UVK75)↑

![](https://cdn.nlark.com/yuque/__latex/090e69433be3f8a57847a21088c66f2f.svg#card=math&code=%5Ctext%7BTNR%20or%20Spe%7D%3D%5Cfrac%7BTN%7D%7BFP%2BTN%7D&id=PDgj7)↓<br />特征服从高斯分布的连续值时使用高斯模型<br />使用`scipy.stats.probplot(x, dist,plot)`函数检查鸢尾花数据是否服从高斯分布<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1628156421733-2273a3d1-91ea-481c-b8ae-45f6b16fc0d7.png#clientId=ucb0515f8-191f-4&from=paste&height=268&id=u800657b8&originHeight=357&originWidth=637&originalType=binary&ratio=1&rotation=0&showTitle=false&size=227375&status=done&style=none&taskId=uef8b6c99-1f73-4256-92eb-009e9fc7429&title=&width=478)
```python
import pandas as pd
import numpy as np
from sklearn import datasets
from scipy import stats
import matplotlib.pyplot as plt
iris=datasets.load_iris()
#print((iris))
plt.figure(figsize=(12,15))
5
for n in range(4):
    print(n)
    for m in range(3):
        x=(iris.data[m*50:m*50+50,n]-iris.data[m*50:m*50+50,n].mean())/iris.data[m*50:m*50+50,n].std()
        plt.subplot(4,3,n*3+m+1)
        stats.probplot(x,dist='norm',plot=plt)
        plt.text(-2,2,iris.feature_names[n])
        if n==0:
            plt.title(iris.target_names[m])
        else:
            plt.title('')
        plt.xlim([-2.5,2.5])
        plt.ylim([-2.5,2.5])
        plt.plot([-2.5,2.5],[-2.5,2.5],c='g')
plt.savefig('chap72.png')
```
![chap72.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1628157782429-ff28fb0a-9b4b-4427-99c5-c64c0f1c81da.png#clientId=ucb0515f8-191f-4&from=ui&id=u5f5731cf&originHeight=1080&originWidth=864&originalType=binary&ratio=1&rotation=0&showTitle=false&size=93654&status=done&style=shadow&taskId=ua354ae68-ffbe-4c78-8284-495a9b30ae3&title=)<br />红色：probplot函数对所有散点最小二乘拟合的直线<br />绿色：45°对角线<br />可以看到speal length和speal width与高斯分布吻合的更好一些，第三个和第四个则差了一些。现在使用第一个和第二个来构建高斯模型。<br />![](https://cdn.nlark.com/yuque/0/2021/jpeg/396745/1628158274323-315d7ebe-dcf2-475e-88a6-ccbca5425b71.jpeg)
```python
from sklearn.model_selection import train_test_split
#X_train,X_test,Y_train,Y_test=train_test_split(iris.data,iris.target,test_size=0.2,random_state=0)
X_train,X_test,Y_train,Y_test=train_test_split(my_data,iris.target,test_size=0.2,random_state=0)
from sklearn.naive_bayes import GaussianNB
clf=GaussianNB()
clf.fit(X_train,Y_train)
y_pred=clf.predict(X_test)
Y=pd.DataFrame(np.transpose([Y_test,y_pred]),columns={'true_type','predict_type'})
Y.head(30)
```
将测试结果和真实的结果打印出来进行对照<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1628161115473-b1d98020-c82b-4f0e-8352-472211c6e99e.png#clientId=ucb0515f8-191f-4&from=paste&height=348&id=u0924acd2&originHeight=1043&originWidth=1771&originalType=binary&ratio=1&rotation=0&showTitle=false&size=98702&status=done&style=shadow&taskId=u880321ff-f993-4968-be98-3c7c8b2d12d&title=&width=590.3333333333334)<br />`sklearn.metrics`模块中的 `confusion_matrix`  函数将预测分类结果和真实分类结果作为参数输入可以生成混淆矩阵。
```python
from sklearn.metrics import confusion_matrix
print(confusion_matrix(y_pred,Y_test))
```
![image.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1628161223687-00a48954-54db-4fd1-beee-745c01fdbcba.png#clientId=ucb0515f8-191f-4&from=paste&height=91&id=uc87f500b&originHeight=274&originWidth=1260&originalType=binary&ratio=1&rotation=0&showTitle=false&size=18419&status=done&style=shadow&taskId=uc858ff24-4292-413c-a6e5-7c6b619d362&title=&width=420)<br />使用`sklearn.metrics`模块中的`classification_report`函数可以看到精度等评价指标。
```python
from sklearn.metrics import classification_report
print(classification_report(y_pred,Y_test))
```
![image.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1628161253898-f2ba49e3-a57a-4555-9ce1-172e689cb336.png#clientId=ucb0515f8-191f-4&from=paste&height=187&id=uee068218&originHeight=561&originWidth=1532&originalType=binary&ratio=1&rotation=0&showTitle=false&size=85947&status=done&style=shadow&taskId=u0c376e71-9ab0-40ee-b0b1-0d6cb6ec025&title=&width=510.6666666666667)
<a name="G5U3P"></a>
## 分类性能评价

- 线性二分类
- 就参数的区分性能做专门评价

双样本t检验的p value作为一种评价指标，并追求小的p值。但是并不认为小的p值是一种性能指标，因为在样本容量足够大的情况下，是很容易得到一个足够小的p值。
<a name="hhDMy"></a>
### ROC曲线（全称:接受者操作特征曲线）
![image.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1628161477561-80ecaf17-9070-468a-8dc3-fb1dafad7267.png#clientId=ucb0515f8-191f-4&from=paste&height=260&id=u957c3969&originHeight=520&originWidth=727&originalType=binary&ratio=1&rotation=0&showTitle=false&size=224435&status=done&style=none&taskId=u925761de-0c9b-4073-919d-1585063b51b&title=&width=364)<br />绘制方法：对同样的测试集，改变线性划分的阈值，随着阈值的改变，分类的敏感性和特异性都会随之改变，以敏感性为纵坐标，1-特异性为横坐标，将选取不同阈值的结果在图中以散点画出，散点连成的曲线就是ROC曲线。<br />ROC越远离45°对角线——分类性能越好<br />量化指标：采用曲线下面积AUC，AUCE[0,1]

- 越靠近1，参数线性区分性能越好
- 越靠近0.5，越接近随机划分
- 小于0.5，说明分类倒置

ROC优势：受两类样本数量不平衡影响较小<br />`sklearn.metrics`模块中的`roc_curve`函数生成绘制ROC曲线所需的tpr, fpr序列，只要输入真实的分类标签和最终用于分类的square变量，可以直接说某个特征，也可以说Logistic回归中的某个概率，或者是其他分类输出用来限制二分类的峰值。函数`roc_auc_score`可以直接获得AUC的结果。
```python
from sklearn.metrics import roc_curve
from sklearn.metrics import roc_auc_score
my_auc=[]
for n in range(4):
    #fpr,tpr,th=roc_curve(iris.target[:100],iris.data[:,n)
    my_auc.append(roc_auc_score(iris.target[:100],iris.data[:100,n]))
print(my_auc)
#print(iris.target[:100])
#print(iris.data[:100,:])
```
![image.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1628162256917-72fca395-3301-4ee5-9967-fefb9e94a747.png#clientId=ucb0515f8-191f-4&from=paste&height=52&id=u4bfc8194&originHeight=157&originWidth=1378&originalType=binary&ratio=1&rotation=0&showTitle=false&size=36247&status=done&style=shadow&taskId=ud40f4164-2939-461d-b005-521256a8775&title=&width=459.3333333333333)<br />这里以鸢尾花数据的四个特征分别区分第一类和第二类。可以看到后两个参数petal length和petal width的线性区分能力都达到了1。也就是说仅单独用petal length和petal width就可以区分两种不同的鸢尾花。这和散点图的形式是完全吻合的。
```python
plt.plot(np.ones([50,1]),iris.data[:50,0],'or')
plt.plot(np.ones([50,1])+0.2,iris.data[50:100,0],'*g')
plt.plot(np.ones([50,1])+1,iris.data[:50,1],'or')
plt.plot(np.ones([50,1])+1.2,iris.data[50:100,1],'*g')
plt.plot(np.ones([50,1])+2,iris.data[:50,2],'or')
plt.plot(np.ones([50,1])+2.2,iris.data[50:100,2],'*g')
plt.plot(np.ones([50,1])+3,iris.data[:50,3],'or')
plt.plot(np.ones([50,1])+3.2,iris.data[50:100,3],'*g')
plt.xticks([1,2,3,4],iris.feature_names)
plt.legend(iris.target_names[:2])
```
![image.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1628162565380-72d6b85a-b3f3-415c-ba09-8210b90ed982.png#clientId=ucb0515f8-191f-4&from=paste&height=343&id=ua869c8e6&originHeight=1028&originWidth=1596&originalType=binary&ratio=1&rotation=0&showTitle=false&size=105023&status=done&style=shadow&taskId=u59d56fc7-1a60-4667-a15f-6882e56fd16&title=&width=532)
```python
plt.figure(figsize=(5,12))
plt.subplot(3,1,1)
plt.scatter(iris.data[:50,0],iris.data[:50,1],c='r',marker='o')
plt.scatter(iris.data[50:100,0],iris.data[50:100,1],c='b',marker='*')
plt.subplot(3,1,2)
plt.scatter(iris.data[:50,0],iris.data[:50,2],c='r',marker='o')
plt.scatter(iris.data[50:100,0],iris.data[50:100,2],c='b',marker='*')
plt.subplot(3,1,3)
plt.scatter(iris.data[:50,0],iris.data[:50,3],c='r',marker='o')
plt.scatter(iris.data[50:100,0],iris.data[50:100,3],c='b',marker='*')
```
![image.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1628169493142-1b00712c-4763-49c6-bf60-136f72d70d36.png#clientId=u6b3be466-60c3-4&from=paste&id=ucaac8d56&originHeight=686&originWidth=322&originalType=url&ratio=1&rotation=0&showTitle=false&size=19898&status=done&style=shadow&taskId=uf9a5ef71-b10f-4e6b-a5e1-cbd170b9321&title=)
