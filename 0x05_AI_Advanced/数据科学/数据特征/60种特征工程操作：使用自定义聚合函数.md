数据科学特征工程<br />agg是一个聚合函数，使用指定轴上的一个或多个操作进行聚合。通过agg函数，可以同时对多列进行提取特征，非常适合用于特征工程。
<a name="Qqteu"></a>
## **内置的聚合函数**
在Pandas内部支持了13中聚合函数，可以在分组之后进行使用：

- `**mean()**`**：分组均值**
- `**sum()**`**：分组求和**
- `**size()**`**：分组个数**
- `**count()**`**：分组大小**
- `**std()**`**：分组标准差**
- `**var()**`**：分组方差**
- `**sem()**`**：均值误差**
- `**describe()**`**：分组描述**
- `**first()**`**：分组第一个元素**
- `**last()**`**：分组最后一个元素**
- `**nth()**`**：分组第N个元素**
- `**min()**`**：分组最小值**
- `**max()**`**：分组最大值**

案例如下，有多种使用方式可供选择：
```python
# 定义模型
df = pd.DataFrame({'group':[1,1,2,2],
  'values':[4,1,1,2],
  'values2':[0,1,1,2]
})

# 分组对两列求均值
df.groupby('group').mean()

# 分组对两列求均值、标准差
df.groupby('group').agg([np.mean,np.std])

# 分组对两列分别聚合
df.groupby('group').agg(
  {'values':['mean','median'],
  'values2':['mean','std']}
)
```
<a name="RTLjl"></a>
## **自定义聚合函数**
如果在Pandas内部的聚合函数不满足要求，也可以自定义聚合函数搭配使用
<a name="X1Z8x"></a>
### **median**
```python
def median(x):
    return np.median(x)
```
<a name="MmTFD"></a>
### **variation_coefficient**
```python
def variation_coefficient(x):
    mean = np.mean(x)
    if mean != 0:
        return np.std(x) / mean
    else:
        return np.nan
```
<a name="aRrj3"></a>
### **variance**
```python
def variance(x):
    return np.var(x)
```
<a name="PtWUp"></a>
### **skewness**
```python
def skewness(x):
    if not isinstance(x, pd.Series):
        x = pd.Series(x)
    return pd.Series.skew(x)
```
<a name="vOqDd"></a>
### **kurtosis**
```python
def kurtosis(x):
    if not isinstance(x, pd.Series):
        x = pd.Series(x)
    return pd.Series.kurtosis(x)
```
<a name="parmh"></a>
### **standard_deviation**
```python
def standard_deviation(x):
    return np.std(x)
```
<a name="WVU7E"></a>
### **large_standard_deviation**
```python
def large_standard_deviation(x):
    if (np.max(x)-np.min(x)) == 0:
        return np.nan
    else:
        return np.std(x)/(np.max(x)-np.min(x))
```
<a name="ADlKa"></a>
### **variation_coefficient**
```python
def variation_coefficient(x):
    mean = np.mean(x)
    if mean != 0:
        return np.std(x) / mean
    else:
        return np.nan
```
<a name="kMToa"></a>
### **variance_std_ratio**
```python
def variance_std_ratio(x):
    y = np.var(x)
    if y != 0:
        return y/np.sqrt(y)
    else:
        return np.nan
```
<a name="Pptei"></a>
### **ratio_beyond_r_sigma**
```python
def ratio_beyond_r_sigma(x, r):
    if x.size == 0:
        return np.nan
    else:
        return np.sum(np.abs(x - np.mean(x)) > r * np.asarray(np.std(x))) / x.size
```
<a name="QzD9I"></a>
### **range_ratio**
```python
def range_ratio(x):
    mean_median_difference = np.abs(np.mean(x) - np.median(x))
    max_min_difference = np.max(x) - np.min(x)
    if max_min_difference == 0:
        return np.nan
    else:
        return mean_median_difference / max_min_difference
```
<a name="vP9Qr"></a>
### **has_duplicate_max**
```python
def has_duplicate_max(x):
    return np.sum(x == np.max(x)) >= 2
```
<a name="ZPosE"></a>
### **has_duplicate_min**
```python
def has_duplicate_min(x):
    return np.sum(x == np.min(x)) >= 2
```
<a name="OldUp"></a>
### **has_duplicate**
```python
def has_duplicate(x):
    return x.size != np.unique(x).size
```
<a name="tFevW"></a>
### **count_duplicate_max**
```python
def count_duplicate_max(x):
    return np.sum(x == np.max(x))
```
<a name="e78zB"></a>
### **count_duplicate_min**
```python
def count_duplicate_min(x):
    return np.sum(x == np.min(x))
```
<a name="agzmE"></a>
### **count_duplicate**
```python
def count_duplicate(x):
    return x.size - np.unique(x).size
```
<a name="KBf94"></a>
### **sum_values**
```python
def sum_values(x):
    if len(x) == 0:
        return 0
    return np.sum(x)
```
<a name="ENP1u"></a>
### **log_return**
```python
def log_return(list_stock_prices):
    return np.log(list_stock_prices).diff()
```
<a name="ru3qm"></a>
### **realized_volatility**
```python
def realized_volatility(series):
    return np.sqrt(np.sum(series**2))
```
<a name="zDdGE"></a>
### **realized_abs_skew**
```python
def realized_abs_skew(series):
    return np.power(np.abs(np.sum(series**3)),1/3)
```
<a name="iNi02"></a>
### **realized_skew**
```python
def realized_skew(series):
    return np.sign(np.sum(series**3))*np.power(np.abs(np.sum(series**3)),1/3)
```
<a name="bY1v1"></a>
### **realized_vol_skew**
```python
def realized_vol_skew(series):
    return np.power(np.abs(np.sum(series**6)),1/6)
```
<a name="la49X"></a>
### **realized_quarticity**
```python
def realized_quarticity(series):
    return np.power(np.sum(series**4),1/4)
```
<a name="jfFFf"></a>
### **count_unique**
```python
def count_unique(series):
    return len(np.unique(series))
```
<a name="ZhgIa"></a>
### **count**
```python
def count(series):
    return series.size
```
<a name="chVLg"></a>
### **maximum_drawdown**
```python
def maximum_drawdown(series):
    series = np.asarray(series)
    if len(series)<2:
        return 0
    k = series[np.argmax(np.maximum.accumulate(series) - series)]
    i = np.argmax(np.maximum.accumulate(series) - series)
    if len(series[:i])<1:
        return np.NaN
    else:
        j = np.max(series[:i])
    return j-k
```
<a name="r1ZVo"></a>
### **maximum_drawup**
```python
def maximum_drawup(series):
    series = np.asarray(series)
    if len(series)<2:
        return 0

    series = - series
    k = series[np.argmax(np.maximum.accumulate(series) - series)]
    i = np.argmax(np.maximum.accumulate(series) - series)
    if len(series[:i])<1:
        return np.NaN
    else:
        j = np.max(series[:i])
    return j-k
```
<a name="uazdJ"></a>
### **drawdown_duration**
```python
def drawdown_duration(series):
    series = np.asarray(series)
    if len(series)<2:
        return 0

    k = np.argmax(np.maximum.accumulate(series) - series)
    i = np.argmax(np.maximum.accumulate(series) - series)
    if len(series[:i]) == 0:
        j=k
    else:
        j = np.argmax(series[:i])
    return k-j
```
<a name="Vwfnw"></a>
### **drawup_duration**
```python
def drawup_duration(series):
    series = np.asarray(series)
    if len(series)<2:
        return 0

    series=-series
    k = np.argmax(np.maximum.accumulate(series) - series)
    i = np.argmax(np.maximum.accumulate(series) - series)
    if len(series[:i]) == 0:
        j=k
    else:
        j = np.argmax(series[:i])
    return k-j
```
<a name="cOqhg"></a>
### **max_over_min**
```python
def max_over_min(series):
    if len(series)<2:
        return 0
    if np.min(series) == 0:
        return np.nan
    return np.max(series)/np.min(series)
```
<a name="O7jh7"></a>
### **mean_n_absolute_max**
```python
def mean_n_absolute_max(x, number_of_maxima = 1):
    """ Calculates the arithmetic mean of the n absolute maximum values of the time series."""
    assert (
        number_of_maxima > 0
    ), f" number_of_maxima={number_of_maxima} which is not greater than 1"

    n_absolute_maximum_values = np.sort(np.absolute(x))[-number_of_maxima:]

    return np.mean(n_absolute_maximum_values) if len(x) > number_of_maxima else np.NaN
```
<a name="LUyNA"></a>
### **count_above**
```python
def count_above(x, t):
    if len(x)==0:
        return np.nan
    else:
        return np.sum(x >= t) / len(x)
```
<a name="agTn7"></a>
### **count_below**
```python
def count_below(x, t):
    if len(x)==0:
        return np.nan
    else:
        return np.sum(x <= t) / len(x)
```
<a name="kIQEU"></a>
### **number_peaks**
```python
def number_peaks(x, n):
    x_reduced = x[n:-n]

    res = None
    for i in range(1, n + 1):
        result_first = x_reduced > _roll(x, i)[n:-n]

        if res is None:
            res = result_first
        else:
            res &= result_first

        res &= x_reduced > _roll(x, -i)[n:-n]
    return np.sum(res)
```
<a name="VIz2H"></a>
### **mean_abs_change**
```python
def mean_abs_change(x):
    return np.mean(np.abs(np.diff(x)))
```
<a name="jQYQf"></a>
### **mean_change**
```python
def mean_change(x):
    x = np.asarray(x)
    return (x[-1] - x[0]) / (len(x) - 1) if len(x) > 1 else np.NaN
```
<a name="uQTif"></a>
### **mean_second_derivative_central**
```python
def mean_second_derivative_central(x):
    x = np.asarray(x)
    return (x[-1] - x[-2] - x[1] + x[0]) / (2 * (len(x) - 2)) if len(x) > 2 else np.NaN
```
<a name="Oi2V5"></a>
### **root_mean_square**
```python
def root_mean_square(x):
    return np.sqrt(np.mean(np.square(x))) if len(x) > 0 else np.NaN
```
<a name="jXpKq"></a>
### **absolute_sum_of_changes**
```python
def absolute_sum_of_changes(x):
    return np.sum(np.abs(np.diff(x)))
```
<a name="G9jpV"></a>
### **longest_strike_below_mean**
```python
def longest_strike_below_mean(x):
    if not isinstance(x, (np.ndarray, pd.Series)):
        x = np.asarray(x)
    return np.max(_get_length_sequences_where(x < np.mean(x))) if x.size > 0 else 0
```
<a name="m6XVf"></a>
### **longest_strike_above_mean**
```python
def longest_strike_above_mean(x):
    if not isinstance(x, (np.ndarray, pd.Series)):
        x = np.asarray(x)
    return np.max(_get_length_sequences_where(x > np.mean(x))) if x.size > 0 else 0
```
<a name="zOR4U"></a>
### **count_above_mean**
```python
def count_above_mean(x):
    m = np.mean(x)
    return np.where(x > m)[0].size
```
<a name="klRFb"></a>
### **count_below_mean**
```python
def count_below_mean(x):
    m = np.mean(x)
    return np.where(x < m)[0].size
```
<a name="pHoGb"></a>
### **last_location_of_maximum**
```python
def last_location_of_maximum(x):
    x = np.asarray(x)
    return 1.0 - np.argmax(x[::-1]) / len(x) if len(x) > 0 else np.NaN
```
<a name="pfs3w"></a>
### **first_location_of_maximum**
```python
def first_location_of_maximum(x):
    if not isinstance(x, (np.ndarray, pd.Series)):
        x = np.asarray(x)
    return np.argmax(x) / len(x) if len(x) > 0 else np.NaN
```
<a name="ZdqNZ"></a>
### **last_location_of_minimum**
```python
def last_location_of_minimum(x):
    x = np.asarray(x)
    return 1.0 - np.argmin(x[::-1]) / len(x) if len(x) > 0 else np.NaN
```
<a name="Yj4Iq"></a>
### **first_location_of_minimum**
```python
def first_location_of_minimum(x):
    if not isinstance(x, (np.ndarray, pd.Series)):
        x = np.asarray(x)
    return np.argmin(x) / len(x) if len(x) > 0 else np.NaN
```
<a name="bEfwW"></a>
### **percentage_of_reoccurring_values_to_all_values**
```python
def percentage_of_reoccurring_values_to_all_values(x):
    if len(x) == 0:
        return np.nan
    unique, counts = np.unique(x, return_counts=True)
    if counts.shape[0] == 0:
        return 0
    return np.sum(counts > 1) / float(counts.shape[0])
```
<a name="dO59r"></a>
### **percentage_of_reoccurring_datapoints_to_all_datapoints**
```python
def percentage_of_reoccurring_datapoints_to_all_datapoints(x):
    if len(x) == 0:
        return np.nan
    if not isinstance(x, pd.Series):
        x = pd.Series(x)
    value_counts = x.value_counts()
    reoccuring_values = value_counts[value_counts > 1].sum()
    if np.isnan(reoccuring_values):
        return 0

    return reoccuring_values / x.size
```
<a name="A2D9U"></a>
### **sum_of_reoccurring_values**
```python
def sum_of_reoccurring_values(x):
    unique, counts = np.unique(x, return_counts=True)
    counts[counts < 2] = 0
    counts[counts > 1] = 1
    return np.sum(counts * unique)
```
<a name="fSbVz"></a>
### **sum_of_reoccurring_data_points**
```python
def sum_of_reoccurring_data_points(x):
    unique, counts = np.unique(x, return_counts=True)
    counts[counts < 2] = 0
    return np.sum(counts * unique)
```
<a name="Bl5xK"></a>
### **ratio_value_number_to_time_series_length**
```python
def ratio_value_number_to_time_series_length(x):
    if not isinstance(x, (np.ndarray, pd.Series)):
        x = np.asarray(x)
    if x.size == 0:
        return np.nan

    return np.unique(x).size / x.size
```
<a name="EvN5k"></a>
### **abs_energy**
```python
def abs_energy(x):
    if not isinstance(x, (np.ndarray, pd.Series)):
        x = np.asarray(x)
    return np.dot(x, x)
```
<a name="jBxzJ"></a>
### **quantile**
```python
def quantile(x, q):
    if len(x) == 0:
        return np.NaN
    return np.quantile(x, q)
```
<a name="fGSJN"></a>
### **number_crossing_m**
```python
def number_crossing_m(x, m):
    if not isinstance(x, (np.ndarray, pd.Series)):
        x = np.asarray(x)
    # From https://stackoverflow.com/questions/3843017/efficiently-detect-sign-changes-in-python
    positive = x > m
    return np.where(np.diff(positive))[0].size
```
<a name="pwGMR"></a>
### **absolute_maximum**
```python
def absolute_maximum(x):
    return np.max(np.absolute(x)) if len(x) > 0 else np.NaN
```
<a name="iZBTA"></a>
### **value_count**
```python
def value_count(x, value):
    if not isinstance(x, (np.ndarray, pd.Series)):
        x = np.asarray(x)
    if np.isnan(value):
        return np.isnan(x).sum()
    else:
        return x[x == value].size
```
<a name="QZLbZ"></a>
### **range_count**
```python
def range_count(x, min, max):
    return np.sum((x >= min) & (x < max))
```
<a name="z13JD"></a>
### **mean_diff**
```python
def mean_diff(x):
    return np.nanmean(np.diff(x.values))
```
