深度学习<br />都知道卷积的重要性，但知道深度学习领域的卷积究竟是什么，又有多少种类吗？研究学者 Kunlun Bai 发布了一篇介绍深度学习的卷积文章，用浅显易懂的方式介绍了深度学习领域的各种卷积及其优势。<br />如果听说过深度学习中不同种类的卷积（比如 2D / 3D / 1x1 /转置/扩张（Atrous）/空间可分/深度可分/平展/分组/混洗分组卷积），并且搞不清楚它们究竟是什么意思，那么这篇文章能帮你理解它们实际的工作方式。<br />在这里归纳总结深度学习中常用的几种卷积，并会试图用一种每个人都能理解的方式解释它们。<br />希望本文能帮助你构建起对卷积的直观认知，并成为研究或学习的有用参考。
<a name="XxQ8m"></a>
##    目录

1. 卷积与互相关
2. 深度学习中的卷积（单通道版本，多通道版本）
3. 3D 卷积
4. 1×1 卷积
5. 卷积算术
6. 转置卷积（去卷积、棋盘效应）
7. 扩张卷积
8. 可分卷积（空间可分卷积，深度可分卷积）
9. 平展卷积
10. 分组卷积
11. 混洗分组卷积
12. 逐点分组卷积
<a name="iY4ic"></a>
##    卷积与互相关
在信号处理、图像处理和其它工程/科学领域，卷积都是一种使用广泛的技术。在深度学习领域，卷积神经网络（CNN）这种模型架构就得名于这种技术。但是，深度学习领域的卷积本质上是信号/图像处理领域内的互相关（cross-correlation）。这两种操作之间存在细微的差别。<br />无需太过深入细节，就能看到这个差别。在信号/图像处理领域，卷积的定义是：<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1655546087142-33753055-643c-4e58-81d7-3741cf759a1a.png#clientId=u788e9171-2710-4&from=paste&id=u4e4ada8e&originHeight=78&originWidth=697&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=u371f1df8-beba-4d4d-8ea8-221845e876f&title=)<br />其定义是两个函数中一个函数经过反转和位移后再相乘得到的积的积分。下面的可视化展示了这一思想：<br />![信号处理中的卷积。过滤器 g 经过反转，然后再沿水平轴滑动。在每一个位置，都计算 f 和反转后的 g 之间相交区域的面积。这个相交区域的面积就是特定位置出的卷积值。](https://cdn.nlark.com/yuque/0/2022/jpeg/396745/1655546087178-98d3864f-4e19-42eb-8402-c3a915ebb0e8.jpeg#clientId=u788e9171-2710-4&from=paste&id=ucf8c538f&originHeight=611&originWidth=877&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=shadow&taskId=u879b6c58-4f7f-45c4-9eed-7b774d70243&title=%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%AD%E7%9A%84%E5%8D%B7%E7%A7%AF%E3%80%82%E8%BF%87%E6%BB%A4%E5%99%A8%20g%20%E7%BB%8F%E8%BF%87%E5%8F%8D%E8%BD%AC%EF%BC%8C%E7%84%B6%E5%90%8E%E5%86%8D%E6%B2%BF%E6%B0%B4%E5%B9%B3%E8%BD%B4%E6%BB%91%E5%8A%A8%E3%80%82%E5%9C%A8%E6%AF%8F%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE%EF%BC%8C%E9%83%BD%E8%AE%A1%E7%AE%97%20f%20%E5%92%8C%E5%8F%8D%E8%BD%AC%E5%90%8E%E7%9A%84%20g%20%E4%B9%8B%E9%97%B4%E7%9B%B8%E4%BA%A4%E5%8C%BA%E5%9F%9F%E7%9A%84%E9%9D%A2%E7%A7%AF%E3%80%82%E8%BF%99%E4%B8%AA%E7%9B%B8%E4%BA%A4%E5%8C%BA%E5%9F%9F%E7%9A%84%E9%9D%A2%E7%A7%AF%E5%B0%B1%E6%98%AF%E7%89%B9%E5%AE%9A%E4%BD%8D%E7%BD%AE%E5%87%BA%E7%9A%84%E5%8D%B7%E7%A7%AF%E5%80%BC%E3%80%82 "信号处理中的卷积。过滤器 g 经过反转，然后再沿水平轴滑动。在每一个位置，都计算 f 和反转后的 g 之间相交区域的面积。这个相交区域的面积就是特定位置出的卷积值。")<br />这里，函数 g 是过滤器。它被反转后再沿水平轴滑动。在每一个位置，都计算 f 和反转后的 g 之间相交区域的面积。这个相交区域的面积就是特定位置出的卷积值。<br />另一方面，互相关是两个函数之间的滑动点积或滑动内积。互相关中的过滤器不经过反转，而是直接滑过函数 f。f 与 g 之间的交叉区域即是互相关。下图展示了卷积与互相关之间的差异。<br />![信号处理中卷积与互相关之间的差异](https://cdn.nlark.com/yuque/0/2022/jpeg/396745/1655546087137-9193a404-1150-45d3-93a7-209585476e26.jpeg#clientId=u788e9171-2710-4&from=paste&id=u1e93ccdc&originHeight=614&originWidth=877&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=shadow&taskId=u29867095-3ac5-4963-b37a-a8cf8eb4824&title=%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%AD%E5%8D%B7%E7%A7%AF%E4%B8%8E%E4%BA%92%E7%9B%B8%E5%85%B3%E4%B9%8B%E9%97%B4%E7%9A%84%E5%B7%AE%E5%BC%82 "信号处理中卷积与互相关之间的差异")<br />在深度学习中，卷积中的过滤器不经过反转。严格来说，这是互相关。本质上是执行逐元素乘法和加法。但在深度学习中，直接将其称之为卷积更加方便。这没什么问题，因为过滤器的权重是在训练阶段学习到的。如果上面例子中的反转函数 g 是正确的函数，那么经过训练后，学习得到的过滤器看起来就会像是反转后的函数 g。因此，在训练之前，没必要像在真正的卷积中那样首先反转过滤器。
<a name="LLyQc"></a>
##    3D 卷积
在上一节的解释中，可以看到实际上是对一个 3D 体积执行卷积。但通常而言，仍在深度学习中称之为 2D 卷积。这是在 3D 体积数据上的 2D 卷积。过滤器深度与输入层深度一样。这个 3D 过滤器仅沿两个方向移动（图像的高和宽）。这种操作的输出是一张 2D 图像（仅有一个通道）。<br />很自然，3D 卷积确实存在。这是 2D 卷积的泛化。下面就是 3D 卷积，其过滤器深度小于输入层深度（核大小<通道大小）。因此，3D 过滤器可以在所有三个方向（图像的高度、宽度、通道）上移动。在每个位置，逐元素的乘法和加法都会提供一个数值。因为过滤器是滑过一个 3D 空间，所以输出数值也按 3D 空间排布。也就是说输出是一个 3D 数据。<br />![在 3D 卷积中，3D 过滤器可以在所有三个方向（图像的高度、宽度、通道）上移动。在每个位置，逐元素的乘法和加法都会提供一个数值。因为过滤器是滑过一个 3D 空间，所以输出数值也按 3D 空间排布。也就是说输出是一个 3D 数据。](https://cdn.nlark.com/yuque/0/2022/jpeg/396745/1655546087201-24a7a1a2-d25d-4d97-a7df-529d6a67e7e1.jpeg#clientId=u788e9171-2710-4&from=paste&id=ua8ea6740&originHeight=643&originWidth=877&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=shadow&taskId=u24b527d4-caa3-45e5-85f1-8373939c1da&title=%E5%9C%A8%203D%20%E5%8D%B7%E7%A7%AF%E4%B8%AD%EF%BC%8C3D%20%E8%BF%87%E6%BB%A4%E5%99%A8%E5%8F%AF%E4%BB%A5%E5%9C%A8%E6%89%80%E6%9C%89%E4%B8%89%E4%B8%AA%E6%96%B9%E5%90%91%EF%BC%88%E5%9B%BE%E5%83%8F%E7%9A%84%E9%AB%98%E5%BA%A6%E3%80%81%E5%AE%BD%E5%BA%A6%E3%80%81%E9%80%9A%E9%81%93%EF%BC%89%E4%B8%8A%E7%A7%BB%E5%8A%A8%E3%80%82%E5%9C%A8%E6%AF%8F%E4%B8%AA%E4%BD%8D%E7%BD%AE%EF%BC%8C%E9%80%90%E5%85%83%E7%B4%A0%E7%9A%84%E4%B9%98%E6%B3%95%E5%92%8C%E5%8A%A0%E6%B3%95%E9%83%BD%E4%BC%9A%E6%8F%90%E4%BE%9B%E4%B8%80%E4%B8%AA%E6%95%B0%E5%80%BC%E3%80%82%E5%9B%A0%E4%B8%BA%E8%BF%87%E6%BB%A4%E5%99%A8%E6%98%AF%E6%BB%91%E8%BF%87%E4%B8%80%E4%B8%AA%203D%20%E7%A9%BA%E9%97%B4%EF%BC%8C%E6%89%80%E4%BB%A5%E8%BE%93%E5%87%BA%E6%95%B0%E5%80%BC%E4%B9%9F%E6%8C%89%203D%20%E7%A9%BA%E9%97%B4%E6%8E%92%E5%B8%83%E3%80%82%E4%B9%9F%E5%B0%B1%E6%98%AF%E8%AF%B4%E8%BE%93%E5%87%BA%E6%98%AF%E4%B8%80%E4%B8%AA%203D%20%E6%95%B0%E6%8D%AE%E3%80%82 "在 3D 卷积中，3D 过滤器可以在所有三个方向（图像的高度、宽度、通道）上移动。在每个位置，逐元素的乘法和加法都会提供一个数值。因为过滤器是滑过一个 3D 空间，所以输出数值也按 3D 空间排布。也就是说输出是一个 3D 数据。")<br />与 2D 卷积（编码了 2D 域中目标的空间关系）类似，3D 卷积可以描述 3D 空间中目标的空间关系。对某些应用（比如生物医学影像中的 3D 分割/重构）而言，这样的 3D 关系很重要，比如在 CT 和 MRI 中，血管之类的目标会在 3D 空间中蜿蜒曲折。
<a name="FkpRB"></a>
##    转置卷积（去卷积）
对于很多网络架构的很多应用而言，往往需要进行与普通卷积方向相反的转换，即希望执行上采样。例子包括生成高分辨率图像以及将低维特征图映射到高维空间，比如在自动编码器或形义分割中。（在后者的例子中，形义分割首先会提取编码器中的特征图，然后在解码器中恢复原来的图像大小，使其可以分类原始图像中的每个像素。）<br />实现上采样的传统方法是应用插值方案或人工创建规则。而神经网络等现代架构则倾向于让网络自己自动学习合适的变换，无需人类干预。为了做到这一点，可以使用转置卷积。<br />转置卷积在文献中也被称为去卷积或 fractionally strided convolution。但是，需要指出「去卷积（deconvolution）」这个名称并不是很合适，因为转置卷积并非信号/图像处理领域定义的那种真正的去卷积。从技术上讲，信号处理中的去卷积是卷积运算的逆运算。但这里却不是这种运算。因此，某些作者强烈反对将转置卷积称为去卷积。人们称之为去卷积主要是因为这样说很简单。后面会介绍为什么将这种运算称为转置卷积更自然且更合适。<br />一直都可以使用直接的卷积实现转置卷积。对于下图的例子，在一个 2×2 的输入（周围加了 2×2 的单位步长的零填充）上应用一个 3×3 核的转置卷积。上采样输出的大小是 4×4。<br />![将 2×2 的输入上采样成 4×4 的输出](https://cdn.nlark.com/yuque/0/2022/jpeg/396745/1655546087140-e417e26d-a627-4ed2-a2d4-8def5ae4cc51.jpeg#clientId=u788e9171-2710-4&from=paste&id=uc9fac73a&originHeight=531&originWidth=473&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=shadow&taskId=uba2e07ad-d2b9-4da7-8876-8bf9c24b2d3&title=%E5%B0%86%202%C3%972%20%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8A%E9%87%87%E6%A0%B7%E6%88%90%204%C3%974%20%E7%9A%84%E8%BE%93%E5%87%BA "将 2×2 的输入上采样成 4×4 的输出")<br />有趣的是，通过应用各种填充和步长，可以将同样的 2×2 输入图像映射到不同的图像尺寸。下面，转置卷积被用在了同一张 2×2 输入上（输入之间插入了一个零，并且周围加了 2×2 的单位步长的零填充），所得输出的大小是 5×5。<br />![将 2×2 的输入上采样成 5×5 的输出](https://cdn.nlark.com/yuque/0/2022/jpeg/396745/1655546087481-652d6fc4-8998-4c7b-a4b8-21c79cccf709.jpeg#clientId=u788e9171-2710-4&from=paste&id=u86825333&originHeight=618&originWidth=543&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=shadow&taskId=ue4589b38-dd2c-4307-94e5-f082cf9fd4e&title=%E5%B0%86%202%C3%972%20%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8A%E9%87%87%E6%A0%B7%E6%88%90%205%C3%975%20%E7%9A%84%E8%BE%93%E5%87%BA "将 2×2 的输入上采样成 5×5 的输出")<br />观察上述例子中的转置卷积能帮助我们构建起一些直观认识。但为了泛化其应用，了解其可以如何通过计算机的矩阵乘法实现是有益的。从这一点上也可以看到为何「转置卷积」才是合适的名称。<br />在卷积中，定义 C 为卷积核，Large 为输入图像，Small 为输出图像。经过卷积（矩阵乘法）后，将大图像下采样为小图像。这种矩阵乘法的卷积的实现遵照：C x Large = Small。<br />下面的例子展示了这种运算的工作方式。它将输入平展为 16×1 的矩阵，并将卷积核转换为一个稀疏矩阵（4×16）。然后，在稀疏矩阵和平展的输入之间使用矩阵乘法。之后，再将所得到的矩阵（4×1）转换为 2×2 的输出。<br />![卷积的矩阵乘法：将 Large 输入图像（4×4）转换为 Small 输出图像（2×2）](https://cdn.nlark.com/yuque/0/2022/jpeg/396745/1655546087567-b030d28e-136e-407e-b9c5-22a3c9d38187.jpeg#clientId=u788e9171-2710-4&from=paste&id=u94eb3e72&originHeight=843&originWidth=877&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=shadow&taskId=u34d1a857-b44d-4631-8034-2448d535c82&title=%E5%8D%B7%E7%A7%AF%E7%9A%84%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%EF%BC%9A%E5%B0%86%20Large%20%E8%BE%93%E5%85%A5%E5%9B%BE%E5%83%8F%EF%BC%884%C3%974%EF%BC%89%E8%BD%AC%E6%8D%A2%E4%B8%BA%20Small%20%E8%BE%93%E5%87%BA%E5%9B%BE%E5%83%8F%EF%BC%882%C3%972%EF%BC%89 "卷积的矩阵乘法：将 Large 输入图像（4×4）转换为 Small 输出图像（2×2）")<br />现在，如果在等式的两边都乘上矩阵的转置 CT，并借助「一个矩阵与其转置矩阵的乘法得到一个单位矩阵」这一性质，那么就能得到公式 CT x Small = Large，如下图所示。<br />![卷积的矩阵乘法：将 Small 输入图像（2×2）转换为 Large 输出图像（4×4）](https://cdn.nlark.com/yuque/0/2022/jpeg/396745/1655546087580-0c78c78d-ac6f-4c56-9020-e22d5f88f3c1.jpeg#clientId=u788e9171-2710-4&from=paste&id=u1bb4bab6&originHeight=721&originWidth=877&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=shadow&taskId=u6a0b9b01-173f-4b82-9f32-e61b4c291d8&title=%E5%8D%B7%E7%A7%AF%E7%9A%84%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%EF%BC%9A%E5%B0%86%20Small%20%E8%BE%93%E5%85%A5%E5%9B%BE%E5%83%8F%EF%BC%882%C3%972%EF%BC%89%E8%BD%AC%E6%8D%A2%E4%B8%BA%20Large%20%E8%BE%93%E5%87%BA%E5%9B%BE%E5%83%8F%EF%BC%884%C3%974%EF%BC%89 "卷积的矩阵乘法：将 Small 输入图像（2×2）转换为 Large 输出图像（4×4）")<br />这里可以看到，执行了从小图像到大图像的上采样。这正是想要实现的目标。现在就知道「转置卷积」这个名字的由来了。<br />转置矩阵的算术解释可参阅：[https://arxiv.org/abs/1603.07285](https://arxiv.org/abs/1603.07285)
<a name="fa1cz"></a>
##    扩张卷积（Atrous 卷积）
扩张卷积由这两篇引入：

- [https://arxiv.org/abs/1412.7062](https://arxiv.org/abs/1412.7062)；
- [https://arxiv.org/abs/1511.07122](https://arxiv.org/abs/1511.07122)

这是一个标准的离散卷积：<br />![](https://cdn.nlark.com/yuque/0/2022/jpeg/396745/1655546087610-def17ca0-1c7f-47f3-8072-b74738cad034.jpeg#clientId=u788e9171-2710-4&from=paste&id=uca773bc6&originHeight=809&originWidth=877&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=u2ac1ff0f-b615-48f7-a24c-efc39224234&title=)<br />扩张卷积如下：<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1655546087649-ea78c069-f27e-4d00-b75e-488cb008fe90.png#clientId=u788e9171-2710-4&from=paste&id=u537d7a9d&originHeight=60&originWidth=490&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=u43d204c5-03d1-43d2-9646-242a40254ac&title=)<br />当 l=1 时，扩张卷积会变得和标准卷积一样。<br />![扩张卷积](https://cdn.nlark.com/yuque/0/2022/jpeg/396745/1655546087853-3d5e6d94-04a0-463c-a027-d8102bd93a1d.jpeg#clientId=u788e9171-2710-4&from=paste&id=ufb5836c7&originHeight=595&originWidth=617&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=shadow&taskId=u03e64841-b783-4505-a3fa-df87213ad1c&title=%E6%89%A9%E5%BC%A0%E5%8D%B7%E7%A7%AF "扩张卷积")<br />直观而言，扩张卷积就是通过在核元素之间插入空格来使核「膨胀」。新增的参数 l（扩张率）表示希望将核加宽的程度。具体实现可能各不相同，但通常是在核元素之间插入 l-1 个空格。下面展示了 l = 1, 2, 4 时的核大小。<br />![扩张卷积的感受野。基本上无需添加额外的成本就能有较大的感受野。](https://cdn.nlark.com/yuque/0/2022/jpeg/396745/1655546087976-8ce56550-7038-4743-8edd-d591a8add352.jpeg#clientId=u788e9171-2710-4&from=paste&id=CziOj&originHeight=339&originWidth=877&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=shadow&taskId=u2dff082a-5bd2-4e7a-a69c-bd6fa8af451&title=%E6%89%A9%E5%BC%A0%E5%8D%B7%E7%A7%AF%E7%9A%84%E6%84%9F%E5%8F%97%E9%87%8E%E3%80%82%E5%9F%BA%E6%9C%AC%E4%B8%8A%E6%97%A0%E9%9C%80%E6%B7%BB%E5%8A%A0%E9%A2%9D%E5%A4%96%E7%9A%84%E6%88%90%E6%9C%AC%E5%B0%B1%E8%83%BD%E6%9C%89%E8%BE%83%E5%A4%A7%E7%9A%84%E6%84%9F%E5%8F%97%E9%87%8E%E3%80%82 "扩张卷积的感受野。基本上无需添加额外的成本就能有较大的感受野。")<br />在这张图像中，3×3 的红点表示经过卷积后，输出图像是 3×3 像素。尽管所有这三个扩张卷积的输出都是同一尺寸，但模型观察到的感受野有很大的不同。l=1 时感受野为 3×3，l=2 时为 7×7。l=3 时，感受野的大小就增加到了 15×15。有趣的是，与这些操作相关的参数的数量是相等的。「观察」更大的感受野不会有额外的成本。因此，扩张卷积可用于廉价地增大输出单元的感受野，而不会增大其核大小，这在多个扩张卷积彼此堆叠时尤其有效。<br />论文《Multi-scale context aggregation by dilated convolutions》的作者用多个扩张卷积层构建了一个网络，其中扩张率 l 每层都按指数增大。由此，有效的感受野大小随层而指数增长，而参数的数量仅线性增长。<br />这篇论文中扩张卷积的作用是系统性地聚合多个比例的形境信息，而不丢失分辨率。这篇论文表明其提出的模块能够提升那时候（2016 年）的当前最佳形义分割系统的准确度。请参阅那篇论文了解更多信息。
<a name="RQIdJ"></a>
##    可分卷积
某些神经网络架构使用了可分卷积，比如 MobileNets。可分卷积有空间可分卷积和深度可分卷积。
<a name="XzEUz"></a>
### 1、空间可分卷积
空间可分卷积操作的是图像的 2D 空间维度，即高和宽。从概念上看，空间可分卷积是将一个卷积分解为两个单独的运算。对于下面的示例，3×3 的 Sobel 核被分成了一个 3×1 核和一个 1×3 核。<br />![Sobel 核可分为一个 3x1 和一个 1x3 核](https://cdn.nlark.com/yuque/0/2022/png/396745/1655546087995-39adb5d4-a2b9-4ae5-ae43-73962b4c4a69.png#clientId=u788e9171-2710-4&from=paste&id=ub49c4cc5&originHeight=189&originWidth=877&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=shadow&taskId=uc8f94a51-a3d2-470a-ae59-cd0aa8f0e27&title=Sobel%20%E6%A0%B8%E5%8F%AF%E5%88%86%E4%B8%BA%E4%B8%80%E4%B8%AA%203x1%20%E5%92%8C%E4%B8%80%E4%B8%AA%201x3%20%E6%A0%B8 "Sobel 核可分为一个 3x1 和一个 1x3 核")<br />在卷积中，3×3 核直接与图像卷积。在空间可分卷积中，3×1 核首先与图像卷积，然后再应用 1×3 核。这样，执行同样的操作时仅需 6 个参数，而不是 9 个。<br />此外，使用空间可分卷积时所需的矩阵乘法也更少。给一个具体的例子，5×5 图像与 3×3 核的卷积（步幅=1，填充=0）要求在 3 个位置水平地扫描核（还有 3 个垂直的位置）。总共就是 9 个位置，表示为下图中的点。在每个位置，会应用 9 次逐元素乘法。总共就是 9×9=81 次乘法。<br />![具有 1 个通道的标准卷积](https://cdn.nlark.com/yuque/0/2022/jpeg/396745/1655546088047-14ce56f2-17d2-429c-805e-50f16857f3c7.jpeg#clientId=u788e9171-2710-4&from=paste&id=u4f5359d8&originHeight=322&originWidth=877&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=shadow&taskId=u4fa99ceb-58ed-408f-bd4a-59bb76b4ff5&title=%E5%85%B7%E6%9C%89%201%20%E4%B8%AA%E9%80%9A%E9%81%93%E7%9A%84%E6%A0%87%E5%87%86%E5%8D%B7%E7%A7%AF "具有 1 个通道的标准卷积")<br />另一方面，对于空间可分卷积，首先在 5×5 的图像上应用一个 3×1 的过滤器。可以在水平 5 个位置和垂直 3 个位置扫描这样的核。总共就是 5×3=15 个位置，表示为下图中的点。在每个位置，会应用 3 次逐元素乘法。总共就是 15×3=45 次乘法。现在得到了一个 3×5 的矩阵。这个矩阵再与一个 1×3 核卷积，即在水平 3 个位置和垂直 3 个位置扫描这个矩阵。对于这 9 个位置中的每一个，应用 3 次逐元素乘法。这一步需要 9×3=27 次乘法。因此，总体而言，空间可分卷积需要 45+27=72 次乘法，少于普通卷积。<br />![具有 1 个通道的空间可分卷积](https://cdn.nlark.com/yuque/0/2022/jpeg/396745/1655546088045-28a61770-beee-45c1-b703-25e98115ee8e.jpeg#clientId=u788e9171-2710-4&from=paste&id=uec9cd068&originHeight=268&originWidth=877&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=shadow&taskId=u7c54eb74-6ff0-4ed2-bdab-5cb328b505b&title=%E5%85%B7%E6%9C%89%201%20%E4%B8%AA%E9%80%9A%E9%81%93%E7%9A%84%E7%A9%BA%E9%97%B4%E5%8F%AF%E5%88%86%E5%8D%B7%E7%A7%AF "具有 1 个通道的空间可分卷积")们稍微推广一下上面的例子。假设现在将卷积应用于一张 N×N 的图像上，卷积核为 m×m，步幅为 1，填充为 0。传统卷积需要 (N-2) x (N-2) x m x m 次乘法，空间可分卷积需要 N x (N-2) x m + (N-2) x (N-2) x m = (2N-2) x (N-2) x m 次乘法。空间可分卷积与标准卷积的计算成本比为：<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1655546088187-02ed99b6-0e85-4ca4-a37f-c4f06d30abec.png#clientId=u788e9171-2710-4&from=paste&id=u153100cd&originHeight=159&originWidth=393&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=u877484e2-bc54-40a5-aa12-d75d97c7e34&title=)<br />因为图像尺寸 N 远大于过滤器大小（N>>m），所以这个比就变成了 2/m。也就是说，在这种渐进情况（N>>m）下，当过滤器大小为 3×3 时，空间可分卷积的计算成本是标准卷积的 2/3。过滤器大小为 5×5 时这一数值是 2/5；过滤器大小为 7×7 时则为 2/7。<br />尽管空间可分卷积能节省成本，但深度学习却很少使用它。一大主要原因是并非所有的核都能分成两个更小的核。如果用空间可分卷积替代所有的传统卷积，那么就限制了自己在训练过程中搜索所有可能的核。这样得到的训练结果可能是次优的。
<a name="t7LjN"></a>
### 2、深度可分卷积
现在来看深度可分卷积，这在深度学习领域要常用得多（比如 MobileNet 和 Xception）。深度可分卷积包含两个步骤：深度卷积核 1×1 卷积。<br />在描述这些步骤之前，有必要回顾一下之前介绍的 2D 卷积核 1×1 卷积。首先快速回顾标准的 2D 卷积。举一个具体例子，假设输入层的大小是 7×7×3（高×宽×通道），而过滤器的大小是 3×3×3。经过与一个过滤器的 2D 卷积之后，输出层的大小是 5×5×1（仅有一个通道）。<br />![用于创建仅有 1 层的输出的标准 2D 卷积，使用 1 个过滤器](https://cdn.nlark.com/yuque/0/2022/jpeg/396745/1655546088335-fd489dbe-731e-49ff-95dd-8bf4c0900e0b.jpeg#clientId=u788e9171-2710-4&from=paste&id=u438aa7c9&originHeight=329&originWidth=877&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=shadow&taskId=u21ec0485-fbe7-4115-bb8c-7301c4f7ae7&title=%E7%94%A8%E4%BA%8E%E5%88%9B%E5%BB%BA%E4%BB%85%E6%9C%89%201%20%E5%B1%82%E7%9A%84%E8%BE%93%E5%87%BA%E7%9A%84%E6%A0%87%E5%87%86%202D%20%E5%8D%B7%E7%A7%AF%EF%BC%8C%E4%BD%BF%E7%94%A8%201%20%E4%B8%AA%E8%BF%87%E6%BB%A4%E5%99%A8 "用于创建仅有 1 层的输出的标准 2D 卷积，使用 1 个过滤器")<br />一般来说，两个神经网络层之间会应用多个过滤器。假设这里有 128 个过滤器。在应用了这 128 个 2D 卷积之后，有 128 个 5×5×1 的输出映射图（map）。然后将这些映射图堆叠成大小为 5×5×128 的单层。通过这种操作，可将输入层（7×7×3）转换成输出层（5×5×128）。空间维度（即高度和宽度）会变小，而深度会增大。<br />![用于创建有 128 层的输出的标准 2D 卷积，要使用 128 个过滤器](https://cdn.nlark.com/yuque/0/2022/jpeg/396745/1655546088368-54f0618c-88ba-4854-9bf1-55ba543eabd2.jpeg#clientId=u788e9171-2710-4&from=paste&id=ud552637b&originHeight=296&originWidth=877&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=shadow&taskId=ufdc740c7-df89-429b-a4ce-36db2ff81a8&title=%E7%94%A8%E4%BA%8E%E5%88%9B%E5%BB%BA%E6%9C%89%20128%20%E5%B1%82%E7%9A%84%E8%BE%93%E5%87%BA%E7%9A%84%E6%A0%87%E5%87%86%202D%20%E5%8D%B7%E7%A7%AF%EF%BC%8C%E8%A6%81%E4%BD%BF%E7%94%A8%20128%20%E4%B8%AA%E8%BF%87%E6%BB%A4%E5%99%A8 "用于创建有 128 层的输出的标准 2D 卷积，要使用 128 个过滤器")<br />现在使用深度可分卷积，看看如何实现同样的变换。<br />首先，将深度卷积应用于输入层。但不使用 2D 卷积中大小为 3×3×3 的单个过滤器，而是分开使用 3 个核。每个过滤器的大小为 3×3×1。每个核与输入层的一个通道卷积（仅一个通道，而非所有通道！）。每个这样的卷积都能提供大小为 5×5×1 的映射图。然后将这些映射图堆叠在一起，创建一个 5×5×3 的图像。经过这个操作之后，得到大小为 5×5×3 的输出。现在可以降低空间维度了，但深度还是和之前一样。<br />![](https://cdn.nlark.com/yuque/0/2022/jpeg/396745/1655546088418-9df87494-a53b-436d-a794-1dbc1ecab86e.jpeg#clientId=u788e9171-2710-4&from=paste&id=u36845a23&originHeight=317&originWidth=877&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=uaaf8fa03-3057-4543-b385-cf4217f7f8b&title=)<br />深度可分卷积——第一步：不使用 2D 卷积中大小为 3×3×3 的单个过滤器，而是分开使用 3 个核。每个过滤器的大小为 3×3×1。每个核与输入层的一个通道卷积（仅一个通道，而非所有通道！）。每个这样的卷积都能提供大小为 5×5×1 的映射图。然后将这些映射图堆叠在一起，创建一个 5×5×3 的图像。经过这个操作之后，得到大小为 5×5×3 的输出。<br />在深度可分卷积的第二步，为了扩展深度，应用一个核大小为 1×1×3 的 1×1 卷积。将 5×5×3 的输入图像与每个 1×1×3 的核卷积，可得到大小为 5×5×1 的映射图。<br />![](https://cdn.nlark.com/yuque/0/2022/jpeg/396745/1655546088454-bb69df6c-4cf1-4065-97fc-bb5c31a9c981.jpeg#clientId=u788e9171-2710-4&from=paste&id=u3fcfceb8&originHeight=270&originWidth=877&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=u343dbdfa-e462-4216-9e5f-f25503baa13&title=)<br />因此，在应用了 128 个 1×1 卷积之后，得到大小为 5×5×128 的层。<br />![深度可分卷积——第二步：应用多个 1×1 卷积来修改深度。](https://cdn.nlark.com/yuque/0/2022/jpeg/396745/1655546088556-dbad4a42-80bc-443a-9158-9bf834096c68.jpeg#clientId=u788e9171-2710-4&from=paste&id=u0a59bc56&originHeight=312&originWidth=900&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=shadow&taskId=ud13f6548-9888-417d-94b3-495b809f095&title=%E6%B7%B1%E5%BA%A6%E5%8F%AF%E5%88%86%E5%8D%B7%E7%A7%AF%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A%E5%BA%94%E7%94%A8%E5%A4%9A%E4%B8%AA%201%C3%971%20%E5%8D%B7%E7%A7%AF%E6%9D%A5%E4%BF%AE%E6%94%B9%E6%B7%B1%E5%BA%A6%E3%80%82 "深度可分卷积——第二步：应用多个 1×1 卷积来修改深度。")<br />通过这两个步骤，深度可分卷积也会将输入层（7×7×3）变换到输出层（5×5×128）。<br />下图展示了深度可分卷积的整个过程。<br />![深度可分卷积的整个过程](https://cdn.nlark.com/yuque/0/2022/jpeg/396745/1655546088809-8b908db2-168e-4cc7-94a1-1d9ac639b827.jpeg#clientId=u788e9171-2710-4&from=paste&id=u6e001f3e&originHeight=186&originWidth=900&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=shadow&taskId=ubb33c526-aa1f-4402-9a43-9cb0829ac76&title=%E6%B7%B1%E5%BA%A6%E5%8F%AF%E5%88%86%E5%8D%B7%E7%A7%AF%E7%9A%84%E6%95%B4%E4%B8%AA%E8%BF%87%E7%A8%8B "深度可分卷积的整个过程")<br />所以，深度可分卷积有何优势呢？效率！相比于 2D 卷积，深度可分卷积所需的操作要少得多。<br />回忆一下 2D 卷积例子的计算成本。有 128 个 3×3×3 个核移动了 5×5 次，也就是 128 x 3 x 3 x 3 x 5 x 5 = 86400 次乘法。<br />可分卷积又如何呢？在第一个深度卷积步骤，有 3 个 3×3×1 核移动 5×5 次，也就是 3x3x3x1x5x5 = 675 次乘法。在 1×1 卷积的第二步，有 128 个 1×1×3 核移动 5×5 次，即 128 x 1 x 1 x 3 x 5 x 5 = 9600 次乘法。因此，深度可分卷积共有 675 + 9600 = 10275 次乘法。这样的成本大概仅有 2D 卷积的 12%！<br />所以，对于任意尺寸的图像，如果应用深度可分卷积，可以节省多少时间？泛化以上例子。现在，对于大小为 H×W×D 的输入图像，如果使用 Nc 个大小为 h×h×D 的核执行 2D 卷积（步幅为 1，填充为 0，其中 h 是偶数）。为了将输入层（H×W×D）变换到输出层（(H-h+1)x (W-h+1) x Nc），所需的总乘法次数为：<br />**Nc x h x h x D x (H-h+1) x (W-h+1)**<br />另一方面，对于同样的变换，深度可分卷积所需的乘法次数为：<br />**D x h x h x 1 x (H-h+1) x (W-h+1) + Nc x 1 x 1 x D x (H-h+1) x (W-h+1) = (h x h + Nc) x D x (H-h+1) x (W-h+1)**<br />则深度可分卷积与 2D 卷积所需的乘法次数比为：<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1655546088802-4c2847e2-cea7-44c2-bb57-cb7900cd58e7.png#clientId=u788e9171-2710-4&from=paste&id=u06340ab1&originHeight=113&originWidth=197&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=uae1240dc-3da4-4f79-8d39-2cf89764684&title=)<br />现代大多数架构的输出层通常都有很多通道，可达数百甚至上千。对于这样的层（Nc >> h），则上式可约简为 1 / h²。基于此，如果使用 3×3 过滤器，则 2D 卷积所需的乘法次数是深度可分卷积的 9 倍。如果使用 5×5 过滤器，则 2D 卷积所需的乘法次数是深度可分卷积的 25 倍。<br />使用深度可分卷积有什么坏处吗？当然是有的。深度可分卷积会降低卷积中参数的数量。因此，对于较小的模型而言，如果用深度可分卷积替代 2D 卷积，模型的能力可能会显著下降。因此，得到的模型可能是次优的。但是，如果使用得当，深度可分卷积能在不降低模型性能的前提下实现效率提升。
<a name="lHvnd"></a>
##    分组卷积
AlexNet 论文（[https://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf](https://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf)）在 2012 年引入了分组卷积。实现分组卷积的主要原因是让网络训练可在 2 个内存有限（每个 GPU 有 1.5 GB 内存）的 GPU 上进行。下面的 AlexNet 表明在大多数层中都有两个分开的卷积路径。这是在两个 GPU 上执行模型并行化（当然如果可以使用更多 GPU，还能执行多 GPU 并行化）。<br />![图片来自 AlexNet 论文](https://cdn.nlark.com/yuque/0/2022/jpeg/396745/1655546088780-53873f64-4d45-451e-a3c4-07b65ae5cfaf.jpeg#clientId=u788e9171-2710-4&from=paste&id=u04257eb5&originHeight=281&originWidth=900&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=shadow&taskId=u7e1c9bff-e986-4249-abb0-9ec10a16664&title=%E5%9B%BE%E7%89%87%E6%9D%A5%E8%87%AA%20AlexNet%20%E8%AE%BA%E6%96%87 "图片来自 AlexNet 论文")<br />这里介绍一下分组卷积的工作方式。首先，典型的 2D 卷积的步骤如下图所示。在这个例子中，通过应用 128 个大小为 3×3×3 的过滤器将输入层（7×7×3）变换到输出层（5×5×128）。推广而言，即通过应用 Dout 个大小为 h x w x Din 的核将输入层（Hin x Win x Din）变换到输出层（Hout x Wout x Dout）。<br />![标准的 2D 卷积](https://cdn.nlark.com/yuque/0/2022/jpeg/396745/1655546088891-f53e6f3a-22f0-4a6f-95d8-02aae453e7bf.jpeg#clientId=u788e9171-2710-4&from=paste&id=u60a048f6&originHeight=248&originWidth=900&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=shadow&taskId=uf9cb186d-4c1d-4373-882a-e45fa48fcbb&title=%E6%A0%87%E5%87%86%E7%9A%84%202D%20%E5%8D%B7%E7%A7%AF "标准的 2D 卷积")<br />在分组卷积中，过滤器会被分为不同的组。每一组都负责特定深度的典型 2D 卷积。下面的例子能让你更清楚地理解。<br />![具有两个过滤器分组的分组卷积](https://cdn.nlark.com/yuque/0/2022/jpeg/396745/1655546088997-344f6ff3-93e1-49fd-ac34-0efaa4b98a99.jpeg#clientId=u788e9171-2710-4&from=paste&id=uca71c732&originHeight=413&originWidth=900&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=shadow&taskId=u8b9b7898-971c-4b3c-bbfd-cdcbe6d793e&title=%E5%85%B7%E6%9C%89%E4%B8%A4%E4%B8%AA%E8%BF%87%E6%BB%A4%E5%99%A8%E5%88%86%E7%BB%84%E7%9A%84%E5%88%86%E7%BB%84%E5%8D%B7%E7%A7%AF "具有两个过滤器分组的分组卷积")<br />上图展示了具有两个过滤器分组的分组卷积。在每个过滤器分组中，每个过滤器的深度仅有名义上的 2D 卷积的一半。它们的深度是 Din/2。每个过滤器分组包含 Dout/2 个过滤器。第一个过滤器分组（红色）与输入层的前一半（[:, :, 0:Din/2]）卷积，而第二个过滤器分组（橙色）与输入层的后一半（[:, :, Din/2:Din]）卷积。因此，每个过滤器分组都会创建 Dout/2 个通道。整体而言，两个分组会创建 2×Dout/2 = Dout 个通道。然后将这些通道堆叠在一起，得到有 Dout 个通道的输出层。
<a name="Eeuu5"></a>
### 1、分组卷积与深度卷积
可能会注意到分组卷积与深度可分卷积中使用的深度卷积之间存在一些联系和差异。如果过滤器分组的数量与输入层通道的数量相同，则每个过滤器的深度都为 Din/Din=1。这样的过滤器深度就与深度卷积中的一样了。<br />另一方面，现在每个过滤器分组都包含 Dout/Din 个过滤器。整体而言，输出层的深度为 Dout。这不同于深度卷积的情况——深度卷积并不会改变层的深度。在深度可分卷积中，层的深度之后通过 1×1 卷积进行扩展。<br />分组卷积有几个优点。<br />第一个优点是高效训练。因为卷积被分成了多个路径，每个路径都可由不同的 GPU 分开处理，所以模型可以并行方式在多个 GPU 上进行训练。相比于在单个 GPU 上完成所有任务，这样的在多个 GPU 上的模型并行化能让网络在每个步骤处理更多图像。人们一般认为模型并行化比数据并行化更好。后者是将数据集分成多个批次，然后分开训练每一批。但是，当批量大小变得过小时，本质上是执行随机梯度下降，而非批梯度下降。这会造成更慢，有时候更差的收敛结果。<br />在训练非常深的神经网络时，分组卷积会非常重要，正如在 ResNeXt 中那样。<br />![图片来自 ResNeXt 论文，https://arxiv.org/abs/1611.05431](https://cdn.nlark.com/yuque/0/2022/jpeg/396745/1655546089134-78b1fb69-be55-4fc8-85db-1cd48f7ad26c.jpeg#clientId=u788e9171-2710-4&from=paste&id=xCsVf&originHeight=332&originWidth=900&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=shadow&taskId=ub049cb1f-fcef-4873-a462-f2cb08bf6ad&title=%E5%9B%BE%E7%89%87%E6%9D%A5%E8%87%AA%20ResNeXt%20%E8%AE%BA%E6%96%87%EF%BC%8Chttps%3A%2F%2Farxiv.org%2Fabs%2F1611.05431 "图片来自 ResNeXt 论文，https://arxiv.org/abs/1611.05431")<br />第二个优点是模型会更高效，即模型参数会随过滤器分组数的增大而减少。在之前的例子中，完整的标准 2D 卷积有 h x w x Din x Dout 个参数。具有 2 个过滤器分组的分组卷积有 (h x w x Din/2 x Dout/2) x 2 个参数。参数数量减少了一半。<br />第三个优点有些让人惊讶。分组卷积也许能提供比标准完整 2D 卷积更好的模型。另一篇出色的博客已经解释了这一点：[https://blog.yani.io/filter-group-tutorial](https://blog.yani.io/filter-group-tutorial)。这里简要总结一下。<br />原因和稀疏过滤器的关系有关。下图是相邻层过滤器的相关性。其中的关系是稀疏的。<br />![在 CIFAR10 上训练的一个 Network-in-Network 模型中相邻层的过滤器的相关性矩阵。高度相关的过滤器对更明亮，而相关性更低的过滤器则更暗。图片来自：https://blog.yani.io/filter-group-tutorial](https://cdn.nlark.com/yuque/0/2022/jpeg/396745/1655546089237-8c1a6b79-2aa8-405f-874d-7dc74536fd8f.jpeg#clientId=u788e9171-2710-4&from=paste&id=uf049a929&originHeight=373&originWidth=373&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=shadow&taskId=u4e40187a-e911-49db-ba39-d8becc6ce07&title=%E5%9C%A8%20CIFAR10%20%E4%B8%8A%E8%AE%AD%E7%BB%83%E7%9A%84%E4%B8%80%E4%B8%AA%20Network-in-Network%20%E6%A8%A1%E5%9E%8B%E4%B8%AD%E7%9B%B8%E9%82%BB%E5%B1%82%E7%9A%84%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E7%9B%B8%E5%85%B3%E6%80%A7%E7%9F%A9%E9%98%B5%E3%80%82%E9%AB%98%E5%BA%A6%E7%9B%B8%E5%85%B3%E7%9A%84%E8%BF%87%E6%BB%A4%E5%99%A8%E5%AF%B9%E6%9B%B4%E6%98%8E%E4%BA%AE%EF%BC%8C%E8%80%8C%E7%9B%B8%E5%85%B3%E6%80%A7%E6%9B%B4%E4%BD%8E%E7%9A%84%E8%BF%87%E6%BB%A4%E5%99%A8%E5%88%99%E6%9B%B4%E6%9A%97%E3%80%82%E5%9B%BE%E7%89%87%E6%9D%A5%E8%87%AA%EF%BC%9Ahttps%3A%2F%2Fblog.yani.io%2Ffilter-group-tutorial "在 CIFAR10 上训练的一个 Network-in-Network 模型中相邻层的过滤器的相关性矩阵。高度相关的过滤器对更明亮，而相关性更低的过滤器则更暗。图片来自：https://blog.yani.io/filter-group-tutorial")<br />分组矩阵的相关性映射图又如何？<br />![在 CIFAR10 上训练的一个 Network-in-Network 模型中相邻层的过滤器的相关性，动图分别展示了有 1、2、4、8、16 个过滤器分组的情况。图片来自 https://blog.yani.io/filter-group-tutorial](https://cdn.nlark.com/yuque/0/2022/jpeg/396745/1655546089246-82dbf360-ea9c-4a9b-9f01-d9a1e6f63ae6.jpeg#clientId=u788e9171-2710-4&from=paste&id=ud3ff0203&originHeight=423&originWidth=426&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=shadow&taskId=u765974a0-7d1f-4d93-9441-4277570efc9&title=%E5%9C%A8%20CIFAR10%20%E4%B8%8A%E8%AE%AD%E7%BB%83%E7%9A%84%E4%B8%80%E4%B8%AA%20Network-in-Network%20%E6%A8%A1%E5%9E%8B%E4%B8%AD%E7%9B%B8%E9%82%BB%E5%B1%82%E7%9A%84%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E7%9B%B8%E5%85%B3%E6%80%A7%EF%BC%8C%E5%8A%A8%E5%9B%BE%E5%88%86%E5%88%AB%E5%B1%95%E7%A4%BA%E4%BA%86%E6%9C%89%201%E3%80%812%E3%80%814%E3%80%818%E3%80%8116%20%E4%B8%AA%E8%BF%87%E6%BB%A4%E5%99%A8%E5%88%86%E7%BB%84%E7%9A%84%E6%83%85%E5%86%B5%E3%80%82%E5%9B%BE%E7%89%87%E6%9D%A5%E8%87%AA%20https%3A%2F%2Fblog.yani.io%2Ffilter-group-tutorial "在 CIFAR10 上训练的一个 Network-in-Network 模型中相邻层的过滤器的相关性，动图分别展示了有 1、2、4、8、16 个过滤器分组的情况。图片来自 https://blog.yani.io/filter-group-tutorial")<br />上图是当用 1、2、4、8、16 个过滤器分组训练模型时，相邻层的过滤器之间的相关性。那篇文章提出了一个推理：「过滤器分组的效果是在通道维度上学习块对角结构的稀疏性……在网络中，具有高相关性的过滤器是使用过滤器分组以一种更为结构化的方式学习到。从效果上看，不必学习的过滤器关系就不再参数化。这样显著地减少网络中的参数数量能使其不容易过拟合，因此，一种类似正则化的效果让优化器可以学习得到更准确更高效的深度网络。」<br />![AlexNet conv1 过滤器分解：正如作者指出的那样，过滤器分组似乎会将学习到的过滤器结构性地组织成两个不同的分组。本图来自 AlexNet 论文。](https://cdn.nlark.com/yuque/0/2022/jpeg/396745/1655546089203-f9a4b873-8a66-452a-b6e8-f859ca47dc8f.jpeg#clientId=u788e9171-2710-4&from=paste&id=u53e74cc4&originHeight=266&originWidth=678&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=shadow&taskId=u12f66e34-cff2-433a-8cb1-56638bab9a2&title=AlexNet%20conv1%20%E8%BF%87%E6%BB%A4%E5%99%A8%E5%88%86%E8%A7%A3%EF%BC%9A%E6%AD%A3%E5%A6%82%E4%BD%9C%E8%80%85%E6%8C%87%E5%87%BA%E7%9A%84%E9%82%A3%E6%A0%B7%EF%BC%8C%E8%BF%87%E6%BB%A4%E5%99%A8%E5%88%86%E7%BB%84%E4%BC%BC%E4%B9%8E%E4%BC%9A%E5%B0%86%E5%AD%A6%E4%B9%A0%E5%88%B0%E7%9A%84%E8%BF%87%E6%BB%A4%E5%99%A8%E7%BB%93%E6%9E%84%E6%80%A7%E5%9C%B0%E7%BB%84%E7%BB%87%E6%88%90%E4%B8%A4%E4%B8%AA%E4%B8%8D%E5%90%8C%E7%9A%84%E5%88%86%E7%BB%84%E3%80%82%E6%9C%AC%E5%9B%BE%E6%9D%A5%E8%87%AA%20AlexNet%20%E8%AE%BA%E6%96%87%E3%80%82 "AlexNet conv1 过滤器分解：正如作者指出的那样，过滤器分组似乎会将学习到的过滤器结构性地组织成两个不同的分组。本图来自 AlexNet 论文。")<br />此外，每个过滤器分组都会学习数据的一个独特表征。正如 AlexNet 的作者指出的那样，过滤器分组似乎会将学习到的过滤器结构性地组织成两个不同的分组——黑白过滤器和彩色过滤器。
