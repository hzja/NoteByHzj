AIXGBoost
<a name="EDIod"></a>
## 前言
XGBoost（eXtreme Gradient Boosting）全名叫极端梯度提升，XGBoost是集成学习方法的王牌，在Kaggle数据挖掘比赛中，大部分获胜者用了XGBoost，XGBoost在绝大多数的回归和分类问题上表现的十分顶尖，本文较详细的介绍了XGBoost的算法原理。
<a name="UJwEx"></a>
## 目录

---

1. 最优模型的构建方法
2. Boosting的回归思想
3. XGBoost的目标函数推导
4. XGBoost的回归树构建方法
5. XGBoost与GDBT的区别
<a name="iFysF"></a>
## 最优模型的构建方法
构建最优模型的一般方法是最小化训练数据的损失函数，用字母 L表示，如下式：<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1656555367455-6a490092-cafa-496e-83fc-d65ffed0796d.png#clientId=uc9c63499-89ab-4&from=paste&id=uabdce29a&originHeight=87&originWidth=275&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=ub0ec6429-ebdc-42db-969a-3c568209086&title=)<br />式（1）称为经验风险最小化，训练得到的模型复杂度较高。当训练数据较小时，模型很容易出现过拟合问题。<br />因此，为了降低模型的复杂度，常采用下式：<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1656555367480-222d1a74-ca1b-4500-b968-f4b46602d6db.png#clientId=uc9c63499-89ab-4&from=paste&id=u06ea5a95&originHeight=52&originWidth=351&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=ubbd3cb86-4246-4cfb-81f6-597e2888c93&title=)<br />其中J(f)为模型的复杂度，式（2）称为结构风险最小化，结构风险最小化的模型往往对训练数据以及未知的测试数据都有较好的预测 。<br />应用：决策树的生成和剪枝分别对应了经验风险最小化和结构风险最小化，XGBoost的决策树生成是结构风险最小化的结果，后续会详细介绍。
<a name="kf9xH"></a>
## Boosting方法的回归思想
Boosting法是结合多个弱学习器给出最终的学习结果，不管任务是分类或回归，都用回归任务的思想来构建最优Boosting模型 。<br />回归思想：把每个弱学习器的输出结果当成连续值，这样做的目的是可以对每个弱学习器的结果进行累加处理，且能更好的利用损失函数来优化模型。<br />假设![](https://cdn.nlark.com/yuque/0/2022/png/396745/1656555367455-5e71e50e-cb77-406e-9d94-8a6238ace661.png#clientId=uc9c63499-89ab-4&from=paste&id=u2532725c&originHeight=36&originWidth=60&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=u92e43baf-0fa0-40bc-b5bf-3eadc9e6a98&title=)是第 t 轮弱学习器的输出结果，![](https://cdn.nlark.com/yuque/0/2022/png/396745/1656555367513-ea55028f-bd7b-444c-9bcf-272c52d69def.png#clientId=uc9c63499-89ab-4&from=paste&id=ua4dd39e7&originHeight=47&originWidth=27&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=u4368f7fc-a1a2-4453-b0de-4386645fe06&title=)是模型的输出结果，![](https://cdn.nlark.com/yuque/0/2022/png/396745/1656555367511-e41f86ac-d58c-480d-98aa-41d1e756b177.png#clientId=uc9c63499-89ab-4&from=paste&id=u5e36c8e8&originHeight=26&originWidth=24&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=ue2d9c05f-787d-41c9-b312-3df34cc0735&title=)是实际输出结果，表达式如下：<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1656555367871-f9479517-157a-4d71-9d2f-df2d23083c58.png#clientId=uc9c63499-89ab-4&from=paste&id=u6b138403&originHeight=110&originWidth=269&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=u0f25d712-e32f-4ffa-bb89-01dc3d7de8d&title=)<br />上面两式就是加法模型，都默认弱学习器的输出结果是连续值。因为回归任务的弱学习器本身是连续值，所以不做讨论，下面详细介绍分类任务的回归思想。
<a name="HkWFn"></a>
### 分类任务的回归思想：
根据2.1式的结果，得到最终的分类器：<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1656555367896-f07718b2-17a5-4579-942e-dc8e5ee20cc0.png#clientId=uc9c63499-89ab-4&from=paste&id=u9fd96b18&originHeight=58&originWidth=393&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=u901b0ea6-1b29-4129-a891-04863401880&title=)<br />分类的损失函数一般选择指数函数或对数函数，这里假设损失函数为对数函数，学习器的损失函数是<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1656555367786-79daa829-f8b6-43e4-80b1-fba718838ce3.png#clientId=uc9c63499-89ab-4&from=paste&id=ueeec4172&originHeight=37&originWidth=345&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=u5c956ea2-51a7-4fd8-a575-410351cb6d3&title=)<br />若实际输出结果yi=1，则：<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1656555367908-c8fe0c52-a1da-499d-9d72-f88df89d00d3.png#clientId=uc9c63499-89ab-4&from=paste&id=u71f76901&originHeight=48&originWidth=314&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=uee0266f4-9d7c-49e6-b41e-348f3f05ded&title=)<br />求（2.5）式对![](https://cdn.nlark.com/yuque/0/2022/png/396745/1656555368456-b05402e5-b857-497e-b17b-a741108444cc.png#clientId=uc9c63499-89ab-4&from=paste&id=u27378da5&originHeight=47&originWidth=39&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=u453a7801-19e0-4847-bee9-58c8e7c84fe&title=)的梯度，得：<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1656555368175-ce4334a5-f122-455a-ba6d-c44a7d04b869.png#clientId=uc9c63499-89ab-4&from=paste&id=u55f2dd9c&originHeight=95&originWidth=197&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=u67dcd760-add0-4904-ac10-07b84012d39&title=)<br />负梯度方向是损失函数下降最快的方向，（2.6）式取反的值大于0，因此弱学习器是往增大![](https://cdn.nlark.com/yuque/0/2022/png/396745/1656555368415-127ec571-dbc2-45a0-b97b-0ba64cc5acbd.png#clientId=uc9c63499-89ab-4&from=paste&id=u23dbb145&originHeight=54&originWidth=40&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=uf0f3718e-f680-4827-9085-c897b5a61de&title=)的方向迭代的，图形表示为：<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1656555368305-4b761eed-5990-4265-a625-ee92529e1881.png#clientId=uc9c63499-89ab-4&from=paste&id=ubde1c1d9&originHeight=283&originWidth=389&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=u781df72a-2bb3-45d1-8635-32cfb1f922b&title=)<br />如上图，当样本的实际标记 yi 是 1 时，模型输出结果![](https://cdn.nlark.com/yuque/0/2022/png/396745/1656555368246-5eeb0951-191d-49c5-94ce-64ddae40ef19.png#clientId=uc9c63499-89ab-4&from=paste&id=u73c6abf7&originHeight=54&originWidth=40&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=ucfe917a8-e19e-4e81-a93e-2b059cdd5ca&title=)随着迭代次数的增加而增加（红线箭头），模型的损失函数相应的减小；当样本的实际标记 yi 是 -1时，模型输出结果![](https://cdn.nlark.com/yuque/0/2022/png/396745/1656555368557-10b61fb7-eceb-4e50-9df8-654defd2c393.png#clientId=uc9c63499-89ab-4&from=paste&id=ud862b815&originHeight=54&originWidth=40&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=u23ab5a5d-27df-468b-a9e0-fbc50db5718&title=)随着迭代次数的增加而减小（红线箭头），模型的损失函数相应的减小 。这就是加法模型的原理所在，通过多次的迭代达到减小损失函数的目的。<br />小结：Boosting方法把每个弱学习器的输出看成是连续值，使得损失函数是个连续值，因此可以通过弱学习器的迭代达到优化模型的目的，这也是集成学习法加法模型的原理所在 。
<a name="rRtOL"></a>
## XGBoost算法的目标函数推导
目标函数，即损失函数，通过最小化损失函数来构建最优模型，由第一节可知， 损失函数应加上表示模型复杂度的正则项，且XGBoost对应的模型包含了多个CART树，因此，模型的目标函数为：<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1656555368631-550dca69-995c-4d90-8458-7e4ddb6d940c.png#clientId=uc9c63499-89ab-4&from=paste&id=u08c31294&originHeight=54&originWidth=357&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=u6de3cfa6-c51c-47d1-b0c1-940ad3247e8&title=)<br />（3.1）式是正则化的损失函数，等式右边第一部分是模型的训练误差，第二部分是正则化项，这里的正则化项是K棵树的正则化项相加而来的。
<a name="XAcw1"></a>
### CART树的介绍
![](https://cdn.nlark.com/yuque/0/2022/png/396745/1656555368741-09872c98-0a64-419e-a7fc-05ef2b60dfe7.png#clientId=uc9c63499-89ab-4&from=paste&id=u8793a7a3&originHeight=131&originWidth=355&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=uc8c2cb52-6687-4945-b589-06f2d8e438a&title=)<br />上图为第K棵CART树，确定一棵CART树需要确定两部分，第一部分就是树的结构，这个结构将输入样本映射到一个确定的叶子节点上，记为![](https://cdn.nlark.com/yuque/0/2022/png/396745/1656555368804-6fbd656f-0f5c-4eec-8ea0-dbd3cec5de76.png#clientId=uc9c63499-89ab-4&from=paste&id=u2e159e76&originHeight=33&originWidth=56&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=uc472f6d3-9e70-4cac-aa7d-e11becbbebd&title=)。第二部分就是各个叶子节点的值，q(x)表示输出的叶子节点序号，![](https://cdn.nlark.com/yuque/0/2022/png/396745/1656555368928-7a1c95e4-d104-4d8c-8d11-b08ca6cd86ac.png#clientId=uc9c63499-89ab-4&from=paste&id=u7523847a&originHeight=31&originWidth=49&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=udb802353-8f41-48b9-952f-13170d4edea&title=)表示对应叶子节点序号的值。由定义得：<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1656555368909-670cda8e-601b-4e45-b3ef-16ae1dedcbba.png#clientId=uc9c63499-89ab-4&from=paste&id=u0a1cf73e&originHeight=36&originWidth=202&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=u8e450fbe-5656-467c-9ffa-60ea7193659&title=)
<a name="d7cfS"></a>
### 树的复杂度定义
XGBoost法对应的模型包含了多棵cart树，定义每棵树的复杂度：<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1656555368982-f182f4c5-f554-413c-a4e2-d4a15dfe4a9d.png#clientId=uc9c63499-89ab-4&from=paste&id=u540a6af5&originHeight=47&originWidth=281&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=u308f5794-95cc-463a-bbf7-0c51635c67f&title=)<br />其中T为叶子节点的个数，||w||为叶子节点向量的模  。γ表示节点切分的难度，λ表示L2正则化系数。<br />如下例树的复杂度表示：<br />![](https://cdn.nlark.com/yuque/0/2022/jpeg/396745/1656555369225-7047a713-481e-4dc4-b980-c2590d3a263e.jpeg#clientId=uc9c63499-89ab-4&from=paste&id=u3c5a0d1c&originHeight=401&originWidth=693&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=uf5520f6c-2971-493a-9014-2f00771a043&title=)
<a name="VelWJ"></a>
### 目标函数推导
根据（3.1）式，共进行t次迭代的学习模型的目标函数为：<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1656555369141-b5905bc8-046b-458a-a734-07603e54f097.png#clientId=uc9c63499-89ab-4&from=paste&id=uc7238995&originHeight=220&originWidth=550&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=uba86ac29-9147-41bd-ba89-71d72ef3a9b&title=)<br />泰勒公式的二阶导近似表示：<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1656555369225-2dc40b84-ee58-426b-b928-28d1fe8e2359.png#clientId=uc9c63499-89ab-4&from=paste&id=ub7435434&originHeight=53&originWidth=512&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=u22284392-993b-48de-abc1-78066700b2c&title=)<br />令![](https://cdn.nlark.com/yuque/0/2022/png/396745/1656555369410-a01408be-4953-4c38-b473-3790e0468b82.png#clientId=uc9c63499-89ab-4&from=paste&id=ua4204d04&originHeight=29&originWidth=53&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=u88ccd4ae-ff82-4db6-a609-6d5f4cf814b&title=)为Δx，则（3.5）式的二阶近似展开：<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1656555369317-7187d43e-4670-43ab-bb6e-852b95615dfd.png#clientId=uc9c63499-89ab-4&from=paste&id=u659fc078&originHeight=167&originWidth=699&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=u3c247d78-34d8-4a28-b4a2-d121bd7df7f&title=)<br />其中：<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1656555369659-f754a0c0-73fe-422c-9c9e-8feea75aad03.png#clientId=uc9c63499-89ab-4&from=paste&id=u59077192&originHeight=35&originWidth=204&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=u45d85810-67e0-4775-98a2-676ae99e877&title=)<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1656555369518-5f47fc65-9c81-48ab-a5df-dae0a5b492eb.png#clientId=uc9c63499-89ab-4&from=paste&id=uaeb71a68&originHeight=34&originWidth=200&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=ufe0ef3b9-024c-4287-a5e6-166014286d2&title=)<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1656555369646-c33abe45-d131-4b71-9678-ebb151aef176.png#clientId=uc9c63499-89ab-4&from=paste&id=u9d267349&originHeight=33&originWidth=107&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=u039ce569-0255-48c2-95e9-2a4a6f57d24&title=)表示前t-1棵树组成的学习模型的预测误差，gi和hi分别表示预测误差对当前模型的一阶导和二阶导 ，当前模型往预测误差减小的方向进行迭代。<br />忽略（3.8）式常数项，并结合（3.4）式，得：<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1656555369844-e3402736-fbfb-45ed-8d06-e08ef6ab7467.png#clientId=uc9c63499-89ab-4&from=paste&id=uc9644bbf&originHeight=62&originWidth=541&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=u55677da5-2d65-4b2e-8684-45a4a9d77ad&title=)<br />通过（3.2）式简化（3.9）式：<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1656555369899-4cacb52b-2eae-47fe-b37d-dda31ccad9e3.png#clientId=uc9c63499-89ab-4&from=paste&id=u5d8acc2d&originHeight=61&originWidth=550&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=ud515be1d-1349-4afa-aea6-7b2e6d924a6&title=)<br />（3.10）式第一部分是对所有训练样本集进行累加，因为所有样本都是映射为树的叶子节点，换种思维，从叶子节点出发，对所有的叶子节点进行累加，得：<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1656555369888-cd84889a-cdb5-4715-8ad8-962c31ee0f98.png#clientId=uc9c63499-89ab-4&from=paste&id=uf646c8bc&originHeight=61&originWidth=488&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=u3493a84b-ba7d-44aa-b449-b2b0b591236&title=)<br />令<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1656555370069-186e27ba-89b0-4f04-8dd7-e7000b315262.png#clientId=uc9c63499-89ab-4&from=paste&id=u02a9d353&originHeight=50&originWidth=201&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=u81a88d06-3260-4ff6-9019-ead0f2e23ef&title=)<br />Gj 表示映射为叶子节点 j 的所有输入样本的一阶导之和，同理，Hj表示二阶导之和。<br />得：<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1656555370217-2cd3481b-9722-4c48-bc47-dc1e301ce9ba.png#clientId=uc9c63499-89ab-4&from=paste&id=ub4bac9aa&originHeight=53&originWidth=431&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=u7dee686d-6f6a-4097-9d93-0dca8359ff4&title=)<br />对于第 t 棵CART树的某一个确定结构（可用q(x)表示），其叶子节点是相互独立的，Gj和Hj是确定量，因此，（3.12）可以看成是关于叶子节点的一元二次函数 。最小化（3.12）式，得：<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1656555370329-491dc543-b475-4ad8-bdc9-fcadd79282a9.png#clientId=uc9c63499-89ab-4&from=paste&id=ucdd14d04&originHeight=60&originWidth=229&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=u589b2a0a-9d39-4c51-8ba3-43759cfdb9c&title=)<br />得到最终的目标函数：<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1656555370240-88989f6f-35b5-437d-a645-fef2cb0ec397.png#clientId=uc9c63499-89ab-4&from=paste&id=udda31093&originHeight=66&originWidth=321&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=uda7b1265-36bc-44fb-a6c3-025c718ea6d&title=)<br />（3.14）也称为打分函数(scoring function)，它是衡量树结构好坏的标准，值越小，代表这样的结构越好 。用打分函数选择最佳切分点，从而构建CART树。
<a name="QIk04"></a>
## CART回归树的构建方法
上节推导得到的打分函数是衡量树结构好坏的标准，因此，可用打分函数来选择最佳切分点。首先确定样本特征的所有切分点，对每一个确定的切分点进行切分，切分好坏的标准如下：<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1656555370361-af1786ec-d1ac-4d3b-8e42-79874f896cf9.png#clientId=uc9c63499-89ab-4&from=paste&id=u7c07962c&originHeight=78&originWidth=456&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=ua0a56042-7367-484b-9170-06bc2d684e9&title=)<br />Gain表示单节点obj*与切分后的两个节点的树obj*之差，遍历所有特征的切分点，找到最大Gain的切分点即是最佳分裂点，根据这种方法继续切分节点，得到CART树。若 γ 值设置的过大，则Gain为负，表示不切分该节点，因为切分后的树结构变差了。γ值越大，表示对切分后obj下降幅度要求越严，这个值可以在XGBoost中设定。
<a name="SCfQy"></a>
## XGBoost与GDBT的区别

1. XGBoost生成CART树考虑了树的复杂度，GDBT未考虑，GDBT在树的剪枝步骤中考虑了树的复杂度。
2. XGBoost是拟合上一轮损失函数的二阶导展开，GDBT是拟合上一轮损失函数的一阶导展开，因此，XGBoost的准确性更高，且满足相同的训练效果，需要的迭代次数更少。
3. XGBoost与GDBT都是逐次迭代来提高模型性能，但是XGBoost在选取最佳切分点时可以开启多线程进行，大大提高了运行速度。
