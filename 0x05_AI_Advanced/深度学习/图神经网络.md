神经网络
<a name="DIzj9"></a>
## 一、图神经网络介绍
<a name="7NmBv"></a>
### **
图神经网络(Graph Neural Networks, GNNs)是基于图结构的深度学习方法，近期被广泛应用到各类图像、自然语言处理等任务上。图神经网络作为神经网络扩展，可以处理以图结构表示的数据格式。在图中，每个节点都由本身的特性以及其相邻的节点和关系所定义，网络通过递归地聚合和转换相邻节点的表示向量来计算节点的表示向量。<br />在论文《Relational inductive biases, deep learning, and graph networks》中，作者定义了通用图网络框架_graph networks_ (GN) framework，概括和扩展了各种图神经网络，并且支持使用简单的模块来构建复杂的结构。GN framework的主要计算单元是GN block，一个图到图的模块，它的输入是一个图，在图结构上进行计算，然后得到同样是图结构的输出。<br />在GN framework下，一个图可以被定义为一个三元组![](https://cdn.nlark.com/yuque/__latex/690f6c58fbe1fd85ba858e7f9858ce11.svg#card=math&code=G%3D%28u%2CV%2CE%29&height=18&id=VBoxx)，![](https://cdn.nlark.com/yuque/__latex/7b774effe4a349c6dd82ad4f4f21d34c.svg#card=math&code=u&height=10&id=WRGFV)是图的一个全局表示，![](https://cdn.nlark.com/yuque/__latex/b49d2e6226bcd32a6daf2a04b4bdbc76.svg#card=math&code=V%3D%5Cleft%5C%7B%20V_i%20%5Cright%5C%7Di%3D1%3AN%5Ev&height=18&id=WRsYp) 代表图中![](https://cdn.nlark.com/yuque/__latex/f5dab1608011d8dc896b3a43cf73f562.svg#card=math&code=N%5Ev&height=15&id=s0QKB)个节点的集合，![](https://cdn.nlark.com/yuque/__latex/1df181eaa1bb40a0067c06ead197170d.svg#card=math&code=v_i&height=12&id=atqmX)为节点i的表示，![](https://cdn.nlark.com/yuque/__latex/1d7f435f46803594e7d8d0f3df98a193.svg#card=math&code=E%3D%5Cleft%5C%7B%28e_k%2Cr_k%2Cs_k%29%5Cright%5C%7Dk%3D1%3AN%5Ee&height=18&id=DMbna)表示图中![](https://cdn.nlark.com/yuque/__latex/003ea107b8162cbcfe48c75b2edaa996.svg#card=math&code=N%5Ee&height=15&id=hgzIZ)条边的集合，![](https://cdn.nlark.com/yuque/__latex/311d95a59af6dd43031e7f9eef946c4f.svg#card=math&code=e_k&height=12&id=jD0OO)为边的表示，![](https://cdn.nlark.com/yuque/__latex/1c06ba8c53212c805a523132ed7041d6.svg#card=math&code=r_k&height=12&id=r7tph)和![](https://cdn.nlark.com/yuque/__latex/2a237e54504442e3d483a39f75df7bfa.svg#card=math&code=s_k&height=12&id=q417S)分别代表边的接收节点和发送节点。 <br />每一个GN block包含三个更新函数![](https://cdn.nlark.com/yuque/__latex/1ed346930917426bc46d41e22cc525ec.svg#card=math&code=%5Cphi&height=16&id=XchPy)，以及三个聚合函数![](https://cdn.nlark.com/yuque/__latex/d2606be4e0cd2c9a6179c8f2e3547a85.svg#card=math&code=%5Crho&height=13&id=l16bS)：<br />![](https://cdn.nlark.com/yuque/__latex/fd9fb9c0086f7b0f4159ac1c5542cd6f.svg#card=math&code=e_k%27%3D%5Cphi%5Ee%28e_k%2Cv_%7Br_k%7D%2Cv_%7Bs_k%7D%2Cu%29&height=19&id=MxIeM)              ![](https://cdn.nlark.com/yuque/__latex/85f46d3d47cde13e7766575a398acbf9.svg#card=math&code=%5Coverline%7Be%7D_i%27%3D%5Crho%5E%7Be%5Crightarrow%20v%7D%28E_i%27%29&height=21&id=Eq1FO)<br />![](https://cdn.nlark.com/yuque/__latex/48a4b3b095208a2ab7b940bbf96d5530.svg#card=math&code=v_i%27%3D%5Cphi%5Ev%28%5Coverline%7Be%7D_i%27%2Cv_%7Bi%7D%2Cu%29&height=21&id=DdmHQ)                     ![](https://cdn.nlark.com/yuque/__latex/dcd6fc50b84b789acae24650a9e6b1a7.svg#card=math&code=%5Coverline%7Be%7D%3D%5Crho%5E%7Be%5Crightarrow%20u%7D%28E%27%29&height=19&id=iu6cs)<br />![](https://cdn.nlark.com/yuque/__latex/7411dafe9adcfe0fffabe82835d711f7.svg#card=math&code=u%27%3D%5Cphi%5Eu%28%5Coverline%7Be%7D%27%2C%5Coverline%7Bv%7D%27%2Cu%29&height=20&id=wxmuw)                     ![](https://cdn.nlark.com/yuque/__latex/9f89fbdbedabd06a23c0a9b5ce1ee9df.svg#card=math&code=%5Coverline%7Bv%7D%27%3D%5Crho%5E%7Bv%5Crightarrow%20u%7D%28V%27%29&height=20&id=Sbmef)<br />上式中![](https://cdn.nlark.com/yuque/__latex/2df2f1c16ffb149bd91e8c3b2e9fb7f5.svg#card=math&code=E_i%27%3D%5Cleft%20%5C%7B%5Cleft%20%28%20e_k%27%2Cr_k%2Cs_k%20%5Cright%29%20%5Cright%5C%7Dr_k%3Di%2Ck%3D1%3AN%5Ee&height=20&id=T9E2W)，![](https://cdn.nlark.com/yuque/__latex/575ae0502a6cf00fa4708e0e19ccbb6c.svg#card=math&code=V%27%3D%5C%7Bv_i%27%5C%7Di%3D1%3BN%5Ev&height=20&id=SWasX)，![](https://cdn.nlark.com/yuque/__latex/ba0f8939e83362eb740dd9f311f79269.svg#card=math&code=E%27%3DU_iE_i%27%3D%5C%7B%28e_k%27%2Cr_k%2Cs_k%29%5C%7Dk%3D1%3AN%5Ee&height=20&id=uAQ1r)。<br />其中 ![](https://cdn.nlark.com/yuque/__latex/a5e3502fac30dfc711520a9198b6ee5a.svg#card=math&code=%5Cphi%5Ee&height=16&id=Cof3Q) 应用于图中每条边的更新， ![](https://cdn.nlark.com/yuque/__latex/7e5ae5e539d8f61c0a023ff749f89127.svg#card=math&code=%5Cphi%5Ev&height=16&id=TgGtH) 应用于图中每个节点的更新， ![](https://cdn.nlark.com/yuque/__latex/cedbbf69993224e74e3f91ea57482003.svg#card=math&code=%5Cphi%5Eu&height=16&id=TMUCt) 则用来更新图的全局表示；![](https://cdn.nlark.com/yuque/__latex/d2606be4e0cd2c9a6179c8f2e3547a85.svg#card=math&code=%5Crho&height=13&id=fpRPD)函数将输入的表示集合整合为一个表示，该函数设计为可以接收任意大小的集合输入，通常可以为加和、平均值或者最大值等不限输入个数的操作。<br />当一个GN block得到一个图 ![](https://cdn.nlark.com/yuque/__latex/dfcf28d0734569a6a693bc8194de62bf.svg#card=math&code=G&height=13&id=U9Li4) 的输入时，计算通常从边到节点，再到全局进行。下图给出了一个GN block的更新过程。<br />![](https://cdn.nlark.com/yuque/0/2020/jpeg/396745/1600566478666-a31e60ec-89a0-4ac2-8e0b-53323cfdf742.jpeg#height=263&id=oZDQt&originHeight=263&originWidth=1080&originalType=binary&size=0&status=done&style=shadow&width=1080)<br />图1 一个GN block的更新过程<br />一个GN block的计算可以被描述为如下几步：<br />1.![](https://cdn.nlark.com/yuque/__latex/a5e3502fac30dfc711520a9198b6ee5a.svg#card=math&code=%5Cphi%5Ee&height=19&id=JJtc6) 更新每一条边，输入参数为边表示![](https://cdn.nlark.com/yuque/__latex/311d95a59af6dd43031e7f9eef946c4f.svg#card=math&code=e_&height=12&id=whUda)，接收和发送节点的表示![](https://cdn.nlark.com/yuque/__latex/a1fe0e7137313a1d55c804063a6d2fb5.svg#card=math&code=V_%7Brk%7D&height=16&id=mowEc)和![](https://cdn.nlark.com/yuque/__latex/5f1f0a797e521329c7be234b6715515f.svg#card=math&code=V_%7Bsk%7D&height=16&id=hZ7rM)以及全局表示![](https://cdn.nlark.com/yuque/__latex/7b774effe4a349c6dd82ad4f4f21d34c.svg#card=math&code=u&height=10&id=CDt4Q)，输出为更新过的边表示![](https://cdn.nlark.com/yuque/__latex/bf268383b23741e601e737215fc902d4.svg#card=math&code=e_k%27&height=18&id=YP98K)；<br />2. ![](https://cdn.nlark.com/yuque/__latex/41ef67638b42459d7c6edead142e1506.svg#card=math&code=%5Crho%5E%7Be%5Crightarrow%20v%7D&height=20&id=mJAhp) 用来有同一个聚合接收节点的边的信息，对节点i得到所有入边及邻近节点信息整合![](https://cdn.nlark.com/yuque/__latex/c2dd22e6a1f91a18e68e0f78b7a2c888.svg#card=math&code=%5Coverline%7Be%7D_i%27&height=20&id=KJ8fC)，用于下一步节点的更新；<br />3. ![](https://cdn.nlark.com/yuque/__latex/7e5ae5e539d8f61c0a023ff749f89127.svg#card=math&code=%5Cphi%5Ev&height=16&id=sn6ML) 更新每一个节点，输入为上文中的![](https://cdn.nlark.com/yuque/__latex/c2dd22e6a1f91a18e68e0f78b7a2c888.svg#card=math&code=%5Coverline%7Be%7D_i%27&height=20&id=pHK2d)，节点表示![](https://cdn.nlark.com/yuque/__latex/1df181eaa1bb40a0067c06ead197170d.svg#card=math&code=v_i&height=12&id=VEqJ6)$以及全局表示![](https://cdn.nlark.com/yuque/__latex/7b774effe4a349c6dd82ad4f4f21d34c.svg#card=math&code=u&height=12&id=Q5Kcu)，输出为更新过的节点表示![](https://cdn.nlark.com/yuque/__latex/08c881ec6862218697a701ffaafa2045.svg#card=math&code=v_i%27&height=20&id=icN24)；<br />4. ![](https://cdn.nlark.com/yuque/__latex/06e480400a03b41021c9ad0ff9c0c87b.svg#card=math&code=%5Crho%5E%7Be%5Crightarrow%20u%7D&height=20&id=NTtVC) 聚合图中所有边的信息得到边信息整合![](https://cdn.nlark.com/yuque/__latex/ae9689a1bd57741bc652f646e9849a86.svg#card=math&code=%5Coverline%7Be%7D&height=16&id=U1czW)；<br />5. ![](https://cdn.nlark.com/yuque/__latex/fbf7d55d5ace959fe1983fc8af33bb90.svg#card=math&code=%5Crho%5E%7Bv%5Crightarrow%20u%7D&height=20&id=s5mEh) 通过聚合图中所有节点信息得到节点的信息整合![](https://cdn.nlark.com/yuque/__latex/86cfcb7509fefa9a60d776c7f249b8d3.svg#card=math&code=%5Coverline%7Bv%7D%27&height=19&id=VFlU4)；<br />6. ![](https://cdn.nlark.com/yuque/__latex/cedbbf69993224e74e3f91ea57482003.svg#card=math&code=%5Cphi%5E&height=19&id=YC33a)更新全局的表示，输入为边信息整合![](https://cdn.nlark.com/yuque/__latex/ae9689a1bd57741bc652f646e9849a86.svg#card=math&code=%5Coverline%7Be%7D&height=16&id=jVnb6)，节点信息整合![](https://cdn.nlark.com/yuque/__latex/86cfcb7509fefa9a60d776c7f249b8d3.svg#card=math&code=%5Coverline%7Bv%7D%27&height=19&id=LD1FG)，以及节点表示![](https://cdn.nlark.com/yuque/__latex/7b774effe4a349c6dd82ad4f4f21d34c.svg#card=math&code=u&height=12&id=lwcIB)，输出为更新过的全局表示![](https://cdn.nlark.com/yuque/__latex/d861d3900eda89c562d90ba7bd7fa341.svg#card=math&code=u%27&height=18&id=QXWEP) 。<br />可以通过上述的更新步骤来套用目前的图神经网络算法，当然这里的步骤的顺序并不是严格固定的，比如可以先更新全局信息，再更新节点信息以及边的信息。
<a name="y77jC"></a>
### **为什么要使用图神经网络**
图神经网络有灵活的结构和更新方式，可以很好的表达一些数据本身的结构特性，除了一些自带图结构的数据集（如Cora，Citeseer等）以外，图神经网络目前也被应用在更多的任务上，比如文本摘要，文本分类和序列标注任务等，目前图神经网络以及其变种在很多任务上都取得了目前最好的结果。<br />比较常见的图神经网络算法主要有Graph Convolutional Network（GCN）和Graph Attention Network（GAT）等网络及其变种，在本文第三部分会给出基于图神经网络框架DGL的GCN以及GAT的代码及注解。
<a name="L2pWb"></a>
## **二、图神经网络库**
相比于传统的基于邻接矩阵的图神经网络实现方法，目前完成度较好的图神经网络框架主要是基于PyTorch和MXNet的DGL (Deep Graph Library)和PyG (PyTorch Geometric)。主要使用DGL作为开发的框架，原因是各种网络模型的tutorial给的比较详尽，同时包括TreeLSTM这种经典模型也可以通过给定节点访问的顺序通过框架很轻松的实现，相比于不使用图网络框架的代码具有更强的可读性。<br />但是，实际上图神经网络框架只适用于图结构中的边和点是同一量级的情况，因为图神经网络框架的信息是通过图中的边来传递的，会将节点的表示复制多次。在这种情况下，反而不如使用邻接矩阵直接做矩阵乘法，因为使用邻接矩阵做矩阵乘法其实不会将节点信息复制多次，会对显存有极大的节省。
<a name="uDnVF"></a>
## **三、常见算法以及代码示例详解**
<a name="xcpI9"></a>
### GCN
GCN的计算公式如下：![](https://cdn.nlark.com/yuque/__latex/cac0c93079b7a8463b56aaa45b10da23.svg#card=math&code=H%5E%7B%28l%2B1%29%7D%3D%5Csigma%28%5Cwidetilde%7BD%7D%5E%7B-%5Cfrac%7B1%7D%7B2%7D%7D%5Cwidetilde%7BA%7D%5Cwidetilde%7BD%7D%5E%7B-%5Cfrac%7B1%7D%7B2%7D%7DH%5E%7B%28l%29%7DW%5E%7B%28l%29%7D%29&height=31&id=d0d8G)<br />上式中![](https://cdn.nlark.com/yuque/__latex/0612a6d4b54b338e596b55198df46021.svg#card=math&code=H%5E%7B%28l%29%7D&height=20&id=zKXb0)表示网络的第l层，![](https://cdn.nlark.com/yuque/__latex/a2ab7d71a0f07f388ff823293c147d21.svg#card=math&code=%5Csigma&height=12&id=lG8ZW)代表非线性激活函数，![](https://cdn.nlark.com/yuque/__latex/734c86fd8d7bdc30951f9ecced92c10c.svg#card=math&code=W%5E%7B%28l%29%7D&height=20&id=fwi37)为该层的权重矩阵，![](https://cdn.nlark.com/yuque/__latex/f623e75af30e62bbd73d6df5b50bb7b5.svg#card=math&code=D&height=16&id=dlhuR)和![](https://cdn.nlark.com/yuque/__latex/7fc56270e7a70fa81a5935b72eacbe29.svg#card=math&code=A&height=16&id=czysK)分别代表度矩阵以及邻接矩阵，~符号表示对每一个节点加上一个自环，即![](https://cdn.nlark.com/yuque/__latex/353305f6f96a80c5431623b466992d9f.svg#card=math&code=%5Cwidetilde%7BA%7D%3DA%2BI&height=21&id=k5GXG)，![](https://cdn.nlark.com/yuque/__latex/dd7536794b63bf90eccfd37f9b147d7f.svg#card=math&code=I&height=16&id=uFmkL)为单位矩阵，由于邻接矩阵是没有进行正则化的，所以论文中通过![](https://cdn.nlark.com/yuque/__latex/4add5ad8c345a2302f6521185312d766.svg#card=math&code=%5Cwidetilde%7BD%7D%5E%7B-%5Cfrac%7B1%7D%7B2%7D%7D%5Cwidetilde%7BA%7D%5Cwidetilde%7BD%7D%5E%7B-%5Cfrac%7B1%7D%7B2%7D%7D&height=28&id=TiaWy)使得结果中每一行的和都为1。<br />![](https://cdn.nlark.com/yuque/0/2020/jpeg/396745/1600566478969-8dd026a6-f1bd-4e7b-b923-9336762f5d70.jpeg#height=363&id=tL4sW&originHeight=363&originWidth=700&originalType=binary&size=0&status=done&style=shadow&width=700)<br />图2 在每一层图网络中，每个节点通过对邻近节点的信息聚合得到这层该节点的输出<br />相比于前文给出的GCN基于邻接矩阵的公式定义，GCN的公式可以被更简洁的定义为以下两步：<br />1）对于节点u,首先将节点邻居表示![](https://cdn.nlark.com/yuque/__latex/0d940266b39d150a39730577c04989e9.svg#card=math&code=h_v&height=18&id=wiKoT)聚合到一起，生成中间表示![](https://cdn.nlark.com/yuque/__latex/a308df186ba8311f7e2539f3b2553a0a.svg#card=math&code=%5Chat%7Bh%7D_u&height=23&id=yBZAk)，<br />2）将得到的中间表示![](https://cdn.nlark.com/yuque/__latex/a308df186ba8311f7e2539f3b2553a0a.svg#card=math&code=%5Chat%7Bh%7D_u&height=23&id=CLG2x)通过一层非线性神经网络层![](https://cdn.nlark.com/yuque/__latex/d537c4a59b0649a8d7b5b1f8ef3b926e.svg#card=math&code=h_u%3Df%28Wu%5Chat%7Bh%7D_u%29&height=24&id=ApJN6)。<br />下面为基于DGL的代码示例，在代码实现中，第一步通过DGL自带的message passing函数实现，第二步通过DGL的`apply_nodes`方法，将基于PyTorch中`nn.Module`的用户自定义函数加入实现：
```python
import dgl
import dgl.function as fn
import torch as th
import torch.nn as nn
import torch.nn.functional as F
from dgl import DGLGraph

gcn_msg = fn.copy_src(src='h', out='m')
gcn_reduce = fn.sum(msg='m', out='h')
```
接下来为`apply_nodes`定义更新节点的自定义函数，这里是一个线性变换加上一个非线性激活函数的网络层：
```python
class NodeApplyModule(nn.Module):
    def __init__(self, in_feats, out_feats, activation):
        super(NodeApplyModule, self).__init__()
        self.linear = nn.Linear(in_feats, out_feats)
        self.activation = activation

    def forward(self, node):
        h = self.linear(node.data['h'])
        h = self.activation(h)
        return {'h' : h}
```
下面定义GCN模块，一层GCN首先通过`update_all`方法将节点信息通过边传递，然后通过`apply_nodes`得到新的节点表示：
```python
class GCN(nn.Module):
    def __init__(self, in_feats, out_feats, activation):
        super(GCN, self).__init__()
        self.apply_mod = NodeApplyModule(in_feats, out_feats, activation)

    def forward(self, g, feature):
        g.ndata['h'] = feature
        g.update_all(gcn_msg, gcn_reduce)
        g.apply_nodes(func=self.apply_mod)
        return g.ndata.pop('h')
```
整个网络模块的定义和Pytorch中的NN模型定义本质上相同，如下我们定义两个GCN网络层：
```python
class Net(nn.Module):
    def __init__(self, in_dim, hidden_dim, out_dim):
        super(Net, self).__init__()
        self.gcn1 = GCN(in_dim, hidden_dim, F.relu)
        self.gcn2 = GCN(hidden_dim, out_dim, F.relu)

        def forward(self, g, features):
            x = self.gcn1(g, features)
            x = self.gcn2(g, x)
            return x
        net = Net()
        print(net)
```
<a name="LWblF"></a>
### GAT
GAT和GCN的主要区别就在于邻近节点信息的聚合方式，GAT通过引入attention机制来替代GCN中的静态归一化卷积运算，下面给出使用 _l _层网络输出来计算第 _l+1_ 层网络输出![](https://cdn.nlark.com/yuque/__latex/bb533f4b075e9ab5636ea95615d59dc5.svg#card=math&code=h_i%5E%7Bl%2B1%7D&height=24&id=g9Mt7)的公式：<br />![](https://cdn.nlark.com/yuque/0/2020/webp/396745/1600566479038-cb816028-3ebd-4a87-abe9-7fca309b36c0.webp#height=172&id=c3JY0&originHeight=274&originWidth=1080&originalType=binary&size=0&status=done&style=shadow&width=677)<br />![](https://cdn.nlark.com/yuque/__latex/2f01eedb80147130dd5e36efde06e09d.svg#card=math&code=z_i%5El%3DW%5E%7B%28l%29%7Dh_i%5E%7B%28l%29%7D%2C%20&height=23&id=AZHGH)<br />![](https://cdn.nlark.com/yuque/__latex/ab7f7c656ce54b6348ead979beeda856.svg#card=math&code=e_%7Bij%7D%5E%7B%28l%29%7D%3DleakyReLU%28%5Coverrightarrow%7Ba%7D%20%5E%7B%28l%29T%7D%28z_i%5E%7B%28l%29%7D%5C%7Cz_j%5E%7B%28l%29%7D%29%29%2C&height=29&id=xErtw)<br />![](https://cdn.nlark.com/yuque/__latex/8bec79047d680641f9aca3719e366ba8.svg#card=math&code=%5Calpha_%7Bij%7D%5E%7B%28l%29%7D%3D%5Cfrac%7B%5Ctext%7Bexp%7D%28e_%7Bij%7D%5E%7B%28l%29%7D%29%7D%7B%5Csum_%7BK%5Cin%20N_i%7D%5Ctext%7Bexp%7D%28e_%7Bij%7D%5E%7B%28l%29%7D%29%7D%2C&height=57&id=peWG9)<br />![](https://cdn.nlark.com/yuque/__latex/57f500b930da42616f58307151d841af.svg#card=math&code=h_i%5E%7Bl%2B1%7D%3D%5Csigma%28%5Csum_%7Bj%5Cin%7BN_i%7D%7D%5Calpha_%7Bij%7D%5E%7B%28l%29%7Dz_%7Bj%7D%5E%7B%28l%29%7D%29%2C&height=38&id=O5es1)<br />在上式中，公式(1)为上一层节点表示![](https://cdn.nlark.com/yuque/__latex/ccf264eb534c9328601fc9d792df79fb.svg#card=math&code=h_i%5E%7B%28l%29%7D&height=26&id=LmYmz)通过可学习的权重矩阵![](https://cdn.nlark.com/yuque/__latex/5e95de488fc446fbe29319c68dfb26aa.svg#card=math&code=W%5El%0A&height=19&id=JddBM)做线性变换；公式(2)计算两个邻近节点的为未进行标准化的attention分数，这里首先将两个节点的表示相连，然后和一个可学习的权重向量![](https://cdn.nlark.com/yuque/__latex/1155604e8ef5f0aed62f8fd3c561c816.svg#card=math&code=%5Coverrightarrow%7Ba%7D%5E%7B%28l%29%7D&height=23&id=FBFze)做点积，最后通过![](https://cdn.nlark.com/yuque/__latex/a2b1e805893964ca62ba2b3467b4c3fc.svg#card=math&code=LeakyRelu&height=16&id=ZfKUM)函数。这种形式通常叫做additive attention，相比Transformer中的则是dot-product attention；公式(3)对每个与该节点有入边的节点的attention分数使用softmax函数作归一化操作；公式(4)与GCN类似，聚合邻近节点的表示，使用公式(3)得到的分数作为权值。具体的计算方式如下图所示：<br />![](https://cdn.nlark.com/yuque/0/2020/webp/396745/1600566479062-71b26ce0-ced3-443f-8b83-a8d8fcb69d11.webp#height=513&id=A8xAt&originHeight=513&originWidth=1080&originalType=binary&size=0&status=done&style=shadow&width=1080)<br />图3 Graph Attention Networks计算attention分数以及更新节点表示<br />下面的基于DGL的代码逐一分解了上面的四个公式，公式(1)中的线性变换直接使用Pytorch中的`torch.nn.Linear`模块
```python
import torch
import torch.nn as nn
import torch.nn.functional as F

class GATLayer(nn.Module):
    def __init__(self, g, in_dim, out_dim):
        super(GATLayer, self).__init__()
        self.g = g
        # equation (1)
        self.fc = nn.Linear(in_dim, out_dim, bias=False)
        # equation (2)
        self.attn_fc = nn.Linear(2 * out_dim, 1, bias=False)

    def edge_attention(self, edges):
        # edge UDF for equation (2)
        z2 = torch.cat([edges.src['z'], edges.dst['z']], dim=1)
        a = self.attn_fc(z2)
        return {'e': F.leaky_relu(a)}


    def message_func(self, edges):
        # message UDF for equation (3) & (4)
        return {'z': edges.src['z'], 'e': edges.data['e']}


    def reduce_func(self, nodes):
        # reduce UDF for equation (3) & (4)
        # equation (3)
        alpha = F.softmax(nodes.mailbox['e'], dim=1)
        # equation (4)
        h = torch.sum(alpha * nodes.mailbox['z'], dim=1)
        return {'h': h}


    def forward(self, h):
        # equation (1)
        z = self.fc(h)
        self.g.ndata['z'] = z
        # equation (2)
        self.g.apply_edges(self.edge_attention)
        # equation (3) & (4)
        self.g.update_all(self.message_func, self.reduce_func)
        return self.g.ndata.pop('h')
```
公式(2)中的![](https://cdn.nlark.com/yuque/__latex/6fd64a8eafc5224488e3523dd225bb7b.svg#card=math&code=e_%7Bij%7D&height=16&id=DzX5U)通过两个相邻节点i和j的表示计算，这里通过DGL的`apply_edges`API来实现，参数是下面的自定义函数`edge_attention`：
```
1def edge_attention(self, edges):
2    # edge UDF for equation (2)
3    z2 = torch.cat([edges.src['z'], edges.dst['z']], dim=1)
4    a = self.attn_fc(z2)
5    return {'e' : F.leaky_relu(a)}
```
这里和可学习权重向量![](https://cdn.nlark.com/yuque/0/2020/png/396745/1600566479159-34e173ad-4484-44f2-bb0d-3bb261c45a64.png#height=24&id=dUTzk&originHeight=93&originWidth=108&originalType=binary&size=0&status=done&style=none&width=28)的点积通过上面定义的线性变换函数`attn_fc`得到，这里`apply_edge`会将所有的边的数据放到一个tensor里，所以`cat`，`attn_fc`可以并行计算，这也是上文提到的如果边的数量比点的数量多一个量级，最好还是使用邻接矩阵的方式实现图网络的原因，因为会将点的信息复制多次。<br />对于公式(3)和公式(4)，使用`update_all`API来实现所有节点的信息传递，message function会发送两部分信息：经过变换的表示![](https://cdn.nlark.com/yuque/__latex/21c2e59531c8710156d34a3c30ac81d5.svg#card=math&code=Z&height=13&id=FKbdl)和每条边上尚未经过归一化的attention分数![](https://cdn.nlark.com/yuque/__latex/e1671797c52e15f763380b45e841ec32.svg#card=math&code=e&height=10&id=sKABM)，然后通过下面的reduce function，首先通过softmax对attention的分数作归一化操作（公式(3)），然后将节点的邻近节点的表示按照归一化之后的attention权重聚合起来得到新的表示（公式(4)）：
```python
def reduce_func(self, nodes):
    # reduce UDF for equation (3) & (4)
    # equation (3)
    alpha = F.softmax(nodes.mailbox['e'], dim=1)
    # equation (4)
    h = torch.sum(alpha * nodes.mailbox['z'], dim=1)
    return {'h' : h}
```

GAT同样使用了类似Transformer的Multi-head Attention，用来加强模型表达能力并且稳定学习过程。每一个attention head有自己独立的参数，可以通过两种方式合并它们的输出：<br />![](https://cdn.nlark.com/yuque/0/2020/png/396745/1600566479121-19983eea-c91c-4bc7-b887-5c2ebfca590a.png#height=38&id=B2WTN&originHeight=152&originWidth=1080&originalType=binary&size=0&status=done&style=none&width=270)或者average：![](https://cdn.nlark.com/yuque/0/2020/png/396745/1600566479135-48494ba5-1095-4aa3-82c6-6bb0fb570d97.png#height=45&id=n17u5&originHeight=180&originWidth=1080&originalType=binary&size=0&status=done&style=none&width=270)![](https://cdn.nlark.com/yuque/__latex/1e28668df03f142ea40ffd4e2bff3b79.svg#card=math&code=h_i%5E%7B%28l%2B1%29%7D%3D%5Csigma%28%5Cfrac%7B1%7D%7BK%7D%5Csum_%7Bk%3D1%7D%5EK%5Csum_%7Bj%5Cin%20N_i%7D%5Calpha%5Ek_%7Bij%7DW%5Ekh_j%5E%7B%28l%29%7D%29&height=55&id=SCViT)<br />上式中![](https://cdn.nlark.com/yuque/__latex/8ce4b16b22b58894aa86c421e8759df3.svg#card=math&code=k&height=13&id=tPOFQ)代表attention heads的数量，原作者建议对于网络中间层使用concatenation，最后一层使用average得到attention的输出，与上面的单个head的GATLayer相结合可以得到下面的代码：
```python
class MultiHeadGATLayer(nn.Module):
    def __init__(self, g, in_dim, out_dim, num_heads, merge='cat'):
        super(MultiHeadGATLayer, self).__init__()
        self.heads = nn.ModuleList()
        for i in range(num_heads):
            self.heads.append(GATLayer(g, in_dim, out_dim))
        self.merge = merge


    def forward(self, h):
        head_outs = [attn_head(h) for attn_head in self.heads]
        if self.merge == 'cat':
            # concat on the output feature dimension (dim=1)
            return torch.cat(head_outs, dim=1)
        else:
            # merge using average
            return torch.mean(torch.stack(head_outs))
```
最后定义一个两层的GAT模型
```python
class GAT(nn.Module):
    def __init__(self, g, in_dim, hidden_dim, out_dim, num_heads):
        super(GAT, self).__init__()
        self.layer1 = MultiHeadGATLayer(g, in_dim, hidden_dim, num_heads)
        # Be aware that the input dimension is hidden_dim*num_heads since
        # multiple head outputs are concatenated together. Also, only
        # one attention head in the output layer.
        self.layer2 = MultiHeadGATLayer(g, hidden_dim * num_heads, out_dim, 1)


    def forward(self, h):
        h = self.layer1(h)
        h = F.elu(h)
        h = self.layer2(h)
        return h
```
上面GAT和GCN的详细代码可以在DGL的Github(https://github.com/dmlc/dgl)上找到。
<a name="EF5yO"></a>
## **四、总结**
图神经网络在近期的研究中被广泛应用，结合参考资料和自身对图神经网络的理解，总结了一个快速上手的简要教程。除了在一些有着天然图结构的任务，图神经网络也可以应用在自然语言处理任务中，可以在模型中更好地表示信息。本文还给出了基于图神经网络框架DGL的GCN和GAT的代码及注解，但是根据实际使用经验，图神经网络框架在处理边数量比节点数量多一个量级的情况下，会比使用邻接矩阵的写法占用更多的内存，还是需要根据具体情况来选择使用。
