# C++类和对象初识

## 什么是类

C++类是对事物的一种抽象，万物都可以当做是类处理，类抽象的是什么?

- 事物的特征:  数据成员表示 美女 : 年龄(int age) 体重(int weight)
- 事物的行为:  成员函数表示 睡觉 购物....


## 什么是对象

对象可以说类的具体化(实例化)  美女(18,90kg)


## 类的创建

- 掌握创建的语法
- 掌握权限限定
- 和结构体区别

   - 在没写构造函数之前，C语言结构体就按照C语言的方式用即可
   - 用了构造函数时候，大家把结构体直接当做C++类去使用
   - 结构体其实可以当做一个默认权限是公有属性的类
   - C++是允许空类和结构体存在

```c
class 类名
{
  //默认为私有属性
  //.....
  public:			//类外只能访问公有属性
    //....公有属性
    				//公有函数--->类外的公有接口
  protected:
    //....保护属性
  private:
    //....私有属性
};
//保护和私有属性区别，暂时不需要知道，后续讲继承的时候会讲
//类中没有权限可言
```


### 创建类完整代码

```c
class MM 
{
public:
	void printData() 
	{
		cout << name << "\t" << age << "\t"<<num << endl;
	}
	void print();
protected:

private:		//一般数据成员写：私有属性
	string name;
	int age;
	int num;
};

//在类外实现类中的函数，必须要用类名限定(类名::函数名)
void MM::print() 
{
	cout << name << "\t" << age << "\t" << num << endl;
}
```


### 结构体和类的区别

```c
#include <iostream>
using namespace std;
class MM 
{
	int num;			//类中默认的是私有属性
public:
	int age;
private:
	string name;
};
struct Boy
{						//结构体中默认的公有属性
	int num;
	int age;
private:
	string name;
};

//C语言是不能写空的结构体
//C++允许空结构体或者类
struct Empty 
{
	//占用内存不是0 是1(标记),写了数据这个标记就不存在
}m;
	//作用:泛型编程做参数包解析的递归循环终止处理

int main() 
{
	struct Boy boy;
	//boy.num = 1001;
	//boy.age = 12;
	MM mm;
	mm.age = 19;
	cout << sizeof(Empty) << endl;
	cout << sizeof(Boy) << endl;
	return 0;
}
```


## 对象创建和初始化

### 对象创建

- 创建普通对象
- 创建对象数组
- 创建对象指针


### 对象的初始化

- 类中直接给数据赋值
- 提供一个共有接口去操作数据
- 提供一个返回引用的接口

### 完整代码

```cassandra
#include <iostream>
#include <string>
using namespace std;
class MM 
{
public:
	void printData()		//普通成员函数只是写在类中，不占对象内存
	{
		cout << name << "\t" << age << "\t"<<num << endl;
	}
	void print();
	void initData(string mmName, int mmAge, int mmNum) 
	{
		name = mmName;
		age = mmAge;
		num = mmNum;
	}
	string& getName() { return name; }
	int& getAge() { return age; }
	int& getNum() { return num; }
protected:

private:		//一般数据成员写：私有属性
	string name="默认值";
	int age=0;
	int num=0;
};

//在类外实现类中的函数，必须要用类名限定(类名::函数名)
void MM::print() 
{
	cout << name << "\t" << age << "\t" << num << endl;
}

int main() 
{
	MM mm;			//创建对象
	MM array[3];
	MM* pMM;
	pMM = &mm;
	pMM = new MM;   //new一个对象
	//new一个对象过程
	//1.创建一个匿名对象(没有名字的对象)
	//2.把匿名对象的首地址赋值指针
	pMM->print();
	pMM->printData();
	//pMM->name = "小芳";   不可访问，类外不能访问public之外的所有属性
	cout << "通过提供共有接口传参的方式初始化对象的数据" << endl;
	mm.initData("小芳", 18, 1001);
	mm.printData();
	cout << "返回引用的去访问数据" << endl;
	MM* p = new MM;
	p->getName() = "MM";
	p->getAge() = 28;
	p->getNum() = 1004;
	p->printData();
	return 0;
}
```


## 成员的访问

- 类中普通数据成员和成员函数必须通过对象去访问
- 只有两种方案

   - 普通对象: 用 对象.成员访问
   - 对象指针:用 对象指针->成员


### 案例代码

```c
#include <iostream>
#include <string>
#include <graphics.h>
#include <iomanip>
using namespace std;
class MM 
{
public:
	void initData(string mmName, int mmAge, int mmNum) 
	{
		name = mmName;
		age = mmAge;
		num = mmNum;
	}
	//不想让别人直接修改数据，不要返回引用，只能看不能操作
	string getName() { return name; }
	int getAge() { return age; }
	int getNum() { return num; }
private:
	string name;
	int age;
	int num;
};
void testObject() 
{
	MM mm;
	mm.initData("小芳", 19, 1002);
	cout << mm.getName() << "\t" << mm.getAge() << "\t" << mm.getNum() << endl;
	//IMAGE img;
	//img.getwidth();
	//img.getheight();
}
void testObjectPoint() 
{
	MM* pMM = new MM;
	pMM->initData("小丽", 29, 1004);
	cout << pMM->getName() << "\t" << pMM->getAge() << "\t" << pMM->getNum() << endl;
}
void testArray() 
{
	MM array[3];
	for (int i = 0; i < 3; i++) 
	{
		string name = "name" + to_string(i);
		array[i].initData(name,18+i,1002+i);
		cout << (array + i)->getName() << "\t" << (array + i)->getAge() << "\t" << (array + i)->getNum() << endl;
	}
}
int main() 
{
	//age = 123;   不能直接访问
	testObject();
	testObjectPoint();
	testArray();
	return 0;
}
```


## 类和对象的其他操作

### 类中含有指针问题

含有指针的处理方案和C语言的结构体中含有指针的处理方案是一样的，相对于C语言来说多了权限问题

```c
#include <iostream>
#include <cstring>
using namespace std;
class MM
{
public:
	void initData(const char* mmName, int mmAge);
	void initMM(const char* mmName, int mmAge);
	void print()
	{
		cout << name << "\t" << age << endl;
	}
	char*& getName() 
	{
		return name;
	}
protected:
	char* name;
	int age;
};
//一般不采用这种方案处理,诟病很大
void MM::initData(const char* mmName, int mmAge)
{
	name = (char *)mmName;
	age = mmAge;
}
void MM::initMM(const char* mmName, int mmAge)
{
	name = new char[strlen(mmName) + 1];
	strcpy(name, mmName);
	age = mmAge;
}
void printConst(const char* str) 	//传入常量和变量 传参const修饰
{
	cout << str << endl;
}
int main()
{

	MM* pMM = new MM;
	pMM->initData("张三", 19);
	pMM->print();
	//strcpy(pMM->getName(), "ILoveyou");  // 百分百有问题，name没有指向一段可操作内存
	char str[10] = "ILoveyou";

	//C++const要求更为严格，尤其是字符串处理
	printConst("ILoveyou");
	printConst(str);

	pMM->getName() =str;
	pMM->print();

	MM* p = new MM;
	p->initMM("ILoveyou",20);
	p->print();
	strcpy(p->getName(), "IMiss");
	p->print();

	return 0;
}
```

### 类不能直接包含自身的对象

只能包含自身指针不能包含自身对象

```c
class Boy 
{
public:
	//Boy boy;       错误代码
	Boy* pBoy;		//指针正确
};
```

### 成员函数指针调用成员函数

```c
class Test 
{
public:
	void print(string info) 
	{
		cout << info << endl;
	}
};
void testFunc() 
{
	Test test;
	//void (*Func)(string) = nullptr;
	//Func = &Test::print;     错误写法，类型
	//1.auto自动推断出类成员函数指针类型
	auto Funcf = &Test::print;   //没问题
	(test.*Funcf)("测试函数");	 //调用还是要学会
	Test testb;
	(testb.*Funcf)("测试函数2");
	testb.print("直接调用");
	//2.正规写一下正常写法
	//不是简单的用*指针名替换函数，而是要加上类名限定
	void (Test:: *Func)(string) = nullptr;
	Func = &Test::print;			//类中所有东西，无论怎么访问，必须类名限定
	(test.*Func)("类成员函数指针访问成员函数");
}
```

<a name="260cd0dc"></a>
### 对象本质

- 对象的本质就是一个数据,只是数据包含操作
- 因为对象的本质是一个数据，所以变量能做的，它都可以

   - 当做函数参数
   - 当做函数返回值
   - 当做另一个结构体数据成员
   - 当做另一个类的数据成员(类的组合，后面会讲)

```c
class Student
{
public:
	void print() 
	{
		cout << name << "\t" << age << endl;
	}
	string& getName() 
	{
		return name;
	}
	int& getAge() 
	{
		return age;
	}
protected:
	string name;
	int age;
};
void printData(Student student) 
{
	student.print();
}
//子函数修改实参，C语言传入实参地址，C++传引用
void modifyStudent(Student& stu) 
{
	stu.getName() = "Memory";
	stu.getAge() = 28;
}
Student* createStu(string name, int age) 
{
	Student* p = new Student;
	p->getName() = name;
	p->getAge() = age;
	return p;
}
void testStudent() 
{
	Student stu;
	modifyStudent(stu);
	printData(stu);
	Student* p = createStu("C++", 19);
	p->print();
	Student temp = *p;
	temp.print();
	//除了赋值之外，其他运算不能直接做
	//Student temp1 = temp + temp;  //算术+条件
}
```
