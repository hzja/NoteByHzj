# C++

<a name="wY6Ry"></a>

## `auto`类型推导
`auto`可以让编译器在编译器就推导出变量的类型，看代码：
```cpp
auto a = 10; // 10是int型，可以自动推导出a是int

int i = 10;
auto b = i; // b是int型

auto d = 2.0; // d是double型
auto f = []() { // f是啥类型？直接用auto就行
    return std::string("d");
}
```
利用`auto`可以通过=右边的类型推导出变量的类型。<br />什么时候使用`auto`呢？简单类型其实没必要使用`auto`，然而某些复杂类型就有必要使用`auto`，比如`lambda`表达式的类型，`async`函数的类型等，例如：
```cpp
auto func = [&] {    
    cout << "xxx";
}; 
// 对于func难道不使用auto吗，反正我是不关心lambda表达式究竟是什么类型。
auto asyncfunc = std::async(std::launch::async, func);
```
<a name="wFxqq"></a>
## 智能指针
C++11新特性中主要有两种智能指针`std::shared_ptr`和`std::unique_ptr`。<br />那什么时候使用`std::shared_ptr`，什么时候使用`std::unique_ptr`呢？

- 当所有权不明晰的情况，有可能多个对象共同管理同一块内存时，要使用`std::shared_ptr`；
- 而`std::unique_ptr`强调的是独占，同一时刻只能有一个对象占用这块内存，不支持多个对象共同管理同一块内存。

两类智能指针使用方式类似，拿`std::unique_ptr`举例：
```cpp
using namespace std;

struct A {
    ~A() {
        cout << "A delete" << endl;
    }
    void Print() {
        cout << "A" << endl;
    }
};


int main() {
    auto ptr = std::unique_ptr<A>(new A);
    auto tptr = std::make_unique<A>(); // error, c++11还不行，需要c++14
    std::unique_ptr<A> tem = ptr; // error, unique_ptr不允许移动，编译失败
    ptr->Print();
    return 0;
}
```
<a name="uYX7L"></a>
## `std::lock`相关
C++11提供了两种锁封装，通过`RAII`方式可动态的释放锁资源，防止编码失误导致始终持有锁。<br />这两种封装是`std::lock_guard`和`std::unique_lock`，使用方式类似，看下面的代码：
```cpp
#include <iostream>
#include <mutex>
#include <thread>
#include <chrono>

using namespace std;
std::mutex mutex_;

int main() {
   auto func1 = [](int k) {
       // std::lock_guard<std::mutex> lock(mutex_);
       std::unique_lock<std::mutex> lock(mutex_);
       for (int i = 0; i < k; ++i) {
           cout << i << " ";
      }
       cout << endl;
  };
   std::thread threads[5];
   for (int i = 0; i < 5; ++i) {
       threads[i] = std::thread(func1, 200);
  }
   for (auto& th : threads) {
       th.join();
  }
   return 0;
}
```
普通情况下建议使用`std::lock_guard`，因为`std::lock_guard`更加轻量级，但如果用在条件变量的`wait`中环境中，必须使用`std::unique_lock`。
<a name="fAHuP"></a>
## 条件变量
条件变量是C++11引入的一种同步机制，它可以阻塞一个线程或多个线程，直到有线程通知或者超时才会唤醒正在阻塞的线程，条件变量需要和锁配合使用，这里的锁就是上面介绍的`std::unique_lock`。<br />这里使用条件变量实现一个`CountDownLatch`：
```cpp

class CountDownLatch {
    public:
    explicit CountDownLatch(uint32_t count) : count_(count);

    void CountDown() {
        std::unique_lock<std::mutex> lock(mutex_);
        --count_;
        if (count_ == 0) {
            cv_.notify_all();
        }
    }

    void Await(uint32_t time_ms = 0) {
        std::unique_lock<std::mutex> lock(mutex_);
        while (count_ > 0) {
            if (time_ms > 0) {
                cv_.wait_for(lock, std::chrono::milliseconds(time_ms));
            } else {
                cv_.wait(lock);
            }
        }
    }

    uint32_t GetCount() const {
        std::unique_lock<std::mutex> lock(mutex_);
        return count_;
    }

    private:
    std::condition_variable cv_;
    mutable std::mutex mutex_;
    uint32_t count_ = 0;
};
```
<a name="wBKye"></a>
## 原子操作
C++11提供了原子类型`std::atomic`，用于原子操作，使用这种方式既可以保证线程安全，也不需要使用锁来进行临界区保护，对一些普通变量来说尤其方便，看代码：
```cpp
std::atomic<int> atomicInt;
atomicInt++;
atomicInt--;
atomicInt.store(2);
int value = atomicInt.load();
```
<a name="adWqM"></a>
## 多线程
什么是多线程这里就不过多介绍，新特性关于多线程最主要的就是`std::thread`的使用，它的使用也很简单，看代码：
```cpp
#include <iostream>
#include <thread>

using namespace std;

int main() {
   auto func = []() {
       for (int i = 0; i < 10; ++i) {
           cout << i << " ";
      }
       cout << endl;
  };
   std::thread t(func);
   if (t.joinable()) {
       t.detach();
  }
   auto func1 = [](int k) {
       for (int i = 0; i < k; ++i) {
           cout << i << " ";
      }
       cout << endl;
  };
   std::thread tt(func1, 20);
   if (tt.joinable()) { // 检查线程可否被join
       tt.join();
  }
   return 0;
}
```
这里记住，`std::thread`在其对象生命周期结束时必须要调用`join()`或者`detach()`，否则程序会`terminate()`，这个问题在C++20中的`std::jthread`得到解决，但是C++20现在多数编译器还没有完全支持所有特性，先暂时了解下即可，项目中没必要着急使用。
<a name="qpGJT"></a>
## 左值右值移动语义相关
大家可能都听说过左值右值，但可能会有部分读者还没有搞清楚这些概念。这里解惑下：<br />关于左值和右值，有两种方式理解：
<a name="XosYL"></a>
### 概念1：
左值：可以放到等号左边的东西叫左值。<br />右值：不可以放到等号左边的东西就叫右值。
<a name="zR307"></a>
### 概念2：
左值：可以取地址并且有名字的东西就是左值。<br />右值：不能取地址的没有名字的东西就是右值。<br />举例来说：
```cpp
int a = b + c
int d = 4; // d是左值，4作为普通字面量，是右值
```
`a`是左值，有变量名，可以取地址，也可以放到等号左边, 表达式`b+c`的返回值是右值，没有名字且不能取地址，`&(b+c)`不能通过编译，而且也不能放到等号左边。<br />左值一般有：

- 函数名和变量名
- 返回左值引用的函数调用
- 前置自增自减表达式`++i`、`--i`
- 由赋值表达式或赋值运算符连接的表达式(a=b, a += b等)
- 解引用表达式`*p`
- 字符串字面值"abcd"

介绍右值前需要先介绍两个概念：纯右值和将亡值。<br />运算表达式产生的临时变量、不和对象关联的原始字面量、非引用返回的临时变量、`lambda`表达式等都是纯右值。例如：

- 除字符串字面值外的字面值
- 返回非引用类型的函数调用
- 后置自增自减表达式`i++`、`i--`
- 算术表达式(`a+b`, `a*b`, `a&&b`, `a==b`等)
- 取地址表达式等(`&a`)

而将亡值是指C++11新增的和右值引用相关的表达式，通常指将要被移动的对象、`T&&`函数的返回值、`std::move`函数的返回值、转换为`T&&`类型转换函数的返回值，将亡值可以理解为即将要销毁的值，通过“盗取”其它变量内存空间方式获取的值，在确保其它变量不再被使用或者即将被销毁时，可以避免内存空间的释放和分配，延长变量值的生命周期，常用来完成移动构造或者移动赋值的特殊任务。例如：
```cpp
class A {
    xxx;
};
A a;
auto c = std::move(a); // c是将亡值
auto d = static_cast<A&&>(a); // d是将亡值
```
<a name="UB9Rv"></a>
## `std::function`和`lambda`表达式
这两个可以说是最常用的特性，使用它们会让函数的调用相当方便。使用`std::function`可以完全替代以前那种繁琐的函数指针形式。<br />还可以结合`std::bind`一起使用，直接看一段示例代码：
```cpp

std::function<void(int)> f; // 这里表示function的对象f的参数是int，返回值是void
#include <functional>
#include <iostream>

struct Foo {
   Foo(int num) : num_(num) {}
   void print_add(int i) const { std::cout << num_ + i << '\n'; }
   int num_;
};

void print_num(int i) { std::cout << i << '\n'; }

struct PrintNum {
   void operator()(int i) const { std::cout << i << '\n'; }
};

int main() {
   // 存储自由函数
   std::function<void(int)> f_display = print_num;
   f_display(-9);

   // 存储 lambda
   std::function<void()> f_display_42 = []() { print_num(42); };
   f_display_42();

   // 存储到 std::bind 调用的结果
   std::function<void()> f_display_31337 = std::bind(print_num, 31337);
   f_display_31337();

   // 存储到成员函数的调用
   std::function<void(const Foo&, int)> f_add_display = &Foo::print_add;
   const Foo foo(314159);
   f_add_display(foo, 1);
   f_add_display(314159, 1);

   // 存储到数据成员访问器的调用
   std::function<int(Foo const&)> f_num = &Foo::num_;
   std::cout << "num_: " << f_num(foo) << '\n';

   // 存储到成员函数及对象的调用
   using std::placeholders::_1;
   std::function<void(int)> f_add_display2 = std::bind(&Foo::print_add, foo, _1);
   f_add_display2(2);

   // 存储到成员函数和对象指针的调用
   std::function<void(int)> f_add_display3 = std::bind(&Foo::print_add, &foo, _1);
   f_add_display3(3);

   // 存储到函数对象的调用
   std::function<void(int)> f_display_obj = PrintNum();
   f_display_obj(18);
}
```
从上面可以看到`std::function`的使用方法，当给`std::function`填入合适的参数表和返回值后，它就变成了可以容纳所有这一类调用方式的函数封装器。`std::function`还可以用作回调函数，或者在C++里如果需要使用回调那就一定要使用`std::function`。<br />`lambda`表达式可以说是C++11引入的最重要的特性之一，它定义了一个匿名函数，可以捕获一定范围的变量在函数内部使用，一般有如下语法形式：
```cpp
auto func = [capture] (params) opt -> ret { 
    func_body; 
};
```
其中`func`是可以当作`lambda`表达式的名字，作为一个函数使用，`capture`是捕获列表，`params`是参数表，`opt`是函数选项(`mutable`之类)， `ret`是返回值类型，`func_body`是函数体。<br />看下面这段使用lambda表达式的示例吧：
```cpp
auto func1 = [](int a) -> int { 
    return a + 1; 
}; 
auto func2 = [](int a) { 
    return a + 2; 
}; 
cout << func1(1) << " " << func2(2) << endl;
```
`std::function`和`std::bind`使得平时编程过程中封装函数更加的方便，而`lambda`表达式将这种方便发挥到了极致，可以在需要的时间就地定义匿名函数，不再需要定义类或者函数等，在自定义STL规则时候也非常方便，让代码更简洁，更灵活，提高开发效率。
<a name="jnLdk"></a>
## `std::file_system`
C++17正式将`file_system`纳入标准中，提供了关于文件的大多数功能，基本上应有尽有，这里简单举几个例子：
```cpp
namespace fs = std::filesystem;
fs::create_directory(dir_path);
fs::copy_file(src, dst, fs::copy_options::skip_existing);
fs::exists(filename);
fs::current_path(err_code);
```
`file_system`之前，想拷贝个文件、获取文件信息等都需要使用好多C语言API搭配使用才能完成需求，而有了`file_system`，一切都变得相当简单。`file_system`是C++17才引入的新功能，但其实在C++14中就可以使用了，只是`file_system`在`std::experimental`空间下。
<a name="R5lnR"></a>
## `std::chrono`
`chrono`很强大，也是常用的功能，平时的打印函数耗时，休眠某段时间等，都是使用`chrono`。<br />在C++11中引入了`duration`、`time_point`和`clocks`，在C++20中还进一步支持了日期和时区。这里简要介绍下C++11中的这几个新特性。
<a name="Jss7x"></a>
### `duration`
`std::chrono::duration`表示一段时间，常见的单位有s、ms等，示例代码：
```cpp
// 拿休眠一段时间举例，这里表示休眠100ms
std::this_thread::sleep_for(std::chrono::milliseconds(100));
```
`sleep_for`里面其实就是`std::chrono::duration`，表示一段时间，实际是这样：
```cpp
typedef duration<int64_t, milli> milliseconds;
typedef duration<int64_t> seconds;
```
`duration`具体模板如下：
```cpp
template <class Rep, class Period = ratio<1> > class duration;
```
Rep表示一种数值类型，用来表示`Period`的数量，比如`int`、`float`、`double`，`Period`是`ratio`类型，用来表示【用秒表示的时间单位】比如`second`，常用的`duration`已经定义好了，在`std::chrono::duration`下：

- `ratio<3600, 1>：hours`
- `ratio<60, 1>：minutes`
- `ratio<1, 1>：seconds`
- `ratio<1, 1000>：microseconds`
- `ratio<1, 1000000>：microseconds`
- `ratio<1, 1000000000>：nanosecons`

ratio的具体模板如下：
```cpp
template <intmax_t N, intmax_t D = 1> class ratio;
```
N代表分子，D代表分母，所以`ratio`表示一个分数，可以自定义`Period`，比如`ratio<2, 1>`表示单位时间是2秒。
<a name="ffgUx"></a>
### `time_point`
表示一个具体时间点，如2020年5月10日10点10分10秒，拿获取当前时间举例：
```cpp
std::chrono::time_point<std::chrono::high_resolution_clock> Now() {
   return std::chrono::high_resolution_clock::now();
}
// std::chrono::high_resolution_clock为高精度时钟，下面会提到
```
<a name="rxzKE"></a>
### `clocks`
时钟，`chrono`里面提供了三种时钟：

- `steady_clock`
- `system_clock`
- `high_resolution_clock`
<a name="ufTuy"></a>
#### `steady_clock`
稳定的时间间隔，表示相对时间，相对于系统开机启动的时间，无论系统时间如何被更改，后一次调用`now()`肯定比前一次调用`now()`的数值大，可用于计时。
<a name="m2xGp"></a>
#### `system_clock`
表示当前的系统时钟，可以用于获取当前时间：
```cpp
int main() {
   using std::chrono::system_clock;
   system_clock::time_point today = system_clock::now();
   std::time_t tt = system_clock::to_time_t(today);
   std::cout << "today is: " << ctime(&tt);
   return 0;
}
// today is: Sun May 10 09:48:36 2020
```
<a name="H3Mf8"></a>
#### `high_resolution_clock`
`high_resolution_clock`表示系统可用的最高精度的时钟，实际上就是`system_clock`或者`steady_clock`其中一种的定义，官方没有说明具体是哪个，不同系统可能不一样，之前看gcc chrono源码中`high_resolution_clock`是`steady_clock`的`typedef`。
