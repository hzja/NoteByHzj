#include <windows.h>
#include <stdio.h>

// 窗口函数的函数原型
LRESULT CALLBACK WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

int WINAPI WinMain(HINSTANCE  hInstance, //当前程序的实例句柄	
				   HINSTANCE  hPrevInstance, 	//现在已不用
				   LPSTR   lpCmdLine,         	 //命令行参数
				   int   nCmdShow)		 //主窗口初始化时的显示方式
{
	//设计一个窗口类
	WNDCLASS wndcls;
	wndcls.style=CS_HREDRAW | CS_VREDRAW;  // 指定如果大小改变就重画
	wndcls.lpfnWndProc=WndProc;	// 窗口函数指针
	wndcls.cbClsExtra=0;		// 没有额外的类内存
	wndcls.cbWndExtra=0;		// 没有额外的类内存
	wndcls.hInstance=hInstance;		// 实例句柄
	wndcls.hIcon=LoadIcon(NULL, IDI_ERROR);	// 使用预定义图标
	wndcls.hCursor=LoadCursor(NULL, IDC_CROSS);	// 使用预定义的光标
	wndcls.hbrBackground=(HBRUSH)GetStockObject(WHITE_BRUSH); // 使用白色背景画刷
	wndcls.lpszMenuName=NULL;	// 不指定菜单
	wndcls.lpszClassName="111";	// 窗口类的名称
	
	//注册这个窗口类
	RegisterClass(&wndcls);
	
	// 创建主窗口
	HWND hwnd;
	hwnd=CreateWindow(
		"111",			// lpClassName，类名
		"hello",			// lpWindowName，标题
		WS_OVERLAPPEDWINDOW,	// dwStyle，窗口风格
		0,			// X，初始 X 坐标
		0,			// Y，初始 Y 坐标
		600,			// nWidth，宽度
		400,			// nHeight，高度
		NULL,			// hWndParent，父窗口句柄
		NULL,			// hMenu，菜单句柄
		hInstance,		// hlnstance，程序实例句柄
		NULL);			// lpParam，用户数据
	
	// 显示窗口，刷新窗口客户区
	ShowWindow(hwnd,SW_SHOWNORMAL);
	UpdateWindow(hwnd);
	
	MSG msg;
	while(GetMessage(&msg,NULL,0,0))  // 从消息队列中取出消息
	{
		TranslateMessage(&msg);  // 转化键盘消息
		DispatchMessage(&msg);  // 将消息分派给相应的窗口
	}
	return msg.wParam;
}

LRESULT CALLBACK WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch(uMsg)
	{
	case WM_CHAR: //字符消息
		char szChar[20];
		sprintf(szChar,"char is %c",wParam);
		MessageBox(hwnd,szChar,"char",0);
		break;
	case WM_LBUTTONDOWN: //鼠标左键按下
		MessageBox(hwnd,"mouse clicked","message",0);
		HDC hdc;
		hdc=GetDC(hwnd);
		TextOut(hdc,0,50,"VC++程序设计", strlen("VC++程序设计"));
		ReleaseDC(hwnd,hdc);
		break;
	case WM_PAINT:  // 窗口客户区需要重画
		HDC hDC;
		PAINTSTRUCT ps;
		hDC=BeginPaint(hwnd,&ps);
		TextOut(hDC,0,0,"你好！",strlen("你好！"));	// 显示文字
		EndPaint(hwnd,&ps);
		break;
	case WM_CLOSE:  //关闭窗口
		if(IDYES==MessageBox(hwnd,"是否真的结束？","message",MB_YESNO))
		{
			DestroyWindow(hwnd);
		}
		break;
	case WM_DESTROY: // 正在销毁窗口
		PostQuitMessage(0);// 向消息队列投递一个WM_QUIT消息
		break;
		// 将我们不处理的消息交给系统做默认处理
	default:
		return DefWindowProc(hwnd,uMsg,wParam,lParam);
	}
	return 0;
}