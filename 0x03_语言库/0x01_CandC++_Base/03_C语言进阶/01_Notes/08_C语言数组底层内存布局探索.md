# C

## 1、一维数组
很多C语言技术书籍上都会说C语言数组虚拟内存地址是连续的，那么来看一下一维数组是否真是如此。写个小程序分别打印数组元素各个地址，观察一下。
```c
#include <stdio.h>
#include <string.h>

int main() {
    int i = 0;

    char arr1[3] = {0};
    printf("一维arr1占用字节数: %d\n", sizeof(arr1));
    printf("一维数组arr1地址\n");
    for (i = 0; i < sizeof(arr1); i++) {
        printf("%p ", arr1 + i);
    }
    printf("\n");
    memset(&arr1[0], 2, sizeof(arr1));
    printf("一维数组arr1内容\n");
    for (i = 0; i < sizeof(arr1); i++) {
        printf("%d ", arr1[i]);
    }
    printf("\n");
    return 0;
}
```
编译运行结果如下：<br />`sizeof`关键字在C语言里用于求数据类型和变量占用字节数，这里特意定义一个char型一维数组，因为char占用一个字节，后面进行一系列处理比较方便。从输出看到一维数组元素地址是连续的，既然地址是连续的那么可以使用`memset`对数组进行初始化。从这里似乎看不到什么特别之处，那么下面看一下二维数组。
```
一维arr1占用字节数: 3
一维数组arr1地址
0x7ffeeb6c73d5 0x7ffeeb6c73d6 0x7ffeeb6c73d7
一维数组arr1内容
2 2 2
```

## 2、二维数组
C语言二维数组有行和列，那么现在可以想一下，二维数组元素虚拟内存地址是否是连续的？元素虚拟内存地址是如何分布的？很多时候大量思考还不如直接写代码做实验观察，下面写个小程序观察一下C语言二维数组虚拟内存地址的分布规律。
```c
#include <stdio.h>
#include <string.h>

int main() {
    int i = 0;
    char *p = NULL;

    char arr2[3][3];
    printf("二维数组rr2占用字节数: %d\n", sizeof(arr2));
    printf("二维数组arr2地址\n");
    p = &arr2[0][0];
    for (i = 0; i < sizeof(arr2); i++) {
        if (i % 3 == 0) {
            printf("\n");
        }
        printf("%p ", p + i);
    }
    printf("\n");
    memset(&arr2[0][0], 3, sizeof(arr2));
    p = &arr2[0][0];
    printf("二维数组arr2内容\n");
    for (i = 0; i < sizeof(arr2); i++) {
        if (i % 3 == 0) {
            printf("\n");
        }
        printf("%d ", *(p + i));
    }
    printf("\n");

    return 0;
}
```
编译输出结果：
```
二维数组rr2占用字节数: 9
二维数组arr2地址

0x7ffeed9043cf 0x7ffeed9043d0 0x7ffeed9043d1
0x7ffeed9043d2 0x7ffeed9043d3 0x7ffeed9043d4
0x7ffeed9043d5 0x7ffeed9043d6 0x7ffeed9043d7
二维数组arr2内容

3 3 3 
3 3 3 
3 3 3
```
在这里依旧像一维数组一样打印二维数组所有元素地址，这里每打印3个元素的地址进行换行。在程序里，定义一个char指针指向二维数组首元素地址，依次输出各个元素地址。从输出可以看出，二维数组元素虚拟内存地址也是连续的。现在思考一个问题，二维数组有行列，数组元素虚拟内存地址到底是按行排列还是按列排列呢？再写一个小程序，按列输出各个元素虚拟内存地址。
```c
#include <stdio.h>
#include <string.h>

int main() {
    int i = 0, j = 0;
    char *p = NULL;

    char arr2[3][3];

    printf("按列输出二维数组arr2元素地址\n");
    for (i = 0; i < 3; i++) {
        for (j = 0; j < 3; j++) {
            printf("%p ", &arr2[i][j]);
        }
        printf("\n");
    }
    printf("\n");

    return 0;
}
```
编译输出结果：
```
按列输出二维数组arr2元素地址
0x7ffeea44a3cf 0x7ffeea44a3d0 0x7ffeea44a3d1
0x7ffeea44a3d2 0x7ffeea44a3d3 0x7ffeea44a3d4
0x7ffeea44a3d5 0x7ffeea44a3d6 0x7ffeea44a3d7
```
本次输出结果和上面的输出结果进行对比可以发现二维数组元素虚拟内存地址是按照列递增。

## 3、多维数组
在C语言里可以定义n维数组只要不嫌麻烦或者项目需要，上面已经分析了一维数组和二维数组元素虚拟内存的布局，那么多维数组元素的虚拟内存布局该如何分析？实践是检验真理唯一标准！直接写代码观察输出总结规律。
```c
#include <stdio.h>
#include <string.h>

int main() {
    int i = 0, j = 0;
    char *p = NULL;

    char arr3[3][3][3];
    printf("三维数组arr3占用字节数: %d\n", sizeof(arr3));
    printf("三维数组arr3地址\n");
    p = &arr3[0][0][0];
    for (i = 0; i < sizeof(arr3); i++) {
        if (i % 3 == 0) {
            printf("\n");
        }
        printf("%p ", p + i);
    }
    printf("\n");
    printf("三维数组arr3内容\n");
    memset(&arr3[0][0][0], 4, sizeof(arr3));
    for (i = 0; i < sizeof(arr3); i++) {
        if (i % 3 == 0) {
            printf("\n");
        }
        printf("%d ", *(p + i));
    }
    printf("\n");

    return 0;
}
```
编译输出结果：
```
三维数组arr3占用字节数: 27
三维数组arr3地址

0x7ffeedda03b0 0x7ffeedda03b1 0x7ffeedda03b2
0x7ffeedda03b3 0x7ffeedda03b4 0x7ffeedda03b5
0x7ffeedda03b6 0x7ffeedda03b7 0x7ffeedda03b8
0x7ffeedda03b9 0x7ffeedda03ba 0x7ffeedda03bb
0x7ffeedda03bc 0x7ffeedda03bd 0x7ffeedda03be
0x7ffeedda03bf 0x7ffeedda03c0 0x7ffeedda03c1
0x7ffeedda03c2 0x7ffeedda03c3 0x7ffeedda03c4
0x7ffeedda03c5 0x7ffeedda03c6 0x7ffeedda03c7
0x7ffeedda03c8 0x7ffeedda03c9 0x7ffeedda03ca
三维数组arr3内容

4 4 4 
4 4 4 
4 4 4 
4 4 4 
4 4 4 
4 4 4 
4 4 4 
4 4 4 
4 4 4
```
这里依旧可以使用`sizeof`求出三维数组占用字节数，并且完全与三维数组arr3占用实际字节数相等。而且可以看到三维数组元素虚拟内存地址也是连续的，**现在可以进行归纳总结：在C语言里无论是几维数组元素虚拟内存地址都是连续的，并且可以用**`**sizeof**`**求出实际占用字节数。**现在继续写一个小程序探索一下三维数组元素内存地址是如何分布的。
```c
#include <stdio.h>
#include <string.h>

int main() {
    int i = 0, j = 0, k = 0;
    char *p = NULL;

    char arr3[3][3][3];

    printf("三维数组arr3元素内存地址\n");
    for (i = 0; i < 3; i++) {
        for (j = 0; j < 3; j++) {
            for (k = 0; k < 3; k++) {
                printf("%p ", &arr3[i][j][k]);
            }
            printf("\n");
        }
        printf("\n");
    }
    printf("\n");

    return 0;
}
```
编译输出结果：
```
三维数组arr3元素内存地址
0x7ffee11723b0 0x7ffee11723b1 0x7ffee11723b2
0x7ffee11723b3 0x7ffee11723b4 0x7ffee11723b5
0x7ffee11723b6 0x7ffee11723b7 0x7ffee11723b8

0x7ffee11723b9 0x7ffee11723ba 0x7ffee11723bb
0x7ffee11723bc 0x7ffee11723bd 0x7ffee11723be
0x7ffee11723bf 0x7ffee11723c0 0x7ffee11723c1

0x7ffee11723c2 0x7ffee11723c3 0x7ffee11723c4
0x7ffee11723c5 0x7ffee11723c6 0x7ffee11723c7
0x7ffee11723c8 0x7ffee11723c9 0x7ffee11723ca
```
看到这里，现在知道在C语言里多维数组元素内存布局规律了吗？从输出可以看出在C语言里三维数组里元素内存地址从最外层（距离变量名最远）到最内层（距离变量名最近）递增。在二维数组里最外层是列，最里层是行，且是按照列递增元素虚拟内存地址，和三维数组元素虚拟地址递增方式一样。**最后可以总结归纳一下，C语言里n维数组元素虚拟内存布局规律：在C语言里n维数组（n >= 1）的元素虚拟地址都是从最外层（距离变量名最远）递增到最内存（距离变量名最近）。**
