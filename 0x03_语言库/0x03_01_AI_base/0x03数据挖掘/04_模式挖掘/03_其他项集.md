# 高维及庞大项集
```
初始化：利用一个算法挖掘粗所有项比较少的频繁项集，比如3-项集
迭代：
    在每一轮，随机从当前的模式池选择出K种子模式
    对于每个的选择出的种子模式，我们找到所有以种子模式为中心且在界限内的模式(聚类)
    所有这些被找到的模式融合一起生成一个父模式集合
    所有的父模式集合作为下一轮的模式池进入下一次迭代
终止：在此轮迭代开始时，当前模式池包含不超过K模式
```

---


# 序列模式
## 项集数据和序列数据

首先我们看看项集数据和序列数据有什么不同，如下图所示。

![序列模式1.png](./img/1592294517804-ddc89da6-0885-4f04-a6f3-5c0364f4444a.png)

左边的数据集就是项集数据，在Apriori和FP Tree算法中我们也已经看到过了，每个项集数据由若干项组成，这些项没有时间上的先后关系。而右边的序列数据则不一样，它是由若干数据项集组成的序列。比如第一个序列![](./img/e9399c9a442d8b252394ecbb2744b6c4.svg)，它由a，abc，ac，d，cf共5个项集数据组成，并且这些项集有时间上的先后关系。对于多于一个项的项集我们要加上括号，以便和其他的项集分开。同时由于项集内部是不区分先后顺序的，为了方便数据处理，我们一般将序列数据内所有的项集内部按字母顺序排序。

注:序列模式的序列是指项集是有相互顺序的，但项集内部是没有顺序的。


## 子序列与频繁序列

了解了序列数据的概念，我们再来看看什么是子序列。子序列和我们数学上的子集的概念很类似，也就是说，如果某个序列![](./img/7fc56270e7a70fa81a5935b72eacbe29.svg)所有的项集在序列![](./img/9d5ed678fe57bcca610140957afab571.svg)中的项集都可以找到，则![](./img/7fc56270e7a70fa81a5935b72eacbe29.svg)就是![](./img/9d5ed678fe57bcca610140957afab571.svg)的子序列。当然，如果用严格的数学描述，子序列是这样的：

对于序列![](./img/a2817135f5ebb0eb35cff11f99bda1a5.svg)和序列![](./img/4b7a1e53a60527d2e3147a401a8506bb.svg)，如果存在数字序列![](./img/85a3e7d861d55d7851eec1181d941c9d.svg)，满足![](./img/2c54fb30a36fd5c6e36fe3039baac9d1.svg)，则称![](./img/7fc56270e7a70fa81a5935b72eacbe29.svg)是![](./img/9d5ed678fe57bcca610140957afab571.svg)的子序列。当然反过来说，![](./img/9d5ed678fe57bcca610140957afab571.svg)是![](./img/7fc56270e7a70fa81a5935b72eacbe29.svg)的超序列。

而频繁序列则和我们的频繁项集很类似，也就是频繁出现的子序列。比如对于下图，支持度阈值定义为50%，也就是需要出现两次的子序列才是频繁序列。而子序列![](./img/f78fa7748c9d94ae144a263eccf33678.svg)是频繁序列，因为它是图中的第一条数据和第三条序列数据的子序列，对应的位置用蓝色标示。

![序列模式2.png](./img/1592294529039-89182239-d140-446c-bf61-a370e4febadf.png)


## GSP

![GSP.png](./img/1592294569889-3bc22ef4-7c92-4922-9dcc-701f46500554.png)


## SPADE

![SPADE.png](./img/1592294589951-ea3c0dc8-4ec1-402f-90e5-45b67d810701.png)


## PrefixSpan

PrefixSpan算法的全称是Prefix-Projected Pattern Growth，即前缀投影的模式挖掘。里面有前缀和投影两个词。那么我们首先看看什么是PrefixSpan算法中的前缀prefix。

![PrefixSpan1.png](./img/1592294619675-a8ec992a-c926-45bf-a047-bfa227644d6d.png)

在PrefixSpan算法中的前缀prefix通俗意义讲就是序列数据前面部分的子序列。如果用严格的数学描述，前缀是这样的：序列![](./img/bacff1803ec2657cfbcd7b45340d22d3.svg)和序列![](./img/b2ab950e61dca18f42611ad1dfa0325e.svg)，![](./img/a9c6d1101125bbf3954a5821e556cced.svg)。满足![](./img/ef00461466cdbba5429319347a00d030.svg)，而![](./img/1d9b2af44f54014fff187e49daa3aa77.svg)，则称![](./img/7fc56270e7a70fa81a5935b72eacbe29.svg)是![](./img/9d5ed678fe57bcca610140957afab571.svg)的前缀。比如对于序列数据![](./img/4a30ed9221e69a85c4cb762a582bf300.svg)，而![](./img/365ec640ae43c191c95198a62e32f5c4.svg)，则![](./img/7fc56270e7a70fa81a5935b72eacbe29.svg)是![](./img/9d5ed678fe57bcca610140957afab571.svg)的前缀。当然![](./img/9d5ed678fe57bcca610140957afab571.svg)的前缀不止一个，比如![](./img/8de3a8eaee8debe226ef01ac1650fc4d.svg)也是![](./img/9d5ed678fe57bcca610140957afab571.svg)的前缀。

看了前缀，我们再来看前缀投影，其实前缀投影这儿就是我们的后缀，有前缀就有后缀嘛。前缀加上后缀就可以构成一个我们的序列。下面给出前缀和后缀的例子。对于某一个前缀，序列里前缀后面剩下的子序列即为我们的后缀。如果前缀最后的项是项集的一部分，则用一个“_”来占位表示。

下面这个例子展示了序列![](./img/e9399c9a442d8b252394ecbb2744b6c4.svg)的一些前缀和后缀，还是比较直观的。要注意的是，如果前缀的末尾不是一个完全的项集，则需要加一个占位符。

在PrefixSpan算法中，相同前缀对应的所有后缀的结合我们称为前缀对应的投影数据库。

![PrefixSpan2.png](./img/1592294654905-9c0a2af1-445e-42f2-922f-12ac605aabf6.png)

PrefixSpan算法由于不用产生候选序列，且投影数据库缩小的很快，内存消耗比较稳定，作频繁序列模式挖掘的时候效果很高。比起其他的序列挖掘算法比如GSP，FreeSpan有较大优势，因此是在生产环境常用的算法。

PrefixSpan运行时最大的消耗在递归的构造投影数据库。如果序列数据集较大，项数种类较多时，算法运行速度会有明显下降。因此有一些PrefixSpan的改进版算法都是在优化构造投影数据库这一块。比如使用伪投影计数。

不过scikit-learn始终不太重视关联算法，一直都不包括这一块的算法集成。当然使用大数据平台的分布式计算能力也是加快PrefixSpan运行速度一个好办法。比如Spark的MLlib就内置了PrefixSpan算法。

### 算法思路

现在我们来看看PrefixSpan算法的思想，PrefixSpan算法的目标是挖掘出满足最小支持度的频繁序列。那么怎么去挖掘出所有满足要求的频繁序列呢。回忆Aprior算法，它是从频繁1项集出发，一步步的挖掘2项集，直到最大的K项集。PrefixSpan算法也类似，它从长度为1的前缀开始挖掘序列模式，搜索对应的投影数据库得到长度为1的前缀对应的频繁序列，然后递归的挖掘长度为2的前缀所对应的频繁序列...以此类推，一直递归到不能挖掘到更长的前缀挖掘为止。

比如对应于我们第二节的例子，支持度阈值为50%。里面长度为1的前缀包括![](./img/3a47785698da557a22d61bcea735089a.svg)，我们需要对这7个前缀分别递归搜索找各个前缀对应的频繁序列。如下图所示，每个前缀对应的后缀也标出来了。由于![](./img/b2f5ff47436671b6e533d8dc3614845d.svg)只在序列4出现，支持度计数只有1，因此无法继续挖掘。我们的长度为1的频繁序列为![](./img/c49baba78d84cdaece28c21f2d414d1d.svg)。去除所有序列中的![](./img/b2f5ff47436671b6e533d8dc3614845d.svg)，即第4条记录变成![](./img/0bcb28f4bb52c93c75ef3d8db98d0337.svg)。

![PrefixSpan3.png](./img/1592294689244-fd6d7e9e-6f99-4fcf-84af-7609621d11dc.png)

现在我们开始挖掘频繁序列，分别从长度为1的前缀开始。这里我们以![](./img/8277e0910d750195b448797616e091ad.svg)为例子来递归挖掘，其他的节点递归挖掘方法和![](./img/8277e0910d750195b448797616e091ad.svg)一样。

方法如下图，首先我们对![](./img/8277e0910d750195b448797616e091ad.svg)的后缀进行计数，得![](./img/391fe07d928479d1bf94944c28680cd4.svg)。注意![](./img/8fa14cdd754f91cc6554c9e71929cce7.svg)和![](./img/7237b129e14a8b0678224235d9e793e4.svg)不一样的，因为前者是在和前缀![](./img/8277e0910d750195b448797616e091ad.svg)不同的项集，而后者是和前缀![](./img/8277e0910d750195b448797616e091ad.svg)同项集。由于此时![](./img/8626246e5caa4d4a43accfca5a0a1633.svg)都达不到支持度阈值，因此我们递归得到的前缀为![](./img/8277e0910d750195b448797616e091ad.svg)的2项频繁序列为![](./img/b64402148fcbef9a25093c087dc22f06.svg)和![](./img/cf9e6a05fe09569184a7aec1867404f3.svg)。

接着我们分别递归![](./img/b64402148fcbef9a25093c087dc22f06.svg)和![](./img/cf9e6a05fe09569184a7aec1867404f3.svg)为前缀所对应的投影序列。首先看![](./img/b64402148fcbef9a25093c087dc22f06.svg)前缀，此时对应的投影后缀只有![](./img/e5b69ee5408efb258ac391f85bf14f36.svg)，此时![](./img/132b57b82da386c08f79f8a3d80fc62c.svg)支持度均达不到阈值，因此无法找到以![](./img/b64402148fcbef9a25093c087dc22f06.svg)为前缀的频繁序列。现在我们来递归另外一个前缀![](./img/cf9e6a05fe09569184a7aec1867404f3.svg)。以![](./img/cf9e6a05fe09569184a7aec1867404f3.svg)为前缀的投影序列为![](./img/846b85b3d46d91dede65f2ef83cbc8eb.svg)，此时进行支持度计数，结果为![](./img/a625dcbee46834e6edbccea897d703a6.svg)，只有![](./img/92eb5ffee6ae2fec3ad71c777531578f.svg)满足支持度阈值，因此我们得到前缀为![](./img/cf9e6a05fe09569184a7aec1867404f3.svg)的三项频繁序列为![](./img/a9a799e41989086e67dc538e35edcc4a.svg)。

我们继续递归以![](./img/a9a799e41989086e67dc538e35edcc4a.svg)为前缀的频繁序列。由于前缀![](./img/a9a799e41989086e67dc538e35edcc4a.svg)对应的投影序列![](./img/4f63d9f5c34e05d93ff24ded735d1a95.svg)支持度全部不达标，因此不能产生4项频繁序列。至此以![](./img/8277e0910d750195b448797616e091ad.svg)为前缀的频繁序列挖掘结束，产生的频繁序列为![](./img/00c2d07ecbc81d4c7e42a4b02cdbc281.svg)。

![PrefixSpan4.png](./img/1592294729888-b83f6677-bd3c-49ad-aa29-6f66972eb482.png)

同样的方法可以得到其他以![](./img/7e58a5ddfd0400a24bbadaa6bce17c0a.svg)为前缀的频繁序列。


### 算法流程

输入：序列数据集![](./img/5dbc98dcc983a70728bd082d1a47546e.svg)和支持度阈值![](./img/7b7f9dbfea05c83784f8b85149852f08.svg)

输出：所有满足支持度要求的频繁序列集

1. 找出所有长度为1的前缀和对应的投影数据库
2. 对长度为1的前缀计数，将支持度低于阈值![](./img/7b7f9dbfea05c83784f8b85149852f08.svg)的前缀项从数据集![](./img/5dbc98dcc983a70728bd082d1a47546e.svg)删除，同时得到所有的频繁1项序列，![](./img/5905475576a21ecdafdaab879ff45aff.svg)
3. 对于每个长度为![](./img/865c0c0b4ab0e063e5caa3387c1a8741.svg)满足支持度要求的前缀进行递归挖掘：
   1. 找出前缀所对应的投影数据库。如果投影数据库为空，则递归返回
   2. 统计对应投影数据库中各项的支持度计数。如果所有项的支持度计数都低于阈值![](./img/7b7f9dbfea05c83784f8b85149852f08.svg)，则递归返回
   3. 将满足支持度计数的各个单项和当前的前缀进行合并，得到若干新的前缀
   4. 令![](./img/b6c8527102a0dddc23cce6bb21099254.svg)，前缀为合并单项后的各个前缀，分别递归执行第3步

### Code实现

[https://spark.apache.org/docs/2.3.0/mllib-frequent-pattern-mining.html](https://spark.apache.org/docs/2.3.0/mllib-frequent-pattern-mining.html)

```python
from pyspark import SparkContext
from pyspark import SparkConf
from  pyspark.mllib.fpm import PrefixSpan

sc = SparkContext("local","testing")

data = [
   [['a'],["a", "b", "c"], ["a","c"],["d"],["c", "f"]],
   [["a","d"], ["c"],["b", "c"], ["a", "e"]],
   [["e", "f"], ["a", "b"], ["d","f"],["c"],["b"]],
   [["e"], ["g"],["a", "f"],["c"],["b"],["c"]]
   ]
rdd = sc.parallelize(data, 2)
model = PrefixSpan.train(rdd, 0.5,4)

sorted(model.freqSequences().collect())
```


## CloSpan(针对closed sequential patterns)

![CloSpan.png](./img/1592381050723-a1ff0e25-bd41-4e63-b8b0-60678d005abe.png)

## 基于约束的序列模式挖掘

![基于约束的序列模式挖掘.png](./img/1592381070231-414e55a3-fb6b-49f3-95bc-e4ab845cc1bf.png)

<a name="waJBC"></a>
### 基于时间约束的序列模式挖掘

![基于时间约束的序列模式挖掘.png](./img/1592381096426-b8d85034-0c21-4f5d-8c77-95e71245944f.png)

---


# 图模式
## 方法分类

候选集生成方式：Apriori vs. Pattern growth (FSG vs. gSpan)

搜索顺序：广度 vs. 深度

重复子图剔除：被动 vs. 主动(gSpan)

支持度计算：GASTON, FFSM, MoFa

模式发现顺序：Path->Tree->Graph (GASTON)


## 基于Apriori的方法

候选集生成 -> 候选集剪枝 -> 支持度计算 -> 候选集剔除  迭代这四步至无法生成候选集或不满足支持度

候选集生成时扩展节点(AGM算法)还是扩展边(FSG算法)都可以，但是经测试是扩展边更高效


## 基于Pattern-Growth的方法

按深度优先来扩展边，从k边子图->(k+1)边子图->(k+2)边子图...

问题：这样会生成很多重复子图

解决：1、定义一个子图生成顺序  2、DFS生成树，用深度优先搜索扁平图  3、gSpan


### gSpan

![gSpan.png](./img/1592381126304-45b992c7-73e9-4e92-9a14-d32509347585.png)

<a name="2d5caeb7"></a>
## 闭合图模式挖掘

如果不存在与高频图![](./img/dfcf28d0734569a6a693bc8194de62bf.svg)有相同支持度的父图![](./img/b1c5660b1392ecb094b31a0e42253ff9.svg)，则![](./img/dfcf28d0734569a6a693bc8194de62bf.svg)是闭合的
<a name="FfDHa"></a>
### CloseGraph
![gSpan.png](./img/1592381166858-da99b5b3-52f8-4b49-8a2f-dbaa6cdd2424.png)
<a name="S2nez"></a>
# Source

[https://blog.csdn.net/anshuai_aw1/article/details/85235044](https://blog.csdn.net/anshuai_aw1/article/details/85235044)
