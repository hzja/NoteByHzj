<a name="a58a08e6"></a>
## 隐马尔可夫模型

介绍隐马尔可夫模型之前，首先需要明白马尔可夫链。

<a name="006c9daa"></a>
### 马尔可夫链

假设随机过程中各个![](./img/86ad9159785a8f6f1c1a74c4eac26365.svg)的概率分布，只与它之前的状态![](./img/cc50d8301ddb3d833f2168022ebb1c67.svg)有关，即![](./img/e4a3c6cf9b8b8f9590d5eea4f34112c7.svg)。比如硬性规定今天的气温只跟昨天有关，跟前天或之前的天气无关。这种假设未必适用所有的应用，但是至少对以前很多不好解决的问题给出了近似解。这个假设后来被命名为马尔可夫假设，而符合这个假设的随机过程则称为马尔可夫过程，也称为马尔可夫链。

![隐马尔可夫1.jpg](./img/1592828299287-1109fabb-8f0c-495b-b4d2-1ff7ced1ea5d.jpeg)

上图中，四个圈表示四个状态，每条边表示一个可能的状态转换，边上的权值为转移概率。例如，状态![](./img/377b1a53b01e907138040867edc7cac2.svg)到状态![](./img/a4e435d4d078e7df1fa07e13d4a32ebb.svg)之间只有一条边，且边上的权重为![](./img/e4c2e8edac362acab7123654b9e73432.svg)。这表示从状态![](./img/377b1a53b01e907138040867edc7cac2.svg)只可能转换到状态![](./img/a4e435d4d078e7df1fa07e13d4a32ebb.svg)，转移概率为![](./img/e4c2e8edac362acab7123654b9e73432.svg)。从![](./img/a4e435d4d078e7df1fa07e13d4a32ebb.svg)出发的有两条边：到![](./img/7068ce0a09670fa0de05318019a7a44a.svg)和到![](./img/b5d338975faf94db214094f2008a10b0.svg)。其中权值![](./img/e95e1ca27d0e39aa03eb5a611ce4122f.svg)表示：如果某个时刻![](./img/e358efa489f58062f10dd7316b65649e.svg)的状态![](./img/86ad9159785a8f6f1c1a74c4eac26365.svg)是![](./img/a4e435d4d078e7df1fa07e13d4a32ebb.svg)，则下一个时刻的状态![](./img/a7f13f3c2a9458be062e9ae65bf0c5b5.svg)的概率是![](./img/e2120c5eb916dba450340fc8d63df4bd.svg)。如果用数学符号表示是![](./img/f86a9de251f7f7e42d466f0e8e0c1566.svg)。类似的，有![](./img/7fb23f095d8f8a975cd69fbfc0a6fdde.svg)。随机选择一个状态作为初始状态，随后按照上述规则随机选择后续状态。这样运行一段时间![](./img/b9ece18c950afbfa6b0fdbfa4ff731d3.svg)后，就会产生一个状态序列：![](./img/8d0e7fc13bd2bfece1c43f0d590fad74.svg)。

<a name="a58a08e6-1"></a>
### 隐马尔可夫模型

隐马尔可夫模型是马尔可夫链的一个扩展：任一时刻![](./img/e358efa489f58062f10dd7316b65649e.svg)的状态![](./img/86ad9159785a8f6f1c1a74c4eac26365.svg)是不可见的。观察者没法通过观察到一个状态序列![](./img/1462b55a711fd73d7b31bd5d3276299a.svg)来推测转移概率等参数。但是，隐马尔可夫模型在每个时刻![](./img/e358efa489f58062f10dd7316b65649e.svg)会输出一个符号![](./img/2b2a0a4b3fbc78a61cec549a40912932.svg)，而且![](./img/2b2a0a4b3fbc78a61cec549a40912932.svg)跟![](./img/86ad9159785a8f6f1c1a74c4eac26365.svg)相关且仅跟![](./img/86ad9159785a8f6f1c1a74c4eac26365.svg)相关。即，我们观测不到状态变化，只能观测到输出符号。

![隐马尔可夫2.png](./img/1592876015294-d5e91e13-af9e-4f7f-8212-9034108cc045.png)

基于马尔可夫假设和独立输出假设，我们可以计算出某个特定的状态序列![](./img/f8a317ff7a0454fcced9aaf4e87cd38c.svg)产生输出符号![](./img/62105f989f430ded6fc4ccb155b89ff1.svg)的概率

![](./img/616c929a5447f3a29cfa39d53a2c6b2e.svg)

除了结构信息，想要确定一个隐马尔可夫模型还需要以下三组参数：

1、状态转移概率：模型在各个状态间转换的概率，通常记为矩阵![](./img/93430792f41aec813468d104b8c5cfcd.svg)其中

![](./img/fdff241b9459606eee73cbd9015158a7.svg)

表示在任意时刻![](./img/e358efa489f58062f10dd7316b65649e.svg)，若状态为![](./img/e406ac4d7c470823a8619c13dd7101be.svg)，则下一时刻状态为![](./img/14730a16e7ffd22066fda608764658c0.svg)的概率

2、输出观测概率：模型根据当前状态获得各个观测值的概率，记矩阵![](./img/38c7d694ccd7c4fc91af45b6e99be6db.svg)其中

![](./img/2eaafb1776cb977d6e441531de7efc9a.svg)

表示任意时刻![](./img/e358efa489f58062f10dd7316b65649e.svg)，若状态为![](./img/e406ac4d7c470823a8619c13dd7101be.svg)，则观测值![](./img/e72a575160511241fdc51b485cea7d1e.svg)被获取的概率

3、初始状态概率：模型在初始时刻各状态出现的概率，记为![](./img/d7f52e2aa7dc6f62041864d2df05dc2f.svg)其中

![](./img/367bf95c53da35ae3bfe73ccace16a72.svg)<br />表示模型的初始状态为![](./img/e406ac4d7c470823a8619c13dd7101be.svg)的概率

通过指定状态空间![](./img/12f27527bbcbebfdebc4ffda139ff725.svg)、观测空间![](./img/bd60d710ce19420dade12257b132cbda.svg)和上面三组参数，就能确定一个隐马尔可夫模型，通常用其参数![](./img/975eef8983cc3c701b3bd6a4bdb2c51d.svg)来指代。给定隐马尔可夫模型![](./img/c6a6eb61fd9c6c913da73b3642ca147d.svg)，它按如下过程产生观测序列![](./img/97914dd616d141e36d07ce78cd04c043.svg)：

1. 设置![](./img/b73c3280b6f85a6ac520af103083f535.svg)，并根据初始状态概率![](./img/4f08e3dba63dc6d40b22952c7a9dac6d.svg)选择初始状态![](./img/4764360e2689c701dfb8b917ba7638ac.svg)
2. 根据状态![](./img/a568bf104397bd8311073893dff24222.svg)和输出观测概率![](./img/9d5ed678fe57bcca610140957afab571.svg)选择观测变量取值![](./img/cf7ee950cf61a6003c0ec4af7971d8a8.svg)
3. 根据状态![](./img/a568bf104397bd8311073893dff24222.svg)和状态转移矩阵![](./img/7fc56270e7a70fa81a5935b72eacbe29.svg)转移模型状态，即确定![](./img/45e4104c78e9eb1a31489fd409e2906d.svg)
4. 若![](./img/447c66836ed2523e0382868ef1d31d51.svg)设置![](./img/877c989c1336eb19adea3326699dba2b.svg)，并转到第2.步，否则停止

其中![](./img/609225fab1a40caaa3820a855255cf26.svg)和![](./img/b60ac2870a337ecdfde02ac01a6e729d.svg)分别为第![](./img/e358efa489f58062f10dd7316b65649e.svg)时刻的状态和观测值

举例如下：假设有4个盒子，每个盒子里都装有红白两种颜色的球

| 盒子 | 1 | 2 | 3 | 4 |
| :---: | :---: | :---: | :---: | :---: |
| 红球 | 5 | 3 | 6 | 8 |
| 白球 | 5 | 7 | 4 | 2 |


按照下面的方法抽球，产生一个球的颜色的观测序列：

开始，从4个盒子里以等概率随机选取1个盒子，从这个盒子里随机抽出1个球，记录颜色后，放回；然后，从当前盒子随机转移到下一个盒子，规则是：如果当前是盒子1，那么下一个盒子一定是盒子2，如果当前是盒子2或3，那么分别以概率0.4，0.6转移到左边或右边的盒子，如果当前是盒子4，那么各以0.5的概率停留在盒子4或转移到盒子3；确定转移的盒子后，再从这个盒子里随机抽取1个球，记录颜色，放回；如此下去，重复5次，得到一个球的颜色的观测序列：

![](./img/45b879bea551ecda3e3493906fe7e89b.svg)

在这个过程中，观察者只能观测到球颜色的序列，观测不到球从哪个盒子取出，即观测不到盒子的序列。

在这个例子中有两个随机序列，一个是盒子的序列（状态序列），一个是球的颜色的观测序列（观测序列）。前者是隐藏的，只有后者是可观测的。这是一个隐马尔可夫模型的例子，根据所给条件，可以明确状态集合、观测集合、序列长度及模型的三要素

状态集合：![](./img/ced93cbdbcde79359c4a756eb951fad0.svg)

观测集合：![](./img/06e6dfb17869ab156c7180b1ec3c96fe.svg)

状态序列和观测序列长度：![](./img/fecf551b5e0e17ba261fb38d7f4f8998.svg)

初始状态概率分布为：![](./img/42777f77bab075e4889bf9cc5ac879ff.svg)

状态转移概率分布为：![](./img/ec505e98c4c9a459f7ed0aac1b28324f.svg)

观测概率分布为：![](./img/45fa3afcc71badb6e63913ade479d6da.svg)

<a name="a33da386"></a>
### 隐马尔可夫模型的训练

围绕着隐马尔可夫模型有三个基本问题：

1. 给定一个模型，如何计算某个特定的输出序列的概率
2. 给定一个模型和某个特定的输出序列，如何找到最能产生这个输出序列的状态序列
3. 给定足够量的观测数据，如何估计隐马尔可夫模型的参数

<a name="446eb7db"></a>
## 三大问题

<a name="4de97f33"></a>
### 给定模型，计算特定的输出序列的概率

使用前向与后向（Forward-Backward）算法。现实任务中，许多任务需要根据以往的观测序列来推测当前时刻最有可能的观测值，这显然可转化为这个计算特定输出序列的概率的问题。

<a name="8ad8e60f"></a>
#### 前向算法

给定隐马尔可夫模型![](./img/c6a6eb61fd9c6c913da73b3642ca147d.svg)，定义到时刻![](./img/e358efa489f58062f10dd7316b65649e.svg)部分观测序列为![](./img/d30b73104a572bc4d0331a31990694c3.svg)且状态为![](./img/da326f7200e158a864695985b2e2f095.svg)的概率为**前向概率**，记作：![](./img/5ab9e8f0dfd9164a1ba25674c414fc94.svg)可以递推地求得前向概率![](./img/72a38afb28584e909938b240ab4d27d1.svg)及观测序列概率![](./img/6f9122ed89c22df2e6263ed956b37a63.svg)

输入：隐马尔可夫模型![](./img/c6a6eb61fd9c6c913da73b3642ca147d.svg)，观测序列![](./img/f186217753c37b9b9f958d906208506e.svg)<br />输出：观测序列概率![](./img/6f9122ed89c22df2e6263ed956b37a63.svg)<br />（1）初值：![](./img/75a80805e645f1f0efd04acb5fb93f81.svg)

（2）递推：对![](./img/339c2a1c3bf7cd4cd0e8132f177436b1.svg)<br />![](./img/aea14520e57fe2dfe61afe61d9c2f34c.svg)

（3）终止：![](./img/27bc94b6dbf2ba955d775a72a7d96e0f.svg)

递推部分就是上个状态转移到当前状态的所有可能乘上当前状态出现对应观测的概率；终止部分即把所有可能出现这种观测的可能加起来，即![](./img/6f9122ed89c22df2e6263ed956b37a63.svg)

**举例如下**

考虑盒子和球模型![](./img/c97cf758ccaab2fce0bd106636e46bea.svg)，状态集合![](./img/4e66464b36b4e885d3294f70c41dcd41.svg)，观测集合![](./img/c2f13d8361173700171329ef81e83dcd.svg)，

![](./img/ab8e0d49e356ed17f4f7d5ff679977cd.svg)，![](./img/27f0de2246a25059e158d5fd7f4033f9.svg)，![](./img/6d736004e5af07a506b4c83e84e1c259.svg)

设![](./img/3e0db748cdfc1dc10642d37a8df8be00.svg)，![](./img/b1b00cfe91c0023643719e431ea0464a.svg)，用前向算法计算![](./img/6f9122ed89c22df2e6263ed956b37a63.svg)

（1）初值：<br />![](./img/4a8be452a49f9e58cb52726b6693c36f.svg)<br />![](./img/a57e186fff666b35c6350d0e7bc0d90a.svg)<br />![](./img/83a7c8f6e5bb299753ed49c6d85d84cb.svg)

（2）迭代：<br />![](./img/64243cc2c02b4dcdd6740aaefef86fb8.svg)<br />![](./img/871ebc9654769f0cf5fa9fec6135e31b.svg)<br />![](./img/9bddcfea41dc7e553f576b1fc04bbe04.svg)<br />![](./img/3e96ae580bfb10767c68b82d2d6201c9.svg)<br />![](./img/066f5fddeb701a62bf097478016c859d.svg)<br />![](./img/44f36ae4db28c1d1476b4d1d007d0dd1.svg)

（3）终止：<br />![](./img/28fed09d9184fd5373dc581b5e8922bb.svg)

<a name="6fb815d9"></a>
#### 后向算法

给定隐马尔可夫模型![](./img/c6a6eb61fd9c6c913da73b3642ca147d.svg)，定义在时刻![](./img/e358efa489f58062f10dd7316b65649e.svg)状态为![](./img/da326f7200e158a864695985b2e2f095.svg)的条件下，从![](./img/43c98a64bcde4857b095743482e04281.svg)到![](./img/b9ece18c950afbfa6b0fdbfa4ff731d3.svg)的部分观测序列为![](./img/5799dab2d3328f8f5d97a830d01015b5.svg)的概率为**后向概率**，记作：![](./img/4f785ba4b3deea847d5c57d380f82bfa.svg)可以用递推地方法求得后向概率![](./img/e2cf72393f4a898513a0bda08d1b1e22.svg)及观测序列概率![](./img/6f9122ed89c22df2e6263ed956b37a63.svg)

输入：隐马尔可夫模型![](./img/c6a6eb61fd9c6c913da73b3642ca147d.svg)，观测序列![](./img/f186217753c37b9b9f958d906208506e.svg)<br />输出：观测序列概率![](./img/6f9122ed89c22df2e6263ed956b37a63.svg)

（1）![](./img/cb63847d872480259352a619e2cbcbda.svg)

（2）对![](./img/fb409df6274cbda6bf9e99a69ab3f8a0.svg)<br />![](./img/a0cc86178deeb0c4c747ece5b06dd641.svg)

（3）![](./img/e422e4b8ebf39f5d6a5ff090016eb1d3.svg)

<a name="4e06bf82"></a>
### 给定模型和特定的输出序列，找到最能产生这个输出序列的状态序列

使用维特比（Viterbi Algorithm）算法。在语音识别等任务中，观测值为语音信号，隐藏状态为文字，目标就是根据观测信号来推断最有可能的状态序列（即对应的文字）。

维特比算法是一种动态规划方法，核心思想是：如果最终的最优路径经过某个![](./img/c02c4a71b77353b6618d5fb75c880ad7.svg)，那么从初始节点到![](./img/df9a2c91fd0411f6c942b10cacc80370.svg)点的路径必然也是一个最优路径，因为每一个节点![](./img/c02c4a71b77353b6618d5fb75c880ad7.svg)只会影响前后两个![](./img/be803de30bf8ae4bec9733689774321c.svg)和![](./img/8e268d819650aa91b5d34fdd3f129cc2.svg)

维特比算法实际上是用动态规划解隐马尔可夫模型预测问题，即用动态规划求概率最大路径。这时一条路径对应着一个状态序列。根据动态规划原理，最优路径具有这样的特性：如果最优路径在时刻![](./img/e358efa489f58062f10dd7316b65649e.svg)通过结点![](./img/70991df5c5bd2bed18661eb397aa1984.svg)，那么这一路径从结点![](./img/70991df5c5bd2bed18661eb397aa1984.svg)到终点![](./img/24506a10c0292ba503e694bc0b23fdec.svg)的部分路径，对于从![](./img/70991df5c5bd2bed18661eb397aa1984.svg)到![](./img/24506a10c0292ba503e694bc0b23fdec.svg)的所有可能的部分路径来说，必须是最优的。因为假如不是这样，那么从![](./img/70991df5c5bd2bed18661eb397aa1984.svg)到![](./img/24506a10c0292ba503e694bc0b23fdec.svg)就有另一条更好的部分路径存在，如果把它和从![](./img/5e432c91623ca672a563c58b83ba6247.svg)到![](./img/70991df5c5bd2bed18661eb397aa1984.svg)的部分路径连接起来，就会形成一条比原来的路径更优的路径，这是矛盾的。依据这一原理，我们只需从时刻![](./img/3f3d5118e374c670258e6e2b2cfb1b0c.svg)开始，递推地计算在时刻![](./img/e358efa489f58062f10dd7316b65649e.svg)状态为![](./img/865c0c0b4ab0e063e5caa3387c1a8741.svg)的各条部分路径的最大概率，直至得到时刻![](./img/66528de02779ea199e6274ffaa3a8c02.svg)状态为![](./img/865c0c0b4ab0e063e5caa3387c1a8741.svg)的各条路径的最大概率。

输入：模型![](./img/73b5677a7472fd948c275c8b601b07b5.svg)和观测![](./img/230ad45fd7d82411b46c080e69f66fa8.svg)<br />输出：最优路径![](./img/da9e60ecc3561de7eeec627d67daac96.svg)<br />（1）初始化：<br />![](./img/a6eabcf9d7c412da39c2d4bb14b3c09c.svg)

（2）递推：对![](./img/8d721fdf1274f1f5c19a3192d7d37a10.svg)<br />![](./img/b4dd6382e0260f3a27f9ef9c6210a1d0.svg)<br />![](./img/f8001a7da11452052d3d09a8d33323fa.svg)

（3）终止：<br />![](./img/d4600b5a0fe80b42df0b93a1dc95b40c.svg)

（4）最优路径回溯：对![](./img/fb409df6274cbda6bf9e99a69ab3f8a0.svg)<br />![](./img/e9770f0483fb88e627357a2e0b4309d6.svg)

**举例如下**

考虑盒子和球模型![](./img/c97cf758ccaab2fce0bd106636e46bea.svg)，状态集合![](./img/4e66464b36b4e885d3294f70c41dcd41.svg)，观测集合![](./img/c2f13d8361173700171329ef81e83dcd.svg)，

![](./img/ab8e0d49e356ed17f4f7d5ff679977cd.svg)，![](./img/27f0de2246a25059e158d5fd7f4033f9.svg)，![](./img/6d736004e5af07a506b4c83e84e1c259.svg)

已知观测序列![](./img/b1b00cfe91c0023643719e431ea0464a.svg)，求最优状态序列，即最优路径![](./img/0b6b4f76c6a55e368b9a91999de4a439.svg)

（1）初始化。在![](./img/3f3d5118e374c670258e6e2b2cfb1b0c.svg)时，对每一个状态![](./img/41cab9292dedca932e9741a7a84f64a6.svg)，求状态![](./img/865c0c0b4ab0e063e5caa3387c1a8741.svg)观测![](./img/2857b4fd34e4e5eb74c88b872110da5f.svg)为红的概率，记此概率为![](./img/6bb83ddb1c89ccb257062e6eee589699.svg)，则

![](./img/cf6ad40ac9230c29485a1af599471b2c.svg)

代入实际数据

![](./img/91e3c0d7d34a3f7806a09002150cc26b.svg)

记![](./img/abcd927d70ce9c5aabd5ab2da40189ac.svg)

（2）在![](./img/a048559662d4b59eb8308cf4f404c163.svg)时，对每个状态![](./img/41cab9292dedca932e9741a7a84f64a6.svg)，求在![](./img/3f3d5118e374c670258e6e2b2cfb1b0c.svg)时状态为![](./img/363b122c528f54df4a0446b6bab05515.svg)观测为红并在![](./img/a048559662d4b59eb8308cf4f404c163.svg)时状态为![](./img/865c0c0b4ab0e063e5caa3387c1a8741.svg)观测![](./img/0a5da2e5220730129349ea549d1b3982.svg)为白的路径的最大概率，记此最大概率为![](./img/6a5e11780902298017cb93f95c78f791.svg)，则

![](./img/33a4b9f10ba0b42a781f9565c73f4c65.svg)

同时，对每个状态![](./img/41cab9292dedca932e9741a7a84f64a6.svg)，记录概率最大路径的前一个状态![](./img/363b122c528f54df4a0446b6bab05515.svg)

![](./img/6f176c18c9855fa1d18ed66fba185cdd.svg)

计算：<br />![](./img/b93d04e00e710fe38de70c508042fb10.svg)

![](./img/e572148ea30ac3800f3c0f11ed43a0ac.svg)<br />![](./img/fba846563b121f3a87af3ae36fd74a7a.svg)

同样，在![](./img/8537377fdd5f3d3367c25fbcd8693925.svg)时，<br />![](./img/e2a2306cbba9eefdc202a243a6923b2a.svg)<br />![](./img/cc8b637288f45cdb93429251d71a01a0.svg)<br />![](./img/b8f834fe934fd66ead40bfac3b3f7366.svg)<br />![](./img/0f1a7f3de20a022bee9a05088387a4ec.svg)

![隐马尔可夫3.png](./img/1592879692523-f49e1bf8-1725-4723-8cbe-11f820fa30b8.png)

（3）以![](./img/7247767256f5aef95a2147aceb81abcc.svg)表示最优路径的概率，则

![](./img/ce687ad932349494501833a414670460.svg)

最优路径的终点是![](./img/9b46971900f0f561562ecec63d26495e.svg)

![](./img/99d575ffceb12727af6400559bef953e.svg)

（4）由最优路径的终点![](./img/9b46971900f0f561562ecec63d26495e.svg)，逆向找到![](./img/6ab09c4995629fc943d7f50d8e987ad5.svg)，![](./img/5e432c91623ca672a563c58b83ba6247.svg)

在![](./img/a048559662d4b59eb8308cf4f404c163.svg)时，![](./img/ba61c616e5a4a151d522400d07bca7fa.svg)<br />在![](./img/3f3d5118e374c670258e6e2b2cfb1b0c.svg)时，![](./img/7be6fcf4386938afd7c472c2499c3be3.svg)

于是求得最优路径，即最优状态序列![](./img/b8a4cdc9faa45fe51fc7e2a7b66e0de0.svg)

<a name="56213c30"></a>
### 给定足够量的观测数据，估计隐马尔可夫模型的参数

使用鲍姆-韦尔奇(Baum-Welch)算法，也就是EM算法。在大多数现实应用中，人工指定模型参数已变得越来越不可行，如何根据训练样本学得最优的模型参数，正好就是本问题。

在利用隐马尔可夫模型解决实际问题中，需要先知道每个状态![](./img/86ad9159785a8f6f1c1a74c4eac26365.svg)产生相应输出符号![](./img/2b2a0a4b3fbc78a61cec549a40912932.svg)的概率![](./img/6f24fa3732f535a8123023bbebfe39a8.svg)，也称为生成概率；和转移概率，即从前一个状态![](./img/cc50d8301ddb3d833f2168022ebb1c67.svg)进入当前状态![](./img/86ad9159785a8f6f1c1a74c4eac26365.svg)的概率![](./img/a3c68fa5826e9071b179d5077accfaad.svg)。这些概率被称为马尔可夫模型的参数，而计算或者估计这些参数的过程称为模型的训练。

我们从条件概率的定义出发，知道：

![](./img/5f1e4945720441152af5854d03ae563b.svg)

![](./img/50ae094672d2b4e57da5bd11f854bc72.svg)

对于上面第一个概率公式（生成概率），状态输出概率，如果有足够多人工标记的数据，知道经过状态![](./img/86ad9159785a8f6f1c1a74c4eac26365.svg)有多少次![](./img/5b01cbefcdbb7359ae9151c2cf6d3794.svg)，每经过这个状态时，分别产生的输出![](./img/2b2a0a4b3fbc78a61cec549a40912932.svg)是什么，而且分别有多少次![](./img/1ee258f8fde354ab94e09641d50afd29.svg)就可以算出（比如语音识别中，符号即每个词对应声波；中英翻译中，中文字为状态，英文字为输出符号）。上述第二个概率公式（转移概率），与前文提到的训练统计语言模型的条件概率完全相同，因此可以依照统计语言模型的训练方法，即数一下出现前一个词后出现这个词的次数（同上文例子，出现“联想”这个词后，出现“公司”的概率是多少，即数一下“联想”的次数，数一下“联想公司”的次数）

![](./img/2712a6ba45fb306205cf7644190d384e.svg)<br />![](./img/5b8046f1a237276ed511f6296a26a501.svg)

然而，像语音识别等这种应用大量人工标注不现实，所以这个方法只适用于一部分应用。因此，训练隐马尔可夫模型更实用的方法是仅仅通过大量观测到的信号![](./img/62105f989f430ded6fc4ccb155b89ff1.svg)就能推算模型参数的![](./img/a3c68fa5826e9071b179d5077accfaad.svg)和![](./img/6f24fa3732f535a8123023bbebfe39a8.svg)的方法，主要是使用鲍姆-韦尔奇算法。

两个不同的隐马尔可夫模型可以产生同样的输出信号，因此，仅仅通过观察到的输出信号来倒推它的隐马尔可夫模型可能会得到多个合适的模型，但总会有一个模型![](./img/b74e69910b0a81b4a3cb5306e038a30d.svg)比其他的![](./img/eb068c46fe58de1acda6b08a72e093e4.svg)更有可能产生观测到的输出，其中![](./img/2554a2bb846cffd697389e5dc8912759.svg)是隐马尔科夫模型的参数（可理解为最大似然）。鲍姆-韦尔奇算法就是来寻找这个最可能的模型![](./img/75a0e4e40acd1f553b343e49aad85dfc.svg)

鲍姆-韦尔奇算法思想：

鲍姆-韦尔奇算法使用的就是EM算法原理。首先找到一组能够产生输出序列![](./img/f186217753c37b9b9f958d906208506e.svg)的模型参数（显然它们是一定存在的，因为转移概率![](./img/44c29edb103a2872f519ad0c9a0fdaaa.svg)和输出概率![](./img/f09564c9ca56850d4cd6b3319e541aee.svg)为均匀分布时，模型可以产生任何输出，当然包括我们观测到的输出![](./img/f186217753c37b9b9f958d906208506e.svg)）现在，有了这样一个初始模型![](./img/bfdbb4a3f27f9c40111dc8a9a59d2d05.svg)，根据上文提到的![](./img/5f1e4945720441152af5854d03ae563b.svg)和![](./img/50ae094672d2b4e57da5bd11f854bc72.svg)公式计算出一组新的模型参数![](./img/7672d625e9a2492987c50d3b87c04349.svg)，为一次迭代，可以证明![](./img/c9089f5c697168bb7980fa836a411795.svg)。经过不断迭代![](./img/e358efa489f58062f10dd7316b65649e.svg)轮，直到模型的质量不再有显著提高，得到的![](./img/2d2eca8e3c91543f842d75169a89dd0d.svg)即我们所求参数。

<a name="d3c958b1"></a>
## [马尔可夫随机场](https://www.zhihu.com/question/35866596/answer/74187736)

马尔可夫随机场（Markov Random Field）包含两层意思。

马尔可夫性质：它指的是一个随机变量序列按时间先后关系依次排开的时候，第![](./img/bac1ab1b8ec3a251cabf813431c52f19.svg)时刻的分布特性，与![](./img/8d9c307cb7f3c4a32822a51922d1ceaa.svg)时刻以前的随机变量的取值无关。拿天气来打个比方。如果我们假定天气是马尔可夫的，其意思就是我们假设今天的天气仅仅与昨天的天气存在概率上的关联，而与前天及前天以前的天气没有关系。其它如传染病和谣言的传播规律，就是马尔可夫的。

随机场：当给每一个位置中按照某种分布随机赋予相空间的一个值之后，其全体就叫做随机场。我们不妨拿种地来打个比方。其中有两个概念：位置（site），相空间（phase space）。“位置”好比是一亩亩农田；“相空间”好比是种的各种庄稼。我们可以给不同的地种上不同的庄稼，这就好比给随机场的每个“位置”，赋予相空间里不同的值。所以，俗气点说，随机场就是在哪块地里种什么庄稼的事情。

马尔可夫随机场：马尔科夫随机场是具有马尔科夫特性的随机拿种地打比方，如果任何一块地里种的庄稼的种类仅仅与它邻近的地里种的庄稼的种类有关，与其它地方的庄稼的种类无关，那么这些地里种的庄稼的集合，就是一个马尔可夫随机场。

<a name="1f29e36c"></a>
### 模型定义

概率图模型是由图表示概率分布。设有联合概率分布![](./img/c362a34d73aad0d7fba4dd1bf1e21b96.svg)，![](./img/9c87f493d64ced16ba967916652d83d9.svg)是一组随机变量。由无向图![](./img/9e9992d6bf50b7580f971487c466a8cb.svg)表示概率分布![](./img/c362a34d73aad0d7fba4dd1bf1e21b96.svg)，即在图![](./img/dfcf28d0734569a6a693bc8194de62bf.svg)中，结点![](./img/f597bb2e018f9feb80df75d899613dbe.svg)表示一个随机变量![](./img/275ecd4169adadf0ed05cd8aedaff544.svg)，![](./img/2bc16c0065f258e8892e8471c8a2a177.svg)；边![](./img/53375db67b95672b2b0522f38d12b96e.svg)表示随机变量之间的概率依赖关系。

给定一个联合概率分布![](./img/c362a34d73aad0d7fba4dd1bf1e21b96.svg)和表示它的无向图![](./img/dfcf28d0734569a6a693bc8194de62bf.svg)。首先定义无向图表示的随机变量之间存在的成对马尔可夫性、局部马尔可夫性和全局马尔可夫性。

成对马尔可夫性：设![](./img/7b774effe4a349c6dd82ad4f4f21d34c.svg)和![](./img/9e3669d19b675bd57058fd4664205d2a.svg)是无向图![](./img/dfcf28d0734569a6a693bc8194de62bf.svg)中任意两个没有边连接的结点，结点![](./img/7b774effe4a349c6dd82ad4f4f21d34c.svg)和![](./img/9e3669d19b675bd57058fd4664205d2a.svg)分别对应随机变量![](./img/53ed852d43f5166c0560d0bd3f86859d.svg)和![](./img/275ecd4169adadf0ed05cd8aedaff544.svg)。其他所有结点为![](./img/f186217753c37b9b9f958d906208506e.svg)，对应的随机变量组是![](./img/20428d714b8c5bae568e95e2bfc05713.svg)。成对马尔可夫性是指给定随机变量组![](./img/20428d714b8c5bae568e95e2bfc05713.svg)的条件下随机变量![](./img/53ed852d43f5166c0560d0bd3f86859d.svg)和![](./img/275ecd4169adadf0ed05cd8aedaff544.svg)是条件独立的，即

![](./img/40c01d529846d19ab8457083ca002e9c.svg)

局部马尔可夫性：设![](./img/f597bb2e018f9feb80df75d899613dbe.svg)是无向图![](./img/dfcf28d0734569a6a693bc8194de62bf.svg)中任意一个结点，![](./img/61e9c06ea9a85a5088a499df6458d276.svg)是与![](./img/9e3669d19b675bd57058fd4664205d2a.svg)有边连接的所有结点，![](./img/f186217753c37b9b9f958d906208506e.svg)是![](./img/9e3669d19b675bd57058fd4664205d2a.svg)，![](./img/61e9c06ea9a85a5088a499df6458d276.svg)以外的其他所有结点。![](./img/9e3669d19b675bd57058fd4664205d2a.svg)表示的随机变量是![](./img/275ecd4169adadf0ed05cd8aedaff544.svg)，![](./img/61e9c06ea9a85a5088a499df6458d276.svg)表示的随机变量组是![](./img/d56eaad3181662388bf82c6ff0d1705a.svg)，![](./img/f186217753c37b9b9f958d906208506e.svg)表示的随机变量是![](./img/20428d714b8c5bae568e95e2bfc05713.svg)。局部马尔可夫性是指在给定随机变量组![](./img/d56eaad3181662388bf82c6ff0d1705a.svg)的条件下随机变量![](./img/275ecd4169adadf0ed05cd8aedaff544.svg)和![](./img/20428d714b8c5bae568e95e2bfc05713.svg)是独立的，即

![](./img/0a23b954f880fc8e562778a8584175b0.svg)

![隐马尔可夫4.png](./img/1592880908379-705a6177-8cfc-41a7-923e-e415378752d9.png)

全局马尔可夫性：设结点集合![](./img/7fc56270e7a70fa81a5935b72eacbe29.svg)，![](./img/9d5ed678fe57bcca610140957afab571.svg)是在无向图![](./img/dfcf28d0734569a6a693bc8194de62bf.svg)中被结点组合![](./img/0d61f8370cad1d412f80b84d143e1257.svg)分开的任意结点集合。结点集合![](./img/7fc56270e7a70fa81a5935b72eacbe29.svg)，![](./img/9d5ed678fe57bcca610140957afab571.svg)，![](./img/0d61f8370cad1d412f80b84d143e1257.svg)所对应的随机变量组分别是![](./img/ee485fd30373e21f257265a590c4c3b5.svg)，![](./img/d0442fe3204d4bb1c099049f88a6b041.svg)，![](./img/f9201c869383bef56a7303910f0f5522.svg)。全局马尔可夫性是指给定随机变量组![](./img/f9201c869383bef56a7303910f0f5522.svg)条件下随机变量![](./img/ee485fd30373e21f257265a590c4c3b5.svg)和![](./img/d0442fe3204d4bb1c099049f88a6b041.svg)是条件独立的，即

![](./img/a027af6f2aa5ee1b89ee26c8f594ee50.svg)

![隐马尔可夫5.png](./img/1592881059036-4c1a08d4-6753-4b21-9a6d-50876489b095.png)

设有联合分布![](./img/c362a34d73aad0d7fba4dd1bf1e21b96.svg)，由无向图![](./img/64a44b190b285a91bdf46901222a20c9.svg)表示，在图![](./img/dfcf28d0734569a6a693bc8194de62bf.svg)中，结点表示随机变量，边表示随机变量之间的依赖关系。如果联合概率分布![](./img/c362a34d73aad0d7fba4dd1bf1e21b96.svg)满足成对、局部或全局马尔可夫性，就称此联合概率分布为概率无向图模型，或马尔可夫随机场。

<a name="d9409e1a"></a>
### 模型的因子分解

马尔科夫随机场(Markov Random Field, MRF)是典型的马尔可夫网，这是一种著名的无向图模型。图中每个结点表示一个或一组变量，结点之间的边表示两个变量之间的依赖关系。马尔科夫随机场有一组[势函数](https://baike.baidu.com/item/%E5%8A%BF%E5%87%BD%E6%95%B0)，又称为“因子”，这是定义在变量子集上的非负实函数，主要用于定义概率分布函数。

![隐马尔可夫6.png](./img/1592881109464-71f2f336-5878-4089-ab1a-608e9fd6d838.png)

上图就是一个简单的马尔科夫随机场。对于图中结点的一个子集，若其中任意两结点间都有边连接，则称该结点子集为一个“团”(clique)。若在一个团中加入另外任何一个结点都不再形成团，则称该团为“极大团”；换言之，极大团就是不能被其他团所包含的团。例如上图![](./img/26d5c5ecf0e321c9d2d86b1682fd1146.svg)，![](./img/f8963f1bdebc1e487931585ec27fcbd6.svg)，![](./img/3f5e7d622f3498faa4f7719feee34ab7.svg)，![](./img/b60aac4d101ffa095d89c6bcad812351.svg)，![](./img/817437415d84447fa360a5c5d5552fc9.svg)，![](./img/d852e3f07f73db3112c49d81d6656b3f.svg)，![](./img/8f38b71172bfdcb48c94cd5a8abf56f2.svg)，![](./img/703e131cc04cae3929f6e34f9cdf5465.svg)都是团，并且除了![](./img/b60aac4d101ffa095d89c6bcad812351.svg)，![](./img/817437415d84447fa360a5c5d5552fc9.svg)，![](./img/8f38b71172bfdcb48c94cd5a8abf56f2.svg)之外都是极大团。显然，每个结点至少出现在一个极大团中。

将概率无向图模型的联合概率分布表示为其最大团上的随机变量的函数的乘积形式的操作，称为概率无向图模型的因子分解。给定概率无向图模型，设其无向图为![](./img/dfcf28d0734569a6a693bc8194de62bf.svg)，![](./img/0d61f8370cad1d412f80b84d143e1257.svg)为![](./img/dfcf28d0734569a6a693bc8194de62bf.svg)上的最大团，![](./img/f9201c869383bef56a7303910f0f5522.svg)表示![](./img/0d61f8370cad1d412f80b84d143e1257.svg)对应的随机变量。那么概率无向图模型的联合概率分布![](./img/c362a34d73aad0d7fba4dd1bf1e21b96.svg)可写作图中所有最大团![](./img/0d61f8370cad1d412f80b84d143e1257.svg)上的函数![](./img/d21120d5b79398884f45c801edb5fd58.svg)的乘积形式，即

![](./img/8146dee2d463d8e44fbf39761d28e5c5.svg)

其中，![](./img/21c2e59531c8710156d34a3c30ac81d5.svg)是规范化因子，由下式得出

![](./img/98d1ddb530ea698e1669767c3c54f0f9.svg)

规范化因子保证![](./img/c362a34d73aad0d7fba4dd1bf1e21b96.svg)构成一个概率分布。函数![](./img/d21120d5b79398884f45c801edb5fd58.svg)称为势函数。这里要求势函数是严格正的，通常定义为指数函数：

![](./img/2cbab2281bde2b5bb752ffd7af2c5de5.svg)

概率无向图模型的因子分解由Hammersley-Clifford定理来保证

![](./img/8146dee2d463d8e44fbf39761d28e5c5.svg)

![](./img/98d1ddb530ea698e1669767c3c54f0f9.svg)

其中，![](./img/0d61f8370cad1d412f80b84d143e1257.svg)是无向图的最大团，![](./img/f9201c869383bef56a7303910f0f5522.svg)是![](./img/0d61f8370cad1d412f80b84d143e1257.svg)的结点对应的随机变量，![](./img/d21120d5b79398884f45c801edb5fd58.svg)是![](./img/0d61f8370cad1d412f80b84d143e1257.svg)上定义的严格正函数，乘积是在无向图所有的最大团上进行的。

<a name="c5c618db"></a>
## [Code实现](https://github.com/fengdu78/lihang-code/blob/master/code/%E7%AC%AC10%E7%AB%A0%20%E9%9A%90%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%A8%A1%E5%9E%8B%28HMM%29/HMM.ipynb)

```python
import numpy as np

class HiddenMarkov:
    def forward(self, Q, V, A, B, O, PI):  # 使用前向算法
        N = len(Q)  # 状态序列的大小
        M = len(O)  # 观测序列的大小
        alphas = np.zeros((N, M))  # alpha值
        T = M  # 有几个时刻，有几个观测序列，就有几个时刻
        for t in range(T):  # 遍历每一时刻，算出alpha值
            indexOfO = V.index(O[t])  # 找出序列对应的索引
            for i in range(N):
                if t == 0:  # 计算初值
                    alphas[i][t] = PI[t][i] * B[i][indexOfO]  # P176（10.15）
                    print('alpha1(%d)=p%db%db(o1)=%f' % (i, i, i, alphas[i][t]))
                else:
                    alphas[i][t] = np.dot([alpha[t - 1] for alpha in alphas], [a[i] for a in A]) * B[i][
                        indexOfO]  # 对应P176（10.16）
                    print('alpha%d(%d)=[sigma alpha%d(i)ai%d]b%d(o%d)=%f' % (t, i, t - 1, i, i, t, alphas[i][t]))
                    # print(alphas)
        P = np.sum([alpha[M - 1] for alpha in alphas])  # P176(10.17)
        # alpha11 = pi[0][0] * B[0][0]    #代表a1(1)
        # alpha12 = pi[0][1] * B[1][0]    #代表a1(2)
        # alpha13 = pi[0][2] * B[2][0]    #代表a1(3)

    def backward(self, Q, V, A, B, O, PI):  # 后向算法
        N = len(Q)  # 状态序列的大小
        M = len(O)  # 观测序列的大小
        betas = np.ones((N, M))  # beta
        for i in range(N):
            print('beta%d(%d)=1' % (M, i))
        for t in range(M - 2, -1, -1):
            indexOfO = V.index(O[t + 1])  # 找出序列对应的索引
            for i in range(N):
                betas[i][t] = np.dot(np.multiply(A[i], [b[indexOfO] for b in B]), [beta[t + 1] for beta in betas])
                realT = t + 1
                realI = i + 1
                print('beta%d(%d)=[sigma a%djbj(o%d)]beta%d(j)=(' % (realT, realI, realI, realT + 1, realT + 1),
                      end='')
                for j in range(N):
                    print("%.2f*%.2f*%.2f+" % (A[i][j], B[j][indexOfO], betas[j][t + 1]), end='')
                print("0)=%.3f" % betas[i][t])
        # print(betas)
        indexOfO = V.index(O[0])
        P = np.dot(np.multiply(PI, [b[indexOfO] for b in B]), [beta[0] for beta in betas])
        print("P(O|lambda)=", end="")
        for i in range(N):
            print("%.1f*%.1f*%.5f+" % (PI[0][i], B[i][indexOfO], betas[i][0]), end="")
        print("0=%f" % P)

    def viterbi(self, Q, V, A, B, O, PI):
        N = len(Q)  # 状态序列的大小
        M = len(O)  # 观测序列的大小
        deltas = np.zeros((N, M))
        psis = np.zeros((N, M))
        I = np.zeros((1, M))
        for t in range(M):
            realT = t+1
            indexOfO = V.index(O[t])  # 找出序列对应的索引
            for i in range(N):
                realI = i+1
                if t == 0:
                    deltas[i][t] = PI[0][i] * B[i][indexOfO]
                    psis[i][t] = 0
                    print('delta1(%d)=pi%d * b%d(o1)=%.2f * %.2f=%.2f'%(realI, realI, realI, PI[0][i], B[i][indexOfO], deltas[i][t]))
                    print('psis1(%d)=0' % (realI))
                else:
                    deltas[i][t] = np.max(np.multiply([delta[t-1] for delta in deltas], [a[i] for a in A])) * B[i][indexOfO]
                    print('delta%d(%d)=max[delta%d(j)aj%d]b%d(o%d)=%.2f*%.2f=%.5f'%(realT, realI, realT-1, realI, realI, realT, np.max(np.multiply([delta[t-1] for delta in deltas], [a[i] for a in A])), B[i][indexOfO], deltas[i][t]))
                    psis[i][t] = np.argmax(np.multiply([delta[t-1] for delta in deltas], [a[i] for a in A]))
                    print('psis%d(%d)=argmax[delta%d(j)aj%d]=%d' % (realT, realI, realT-1, realI, psis[i][t]))
        print(deltas)
        print(psis)
        I[0][M-1] = np.argmax([delta[M-1] for delta in deltas])
        print('i%d=argmax[deltaT(i)]=%d' % (M, I[0][M-1]+1))
        for t in range(M-2, -1, -1):
            I[0][t] = psis[int(I[0][t+1])][t+1]
            print('i%d=psis%d(i%d)=%d' % (t+1, t+2, t+2, I[0][t]+1))
        print(I)

#测试数据
Q = [1, 2, 3]
V = ['红', '白']
A = [[0.5, 0.2, 0.3], [0.3, 0.5, 0.2], [0.2, 0.3, 0.5]]
B = [[0.5, 0.5], [0.4, 0.6], [0.7, 0.3]]
# O = ['红', '白', '红', '红', '白', '红', '白', '白']
O = ['红', '白', '红', '白']
PI = [[0.2, 0.4, 0.4]]

HMM = HiddenMarkov()
# HMM.forward(Q, V, A, B, O, PI)
# HMM.backward(Q, V, A, B, O, PI)
HMM.viterbi(Q, V, A, B, O, PI)
```

<a name="Source"></a>
## Source

[https://www.zhihu.com/question/35866596/answer/236886066](https://www.zhihu.com/question/35866596/answer/236886066)
