<a name="8b425fc0"></a>
## **算法分类**

<a name="dfe0def9"></a>
### **线性非线性**

**非线性时间比较类排序**：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此称为非线性时间比较类排序。

**线性时间非比较类排序**：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此称为线性时间非比较类排序。

![线性非线性.png](./img/1598950014364-acb93b58-513b-4097-ada1-c68fdb66ca89.png)

<a name="f13c3e07"></a>
### 复杂度

![复杂度.png](./img/1598950035065-4f47d489-a9e6-4b11-a02d-ecfcfdcc8fb5.png)

<a name="8b1772dd"></a>
### 相关概念

**稳定**：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。

**不稳定**：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。

**时间复杂度**：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。

**空间复杂度：**是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。

<a name="3dff4320"></a>
## 冒泡排序（Bubble Sort）

![冒泡排序.gif](./img/1598950052393-771c8307-c7a2-41ca-96a0-97efd9a3893a.gif)

<a name="9d0cddba"></a>
## 选择排序（Selection Sort）

![选择排序.gif](./img/1598950071053-2f242ab7-0c56-47af-8242-69a10b8146dd.gif)

<a name="7a963ce8"></a>
## 插入排序（Insertion Sort）

![插入排序.gif](./img/1598950088271-4df19564-1f5f-4128-894b-c58eb1e20c6c.gif)

<a name="a6f93998"></a>
## 希尔排序（Shell Sort）

![希尔排序.gif](./img/1598950108982-68224e4e-76b3-40fd-8a5d-1daed50c4114.gif)

<a name="1f9a4cb0"></a>
## 归并排序（Merge Sort）

![归并排序.gif](./img/1598950123374-725fdab1-a95a-4957-977e-ab557ee79359.gif)

```python
def merge(left, right):
    res = []
    while left and right:
        if left[0] < right[0]:
            res.append(left.pop(0))
        else:
            res.append(right.pop(0))
    res = res + left + right
    return res

def mergesort(lists):
    if len(lists) <= 1:
        return lists
    mid = len(lists)//2
    left = mergesort(lists[:mid])
    right = mergesort(lists[mid:])
    return merge(left,right)
```

<a name="aa698160"></a>
## 快速排序（Quick Sort）

![快速排序.gif](./img/1598950140912-8d845d5b-0244-4d0b-b266-d71a96694fd1.gif)

```python
def partition(arr, beg, end):
    pivot = arr[end-1]
    i = beg - 1
    for j in range(beg, end-1):
        if arr[j] <= pivot:
            i = i + 1
            arr[i], arr[j] = arr[j], arr[i]
    arr[i+1], arr[end-1] = arr[end-1], arr[i+1]
    return i + 1
 
def quicksort(arr, beg, end):
    if beg < end - 1:
        q = partition(arr, beg, end)
        quicksort(arr, beg, q)
        quicksort(arr, q+1, end)
```

<a name="a0e533c5"></a>
## 堆排序（Heap Sort）

![堆排序.gif](./img/1598950163620-88ba83f5-aaa3-431d-a51f-59fe0c3661d9.gif)

<a name="c7bf7272"></a>
## 计数排序（Counting Sort）

![计数排序.gif](./img/1598950178236-8c3800dd-e791-4a07-b1d3-bf0047ad13fd.gif)

<a name="dc5c30cc"></a>
## 桶排序（Bucket Sort）

![桶排序.png](./img/1598950196549-46c403c3-4915-4f34-bee1-4808eb099e3e.png)

<a name="5d9dadd4"></a>
## 基数排序（Radix Sort）

![基数排序.gif](./img/1598950217949-1fce3f7b-f230-42f6-b7b6-b1b0a386c302.gif)

<a name="Source"></a>
## Source

[https://www.cnblogs.com/onepixel/p/7674659.html](https://www.cnblogs.com/onepixel/p/7674659.html)
