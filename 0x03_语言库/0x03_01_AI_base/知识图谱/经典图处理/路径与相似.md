<a name="x13Az"></a>
# 最短路径

最短路径是最早一批被关注的问题之一，DFS、BFS和Dijkstra都是解决最短路径的经典方法，也都非常基础，在这里我就不做过多展开。

<a name="zN2En"></a>
## 深搜(DFS)


[DFS](https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%25E6%25B7%25B1%25E5%25BA%25A6%25E4%25BC%2598%25E5%2585%2588%25E6%2590%259C%25E7%25B4%25A2/5224976%3Ffromtitle%3DDFS%26fromid%3D5055)：深度优先搜索算法(Depth-First-Search，DFS)是一种用于遍历或搜索树或图的算法。沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点![](./img/9e3669d19b675bd57058fd4664205d2a.svg)的所在边都己被探寻过，搜索将回溯到发现节点![](./img/9e3669d19b675bd57058fd4664205d2a.svg)的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。属于盲目搜索。<br />![DFS.gif](./img/1593519674740-b656e283-7a9a-4d60-9857-ad9bcaf9c1f7.gif)
<a name="Bwly2"></a>
## 广搜(BFS)


[BFS](https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%25E5%25AE%25BD%25E5%25BA%25A6%25E4%25BC%2598%25E5%2585%2588%25E6%2590%259C%25E7%25B4%25A2/5224802%3Ffromtitle%3DBFS%26fromid%3D542084)：宽度优先搜索算法(Breadth-First-Search，DFS)以一种系统的方式探寻图的边，从而“发现”![](./img/03c7c0ace395d80182db07ae2c30f034.svg)所能到达的所有顶点，并计算![](./img/03c7c0ace395d80182db07ae2c30f034.svg)到所有这些顶点的距离(最少边数)，该算法同时能生成一棵根为![](./img/03c7c0ace395d80182db07ae2c30f034.svg)且包括所有可达顶点的宽度优先树。所有因为展开节点而得到的子节点都会被加进一个先进先出的队列中。其邻居节点尚未被检验过的节点会被放置在一个被称为 open 的容器中，而被检验过的节点则被放置在被称为 closed 的容器中。<br />![BFS.gif](./img/1593519687159-352588a6-7473-4d74-b627-325fd8d4c259.gif)
<a name="6fncK"></a>
## Dijkstra


[Dijkstra](https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%25E8%25BF%25AA%25E5%2585%258B%25E6%2596%25AF%25E7%2589%25B9%25E6%258B%2589%25E7%25AE%2597%25E6%25B3%2595/23665989%3Ffromtitle%3DDijkstra%25E7%25AE%2597%25E6%25B3%2595%26fromid%3D215612)：Dijkstra算法通过为每个顶点![](./img/9e3669d19b675bd57058fd4664205d2a.svg)保留当前为止所找到从![](./img/03c7c0ace395d80182db07ae2c30f034.svg)到![](./img/9e3669d19b675bd57058fd4664205d2a.svg)的最短路径来工作的<br />![Dijkstra.gif](./img/1593519698605-e8bd2968-a6de-4cfa-9e7e-ff68521eb871.gif)

<a name="1w1sN"></a>
# 节点相似

<a name="uNpiS"></a>
## SimRank

如果两个节点被相似或相同的节点关联，则认为这两个主体相似

![](./img/5fc48fd0d4675fa7ea384ad831ea0862.svg)

<a name="0ILVg"></a>
## Personalized PageRank(P-Pagerank)


P-Pagerank的分数![](./img/9dd4e461268c8034f5c8564e155c67a6.svg)被定义为：![](./img/174c51efa0b749851cfdb62a714a16cf.svg)，其中![](./img/44c29edb103a2872f519ad0c9a0fdaaa.svg)为网络![](./img/dfcf28d0734569a6a693bc8194de62bf.svg)的转移矩阵，![](./img/92eb5ffee6ae2fec3ad71c777531578f.svg)是一个称为Personalized vector随机向量，![](./img/5ce16a78fb200155908b0368fd3680fa.svg)是隐形传输常数。

<a name="WOutV"></a>
## Random Walk

通过元路径(meta-path)![](./img/44c29edb103a2872f519ad0c9a0fdaaa.svg)从节点![](./img/9dd4e461268c8034f5c8564e155c67a6.svg)随机游走到达![](./img/415290769594460e2e485922904f345d.svg)的概率

![路径与相似1.png](./img/1593518390584-be9786df-a18b-4353-9bd6-df853554e2ee.png)

<a name="cJt2e"></a>
## Pairwise Random Walk


根据元路径(meta-path)![](./img/acd250b3d13fd618b2598081858e967f.svg)，从![](./img/90cbc22edf225adf8a68974f51227f05.svg)两点随机游走，到达共同节点![](./img/fbade9e36a3f36d3d676c1b808451dd7.svg)的概率

![路径与相似2.png](./img/1593518473427-cdea096f-fdc7-47f6-964f-5eb898cd3c5e.png)
<a name="n3D0t"></a>
## PathSim

简单回顾一下Meta-path，两个主体在Meta-level的路径，描述两主体的关系比如作者-论文-作者（两个人共写一篇论文，这是网络中两作者间一种联系），当然一个网络中有多种Meta-path，比如作者-论文-会议-论文-作者...

PathSim计算公式：![](./img/fe1a6fc347dcf8cea4751c75c00dd5df.svg)

比如下图例子：![](./img/7bea908f94095d6f2df161fd11f5edcb.svg)

![路径与相似3.png](./img/1593518637687-d2b550e9-aa38-43ec-891e-1681c6b2b7dc.png)  ![路径与相似4.png](./img/1593518649496-911a5886-5aab-45b3-b731-b8cb4a61d964.png)
