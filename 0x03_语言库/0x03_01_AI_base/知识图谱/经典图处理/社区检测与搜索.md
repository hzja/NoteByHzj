<a name="6be40052"></a>
## 社区检测与社区搜索比较

|  | Community Detection | Community Search |
| :---: | :---: | :---: |
| Goal | Find all communities with a global criterion | Find communities for particular persons |
| Cost | Expensive | Less expensive |
| Status | Graphs evolve | Online and dynamic |


<a name="U0m1k"></a>
## 常规算法比较

度量指标：1、计算时间复杂度；2、精确度（与实际标签比较、计算标准化互信息）；3、有效性（聚类系数、模块度、强度）；4、密度敏感性；5、混合社区敏感点；6、离群点检测。

基于下图可以看到，LPA（标签传播算法）和HANP（基于LPA的改进）效果好且高效。<br />![社区检测与搜索1.png](./img/1593432410206-d4420b35-a07a-4a78-a15f-2d2eb5c0cf5b.png)

<a name="790ba709"></a>
## 聚类

<a name="5d203e9e"></a>
### 层次化聚类

输入：给以网络（邻接矩阵）

1. 由网络结构计算距离矩阵
2. 距离确定节点相似度（相邻即![](./img/c4ca4238a0b923820dcc509a6f75849b.svg)，隔最少![](./img/7b8b965ad4bca0e41ab51de7b31363a1.svg)个相连即![](./img/40b85027598d87611b1c8d5d11e46812.svg)）
3. 根据相似度从强到弱递归合并节点
4. 根据实际需求横切树状图（如下图要分![](./img/eccbc87e4b5ce2fe28308fd9f2a7baf3.svg)类，可在![](./img/f033ab37c30201f73f142449d037028d.svg)切一刀：分为绿色，样本6，样本3，4）

![社区检测与搜索2.png](./img/1593432430617-d190f59a-4834-4c4e-9a55-24a1c9953c8d.png)

<a name="a62fb221"></a>
### 谱聚类

将图![](./img/5f65129cab9672382381b89bcea31d5f.svg)切分成相互没有连接的![](./img/8ce4b16b22b58894aa86c421e8759df3.svg)个子图：![](./img/93c8200ed699a487f7f3f4275e626c2e.svg)，要求![](./img/fb6f67d20252339e0985dbb492c972f7.svg)且![](./img/82dfdfe0a88e598ce3e56a63cb2945a6.svg)，设![](./img/61e9c06ea9a85a5088a499df6458d276.svg)为边权重，优化目标为

![](./img/458e805408a0e6b1437c174731f764b8.svg)

将划分问题转化为求解拉普拉斯矩阵的![](./img/8ce4b16b22b58894aa86c421e8759df3.svg)个最小特征值问题。

算法过程：

1. 构建拉普拉斯矩阵：![](./img/b0e0fd674d7fb1861ea5cf57652b39db.svg)，其中![](./img/f623e75af30e62bbd73d6df5b50bb7b5.svg)：度矩阵（对角矩阵），![](./img/61e9c06ea9a85a5088a499df6458d276.svg)：邻接矩阵
2. 标准化：![](./img/c00ad20bd6ed81b01996840378731a1d.svg)
3. 求最小的![](./img/7b8b965ad4bca0e41ab51de7b31363a1.svg)个特征值对应的特征向量（降维）
4. 标准化后再用常规方法（k-means等）聚为![](./img/8ce4b16b22b58894aa86c421e8759df3.svg)各类

![社区检测与搜索3.png](./img/1593434527987-3e8cf23a-bf4e-4529-8d46-853d29078d68.png)

<a name="5bc02040"></a>
## 图划分

目标：划分为近似相等的分区，同时边切边最小。（明尼苏达大学的METIS是最权威的图划分工具）<br />![社区检测与搜索4.png](./img/1593434546472-beb77762-ee97-4691-801b-772caa5ebf01.png)


<a name="4cb92511"></a>
## 分裂算法-GN算法

思想：

1. 定义边介数（betweenness）指标：衡量的是网络里一个边占据其它节点间捷径的程度
2. 具有高边介数的边代表了社区的边界

边介数最常见的定义：图中通过该边的所有最短路径数量。如下图![](./img/7fc56270e7a70fa81a5935b72eacbe29.svg)和![](./img/9d5ed678fe57bcca610140957afab571.svg)之间的边即当前最可能切除的

![社区检测与搜索5.png](./img/1593434604708-83b8a65c-cae5-4069-9188-1f5cf813a18c.png)

算法过程：

1. 找到网络中具有最大边介数的边
2. 删除该边
3. 重复1.和2.，直到所有边被移除或数量已满足要求![](./img/8ce4b16b22b58894aa86c421e8759df3.svg)类

<a name="1663b003"></a>
## 模块度优化算法

思想：

1. 定义模块度（Modularity）指标：衡量一个社区的划分好坏
2. 以模块度为目标进行优化；例如在层次化聚类中使用贪婪算法

一种模块度的定义：![](./img/03c4e065009e6b7f64297e21092e3547.svg)

假设网络被划分为![](./img/8ce4b16b22b58894aa86c421e8759df3.svg)个社区，那么定义一个![](./img/5b5f0112171324a6f9fc5df06f6019dd.svg)的对称矩阵![](./img/e1671797c52e15f763380b45e841ec32.svg)，它的元素![](./img/6fd64a8eafc5224488e3523dd225bb7b.svg)表示社区![](./img/865c0c0b4ab0e063e5caa3387c1a8741.svg)和社区![](./img/363b122c528f54df4a0446b6bab05515.svg)之间的边的数量占比。![](./img/2aecb1dc57e87620a373d19b0a889efb.svg)表示连接社区![](./img/865c0c0b4ab0e063e5caa3387c1a8741.svg)的边的总数占比。

![社区检测与搜索6.png](./img/1593479622089-3f7995ce-5b5d-411e-9b93-536da253d0c1.png)<br />举例如下：

![社区检测与搜索7.png](./img/1593479644523-2642bc36-21f6-4573-9177-d934cdcbe624.png)<br />有小伙伴会疑惑，上图例子里这个7咋来的，这个10又咋来的？其实图链接被看作是双向的，所以完整的计算公式应该如下，第二部分分子3是社区1内有3个边，双向的所以乘以2，再加节点1有一个连接到社区外节点10的边，所以是2乘以3再加1：![](./img/0b49a37a1e5e542bf7ed1f731170d4f5.svg)

<a name="b34ad4a7"></a>
## 标签传播算法

启发式规则：一个节点应该与多数邻居在同一社区内。特点：适合半监督和无监督、效率很高适合大规模、存在震荡->采取异步更新、结果可能不稳定

算法过程：

1. 给每个节点初始化一个标签
2. 在网络中传播标签
3. 选择邻居的标签中数量最多的进行更新（若有相同数量标签时，选择具有最高ID的标签）
4. 重复步骤2和3，直到收敛或满足迭代次数

![社区检测与搜索8.png](./img/1593479917310-994082a3-0287-4b39-94fc-99874f344979.png)

<a name="c497f681"></a>
## 随机游走

思想：

1. 从节点出发随机游走，停留在社区内的概率高于到达社区外的。
2. 重复随机游走，强化并逐渐显现社区结构。

算法过程：

1. 建立邻接矩阵（含自环）
2. 标准化转移概率矩阵
3. Expansion操作，对矩阵计算![](./img/e1671797c52e15f763380b45e841ec32.svg)次幂方
4. Inflation操作，对矩阵元素计算![](./img/4b43b0aee35624cd95b910189b3dc231.svg)次幂方并标准化（这一步将强化紧密的点，弱化松散的点）
5. 重复直到稳定
6. 对结果矩阵进行常规聚类

![社区检测与搜索9.png](./img/1593480065851-ee7abf68-cec7-40c6-b9b9-b7e622e24822.png)  ![社区检测与搜索10.png](./img/1593480075621-ea3b1856-093e-40b2-8abf-a001775c5a3b.png)

<a name="3dd4e07e"></a>
## [K-Truss](https://arxiv.org/pdf/1205.6693.pdf)

给以图![](./img/dfcf28d0734569a6a693bc8194de62bf.svg)，K-truss定义为：每个在最大的子图![](./img/c1d9f50f86825a1a2302ec2449c17196.svg)中的边至少在![](./img/65a601e0d6943f2ee09042ac70807823.svg)个存在于![](./img/c1d9f50f86825a1a2302ec2449c17196.svg)的三角形中，如下左图

1. K-truss: each edge within at least ![](./img/65a601e0d6943f2ee09042ac70807823.svg) triangles
2. Edge Connectivity: common edges shared by triangles
3. Maximal Subgraph

![社区检测与搜索11.png](./img/1593480137304-a48ae3f5-3928-46c6-815c-8be53074be7b.png)  ![社区检测与搜索12.png](./img/1593480178019-4d4071a2-b8d5-4b09-a399-4b4a827289a0.png)

<a name="83eed70d"></a>
## 其它算法

派系过滤算法（clique percolation algorithm）- 社区的网络

领导力扩张（Leadership expansion）- 类似与kmeans

基于聚类系数的方法（Maximal K-Mutual friends）- 目标函数优化

HANP（Hop attenuation & node preference)- LPA增加节点传播能力

SLPA（Speak-Listen Propagation Algorithm)- 记录历史标签序列

Matrix blocking – 根据邻接矩阵列向量的相似性排序

Skeleton clustering – 映射网络到核心连接树后进行检测

算法在实现时通常需要关注：同步/异步，节点遍历方式，平局决胜，迭代终止，超大社区，串行/并行等问题。

<a name="Source"></a>
## Source

[https://arxiv.org/pdf/1205.6693.pdf](https://arxiv.org/pdf/1205.6693.pdf)<br />[https://arxiv.org/pdf/cs/0504107.pdf](https://arxiv.org/pdf/cs/0504107.pdf)<br />[http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.722.9193&rep=rep1&type=pdf](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.722.9193&rep=rep1&type=pdf)<br />[http://keg.cs.tsinghua.edu.cn/jietang/publications/TKDE13-Sun-etl-al-co-evolution-of-multi-typed-objects-in-dynamic-networks.pdf](http://keg.cs.tsinghua.edu.cn/jietang/publications/TKDE13-Sun-etl-al-co-evolution-of-multi-typed-objects-in-dynamic-networks.pdf)
