当对数据建模时，首先应该建立一个标准基线方案，然后再通过优化对该方案进行修改。在项目的第一部分中，必须要投入时间来理解业务需求并进行充分的探索性分析。建立一个原始模型。可以有助于理解数据，采用适当的验证策略，或为引入奇特的想法提供数据的支持。<br />在这个初步阶段之后，可以根据不同的情况选择不同的优化方式，例如改变模型，进行数据的处理，甚至是引入更多的外部数据。<br />对于每个方案，都需要对数据进行处理，建模和验证，这都需要从头开始对模型进行再训练，这时就会浪费很多的时间，如果可以通过一些简单而有效的技巧来提高预测的速度。例如，都知道特征选择是一种降低预测模型输入的特征维数的技术。特征选择是大多数机器学习管道中的一个重要步骤，主要用于提高性能。当减少特征时，就是降低了模型的复杂性，从而降低了训练和验证的时间。<br />在这里，展示了特征选择在减少预测推理时间方面的有效性，同时避免了性能的显着下降。tspiral 是一个 Python 包，它提供了各种预测技术。并且它与 scikit-learn 可以完美的集成使用。<br />为了进行实验，模拟了多个时间序列，每个小时的频率和双季节性(每日和每周)。此外还加入了一个从一个平滑的随机游走中得到的趋势，这样就引入了一个随机的行为。
```python
import numpy as np 
import pandas as pd 
from time import time
from tqdm import tqdm
import matplotlib.pyplot as plt

from sklearn.pipeline import make_pipeline
from sklearn.feature_selection import SelectFromModel
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression, Ridge

from tsprial.forecasting import ForecastingCascade, ForecastingChain


def gen_sinusoidal(timesteps, amp, freq, noise):
    X = np.arange(timesteps)
    e = np.random.normal(0,noise, (timesteps,))
    y = amp*np.sin(X*(2*np.pi/freq))+e
    return y

def gen_randomwalk(timesteps, noise):
    y = np.random.normal(0,noise, (timesteps,))
    return y.cumsum()

def gen_ts(timesteps, amp, freq, noise, random_state=0):
    np.random.seed(random_state)
    
    if isinstance(freq, (int,float)):
        seas = gen_sinusoidal(timesteps=timesteps, amp=amp, freq=freq, noise=noise)
    elif np.iterable(freq) and not isinstance(freq, str):
        seas = np.zeros(timesteps)
        for f in freq:
            if isinstance(f, (int,float)):
                seas += \
                    gen_sinusoidal(timesteps=timesteps, amp=amp, freq=f, noise=noise)
            else:
                raise ValueError("freq not understood.")
    else:
        raise ValueError("freq not understood.")
    
    rw = gen_randomwalk(timesteps=timesteps, noise=1)
    X = np.linspace(0,10, timesteps).reshape(-1,1)
    X = np.power(X, [1,2])
    trend = LinearRegression().fit(X, rw).predict(X)
    
    return seas + trend


def get_metrics(model, X, y, metrics=None):
    
    score = {
        'mse': [model.score(X, y, scoring='mse')],
        'mae': [model.score(X, y, scoring='mae')],
        'mape': [model.score(X, y, scoring='mape')],
        'rmse': [model.score(X, y, scoring='rmse')],
    }
    
    if metrics is not None:
        for metric,s in score.items():
            metrics[metric].extend(s)
    else:
        metrics = score
    
    return metrics


n_series, timesteps = 100, 4000

df = {}
for i in range(n_series):
    df[f'ts_{i}'] = gen_ts(
        timesteps, 
        amp=10, freq=[24,24*7], noise=4,
        random_state=i
    )
df = pd.DataFrame(
    df, index=pd.date_range(
    '2020-01-01', periods=timesteps, freq='H'
    )
)

df.sample(n=10, axis=1, random_state=33).plot(
    legend=False, figsize=(10,5))
```
![](https://cdn.nlark.com/yuque/0/2022/png/396745/1663991417066-11f5e346-daef-4cc5-af7c-6cb1dc5fd939.png#averageHue=%23bb913e&clientId=u82464c8f-5f59-4&from=paste&id=u853203f5&originHeight=314&originWidth=606&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=u07aaa74e-bffa-41db-b5e1-96b13de58e1&title=)<br />这个时序数据的最后一部分是用作测试使用的，会记录其中测量预测误差和做出预测所需的时间。对于这个实验模拟了100个独立的时间序列。之所以说“独立”，是因为尽管它们表现出非常相似的行为，但所有的系列并不相互关联。通过这种方式，分别对它们进行建模。<br />使用目标的滞后值作为输入来预测时间序列。换句话说，为了预测下一个小时的值，使用表格格式重新排列了以前可用的每小时观测值。这样时间序列预测的特征选择就与标准的表格监督任务一样。这样特征选择的算法就可以简单地对滞后的目标特征进行操作。
<a name="TfqCy"></a>
## 递归预测
下面是一个使用递归预测进行特征选择的例子。
```python
from sklearn.linear_model import Ridge
from sklearn.pipeline import make_pipeline
from sklearn.feature_selection import SelectFromModel
from tsprial.forecasting import ForecastingCascade

max_lags = 72
recursive_model = ForecastingCascade(
    make_pipeline(
        SelectFromModel(
            Ridge(), threshold='median',
            max_features=max_lags,
        ), 
        Ridge()
    ),
    lags=range(1,169),
    use_exog=False
)

recursive_model.fit(None, y)

selected_lags = recursive_model.estimator_['selectfrommodel'].get_support(indices=True)
```
<a name="vo77G"></a>
### 选择所有滞后的预测
![](https://cdn.nlark.com/yuque/0/2022/png/396745/1663991417096-bc58aa48-d3b7-4d34-8c44-db817469ce5b.png#averageHue=%23e3d7d7&clientId=u82464c8f-5f59-4&from=paste&id=u785e2fe1&originHeight=104&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=u99d9970b-6785-463a-9cc7-82bd7cb9b07&title=)
<a name="uA2qo"></a>
### 选择周期性滞后的预测
![](https://cdn.nlark.com/yuque/0/2022/png/396745/1663991418158-a2e18cdc-e607-421d-a943-ee8ab1ce52ee.png#averageHue=%23e2d6d6&clientId=u82464c8f-5f59-4&from=paste&id=ue3ebbb94&originHeight=103&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=u885aead3-907d-43b3-91f1-81c6da1b539&title=)
<a name="ZbX4T"></a>
### 选择有意义的滞后的预测
训练数据上选择的有意义的滞后<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1663991417141-ee87f2d1-66cc-4dad-84c8-fb3f79e0d6ca.png#averageHue=%23e2d6d6&clientId=u82464c8f-5f59-4&from=paste&id=ufa2cfbad&originHeight=98&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=ud16703b5-e80f-4733-a7d2-43d4c00cc70&title=)<br />使用元估计器的重要性权重（线性模型的系数）从训练数据中选择重要特征。这是一种简单而快速的选择特征的方法，因为处理后的数据可以使用通常应用于表格回归任务的相同技术来执行。
<a name="LhNSS"></a>
## 直接预测
在直接预测的情况下，需要为每个预测步骤拟合一个单独的估计器。需要为每个预测步骤进行选择。每个估计器会选择不同的重要程度的滞后子集，并汇总结果生成一组独特的有意义的滞后。
<a name="gKiKr"></a>
### 选择所有滞后的预测
![](https://cdn.nlark.com/yuque/0/2022/png/396745/1663991417098-2dd645ea-338b-4103-bbc6-74da01f93ae8.png#averageHue=%23e2d6d6&clientId=u82464c8f-5f59-4&from=paste&id=uff5e40f4&originHeight=100&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=uc8cc4d7c-785a-4b63-84dd-5e79f1cbbaa&title=)
<a name="pKKt2"></a>
### 选择周期性滞后预测
![](https://cdn.nlark.com/yuque/0/2022/png/396745/1663991417407-a6445144-a4a8-49b2-b202-86eb5378fb37.png#averageHue=%23e1d5d5&clientId=u82464c8f-5f59-4&from=paste&id=u5f50de85&originHeight=98&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=u924e77df-5359-452b-b134-3c82a764299&title=)
<a name="GyHZw"></a>
### 选择有意义的滞后的预测
![](https://cdn.nlark.com/yuque/0/2022/png/396745/1663991417458-b5481377-3b94-447f-904c-3417aee237e8.png#averageHue=%23e2d6d6&clientId=u82464c8f-5f59-4&from=paste&id=ucc4c5b28&originHeight=100&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=ua5372689-b327-4399-8bde-4c31fc49aa8&title=)
<a name="tD3kX"></a>
## 结果总结
![](https://cdn.nlark.com/yuque/0/2022/png/396745/1663991417424-dc005f76-8a0d-4228-8545-3513996f4f95.png#averageHue=%23e8e8e8&clientId=u82464c8f-5f59-4&from=paste&id=u421c01d5&originHeight=360&originWidth=1016&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=u40836f5e-e062-4e61-b301-621379988d8&title=)<br />这里采用了三种递归和直接方法。首先，使用过去长达168小时的所有延迟（full）。然后，只使用周期性滞后（dummy）。最后只考虑在训练数据上选择的有意义的滞后（filtered）来拟合模型<br />可以看到最直接方法是最准确的。而full的方法比dummy的和filter的方法性能更好，在递归的方法中，full和filtered的结果几乎相同。<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1663991417610-a62ee487-85b3-43cc-98de-e83c180684dc.png#averageHue=%23a6977c&clientId=u82464c8f-5f59-4&from=paste&id=u71f56858&originHeight=617&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=u97d384db-4d3f-4b90-87a4-019ddb95940&title=)<br />对于时间来说，dummy方法是最快的方法，这个应该是预料之中的因为它考虑的特征数量很少。出于同样的原因，filtered要比full快。但是令人惊讶的是，filtered的速度是full方法的一半。这可能是一个很好的结果，因为可以通过简单的特征选择以更快的方式获得良好的预测。<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1663991417697-71f0044c-6244-4c3d-b9fd-b965161ca0d6.png#averageHue=%23f9f1e3&clientId=u82464c8f-5f59-4&from=paste&id=ufabb6b2f&originHeight=319&originWidth=554&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=u49dceb4d-0af0-4ff8-b16d-962af7ce078&title=)<br />上面的测试结果和表格都是利用 tspiral 的来进行处理和生成的。它简化了有意义的自回归滞后的识别，并赋予了使用时间序列操作特征选择的可能性。最后还通过这个实验发现了如何通过简单地应用适当的滞后选择来减少预测的推理时间。
