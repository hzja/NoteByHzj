数据科学 Python
<a name="EdR68"></a>
## 基本概念
数据：传感器采集到的各种物理、生物、化学指标等等各种可记录、可表征的数量、性质都是数据。现实中某种事物或事物间关系数量或性质的表征与记录，都称之为数据。
<a name="kfVYz"></a>
### 大数据(Big Data)的4V特点
体量大( high Volume )<br />速度快时效高( high Velocity )<br />类型繁多( high Variety )<br />价值密度低( High Veracity )
<a name="JSdKj"></a>
### 数据分析的三大变革
随机样本→全体数据【相对的】<br />精确性→混杂性【不能OR不必？】<br />因果关系→相关关系

| 应用层面 | 有一定适用性 |
| --- | --- |
| 科学层面 | 并未获得学术届一致认可 |

<a name="eU5pc"></a>
### 数据科学
<a name="gjq01"></a>
#### 定义
> 应用科学的方法、流程、算法和系统从多种形式的结构化或非结构化数据中提取知识和洞见的交叉学科。
> ——维基百科

<a name="KJkIo"></a>
#### 数据科学的范畴

- 搜集
- 存储
- 分类
- 处理
- 分析
- 呈现
<a name="jboCP"></a>
#### 数据科学项目中的人员
![](https://cdn.nlark.com/yuque/0/2021/jpeg/396745/1627739083953-802124b7-251f-4731-8d09-7f7099f4052b.jpeg)<br />**数据科学家的职责**

- 设定项目战略
- 挑选数据源及工具
- 保证客户知悉
- 技术层面工作（数据的检查、处理、分析、评价）
- 设定项目计划并跟踪
<a name="P0DER"></a>
## 数据科学项目的典型流程
![](https://cdn.nlark.com/yuque/0/2021/jpeg/396745/1627739491033-95567cd3-f80d-4d6b-9739-0bff101cf4af.jpeg)
<a name="DRuAj"></a>
### 问题的确定
<a name="SNMmU"></a>
#### 用户层面

- 出资方的动机和需求?
- 出资方已经和正在做的?为什么不够好?
<a name="gtrt8"></a>
#### 数据科学层面
现实问题的抽象化描逑预测?<br />分类?打分或排名?聚类?关联?特征化?
<a name="AXQsh"></a>
### 制定目标

- 应用层面
- 模型（数据科学）层面

明确、具体、可验证、可量化
<a name="MGWYq"></a>
### 收集数据
第二步设计并实施实验<br />我能得到什么数据?<br />有助于解决问题吗?<br />数据量是多少?<br />数据质量如何?
<a name="JeeoW"></a>
### 探索性数据分析（简称EDA)
初步了解数据特性<br />形成一些初步假设
<a name="MSqEW"></a>
### 建立模型（分析)
![](https://cdn.nlark.com/yuque/0/2021/jpeg/396745/1627740465511-334d7a4c-9bfc-4fcd-9c44-e875e6a12e46.jpeg)
<a name="oprXN"></a>
### 常见的模型

- 统计学模型
- 回归（线性、Logistic )
- 贝叶斯分类器
- 神经网络
- 随机森林
<a name="oRk8h"></a>
### 评价模型
混淆矩阵<br />ROC曲线和AUC<br />统计检验p-value<br />置信区间<br />专业领域指标
<a name="Y7hvW"></a>
### 指标做到多少算是可接受呢?
有效的数据科学模型评价指标需优于以往实现、同类任务的模型所实现的指标<br />不了解以往工作的情况下→至少要优于空模型【最简单的模型】的指标
<a name="GedWv"></a>
### 展现结果
![](https://cdn.nlark.com/yuque/0/2021/jpeg/396745/1627741623717-45a3b441-15dd-4639-be05-ce482ab08404.jpeg)

<a name="OtOVK"></a>
### 部署模型
测试<br />确保稳定运行<br />避免灾难性决策
<a name="VWU58"></a>
## Python数据科学常用的库
SciPy：科学算法如线性代数、信号与图像处理、优化、FFT;<br />Pandas：特有数据结构;<br />Scikit-learn：预处理、监督/无监督学习、模式选择、验证和误差指标;<br />Matplotlib：绘图。
<a name="cukO7"></a>
## 数据的导入与准备
<a name="MCldm"></a>
### `NumPy.loadtxt`方法
①将指定文件中的数据加载到数组<br />②支持纯文本文件，如后缀名为txt文件和csv文件<br />③返回NumPy的ndarray多维数组<br />④—般用来加载数据类型一致的数据文件
```python
#loadtxt
import numpy as np

x=np.loadtxt('C:\Python\Scripts\my_data\global-earthquakes.csv', delimiter=',')# 注意调用方法时的参数传递语法
print(type(x))
print(x.shape)
print('\n')
print(x[:2,:3]) #ndarray 的二维切取
x_int=np.loadtxt('global-earthquakes.csv', delimiter=',', dtype=int)
print('\n')
print(x_int[:2,:3])
```
loadtxt读取电子表格数据并以二维数组（矩阵）的形式返j默认电子表格中原始数据类型是一致的。<br />不一致时?则尝试转换成一致，不成功则会报错。
<a name="lsCir"></a>
### `Pandas.read_csv`方法
面对数据并不统一的电子表格数据则更倾向于`Pandas.read_csv`方法，`Pandas.read_csv`方法会将电子表格文件中数据转换为Pandas的DataFrame结构。
```python
#read_csv
import pandas as pd

data=pd.read_csv('C:\Python\Scripts\my_data\iris.csv',header=None,names=['sepal_len','sepal_wid','petal_len','petal_wid','target'])
print(type(data))
print('\n')
print(data.head())
print('\n')
```
<a name="vqZY6"></a>
### 获取在线文件——使用Python自带的urllib模块
`urllib.request.urlopen`方法
```python
import urllib

target_page='https://www.csie.ntu.edu.tw/~cjlin/libsvmtools/datasets/binary/a1a'
a2a=urllib.request.urlopen(target_page)
from sklearn.datasets import load_svmlight_file

x_train, y_train = load_svmlight_file(a2a) # 这里是 Python 风格的多重赋值
print (x_train.shape, y_train.shape)
print(x_train[:1][:100]) #x_train 是个稀疏矩阵，返回的是矩阵中非零元素的位置
print(type(x_train))
print('\n')
print(y_train[:10])
print(type(y_train))
```
<a name="CczKk"></a>
### 非结构化数据的格式化处理
对于非结构化的数据，要处理成结构化便于处理的表格形式。
```python
# 文本信息结构化示例
from sklearn.datasets import fetch_20newsgroups

my_news=fetch_20newsgroups(categories=['sci.med']) # 下载医学新闻数据集
print(type(my_news),'\n')
print(twenty_sci_news.data[0],'\n')

from sklearn.feature_extraction.text import CountVectorizer
count_vect=CountVectorizer()
word_count=count_vect.fit_transform(my_news.data) # 返回一个稀疏矩阵对象
print(type(word_count))
print(word_count.shape,'\n')
print(word_count[0]) # 第一行上非零元素的坐标（元组表示）以及频次
word_list=count_vect.get_feature_names()
for n in word_count[0].indices:
	print(word_list[n],'\t appears ', word_count[0,n],'times') # 打印第一篇新闻的字频情况
```
<a name="R0CSe"></a>
### 对大数据的读取
数据量过大时，应该以连续流的方式流入，而非一次性加载
```python
import pandas as pd
my_chunk=pd.read_csv('C:\Python\Scripts\my_data\iris.csv',header=None,
names=['c1','c2','c3','c4','c5'],
chunksize=20)
print(type(my_chunk))
# 注意规定 chunksize 后，返回的数据类型不再是 DataFrame
# 而是一个可迭代的 TextFileReader 对象
# 它保存了若干个 chunk 位置，但只有当被迭代器指到时，才会真正把对应的数据块读入到内存
for n,chunk in enumerate(my_chunk): # 枚举函数既返回元素序号，又返回每个元素
	print(chunk.shape)
    if n <= 2:
    	print(chunk) # 每一个 chunk 又是一个 DataFrame
    print('\n')
    if n <= 2:
    	print(my_chunk.get_chunk(1),'\n')
        #get_chunk 函数是从当前位置起获取指定大小的数据块，返回也是 dataframe
        #get_chunk 会改变迭代器指针
```
csv包中的`reader`函数和`DictReader`函数也可以实现小块数据的迭代
```python
import numpy as np
import pandas as pd
import csv

with open('C:\Python\Scripts\my_data\iris.csv','r') as my_data_stream:
    #with 命令保证后面缩进的命令块执行完毕后文件会关闭
    # 用 open 命令以只读方式打开文件，创建的文件对象保存在 my_data_stream 中
    # 用 csv.reader 对给定的文件对象读取，一次读取文件中的一行，作为列表对象
    # 这里的 reader 返回的是迭代器对象
    my_reader=csv.reader(my_data_stream,dialect='excel')
    for n,row in enumerate(my_reader):
        if n<=5:
            print(row) # 可见每个 row 都是一个列表
            print(type(row),'\n')
```
```python
import numpy as np
import pandas as pd
import csv
def batch_read(filename, batch=5): # 注意自定义函数的语法
with open(filename,'r') as data_stream:
    #with 命令保证后面缩进的命令块执行完毕后文件会关闭
    # 用 open 命令以只读方式打开文件，创建的文件对象保存在 data_stream 中
    batch_output=list() # 初始化 batch_output 列表
    # 用 csv.reader 对给定的文件对象读取，一次读取文件中的一行，作为列表的一个元素
    # 这里的 reader 返回的是迭代器对象
    for n,row in enumerate(csv.reader(data_stream,dialect='excel')):
        # 枚举函数返回包含行号和行内容的元组
        #for 循环遍历 reader 返回的列表
        if n>0 and n%batch==0:
            #yield 属生成器，类似于 return，但可迭代复用,
            # 下句把 batch_output 列表转换为 ndarray 返回
            yield(np.array(batch_output))
            batch_output=list() # 重置 batch_output
        batch_output.append(row) # 更新 batch_output
    yield(np.array(batch_output)) # 返回最后的几行
for batch_input in batch_read('C:\Python\Scripts\my_data\iris.csv',batch=7):
    # 注意允许修改默认参数
    print(batch_input)
    print('\n')
```
<a name="cwXvM"></a>
## 探索性数据分析
EDA目的探索性数据分析，简称EDA

- 初步了解数据集
- 验证初步假设
1. EDA的基本流程与常用方法
2. EDA后的数据处理与清洗
3. 必要补充

①统计学概念<br />②现代信号处理背景
<a name="BsCsa"></a>
### EDA的流程

1. 数据检查与预处理

数据检查:数据的规模与特征的数据类型及意义<br />预处理∶缺失处理<br />异常处理冗余处理

2. 数据的初步分析
```python
import pandas as pd
my_data = pd.read_csv("C:\Python\Scripts\my_data\Titanic.csv")
my_data
print(my_data.info()) # 这里可以看到，dataframe 的 info 方法能返回对数据的一些总结
<class 'pandas.core.frame.DataFrame'>
RangeIndex: 891 entries, 0 to 890
Data columns (total 12 columns):
PassengerId 891 non-null int64
Survived 891 non-null int64
Pclass 891 non-null int64
Name 891 non-null object
Sex 891 non-null object
Age 714 non-null float64
SibSp 891 non-null int64
Parch 891 non-null int64
Ticket 891 non-null object
Fare 891 non-null float64
Cabin 204 non-null object
Embarked 889 non-null object
dtypes: float64(2), int64(5), object(5)
memory usage: 83.6+ KB
```
<a name="TzJ7F"></a>
### 数据类型的判断以及后期的作用
![](https://cdn.nlark.com/yuque/0/2021/jpeg/396745/1627827332806-bbdb0a38-980a-4cee-8593-f836f2a71c67.jpeg)
<a name="tAqsd"></a>
### 数据的问题
数据有缺失吗?要如何处理?<br />数据有明显异常吗?怎么处理?<br />数据有冗余吗?怎么处理?
<a name="Yq9lM"></a>
#### 缺失数据（用NaN来表示）
<a name="p7Ycz"></a>
##### 直接丢弃?
`dataframe.dropna`函数(样本容量大，缺失信息少)
```python
import pandas as pd
import numpy as np
my_data = pd.read_csv("C:\Python\Scripts\my_data\Titanic.csv")
my_data.head(15)
# 设置参数axis=0则丢弃所有有Nan的行
my_fil_data1=my_data.dropna(axis=0)
my_fil_data1.head(7)
# 设置参数axis=0则丢弃所有有Nan的列
my_fil_data2=my_data.dropna(axis=1)
my_fil_data2.head(7)
```
<a name="upG2a"></a>
##### 做特定的替代?
`dataframe.fillna`方法(样本容量小，无法承受信息进一步缺失，将缺失值进行替换处理)
```python
mean_Age=int(my_data[['Age']].mean()[0])
my_dict={'Age':mean_Age,'Cabin':'haha'}
my_fil_data3=my_data.fillna(my_dict)
my_fil_data3.head(7)

# 如果不用固定值来填充缺失项，fillna还提供用邻近值来填充的选择。

# method='ffill'表示使用缺失值之前的有效值进行填充
my_fil_data4=my_data.fillna(method='ffill')
my_fil_data4.head(7)

# method='bfill'表示使用缺失值之后的有效值进行填充
my_fil_data5=my_data.fillna(method='bfill')
my_fil_data5.head(7)
```
![](https://cdn.nlark.com/yuque/0/2021/jpeg/396745/1627828566362-86b1686d-ac33-43b5-bab0-a35ab73c5191.jpeg)
<a name="OxPIu"></a>
#### 服从正态分布的数据：z-score

(无量纲)<br />Z-score >3怀疑异常
<a name="D1udO"></a>
#### 不服从正态分布的数据使用四分位距方法处理
q1——第1个四分位数<br />q3——第3个四分位数<br />——四分位距

<a name="FSBVS"></a>
### 异常值
| 情况 | 处理方法 |
| --- | --- |
| 确定是出错的数据 | 丢弃和替换 |
| 不能肯定是错误 | 增加样本容量 |

①确保样本能尽量真实反映总体<br />②减小异常值对于结果的影响
<a name="GZqJr"></a>
### 数据冗余
数据中含有重复值，冗余数据在存储和计算中消耗更多的资源，并不能因此而提升性能，因此最好去除。
```python
import pandas as pd
student_scores=pd.DataFrame({'姓名':['张三']*3+['李四']*3+['王五']*3,'成绩':[10,10,10,8,8,8,5,5,5]})
student_scores
# duplicated()方法可以判断重复情况
student_scores.duplicated()
# drop_duplicates()可以直接删除重复值
my_fil_data5=student_scores.drop_duplicates()
my_fil_data5
```
数据列直接重复的情况——直接通过列名称或特征名筛选
<a name="Efa70"></a>
#### 不同特征出现冗余的情况
比如年收入是月平均收入的12倍，这两个特征是重复的，必须删除一个<br />如果一个特征可以通过将另一个特征线性变换得到，那么这两个特征就是重复的，可以去掉一个。
<a name="CdSdq"></a>
#### 判断冗余特征常用方法——线性相关分析
判断冗余特征常用方法：线性相关分析使用`Dataframe.corr`函数<br />当`method=pearson`时，直接求线性相关系数

- 线性相关系数接近1或-1，则说明两个特征存在强的线性相关或反相关，有着较大的冗余;
- 线性相关系数等于0，则说明两个特征间没有线性相关性。
```python
# 求鸢尾花数据每两个特征之间的相关性
import pandas as pd
import numpy as np
my_data = pd.read_csv("C:\Python\Scripts\my_data\iris.csv",header=None,
names=['sepal_length','sepal_width','petal_length','petal_width','target'])
print(my_data.corr(method='pearson'))
sepal_length sepal_width petal_length petal_width
sepal_length 1.000000 -0.109369 0.871754 0.817954
sepal_width -0.109369 1.000000 -0.420516 -0.356544
petal_length 0.871754 -0.420516 1.000000 0.962757
petal_width 0.817954 -0.356544 0.962757 1.000000
```
<a name="uqWi1"></a>
### 数据的描述性统计
<a name="UA0Nc"></a>
#### 描述性统计
不对数据做任何预先地猜想，实事求是地分析样本数据是怎样的。<br />描述性统计结果→思考→形成一些初步结论或假设<br />![](https://cdn.nlark.com/yuque/0/2021/jpeg/396745/1627831059421-c250db71-d3e7-4f7c-a1ba-b9cde6a46a4c.jpeg)
<a name="Iryi0"></a>
#### 位置性测度计算
位置性测度主要用来反映样本集合的中心成员或特定成员在所考察的数域或空间中的位置。

- 算术平均( arithnetic mean )
   - 定义：所有考察的样本值求统计平均。
   - 算术平均容易受样本中的极端值影响。
- 中位数（ median )
   - 定义：将所有样本按数值从小到大或从大到小排序以后，最中间位置的一个数，或者两个数的平均。
   - 中位数对极端值不敏感，但是对于中位数以外的所有值也都不敏感。
- p百分位数（ quantiles )
   - 定义：是将所有样本值按从小到大的顺序排好，排序在第p%的样本取值。第p个百分位数记为Vp→样本中有且仅有p%的观察值小于等于Vp
   - 常用的p百分位数( quantiles )
      - 第10百分位数
      - 第25百分位数（又称第1四分位数)
      - 第75百分位数（又称第3个四分位数)
      - 第90百分位数
      - 第50百分位数（中位数)
- 众数（ mode )
   - 定义：样本集中出现次数最多的那个值。(众数可能只有一个，也可能出现两个甚至更多)
```java
# 位置性测度
import pandas as pd
import numpy as np
my_data = pd.read_csv("C:\Python\Scripts\my_data\Titanic.csv")
print('对 Fare 的位置性测度统计结果：')
print('均值：\t\t',my_data[['Fare']].mean()[0])
#mean 这里返回的是 series，可以用方括号序号来访问，下同
print('中位数：\t',my_data[['Fare']].median()[0])
print('第 25 个百分位数：',my_data[['Fare']].quantile(q=0.25)[0])
#q 参数指明第几个百分位数，默认值是 0.5
print('众数：\t\t',my_data[['Fare']].mode().values[0,0])
#mode 返回的是 dataframe，所以用 dataframe 的 values 属性获取值
#values 本身是 ndarray，所以用二维数组的方式访问

对 Fare 的位置性测度统计结果：
均值： 32.204207968574636
中位数： 14.4542
第 25 个百分位数： 7.9104
众数： 8.05
```
<a name="MNpea"></a>
#### 离散性测度

- 极差
- 方差
- 标准差
- 变异系数

极差( range )：指集合中最大与最小值之间的差异。<br />方差( variance )：对集合中所有样本值相对于均值的偏差的平方求近似平均。<br />标准差( Standard Deviation )：方差的平方根称为标准差。<br />方差与标准差可以总体衡量集合中数据偏离均值的程度。<br />在不同的物理量之间，方差或标准差是不好直接做比较的<br />变异系数( coefficient of variation,CV ) —— 
```java
# 离散性测度
print('对 Fare 的离散性测度统计结果：')
print('变化范围：\t [',my_data[['Fare']].min()[0],'\t',my_data[['Fare']].max()[0],']')
print('极差：\t\t',my_data[['Fare']].max()[0]-my_data[['Fare']].min()[0])
print('方差：\t\t',my_data[['Fare']].var()[0])
print('标准差：\t',my_data[['Fare']].std()[0])
print('变异系数：\t',my_data[['Fare']].std()[0]/my_data[['Fare']].mean()[0])
对 Fare 的离散性测度统计结果：
变化范围： [ 0.0 512.3292 ]
极差： 512.3292
方差： 2469.436845743116
标准差： 49.6934285971809
变异系数： 1.5430725278408497

# describe函数:对dataframe中所有用数值保存的特征(无论是整数还是浮点数)，一次性计算多个常用的描迹性统计量。
# print(my_data[['Fare']].describe())
my_data.describe()
```
`count`函数：对该列所有非空元素的计数<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1627833259280-13ea88b5-2c03-40e3-bf53-4d866e2a15fa.png#clientId=u0d949012-3434-4&from=paste&height=388&id=u3afe387a&originHeight=1163&originWidth=1651&originalType=binary&ratio=1&size=461296&status=done&style=shadow&taskId=uc0906179-85e7-430e-934e-b8b35ffa2f7&width=550.3333333333334)
<a name="IPOUj"></a>
#### 图形化方式：直方图和箱型图
<a name="VQLBp"></a>
##### 直方图：一种反映数据分布的柱状统计图。
将数据分组，记录样本在每个组中出现的频数。<br />X轴———观测参数，分组( bin，通常保持一致)<br />Y轴———对应分组中的样本个数
```java
 my_data[['Fare']].hist(bins=40,figsize=(18,5),xlabelsize=16,ylabelsize=16)
```
![image.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1627833452042-026d387e-e2ba-4578-a1f4-fc782a8ddbcc.png#clientId=u0d949012-3434-4&from=paste&height=182&id=ucc91285c&originHeight=545&originWidth=1640&originalType=binary&ratio=1&size=59177&status=done&style=shadow&taskId=u87aa04db-2e24-461a-9372-d57e8e024da&width=546.6666666666666)
<a name="KRI8F"></a>
##### 箱型图
![image.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1627833576290-f9598d45-bbd3-4b63-b23f-272f26811fcc.png#clientId=u0d949012-3434-4&from=paste&height=259&id=udf3c3a48&originHeight=776&originWidth=1432&originalType=binary&ratio=1&size=605883&status=done&style=none&taskId=u0f30b56a-0154-4187-9495-25c4ed1acae&width=477.3333333333333)
```java
my_data[['Fare']].boxplot()
```
![image.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1627833617010-67e6aa75-9fdc-4059-b35a-5e1b6244a376.png#clientId=u0d949012-3434-4&from=paste&height=319&id=u249781e6&originHeight=958&originWidth=1479&originalType=binary&ratio=1&size=59597&status=done&style=shadow&taskId=u13591379-d3a7-4ba4-91eb-3f8dcd98b62&width=493)
<a name="Ucs18"></a>
#### 非数值型的特征
分组→对各组进行频次统计→绘制与直方图类似的柱状图
```python
# 看数据在不同组的分布
import pandas as pd
import numpy as np
from matplotlib import pyplot as plt
my_data = pd.read_csv("C:\Python\Scripts\my_data\Titanic.csv")
my_plot_data=my_data[['Pclass']].groupby(['Pclass']).size()
print(my_plot_data)
my_plot_data.plot(kind='bar')
```
![image.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1627873410507-23ccbf98-ce10-4e5a-9f10-adfffd700d8d.png#clientId=udf73a95f-e2e1-4&from=paste&height=320&id=uf8bdc9ae&originHeight=961&originWidth=1408&originalType=binary&ratio=1&size=57823&status=done&style=shadow&taskId=ub01dc357-98cb-4e03-b017-16d842b0985&width=469.3333333333333)
```python
# 分组统计
print('表 1. 按仓位等级分组求船费、年龄、同行平辈人数、同行父母和子女人数的均值')
print(my_data[['Fare','Age','SibSp','Parch','Pclass']].groupby(['Pclass']).mean())
print('\n\n表 2. 按仓位等级分组求船费、年龄、同行平辈人数、同行父母和子女人数的标准差')
print(my_data[['Fare','Age','SibSp','Parch','Pclass']].groupby(['Pclass']).std())
```
![image.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1627873476365-86c8bf8f-92c1-433f-aba5-fcee52b0defe.png#clientId=udf73a95f-e2e1-4&from=paste&height=251&id=ue77431c2&originHeight=752&originWidth=1592&originalType=binary&ratio=1&size=287752&status=done&style=shadow&taskId=u7ac2d1e1-6fb5-4b16-9190-599fd08d920&width=530.6666666666666)
```python
# 借助分组、筛选的图形化描述
gender_dst_org=my_data[['Sex']].groupby(['Sex']).size()
print('数据文件中全部非空数据的性别情况')
print(gender_dst_org,'\n')
my_filter=my_data[my_data.Survived==1] #dataframe 的数据筛选
gender_dst_srv=my_filter[['Sex']].groupby(['Sex']).size()
print('数据文件中幸存者的性别情况')
print(gender_dst_srv,'\n')
my_tmp=pd.concat([gender_dst_org,gender_dst_srv],axis=1)
# 数据连接，axis=1 表示增加列
my_plot_data=my_tmp.rename(columns={0:'Total',1:'Survived'}) # 列重命名
print(my_plot_data)
my_plot_data.plot(kind='bar')
```
![image.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1627873543382-cfcf9e08-4662-4e97-8b3c-0d370060171e.png#clientId=udf73a95f-e2e1-4&from=paste&height=332&id=u0df1029d&originHeight=996&originWidth=1023&originalType=binary&ratio=1&size=152469&status=done&style=shadow&taskId=u305cc885-5028-43f5-869e-49ada660130&width=341)![image.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1627873552692-36a65a93-9e7f-4706-ab26-d756b59fd307.png#clientId=udf73a95f-e2e1-4&from=paste&height=363&id=uf21a09c3&originHeight=1089&originWidth=1500&originalType=binary&ratio=1&size=78240&status=done&style=shadow&taskId=u564bfcab-ccdc-46fd-ae0a-665e5d8ea12&width=500)
<a name="nfddK"></a>
#### 散点图
```python
import pandas as pd
import numpy as np
my_data=dmy_data = pd.read_csv("C:\Python\Scripts\my_data\iris.csv",header=None,
                               names=['sepal_length','sepal_width','petal_length',
                                      'petal_width','target'])
# my_data.head(5)
my_set=set(my_data['target']) # 创建一个类别名集合
print(my_set)
my_set_list=list(my_set) #set 不能直接访问其元素，转换成 list 后可以访问
colors=list()
palette={my_set_list[0]:"red",my_set_list[1]:"green",my_set_list[2]:"blue"}
# 字典，给三种类别对应散点图中的三种 marker_color
# print(my_data['target'])
for n,row in enumerate(my_data['target']): # 根据类别为每个样本设置绘图颜色
    colors.append(palette[my_data['target'][n]])
#print(colors)
# 对 my_data 中的数值型数据，每两个特征绘制散点图
scatterplot=pd.plotting.scatter_matrix(my_data,alpha=0.3,
                                       figsize=(10,10), diagonal='hist',color=colors,
                                       marker='o',grid=True)
```


