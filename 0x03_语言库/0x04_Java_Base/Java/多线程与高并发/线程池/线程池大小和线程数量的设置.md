Java 线程池<br />一个线程数设置的理论：

- CPU 密集型的程序 - 核心数 + 1
- I/O 密集型的程序 - 核心数 * 2
<a name="zUusN"></a>
### 线程数和CPU利用率的小测试
抛开一些操作系统，计算机原理不谈，说一个基本的理论（不用纠结是否严谨，只为好理解）：一个CPU核心，单位时间内只能执行一个线程的指令 ** 那么理论上，一个线程只需要不停的执行指令，就可以跑满一个核心的利用率。<br />写个死循环空跑的例子验证一下：<br />测试环境：AMD Ryzen 5 3600, 6 - Core, 12 - Threads
```java
public class CPUUtilizationTest {
    public static void main(String[] args) {
        //死循环，什么都不做
        while (true){
        }
    }
}
```
运行这个例子后，来看看现在CPU的利用率：<br />![2021-05-23-01-17-55-757608.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1621704018092-8be9b94f-afe5-477a-b26a-907ba9bb1536.png#clientId=u23efa80f-7d55-4&from=ui&id=uac7df40c&originHeight=609&originWidth=1080&originalType=binary&size=74921&status=done&style=none&taskId=u6140f824-31c9-491c-9fc2-b2329f73ee6)<br />从图上可以看到，3号核心利用率已经被跑满了<br />基于上面的理论，多开几个线程试试呢？
```java
public class CPUUtilizationTest {
    public static void main(String[] args) {

        for (int j = 0; j < 6; j++) {
            new Thread(new Runnable() {
                @Override
                public void run() {
                    while (true){
                    }
                }
            }).start();
        }
    }
}
```
此时再看CPU利用率，1/2/5/7/9/11 几个核心的利用率已经被跑满：<br />![2021-05-23-01-17-55-915143.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1621704028640-c3a24015-4617-40d5-a19d-8584982baf46.png#clientId=u23efa80f-7d55-4&from=ui&id=ufd6ddfd6&originHeight=512&originWidth=1080&originalType=binary&size=111325&status=done&style=none&taskId=u82627a91-4403-4ba1-a094-70170ba894e)<br />那如果开12个线程呢，是不是会把所有核心的利用率都跑满？答案一定是会的：<br />![2021-05-23-01-17-56-078919.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1621704043690-48a17b6d-f625-4369-b6d8-789781522d81.png#clientId=u23efa80f-7d55-4&from=ui&id=u71b71407&originHeight=526&originWidth=1080&originalType=binary&size=124142&status=done&style=none&taskId=u0078aa74-f31b-4f2b-80dd-ddc9fdb9747)<br />如果此时把上面例子的线程数继续增加到24个线程，会出现什么结果呢？<br />![2021-05-23-01-17-56-421993.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1621704056859-5a994f89-8125-4a05-8217-3b9e185e79ce.png#clientId=u23efa80f-7d55-4&from=ui&id=u0d1216e0&originHeight=519&originWidth=1080&originalType=binary&size=316026&status=done&style=none&taskId=u5e815cd0-4e9c-461a-b688-c88480db9eb)<br />从上图可以看到，CPU利用率和上一步一样，还是所有核心100%，不过此时负载已经从11.x增加到了22.x，说明此时CPU更繁忙，线程的任务无法及时执行。<br />现代CPU基本都是多核心的，比如这里测试用的AMD 3600，6核心12线程（超线程），可以简单的认为它就是12核心CPU。那么这个CPU就可以同时做12件事，互不打扰。<br />如果要执行的线程大于核心数，那么就需要通过操作系统的调度了。操作系统给每个线程分配CPU时间片资源，然后不停的切换，从而实现“并行”执行的效果。<br />但是这样真的更快吗？从上面的例子可以看出，一个线程 就可以把一个核心 的利用率跑满。如果每个线程都很“霸道”，不停的执行指令，不给CPU空闲的时间，并且同时执行的线程数大于CPU的核心数，就会导致操作系统更频繁的执行切换线程执行 ，以确保每个线程都可以得到执行。<br />不过切换是有代价的，每次切换会伴随着寄存器数据更新，内存页表更新等操作 。虽然一次切换的代价和I/O操作比起来微不足道，但如果线程过多，线程切换的过于频繁，甚至在单位时间内切换的耗时已经大于程序执行的时间，就会导致CPU资源过多的浪费在上下文切换上，而不是在执行程序，得不偿失。<br />上面死循环空跑的例子，有点过于极端了，正常情况下不太可能有这种程序。<br />大多程序在运行时都会有一些 I/O操作，可能是读写文件，网络收发报文等，这些 I/O 操作在进行时时需要等待反馈的。比如网络读写时，需要等待报文发送或者接收到，在这个等待过程中，线程是等待状态，CPU没有工作。此时操作系统就会调度CPU去执行其他线程的指令，这样就完美利用了CPU这段空闲期，提高了CPU的利用率。<br />上面的例子中，程序不停的循环什么都不做，CPU要不停的执行指令，几乎没有啥空闲的时间。如果插入一段I/O操作呢，I/O 操作期间 CPU是空闲状态，CPU的利用率会怎么样呢？先看看单线程下的结果：
```java
public class CPUUtilizationTest {
    public static void main(String[] args) throws InterruptedException {

        for (int n = 0; n < 1; n++) {
            new Thread(new Runnable() {
                @Override
                public void run() {
                    while (true){
                        //每次空循环 1亿 次后，sleep 50ms，模拟 I/O等待、切换
                        for (int i = 0; i < 100_000_000l; i++) {
                        }
                        try {
                            Thread.sleep(50);
                        }
                        catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                }
            }).start();
        }
    }
}
```
![2021-05-23-01-17-56-576579.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1621704086190-9ec223db-001d-43a5-ae7d-39a99f68c643.png#clientId=u23efa80f-7d55-4&from=ui&id=ucac4b716&originHeight=517&originWidth=1080&originalType=binary&size=99893&status=done&style=none&taskId=u9d6a3dd5-3640-443e-999e-9b65ce9b8bc)<br />唯一有利用率的9号核心，利用率也才50%，和前面没有sleep的100%相比，已经低了一半了。现在把线程数调整到12个看看：<br />![2021-05-23-01-17-56-748169.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1621704096836-31652afd-97d9-463b-8aba-1fcbf48c5c0f.png#clientId=u23efa80f-7d55-4&from=ui&id=u3664a174&originHeight=518&originWidth=1080&originalType=binary&size=121796&status=done&style=none&taskId=u78056721-4f79-4d30-befe-ebe00c15b9e)<br />单个核心的利用率60左右，和刚才的单线程结果差距不大，还没有把CPU利用率跑满，现在将线程数增加到18：<br />![2021-05-23-01-17-56-946589.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1621704107319-d85a6d18-cb1d-4774-8095-4c945c38d2d0.png#clientId=u23efa80f-7d55-4&from=ui&id=u35e1aa9f&originHeight=514&originWidth=1080&originalType=binary&size=121535&status=done&style=none&taskId=uc17cf4b6-4131-40c5-9373-2ff90edc1a2)<br />此时单核心利用率，已经接近100%了。由此可见，当线程中有 I/O 等操作不占用CPU资源时，操作系统可以调度CPU可以同时执行更多的线程。<br />现在将I/O事件的频率调高看看呢，把循环次数减到一半，50_000_000，同样是18个线程：<br />![2021-05-23-01-17-57-078241.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1621704116720-f38979af-4704-436f-aad8-1d239c07358e.png#clientId=u23efa80f-7d55-4&from=ui&id=u394292f4&originHeight=510&originWidth=1080&originalType=binary&size=111073&status=done&style=none&taskId=u6864e3e7-3548-400e-939f-9b9bd188d4a)<br />此时每个核心的利用率，大概只有70%左右了。
<a name="Gf0YT"></a>
### 线程数和CPU利用率的小总结
上面的例子，只是辅助，为了更好的理解线程数/程序行为/CPU状态的关系，来简单总结一下：

1. 一个极端的线程（不停执行“计算”型操作时），就可以把单个核心的利用率跑满，多核心CPU最多只能同时执行等于核心数的“极端”线程数
2. 如果每个线程都这么“极端”，且同时执行的线程数超过核心数，会导致不必要的切换，造成负载过高，只会让执行更慢
3. I/O 等暂停类操作时，CPU处于空闲状态，操作系统调度CPU执行其他线程，可以提高CPU利用率，同时执行更多的线程
4. I/O 事件的频率频率越高，或者等待/暂停时间越长，CPU的空闲时间也就更长，利用率越低，操作系统可以调度CPU执行更多的线程
<a name="JAoR8"></a>
### 线程数规划的公式
前面的铺垫，都是为了帮助理解，现在来看看书本上的定义。《Java 并发编程实战》介绍了一个线程数计算的公式：<br />![2021-05-23-01-17-57-213876.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1621704130670-85e7f357-e075-4df8-aa08-ea7e58afd063.png#clientId=u23efa80f-7d55-4&from=ui&id=ua081504d&originHeight=321&originWidth=1080&originalType=binary&size=22418&status=done&style=shadow&taskId=u78132d3e-f973-4369-aa2a-ee6bc910721)<br />如果希望程序跑到CPU的目标利用率，需要的线程数公式为：<br />![2021-05-23-01-17-57-312612.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1621704142441-b27cf65b-dc4f-4e8b-90fe-1121926d8e07.png#clientId=u23efa80f-7d55-4&from=ui&id=uc883aaf0&originHeight=108&originWidth=820&originalType=binary&size=5406&status=done&style=shadow&taskId=u2c7b946b-72db-490f-b66f-9e979c0d92d)<br />公式很清晰，现在来带入上面的例子试试看：<br />如果期望目标利用率为90%（多核90），那么需要的线程数为：<br />![2021-05-23-01-17-57-577908.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1621704152918-811159a2-4f6a-4f78-ada1-6b93b50299ac.png#clientId=u23efa80f-7d55-4&from=ui&id=uce8e437d&originHeight=108&originWidth=1058&originalType=binary&size=10312&status=done&style=shadow&taskId=uc73d60bf-6512-4445-8df6-42e2acf0690)<br />现在把线程数调到22，看看结果：<br />![2021-05-23-01-17-57-983370.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1621704163603-b5b334cf-ce38-4563-aeeb-6c356cb76745.png#clientId=u23efa80f-7d55-4&from=ui&id=u3f9d473b&originHeight=523&originWidth=1080&originalType=binary&size=122835&status=done&style=none&taskId=uf4bfe882-8f51-423b-b8bc-b2dbf3c20d8)<br />现在CPU利用率大概80+，和预期比较接近了，由于线程数过多，还有些上下文切换的开销，再加上测试用例不够严谨，所以实际利用率低一些也正常。<br />把公式变个形，还可以通过线程数来计算CPU利用率：<br />![2021-05-23-01-17-58-089126.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1621704173533-424fa1f7-ae81-4004-8b98-b60d3f92dc3b.png#clientId=u23efa80f-7d55-4&from=ui&id=ud5288631&originHeight=207&originWidth=1080&originalType=binary&size=21483&status=done&style=shadow&taskId=u7f44fb59-42d2-4066-bfb2-4c279fc0497)<br />虽然公式很好，但在真实的程序中，一般很难获得准确的等待时间和计算时间，因为程序很复杂，不只是“计算” 。一段代码中会有很多的内存读写，计算，I/O 等复合操作，精确的获取这两个指标很难，所以光靠公式计算线程数过于理想化。
<a name="UdUWz"></a>
### 真实程序中的线程数
那么在实际的程序中，或者说一些Java的业务系统中，线程数（线程池大小）规划多少合适呢？<br />先说结论：没有固定答案，先设定预期，比如期望的CPU利用率在多少，负载在多少，GC频率多少之类的指标后，再通过测试不断的调整到一个合理的线程数<br />比如一个普通的，SpringBoot 为基础的业务系统，默认Tomcat容器+HikariCP连接池+G1回收器，如果此时项目中也需要一个业务场景的多线程（或者线程池）来异步/并行执行业务流程。<br />此时按照上面的公式来规划线程数的话，误差一定会很大。因为此时这台主机上，已经有很多运行中的线程了，Tomcat有自己的线程池，HikariCP也有自己的后台线程，JVM也有一些编译的线程，连G1都有自己的后台线程。这些线程也是运行在当前进程、当前主机上的，也会占用CPU的资源。<br />所以受环境干扰下，单靠公式很难准确的规划线程数，一定要通过测试来验证。<br />流程一般是这样：

1. 分析当前主机上，有没有其他进程干扰
2. 分析当前JVM进程上，有没有其他运行中或可能运行的线程
3. 设定目标
   1. 目标CPU利用率 - 最高能容忍CPU飙到多少？
   2. 目标GC频率/暂停时间 - 多线程执行后，GC频率会增高，最大能容忍到什么频率，每次暂停时间多少？
   3. 执行效率 - 比如批处理时，单位时间内要开多少线程才能及时处理完毕
   4. ……
4. 梳理链路关键点，是否有卡脖子的点，因为如果线程数过多，链路上某些节点资源有限可能会导致大量的线程在等待资源（比如三方接口限流，连接池数量有限，中间件压力过大无法支撑等）
5. 不断的增加/减少线程数来测试，按最高的要求去测试，最终获得一个“满足要求”的线程数**

而且而且而且！不同场景下的线程数理念也有所不同：

1. Tomcat中的maxThreads，在Blocking I/O和No-Blocking I/O下就不一样
2. Dubbo 默认还是单连接呢，也有I/O线程（池）和业务线程（池）的区分，I/O线程一般不是瓶颈，所以不必太多，但业务线程很容易称为瓶颈
3. Redis 6.0以后也是多线程了，不过它只是I/O 多线程，“业务”处理还是单线程

所以，不要纠结设置多少线程了。没有标准答案，一定要结合场景，带着目标，通过测试去找到一个最合适的线程数。<br />可能还有同学可能会有疑问：“系统也没啥压力，不需要那么合适的线程数，只是一个简单的异步场景，不影响系统其他功能就可以”<br />很正常，很多的内部业务系统，并不需要啥性能，稳定好用符合需求就可以了，那么推荐的线程数是：CPU核心数
<a name="ZZSTj"></a>
### 附录
<a name="WoFOI"></a>
#### Java 获取CPU核心数
```java
Runtime.getRuntime().availableProcessors()//获取逻辑核心数，如6核心12线程，那么返回的是12
```
<a name="yI2bl"></a>
#### Linux 获取CPU核心数
```bash
# 总核数 = 物理CPU个数 X 每颗物理CPU的核数
# 总逻辑CPU数 = 物理CPU个数 X 每颗物理CPU的核数 X 超线程数

# 查看物理CPU个数
cat /proc/cpuinfo| grep "physical id"| sort| uniq| wc -l

# 查看每个物理CPU中core的个数(即核数)
cat /proc/cpuinfo| grep "cpu cores"| uniq

# 查看逻辑CPU的个数
cat /proc/cpuinfo| grep "processor"| wc -l
```
