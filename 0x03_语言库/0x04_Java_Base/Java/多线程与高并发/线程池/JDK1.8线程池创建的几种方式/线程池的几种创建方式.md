Java 线程池<br />在 Java 语言中，并发编程都是通过创建线程池来实现的，而线程池的创建方式也有很多种，每种线程池的创建方式都对应了不同的使用场景，总体来说线程池的创建可以分为以下两类：

- 通过 ThreadPoolExecutor 手动创建线程池。
- 通过 Executors 执行器自动创建线程池。

![](https://cdn.nlark.com/yuque/0/2022/png/396745/1647607379505-679cd946-02fc-41b3-9b12-a6ed31886034.png#clientId=u58d4a65f-b25d-4&from=paste&id=u17044219&originHeight=348&originWidth=1058&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=ud92c3ada-3876-40a1-8ec0-e39f65537aa&title=)而以上两类创建线程池的方式，又有 7 种具体实现方法，这 7 种实现方法分别是：

1. `Executors.newFixedThreadPool`：创建一个固定大小的线程池，可控制并发的线程数，超出的线程会在队列中等待。
2. `Executors.newCachedThreadPool`：创建一个可缓存的线程池，若线程数超过处理所需，缓存一段时间后会回收，若线程数不够，则新建线程。
3. `Executors.newSingleThreadExecutor`：创建单个线程数的线程池，它可以保证先进先出的执行顺序。
4. `Executors.newScheduledThreadPool`：创建一个可以执行延迟任务的线程池。
5. `Executors.newSingleThreadScheduledExecutor`：创建一个单线程的可以执行延迟任务的线程池。
6. `Executors.newWorkStealingPool`：创建一个抢占式执行的线程池（任务执行顺序不确定）【JDK 1.8 添加】。
7. `ThreadPoolExecutor`：手动创建线程池的方式，它创建时最多可以设置 7 个参数。

接下来分别来看这 7 种线程池的具体使用。
<a name="H696t"></a>
## 1、FixedThreadPool
创建一个固定大小的线程池，可控制并发线程数。使用 FixedThreadPool 创建 2 个固定大小的线程池，具体实现代码如下：
```java
public static void fixedThreadPool() {
    // 创建 2 个线程的线程池
    ExecutorService threadPool = Executors.newFixedThreadPool(2);
    
    // 创建任务
    Runnable runnable = new Runnable() {
        @Override
        public void run() {
            System.out.println("任务被执行,线程:" + Thread.currentThread().getName());
        }
    };
    
    // 线程池执行任务(一次添加 4 个任务)
    // 执行任务的方法有两种:submit 和 execute
    threadPool.submit(runnable);  // 执行方式 1:submit
    threadPool.execute(runnable); // 执行方式 2:execute
    threadPool.execute(runnable);
    threadPool.execute(runnable);
}
```
以上程序的执行结果如下图所示：![](https://cdn.nlark.com/yuque/0/2022/png/396745/1647607379527-aa95a2b1-d271-4e42-beec-ec26cde96d08.png#clientId=u58d4a65f-b25d-4&from=paste&id=u15d0c778&originHeight=304&originWidth=778&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ue5177605-c1ad-423f-b81e-3a77de5fe2e&title=)如果觉得以上方法比较繁琐，还用使用以下简单的方式来实现线程池的创建和使用：
```java
public static void fixedThreadPool() {
    // 创建线程池
    ExecutorService threadPool = Executors.newFixedThreadPool(2);
    // 执行任务
    threadPool.execute(() -> {
        System.out.println("任务被执行,线程:" + Thread.currentThread().getName());
    });
}
```
<a name="r3oQe"></a>
## 2、CachedThreadPool
创建一个可缓存的线程池，若线程数超过任务所需，那么多余的线程会被缓存一段时间后才被回收，若线程数不够，则会新建线程。CachedThreadPool 使用示例如下：
```java
public static void cachedThreadPool() {
    // 创建线程池
    ExecutorService threadPool = Executors.newCachedThreadPool();
    // 执行任务
    for (int i = 0; i < 10; i++) {
        threadPool.execute(() -> {
            System.out.println("任务被执行,线程:" + Thread.currentThread().getName());
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
            }
        });
    }
}
```
以上程序的执行结果如下图所示：![](https://cdn.nlark.com/yuque/0/2022/png/396745/1647607379515-9a2a57fe-f47e-43a1-9f36-0c400b4ef6b1.png#clientId=u58d4a65f-b25d-4&from=paste&id=u81517c27&originHeight=630&originWidth=746&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ubbbbb44d-dbab-45bf-b088-12f79b25f9b&title=)从上述结果可以看出，线程池创建了 10 个线程来执行相应的任务。
<a name="emu4M"></a>
### 使用场景
CachedThreadPool 是根据短时间的任务量来决定创建的线程数量的，所以它适合短时间内有突发大量任务的处理场景。
<a name="sJdV5"></a>
## 3、SingleThreadExecutor
创建单个线程的线程池，它可以保证先进先出的执行顺序。SingleThreadExecutor 使用示例如下：
```java
public static void singleThreadExecutor() {
    // 创建线程池
    ExecutorService threadPool = Executors.newSingleThreadExecutor();
    // 执行任务
    for (int i = 0; i < 10; i++) {
        final int index = i;
        threadPool.execute(() -> {
            System.out.println(index + ":任务被执行");
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
            }
        });
    }
}
```
以上程序的执行结果如下图所示：<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1647607379482-7cbce1b0-5d3f-40d4-8529-6d5d2ae23749.png#clientId=u58d4a65f-b25d-4&from=paste&id=u38ec8435&originHeight=588&originWidth=288&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u3511b1f4-c608-497e-aa89-d82789620a3&title=)
<a name="GEVs1"></a>
### 单个线程的线程池有什么意义？
单个线程的线程池相比于线程来说，它的优点有以下 2 个：

- 可以复用线程：即使是单个线程池，也可以复用线程。
- 提供了任务管理功能：单个线程池也拥有任务队列，在任务队列可以存储多个任务，这是线程无法实现的，并且当任务队列满了之后，可以执行拒绝策略，这些都是线程不具备的。
<a name="juS66"></a>
## 4、ScheduledThreadPool
创建一个可以执行延迟任务的线程池。使用示例如下：
```java
public static void scheduledThreadPool() {
    // 创建线程池
    ScheduledExecutorService threadPool = Executors.newScheduledThreadPool(5);
    // 添加定时执行任务(1s 后执行)
    System.out.println("添加任务,时间:" + new Date());
    threadPool.schedule(() -> {
        System.out.println("任务被执行,时间:" + new Date());
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
        }
    }, 1, TimeUnit.SECONDS);
}
```
以上程序的执行结果如下图所示：![](https://cdn.nlark.com/yuque/0/2022/png/396745/1647607379417-b6f1d058-926f-47ed-b886-6642c0eebfbe.png#clientId=u58d4a65f-b25d-4&from=paste&id=ud0a0b212&originHeight=172&originWidth=1038&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u7dda267d-824c-44cf-9e05-f176ed63edf&title=)从上述结果可以看出，任务在 1 秒之后被执行了，实现了延迟 1s 再执行任务。
<a name="wBmMd"></a>
## 5、SingleThreadScheduledExecutor
创建一个单线程的可以执行延迟任务的线程池，此线程池可以看作是 ScheduledThreadPool 的单线程池版本。它的使用示例如下：
```java
public static void SingleThreadScheduledExecutor() {
    // 创建线程池
    ScheduledExecutorService threadPool = Executors.newSingleThreadScheduledExecutor();
    // 添加定时执行任务(2s 后执行)
    System.out.println("添加任务,时间:" + new Date());
    threadPool.schedule(() -> {
        System.out.println("任务被执行,时间:" + new Date());
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
        }
    }, 2, TimeUnit.SECONDS);
}
```
以上程序的执行结果如下图所示：![](https://cdn.nlark.com/yuque/0/2022/png/396745/1647607379901-59bc2a0d-deb9-418e-aeb8-3675dac97765.png#clientId=u58d4a65f-b25d-4&from=paste&id=u370f80fc&originHeight=172&originWidth=1044&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u5413faf0-384b-44a0-94f0-c971fb4300d&title=)从上述结果可以看出，任务在 2 秒之后被执行了。
<a name="w8BqQ"></a>
## 6、newWorkStealingPool
创建一个抢占式执行的线程池（任务执行顺序不确定），此方法是 JDK 1.8 版本新增的，因此只有在 JDK 1.8 以上的程序中才能使用。newWorkStealingPool 使用示例如下：
```java
public static void workStealingPool() {
    // 创建线程池
    ExecutorService threadPool = Executors.newWorkStealingPool();
    // 执行任务
    for (int i = 0; i < 10; i++) {
        final int index = i;
        threadPool.execute(() -> {
            System.out.println(index + " 被执行,线程名:" + Thread.currentThread().getName());
        });
    }
    // 确保任务执行完成
    while (!threadPool.isTerminated()) {
    }
}
```
以上程序的执行结果如下图所示：![](https://cdn.nlark.com/yuque/0/2022/png/396745/1647607379857-f375bb7a-930f-4e48-92c5-36e1a9d93700.png#clientId=u58d4a65f-b25d-4&from=paste&id=u381bbafa&originHeight=584&originWidth=904&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=udca549ca-344e-47eb-adb1-c0f2be2db7b&title=)从上述结果可以看出，任务的执行顺序是不确定的，因为它是抢占式执行的。
<a name="eaZ2F"></a>
## 7、ThreadPoolExecutor
**ThreadPoolExecutor 是最原始、也是最推荐的手动创建线程池的方式**，它在创建时最多提供 7 个参数可供设置。ThreadPoolExecutor 使用示例如下：
```java
public static void myThreadPoolExecutor() {
    // 创建线程池
    ThreadPoolExecutor threadPool = new ThreadPoolExecutor(5, 10, 100, TimeUnit.SECONDS, new LinkedBlockingQueue<>(10));
    // 执行任务
    for (int i = 0; i < 10; i++) {
        final int index = i;
        threadPool.execute(() -> {
            System.out.println(index + " 被执行,线程名:" + Thread.currentThread().getName());
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
    }
}
```
以上程序的执行结果如下图所示：![](https://cdn.nlark.com/yuque/0/2022/png/396745/1647607379956-0edebb44-0ed2-4815-9e99-e49e9417492e.png#clientId=u58d4a65f-b25d-4&from=paste&id=u8c0d834e&originHeight=582&originWidth=700&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ud55adfa3-7425-4cdc-9da6-82e6f945135&title=)**ThreadPoolExecutor 相比于其他创建线程池的优势在于，它可以通过参数来控制最大任务数和拒绝策略，让线程池的执行更加透明和可控**，所以在阿里巴巴《Java开发手册》是这样规定的：
> 【强制要求】**线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。**
> 说明：Executors 返回的线程池对象的弊端如下：
> 1） FixedThreadPool 和 SingleThreadPool：允许的请求队列长度为 `Integer.MAX_VALUE`，可能会堆积大量的请求，从而导致 OOM。
> 2）CachedThreadPool：允许的创建线程数量为 `Integer.MAX_VALUE`，可能会创建大量的线程，从而导致 OOM。

<a name="yO9F0"></a>
## 总结
线程池的创建方式总共有以下 7 种：

1. `Executors.newFixedThreadPool`：创建一个固定大小的线程池，可控制并发的线程数，超出的线程会在队列中等待。
2. `Executors.newCachedThreadPool`：创建一个可缓存的线程池，若线程数超过处理所需，缓存一段时间后会回收，若线程数不够，则新建线程。
3. `Executors.newSingleThreadExecutor`：创建单个线程数的线程池，它可以保证先进先出的执行顺序。
4. `Executors.newScheduledThreadPool`：创建一个可以执行延迟任务的线程池。
5. `Executors.newSingleThreadScheduledExecutor`：创建一个单线程的可以执行延迟任务的线程池。
6. `Executors.newWorkStealingPool`：创建一个抢占式执行的线程池（任务执行顺序不确定）【JDK 1.8 添加】。
7. `ThreadPoolExecutor`：手动创建线程池的方式，它创建时最多可以设置 7 个参数。

而**线程池的创建推荐使用最后一种 ThreadPoolExecutor 的方式来创建，因为使用它可以明确线程池的运行规则，规避资源耗尽的风险**。
