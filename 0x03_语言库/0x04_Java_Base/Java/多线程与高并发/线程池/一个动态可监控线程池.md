Java
<a name="d12iV"></a>
## 背景
作为一个Java开发者，应用里少不了使用ThreadPoolExecutor 创建线程池，在使用的过程中是否有以下痛点：<br />**1、代码中创建了一个 ThreadPoolExecutor，但是不知道那几个核心参数设置多少比较合适**<br />**2、凭经验设置参数值，上线后发现需要调整，改代码重新发布服务，非常麻烦**<br />**3、线程池相对开发人员来说是个黑盒，运行情况不能及时感知到，直到出现问题**<br />面对这些痛点是否经常抓耳挠腮，所以，带着这个问题，介绍这个开源的项目：<br />**dynamic-tp**   🔥🔥🔥 基于配置中心的轻量级动态可监控线程池<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1693888310283-8375e125-3e35-4a68-b69d-d8101536794a.png#averageHue=%2310151e&clientId=u04ca03e8-8ca0-4&from=paste&id=u26c6c24f&originHeight=296&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=uf02c7b49-6c9a-4d0a-8a84-abb41d2f189&title=)
<a name="b5K4v"></a>
## 介绍
**dynamic-tp**  ，是一个让线程池变的更简单的工具，并且拥有众多优势：

- **动态调参：在运行时动态调整线程池参数，包括核心线程数、最大线程数、空闲线程超时时间、任务队列大小等**
- **通知报警：目前支持调参通知、活性、队列容量、拒绝策略、超时共六类通知报警维度，在运行时实时+定时检测，触发阈值进行推送**
- **运行监控：定时采集线程池运行指标数据，提供jsonlog、micrometer、endpoint三种指标数据采集方式，可灵活选择**
- **三方包集成：集成三方中间件线程池管理，已接入dubbo、rocketmq、hystrix、grpc、tomcat、undertow、jetty、grpc、okhttp等组件线程池管理**
<a name="QGklI"></a>
## 快速使用
dynamic-tp的使用也非常简单，支持多种配置中心集成，下面无配置中心应用接入为例，具体文档可以参考如下地址。<br />官网地址：[https://dynamictp.cn/guide/use/quick-start.html](https://dynamictp.cn/guide/use/quick-start.html)
<a name="p96aD"></a>
### 1、引入相应配置中心的依赖
```xml
<dependency>
  <groupId>org.dromara.dynamictp</groupId>
  <artifactId>dynamic-tp-core</artifactId>
  <version>1.1.3</version>
</dependency>
```
<a name="IfIrP"></a>
### 2、配置线程池实例
配置线程池有两种方式，一是配置中心配置（推荐），二是代码配置<br />**a、配置中心配置，仅供参考，请根据自己实际需要进行删改**
```yaml
spring:
  dynamic:
    tp:
      enabled: true
      enabledCollect: true                    # 是否开启监控指标采集，默认false
      collectorTypes: micrometer,logging      # 监控数据采集器类型（logging | micrometer | internal_logging），默认micrometer
      logPath: /home/logs                     # 监控日志数据路径，默认 ${user.home}/logs，采集类型非logging不用配置
      monitorInterval: 5                      # 监控时间间隔（报警检测、指标采集），默认5s
      apollo:                                 # apollo配置，不配置默认拿apollo配置第一个namespace
        namespace: user-center-dtp-dev.yml
      configType: yml                         # 配置文件类型
      platforms:                              # 通知报警平台配置
        - platform: wechat
          platformId: 1                            # 平台id
          urlKey: 3a700-127-4bd-a798-c53d8b69c     # 替换
          receivers: test1,test2                   # 接受人企微名称
        - platform: ding
          platformId: 2                            # 平台id
          urlKey: f80dad441fcd655438f4a08dcd6a     # 替换
          secret: SECb5441fa6f375d5b9d21           # 替换，非sign模式可以没有此值
          receivers: 18888888888                   # 钉钉账号手机号
        - platform: lark
          platformId: 3
          urlKey: 0d944ae7-b24a-40                 # 替换
          receivers: test1,test2                   # 接受人飞书名称/openid
        - platform: email
          platformId: 4
          receivers: 123456@qq.com,789789@qq.com   # 收件人
      executors:                                   # 动态线程池配置，都有默认值，采用默认值的可以不配置该项，减少配置量
        - threadPoolName: dtpExecutor1
          threadPoolAliasName: 测试线程池             # 线程池别名
          executorType: common                     # 线程池类型common、eager：适用于io密集型
          corePoolSize: 6
          maximumPoolSize: 8
          queueCapacity: 200
          queueType: VariableLinkedBlockingQueue   # 任务队列，查看源码QueueTypeEnum枚举类
          rejectedHandlerType: CallerRunsPolicy    # 拒绝策略，查看RejectedTypeEnum枚举类
          keepAliveTime: 50
          allowCoreThreadTimeOut: false                  # 是否允许核心线程池超时
          threadNamePrefix: test                         # 线程名前缀
          waitForTasksToCompleteOnShutdown: false        # 参考spring线程池设计，优雅关闭线程池
          awaitTerminationSeconds: 5                     # 单位（s）
          preStartAllCoreThreads: false                  # 是否预热所有核心线程，默认false
          runTimeout: 200                                # 任务执行超时阈值，目前只做告警用，单位（ms）
          queueTimeout: 100                              # 任务在队列等待超时阈值，目前只做告警用，单位（ms）
          taskWrapperNames: ["ttl", "mdc"]               # 任务包装器名称，继承TaskWrapper接口
          notifyEnabled: true                            # 是否开启报警，默认true
          notifyItems:                     # 报警项，不配置自动会按默认值配置（变更通知、容量报警、活性报警、拒绝报警、任务超时报警）
            - type: capacity               # 报警项类型，查看源码 NotifyTypeEnum枚举类
              enabled: true
              threshold: 80                # 报警阈值
              platforms: [ding,wechat]     # 可选配置，不配置默认拿上层platforms配置的所以平台
              interval: 120                # 报警间隔（单位：s）
            - type: change
              enabled: true
            - type: liveness
              enabled: true
              threshold: 80
            - type: reject
              enabled: true
              threshold: 1
            - type: run_timeout
              enabled: true
              threshold: 1
            - type: queue_timeout
              enabled: true
              threshold: 1
```
**b、代码配置，如果想后期再添加到配置中心，可以先用 **`**@Bean**`** 编码式声明（方便 Spring 依赖注入）**
```java
@Configuration
public class DtpConfig {

    /**
     * 通过 {@link @DynamicTp} 注解定义普通 juc 线程池，会享受到该框架监控功能，注解名称优先级高于方法名
     *
     * @return 线程池实例
     */
    @DynamicTp("commonExecutor")
    @Bean
    public ThreadPoolExecutor commonExecutor() {
        return (ThreadPoolExecutor) Executors.newFixedThreadPool(1);
    }

    /**
     * 通过 {@link ThreadPoolCreator} 快速创建一些简单配置的动态线程池
     * tips: 建议直接在配置中心配置就行，不用 @Bean 声明
     *
     * @return 线程池实例
     */
    @Bean
    public DtpExecutor dtpExecutor1() {
        return ThreadPoolCreator.createDynamicFast("dtpExecutor1");
    }

    /**
     * 通过 {@link ThreadPoolBuilder} 设置详细参数创建动态线程池（推荐方式），
     * ioIntensive，参考 tomcat 线程池设计，实现了处理 io 密集型任务的线程池，具体参数可以看代码注释
     * <p>
     * tips: 建议直接在配置中心配置就行，不用@Bean声明
     *
     * @return 线程池实例
     */
    @Bean
    public DtpExecutor ioIntensiveExecutor() {
        return ThreadPoolBuilder.newBuilder()
                .threadPoolName("ioIntensiveExecutor")
                .corePoolSize(20)
                .maximumPoolSize(50)
                .queueCapacity(2048)
                .ioIntensive(true)
                .buildDynamic();
    }

    /**
     * tips: 建议直接在配置中心配置就行，不用 @Bean 声明
     *
     * @return 线程池实例
     */
    @Bean
    public ThreadPoolExecutor dtpExecutor2() {
        return ThreadPoolBuilder.newBuilder()
                .threadPoolName("dtpExecutor2")
                .corePoolSize(10)
                .maximumPoolSize(15)
                .keepAliveTime(50)
                .timeUnit(TimeUnit.MILLISECONDS)
                .workQueue(QueueTypeEnum.SYNCHRONOUS_QUEUE.getName(), null, false)
                .waitForTasksToCompleteOnShutdown(true)
                .awaitTerminationSeconds(5)
                .buildDynamic();
    }
}
```
<a name="u3CCM"></a>
### 3、启动类加 `@EnableDynamicTp` 注解
<a name="JCgtZ"></a>
### 4、使用 `@Resource` 或 `@Autowired` 进行依赖注入
```java
@Resource
private ThreadPoolExecutor dtpExecutor1;

public void exec() {
    dtpExecutor1.execute(() -> System.out.println("test"));
}
```
<a name="QSN0Z"></a>
## 总结
总的来说dynamic-tp是一个非常轻量的线程池，并且功能丰富，对代码零侵入，而且集监控报警于一体，使用上基本无需担心<br />最后在贴上地址：<br />使用文档：[https://dynamictp.cn/](https://dynamictp.cn/)<br />github代码：[https://github.com/dromara/dynamic-tp](https://github.com/dromara/dynamic-tp)<br />gitee代码：[https://gitee.com/dromara/dynamic-tp](https://gitee.com/dromara/dynamic-tp)
