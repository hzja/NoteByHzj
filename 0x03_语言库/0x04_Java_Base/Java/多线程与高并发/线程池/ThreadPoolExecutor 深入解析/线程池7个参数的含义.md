Java 线程池<br />线程池的 7 大参数是指，在使用 `ThreadPoolExecutor` 创建线程池时所设置的 7 个参数，如以下源码所示：
```java
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler) {
    //...
}
```
这 7 个参数分别是：

1. `corePoolSize`：核心线程数。
2. `maximumPoolSize`：最大线程数。
3. `keepAliveTime`：空闲线程存活时间。
4. `TimeUnit`：时间单位。
5. `BlockingQueue`：线程池任务队列。
6. `ThreadFactory`：创建线程的工厂。
7. `RejectedExecutionHandler`：拒绝策略。
<a name="eD3JN"></a>
## 参数1：`corePoolSize`
**核心线程数：是指线程池中长期存活的线程数。**
> 这就好比古代大户人家，会长期雇佣一些“长工”来给他们干活，这些人一般比较稳定，无论这一年的活多活少，这些人都不会被辞退，都是长期生活在大户人家的。

<a name="gl5Rp"></a>
## 参数2：`maximumPoolSize`
**最大线程数：线程池允许创建的最大线程数量，当线程池的任务队列满了之后，可以创建的最大线程数。**
> 这是古代大户人家最多可以雇佣的人数，比如某个节日或大户人家有人过寿时，因为活太多，仅靠“长工”是完不成任务，这时就会再招聘一些“短工”一起来干活，这个最大线程数就是“长工”+“短工”的总人数，也就是招聘的人数不能超过 maximumPoolSize。

<a name="MQh0y"></a>
### 注意事项
最大线程数 maximumPoolSize 的值不能小于核心线程数 corePoolSize，否则在程序运行时会报 IllegalArgumentException 非法参数异常，如下图所示：![](https://cdn.nlark.com/yuque/0/2022/png/396745/1647501312962-394cf991-9337-4d22-abd4-8694d6390a89.png#clientId=u8bd815ce-cc0c-4&from=paste&id=u4e250dda&originHeight=501&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u84a62cf1-669e-498f-a982-6f03e319a09&title=)
<a name="Gbwis"></a>
## 参数3：`keepAliveTime`
**空闲线程存活时间，当线程池中没有任务时，会销毁一些线程，销毁的线程数=maximumPoolSize（最大线程数）-corePoolSize（核心线程数）。**
> 还是以大户人家为例，当大户人家比较忙的时候就会雇佣一些“短工”来干活，但等干完活之后，不忙了，就会将这些“短工”辞退掉，而 keepAliveTime 就是用来描述没活之后，短工可以在大户人家待的（最长）时间。

<a name="dGnSd"></a>
## 参数4：`TimeUnit`
**时间单位：空闲线程存活时间的描述单位**，此参数是配合参数 3 使用的。参数 3 是一个 long 类型的值，比如参数 3 传递的是 1，那么这个 1 表示的是 1 天？还是 1 小时？还是 1 秒钟？是由参数 4 说了算的。TimeUnit 有以下 7 个值：

1. `TimeUnit.DAYS`：天
2. `TimeUnit.HOURS`：小时
3. `TimeUnit.MINUTES`：分
4. `TimeUnit.SECONDS`：秒
5. `TimeUnit.MILLISECONDS`：毫秒
6. `TimeUnit.MICROSECONDS`：微妙
7. `TimeUnit.NANOSECONDS`：纳秒
<a name="XcjTo"></a>
## 参数5：`BlockingQueue`
**阻塞队列：线程池存放任务的队列，用来存储线程池的所有待执行任务。**它可以设置以下几个值：

1. `ArrayBlockingQueue`：一个由数组结构组成的有界阻塞队列。
2. `LinkedBlockingQueue`：一个由链表结构组成的有界阻塞队列。
3. `SynchronousQueue`：一个不存储元素的阻塞队列，即直接提交给线程不保持它们。
4. `PriorityBlockingQueue`：一个支持优先级排序的无界阻塞队列。
5. `DelayQueue`：一个使用优先级队列实现的无界阻塞队列，只有在延迟期满时才能从中提取元素。
6. `LinkedTransferQueue`：一个由链表结构组成的无界阻塞队列。与SynchronousQueue类似，还含有非阻塞方法。
7. `LinkedBlockingDeque`：一个由链表结构组成的双向阻塞队列。

比较常用的是 `LinkedBlockingQueue`，线程池的排队策略和 BlockingQueue 息息相关。
<a name="UBloA"></a>
## 参数6：`ThreadFactory`
**线程工厂：线程池创建线程时调用的工厂方法，通过此方法可以设置线程的优先级、线程命名规则以及线程类型（用户线程还是守护线程）等。**线程工厂的使用示例如下：
```java
public static void main(String[] args) {
    // 创建线程工厂
    ThreadFactory threadFactory = new ThreadFactory() {
        @Override
        public Thread newThread(Runnable r) {
            // 创建线程池中的线程
            Thread thread = new Thread(r);
            // 设置线程名称
            thread.setName("Thread-" + r.hashCode());
            // 设置线程优先级（最大值：10）
            thread.setPriority(Thread.MAX_PRIORITY);
            //......
            return thread;
        }
    };
    // 创建线程池
    ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(10, 10, 0,
                                                                   TimeUnit.SECONDS, new LinkedBlockingQueue<>(),
                                                                   threadFactory); // 使用自定义的线程工厂
    threadPoolExecutor.submit(new Runnable() {
        @Override
        public void run() {
            Thread thread = Thread.currentThread();
            System.out.println(String.format("线程：%s，线程优先级：%d",
                                             thread.getName(), thread.getPriority()));
        }
    });
}
```
以上程序的执行结果如下：![](https://cdn.nlark.com/yuque/0/2022/png/396745/1647501312953-bdf4ce32-eddc-44bd-8553-2bcfb0d41e3f.png#clientId=u8bd815ce-cc0c-4&from=paste&id=u0a4b8cb3&originHeight=282&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6f994d2c-a4a0-4b8d-bc49-8adf6ab0f38&title=)从上述执行结果可以看出，自定义线程工厂起作用了，线程的名称和线程的优先级都是通过线程工厂设置的。
<a name="lJ7LB"></a>
## 参数7：`RejectedExecutionHandler`
**拒绝策略：当线程池的任务超出线程池队列可以存储的最大值之后，执行的策略。**默认的拒绝策略有以下 4 种：

- `AbortPolicy`：拒绝并抛出异常。
- `CallerRunsPolicy`：使用当前调用的线程来执行此任务。
- `DiscardOldestPolicy`：抛弃队列头部（最旧）的一个任务，并执行当前任务。
- `DiscardPolicy`：忽略并抛弃当前任务。

线程池的默认策略是 AbortPolicy 拒绝并抛出异常。
<a name="akWx2"></a>
## 总结
这里介绍了线程池的 7 大参数：

1. `corePoolSize`：核心线程数，线程池正常情况下保持的线程数，大户人家“长工”的数量。
2. `maximumPoolSize`：最大线程数，当线程池繁忙时最多可以拥有的线程数，大户人家“长工”+“短工”的总数量。
3. `keepAliveTime`：空闲线程存活时间，没有活之后“短工”可以生存的最大时间。
4. `TimeUnit`：时间单位，配合参数 3 一起使用，用于描述参数 3 的时间单位。
5. `BlockingQueue`：线程池的任务队列，用于保存线程池待执行任务的容器。
6. `ThreadFactory`：线程工厂，用于创建线程池中线程的工厂方法，通过它可以设置线程的命名规则、优先级和线程类型。
7. `RejectedExecutionHandler`：拒绝策略，当任务量超过线程池可以保存的最大任务数时，执行的策略。
