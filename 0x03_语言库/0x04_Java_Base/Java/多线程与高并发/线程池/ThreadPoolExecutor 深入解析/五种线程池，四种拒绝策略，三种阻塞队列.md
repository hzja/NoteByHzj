Java 线程池
<a name="KQtqM"></a>
### 线程池的工作原理
```java
ThreadPoolExecutor(int corePoolSize,// 核心线程数
                   int maximumPoolSize,//最大线程数
                   long keepAliveTime,//空闲线程存活时间
                   TimeUnit unit,//存活时间单位
                   BlockingQueue<Runnable> workQueue,//阻塞队列
                   RejectedExecutionHandler handler)//拒绝策略
```
当`ThreadPoolExecutor`线程池被创建的时候，里边是没有工作线程的，直到有任务进来（执行了`execute`方法）才开始创建线程去工作，工作原理如下（即`execute`方法运行原理）：
:::info
调用线程池的execute方法的时候如果当前的工作线程数 小于 核心线程数，则创建新的线程执行任务；否则将任务加入阻塞队列。如果队列满了则根据最大线程数去创建额外（核心线程数以外）的工作线程去执行任务；如果工作线程数达到了最大线程数，则根据拒绝策略去执行。存活时间到期的话只是回收核心线程（`maximumPoolSize - corePoolSize`）以外的线程
:::
```java
// 分3个步骤进行:
// 1. 如果运行的线程少于corePoolSize，请尝试使用给定的命令作为第一个线程启动一个新线程的任务。对addWorker的调用会自动检查runState和workerCount，这样可以防止虚假警报的增加当它不应该的时候，返回false。
// 2. 如果任务可以成功排队，那么仍然需要来再次检查我们是否应该添加线程(因为自从上次检查后，现有的已经死了)或者那样自进入此方法后池就关闭了。所以我们重新检查状态，并在必要时回滚队列停止，或启动一个新线程(如果没有线程)。
// 3. 如果不能将任务放入队列，那么尝试添加一个新的线程。如果它失败了，我们知道我们被关闭或饱和了所以拒绝这个任务。
public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();
    int c = ctl.get();
    // 第一步
    if (workerCountOf(c) < corePoolSize) {
        if (addWorker(command, true))
            return;
        c = ctl.get();
    }
    // 第二步骤
    if (isRunning(c) && workQueue.offer(command)) {
        int recheck = ctl.get();
        if (! isRunning(recheck) && remove(command))
            reject(command);
        else if (workerCountOf(recheck) == 0)
            addWorker(null, false);
    }
    // 第三步
    else if (!addWorker(command, false))
        reject(command);
}
```
<a name="PUhZj"></a>
### 五种线程池
```java
ExecutorService threadPool = null;
threadPool = Executors.newCachedThreadPool();
//有缓冲的线程池，线程数 JVM 控制
threadPool = Executors.newFixedThreadPool(3);
//固定大小的线程池
threadPool = Executors.newScheduledThreadPool(2);
threadPool = Executors.newSingleThreadExecutor();
//单线程的线程池，只有一个线程在工作
threadPool = new ThreadPoolExecutor();
//默认线程池，可控制参数比较多  

ThreadPoolExecutor参数：
public class ThreadPoolExecutor extends AbstractExecutorService {
    .....
    public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,
            BlockingQueue<Runnable> workQueue);
    public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,
            BlockingQueue<Runnable> workQueue,ThreadFactory threadFactory);
    public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,
            BlockingQueue<Runnable> workQueue,RejectedExecutionHandler handler);
    public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,
        BlockingQueue<Runnable> workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler);
    ...
}
```
参数含义以及功能：

- `corePoolSize`：核心池的大小，这个参数跟后面讲述的线程池的实现原理有非常大的关系。在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用了`prestartAllCoreThreads()`或者`prestartCoreThread()`方法，从这2个方法的名字就可以看出，是预创建线程的意思，即在没有任务到来之前就创建`corePoolSize`个线程或者一个线程。默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到`corePoolSize`后，就会把到达的任务放到缓存队列当中；
- `maximumPoolSize`：线程池最大线程数，这个参数也是一个非常重要的参数，它表示在线程池中最多能创建多少个线程；
- `keepAliveTime`：表示线程没有任务执行时最多保持多久时间会终止。默认情况下，只有当线程池中的线程数大于`corePoolSize`时，`keepAliveTime`才会起作用，直到线程池中的线程数不大于`corePoolSize`，即当线程池中的线程数大于`corePoolSize`时，如果一个线程空闲的时间达到`keepAliveTime`，则会终止，直到线程池中的线程数不超过`corePoolSize`。但是如果调用了`allowCoreThreadTimeOut(boolean)`方法，在线程池中的线程数不大于`corePoolSize`时，`keepAliveTime`参数也会起作用，直到线程池中的线程数为0；
- `unit`：参数`keepAliveTime`的时间单位，有7种取值，在`TimeUnit`类中有7种静态属性：
```java
TimeUnit.DAYS;               //天
TimeUnit.HOURS;             //小时
TimeUnit.MINUTES;           //分钟
TimeUnit.SECONDS;           //秒
TimeUnit.MILLISECONDS;      //毫秒
TimeUnit.MICROSECONDS;      //微妙
TimeUnit.NANOSECONDS;       //纳秒
```
`workQueue`：一个阻塞队列，用来存储等待执行的任务，这个参数的选择也很重要，会对线程池的运行过程产生重大影响，一般来说，这里的阻塞队列有以下几种选择：
```java
ArrayBlockingQueue;
LinkedBlockingQueue;
SynchronousQueue;
```
`ArrayBlockingQueue`和`PriorityBlockingQueue`使用较少，一般使用`LinkedBlockingQueue`和`Synchronous`。线程池的排队策略与`BlockingQueue`有关。

- `threadFactory`：线程工厂，主要用来创建线程；
- `handler`：表示当拒绝处理任务时的策略，有以下四种取值：
   - `ThreadPoolExecutor.AbortPolicy`:（默认）丢弃任务并抛出`RejectedExecutionException`异常。
   - `ThreadPoolExecutor.DiscardPolicy`：也是丢弃任务，但是不抛出异常。
   - `ThreadPoolExecutor.DiscardOldestPolicy`：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）
   - `ThreadPoolExecutor.CallerRunsPolicy`：由调用线程处理该任务
<a name="IE77X"></a>
### 四种拒绝策略
```java
RejectedExecutionHandler rejected = null;
rejected = new ThreadPoolExecutor.AbortPolicy();
//默认，队列满了丢任务抛出异常
rejected = new ThreadPoolExecutor.DiscardPolicy();
//队列满了丢任务不抛异常
rejected = new ThreadPoolExecutor.DiscardOldestPolicy();
//将最早进入队列的任务删，之后再尝试加入队列
rejected = new ThreadPoolExecutor.CallerRunsPolicy();
//如果添加到线程池失败，那么主线程会自己去执行该任务；如果执行程序已关闭（主线程运行结束），则会丢弃该任务
```
当然也可以根据应用场景实现 `RejectedExecutionHandler` 接口，自定义饱和策略，如记录 日志或持久化存储不能处理的任务
<a name="mhMzp"></a>
### 三种阻塞队列
```java
BlockingQueue<Runnable> workQueue = null;
workQueue = new ArrayBlockingQueue<>(5);
//基于数组的先进先出队列，有界
workQueue = new LinkedBlockingQueue<>();
//基于链表的先进先出队列，无界
workQueue = new SynchronousQueue<>();
//无缓冲的等待队列，无界
```
