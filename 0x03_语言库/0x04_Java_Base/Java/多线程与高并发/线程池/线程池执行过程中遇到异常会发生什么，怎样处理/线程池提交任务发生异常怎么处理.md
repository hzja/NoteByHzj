Java 线程池
<a name="N1vRZ"></a>
### 1、当提交新任务时，异常如何处理呢?
先来看一段代码：
```java
ExecutorService threadPool = Executors.newFixedThreadPool(5);
for (int i = 0; i < 5; i++) {
    threadPool.submit(() -> {
        System.out.println("current thread name" + Thread.currentThread().getName());
        Object object = null;
        System.out.print("result## "+object.toString());
    });
}
```
显然，这段代码会有异常，再来看看运行结果<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1630459732522-15313ac7-b9d4-4b78-9a4b-4cf01355cb52.png#clientId=u8160d6de-ba51-4&from=paste&height=331&id=u15989b9d&originHeight=994&originWidth=2743&originalType=binary&ratio=1&rotation=0&showTitle=false&size=159058&status=done&style=shadow&taskId=u01782ba9-3475-4d70-87ad-3685c21d0f4&title=&width=914.3333333333334)<br />虽然没有结果输出，但是也没有抛出异常，所以无法感知任务出现了异常，所以需要添加`try/catch`。如下图：
```java
/**
 * ThreadPoolTest
 * <p>
 * encoding:UTF-8
 *
 * @author Fcant 上午 09:27 2021/9/1/0001
 */
public class ThreadPoolTest {
    public static void main(String[] args) {
        ExecutorService threadPool = Executors.newFixedThreadPool(5);
        for (int i = 0; i < 5; i++) {
            threadPool.submit(() -> {
                System.out.println("current thread name" + Thread.currentThread().getName());
                try {
                    Object object = null;
                    System.out.print("result## " + object.toString());
                } catch (Exception e) {
                    System.out.println("程序出异常啦！！！");
                }
            });
        }
    }
}
```
![image.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1630459868457-9c4e852c-108b-4ce5-b76d-a9420a98d7ff.png#clientId=u8160d6de-ba51-4&from=paste&height=227&id=u12cae088&originHeight=681&originWidth=2898&originalType=binary&ratio=1&rotation=0&showTitle=false&size=195760&status=done&style=shadow&taskId=u6daccd35-0583-42f2-9abe-3e6476e8588&title=&width=966)<br />因此，线程的异常处理，可以直接`try...catch`捕获。
<a name="Kbu1F"></a>
### 2、线程池`exec.submit()`的执行流程
通过debug上面有异常的`submit`方法，处理有异常`submit`方法的主要执行流程图如下：<br />![2021-09-01-09-24-06-957878.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1630459885317-de934748-6e49-4103-83ef-10a24ffd4429.png#clientId=u8160d6de-ba51-4&from=ui&id=u0f23d69b&originHeight=953&originWidth=783&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23080&status=done&style=shadow&taskId=u9d0e4b7b-5fda-4dd2-b27d-ab8e09a0638&title=)<br />submit方法执行流程
```java
//构造feature对象
/**
     * @throws RejectedExecutionException {@inheritDoc}
     * @throws NullPointerException       {@inheritDoc}
     */
public Future<?> submit(Runnable task) {
    if (task == null) throw new NullPointerException();
    RunnableFuture<Void> ftask = newTaskFor(task, null);
    execute(ftask);
    return ftask;
}
protected <T> RunnableFuture<T> newTaskFor(Runnable runnable, T value) {
    return new FutureTask<T>(runnable, value);
}
public FutureTask(Runnable runnable, V result) {
    this.callable = Executors.callable(runnable, result);
    this.state = NEW;       // ensure visibility of callable
}
public static <T> Callable<T> callable(Runnable task, T result) {
    if (task == null)
        throw new NullPointerException();
    return new RunnableAdapter<T>(task, result);
}
//线程池执行
public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();
    int c = ctl.get();
    if (workerCountOf(c) < corePoolSize) {
        if (addWorker(command, true))
            return;
        c = ctl.get();
    }
    if (isRunning(c) && workQueue.offer(command)) {
        int recheck = ctl.get();
        if (! isRunning(recheck) && remove(command))
            reject(command);
        else if (workerCountOf(recheck) == 0)
            addWorker(null, false);
    }
    else if (!addWorker(command, false))
        reject(command);
}
//捕获异常
public void run() {
    if (state != NEW ||
        !UNSAFE.compareAndSwapObject(this, runnerOffset,
                                     null, Thread.currentThread()))
        return;
    try {
        Callable<V> c = callable;
        if (c != null && state == NEW) {
            V result;
            boolean ran;
            try {
                result = c.call();
                ran = true;
            } catch (Throwable ex) {
                result = null;
                ran = false;
                setException(ex);
            }
            if (ran)
                set(result);
        }
    } finally {
        // runner must be non-null until state is settled to
        // prevent concurrent calls to run()
        runner = null;
        // state must be re-read after nulling runner to prevent
        // leaked interrupts
        int s = state;
        if (s >= INTERRUPTING)
            handlePossibleCancellationInterrupt(s);
    }
}
```
通过以上分析，`submit`执行的任务，可以通过`Future`对象的`get`方法接收抛出的异常，再进行处理。再通过一个demo，看一下`Future`对象的`get`方法处理异常的姿势，如下图：
```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

/**
 * ThreadPoolTest
 * <p>
 * encoding:UTF-8
 *
 * @author Fcant 上午 09:27 2021/9/1/0001
 */
public class ThreadPoolTest {
    public static void main(String[] args) {
        ExecutorService threadPool = Executors.newFixedThreadPool(5);
        for (int i = 0; i < 5; i++) {
            Future future = threadPool.submit(() -> {
                System.out.println("current thread name" + Thread.currentThread().getName());

                    Object object = null;
                    System.out.print("result## " + object.toString());

            });
            try {
                future.get();
            } catch (Exception e) {
                System.out.println("程序出异常啦！！！");
            }
        }
    }
}
```
![image.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1630460063967-035387c2-c402-45c3-ae26-0b987e23f618.png#clientId=u8160d6de-ba51-4&from=paste&height=346&id=u0acaffbc&originHeight=1039&originWidth=2645&originalType=binary&ratio=1&rotation=0&showTitle=false&size=224626&status=done&style=shadow&taskId=u89cdb981-4f03-4529-81fa-90903caab5a&title=&width=881.6666666666666)<br />因此，可以使用这两种方案处理线程池异常：

1. 在任务代码`try/catch`捕获异常，
2. 通过`Future`对象的`get`方法接收抛出的异常
<a name="uTmkS"></a>
### 3、为工作者线程设置`UncaughtExceptionHandler`，在`uncaughtException`方法中处理异常
也可以为工作者线程设置`UncaughtExceptionHandler`，在`uncaughtException`方法中处理异常，直接看这样实现的正确姿势：
```java
ExecutorService threadPool = Executors.newFixedThreadPool(1, r -> {
    Thread t = new Thread(r);
    t.setUncaughtExceptionHandler(
        (t1, e) -> {
            System.out.println(t1.getName() + "线程抛出的异常"+e);
        });
    return t;
});
threadPool.execute(()->{
    Object object = null;
    System.out.print("result## " + object.toString());
});
```
运行结果：<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1630460170783-48b56ca4-c5b6-4d92-b89d-c511d7e03dfc.png#clientId=u8160d6de-ba51-4&from=paste&height=344&id=u77673412&originHeight=1033&originWidth=2787&originalType=binary&ratio=1&rotation=0&showTitle=false&size=152386&status=done&style=shadow&taskId=u74f35379-47bb-4390-91da-4da5a57a142&title=&width=929)
<a name="rqS3Y"></a>
### 4、重写`ThreadPoolExecutor`的`afterExecute`方法，处理传递的异常引用
这是jdk文档的一个demo：
```java
class ExtendedExecutor extends ThreadPoolExecutor {
    // 这可是jdk文档里面给的例子。。
    protected void afterExecute(Runnable r, Throwable t) {
        super.afterExecute(r, t);
        if (t == null && r instanceof Future<?>) {
            try {
                Object result = ((Future<?>) r).get();
            } catch (CancellationException ce) {
                t = ce;
            } catch (ExecutionException ee) {
                t = ee.getCause();
            } catch (InterruptedException ie) {
                Thread.currentThread().interrupt(); // ignore/reset
            }
        }
        if (t != null)
            System.out.println(t);
    }
}}
```
<a name="z3EEI"></a>
### 5、因此，被问到线程池异常处理，如何回答？
![2021-09-01-09-24-08-153881.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1630460184474-f3d4a5c7-c5ef-43b2-ae2d-78cd839d221e.png#clientId=u8160d6de-ba51-4&from=ui&id=ue95de99f&originHeight=305&originWidth=1080&originalType=binary&ratio=1&rotation=0&showTitle=false&size=58457&status=done&style=shadow&taskId=u041991cc-14fb-4b1e-aaf0-8ab9437fa0d&title=)
