Java线程池<br />在实际开发中，常常会用到线程池，但任务一旦提交到线程池之后，如果发生异常之后，怎么处理？怎么获取到异常信息？在了解这个问题之前，可以先看一下 线程池的源码解析，从源码中知道了线程池的提交方式：`submit`和`execute`的区别，接下来分别使用他们执行带有异常的任务！看结果是怎么样的！<br />先用伪代码模拟一下线程池抛异常的场景：
```java
public class ThreadPoolException {
    public static void main(String[] args) {

        //创建一个线程池
        ExecutorService executorService= Executors.newFixedThreadPool(1);

        //当线程池抛出异常后 submit无提示，其他线程继续执行
        executorService.submit(new task());

        //当线程池抛出异常后 execute抛出异常，其他线程继续执行新任务
        executorService.execute(new task());
    }
}

//任务类
class task implements  Runnable{

    @Override
    public void run() {
        System.out.println("进入了task方法！！！");
        int i=1/0;

    }
}
```
运行结果：<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1676945142037-1c32272f-78c9-42df-a6b5-c4a7ad1aa274.png#averageHue=%23faedec&clientId=u3cc1ea76-db35-4&from=paste&id=ufa74baf8&originHeight=196&originWidth=1051&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=uf793035b-8ccb-473b-b0df-3127a674d05&title=)<br />可以看到：submit不打印异常信息，而`execute`则会打印异常信息！`submit`的方式不打印异常信息，显然在生产中，是不可行的，因为无法保证线程中的任务永不异常，而如果使用`submit`的方式出现了异常，直接如上写法，将无法获取到异常信息，做出对应的判断和处理，所以下一步需要知道如何获取线程池抛出的异常！<br />`submit()`想要获取异常信息就必须使用`get()`方法！！
```java
//当线程池抛出异常后 submit无提示，其他线程继续执行
Future<?> submit = executorService.submit(new task());
submit.get();
```
submit打印异常信息如下：<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1676945142055-c45215fc-e7c3-4092-a1d0-3da40d8bc99d.png#averageHue=%23fcfbfa&clientId=u3cc1ea76-db35-4&from=paste&id=u9215fd5e&originHeight=111&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u7f945d7b-f1e1-4f5b-9a75-aff2af133ee&title=)
<a name="GqM4I"></a>
### 方案一：使用 try-catch
```java
public class ThreadPoolException {
    public static void main(String[] args) {
        
        //创建一个线程池
        ExecutorService executorService = Executors.newFixedThreadPool(1);

        //当线程池抛出异常后 submit无提示，其他线程继续执行
        executorService.submit(new task());

        //当线程池抛出异常后 execute抛出异常，其他线程继续执行新任务
        executorService.execute(new task());
    }
}
// 任务类
class task implements Runnable {
    @Override
    public void run() {
        try {
            System.out.println("进入了task方法！！！");
            int i = 1 / 0;
        } catch (Exception e) {
            System.out.println("使用了try -catch 捕获异常" + e);
        }
    }
}
```
打印结果：<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1676945142087-2ef30f56-b987-459c-9fc6-18500301919c.png#averageHue=%23f7edec&clientId=u3cc1ea76-db35-4&from=paste&id=ud744d185&originHeight=178&originWidth=875&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u21f36fb9-4b58-4519-9e71-51a47ffc378&title=)<br />可以看到 `submit` 和 `execute`都清晰易懂的捕获到了异常，可以知道任务出现了问题，而不是消失的无影无踪。
<a name="gPQHi"></a>
### 方案二：使用`Thread.setDefaultUncaughtExceptionHandler`方法捕获异常
方案一中，每一个任务都要加一个try-catch 实在是太麻烦了，而且代码也不好看，那么这样想的话，可以用`Thread.setDefaultUncaughtExceptionHandler`方法捕获异常<br />[![](https://cdn.nlark.com/yuque/0/2023/png/396745/1676945142127-98387722-1607-421b-8d0b-7da4f392c033.png#averageHue=%23f9f4f3&clientId=u3cc1ea76-db35-4&from=paste&id=u79f19bb0&originHeight=186&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=ufb352ece-8f3f-4d37-b1e8-538e4c3e633&title=)](https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247520168&idx=1&sn=89732de3c6b9faa4d9af312f6bd93d4f&chksm=fcf75065cb80d973234c7af37c768c2f2760c411cfec480d189b26a4ad8f8036b814e00c1330&token=523620251&lang=zh_CN&scene=21#wechat_redirect)<br />`UncaughtExceptionHandler` 是Thread类一个内部类，也是一个函数式接口。<br />内部的`uncaughtException`是一个处理线程内发生的异常的方法，参数为线程对象t和异常对象e。<br />![2023-02-21-10-15-56.366286200.png](https://cdn.nlark.com/yuque/0/2023/png/396745/1676945897506-32134960-4247-481f-bdc3-86bdf3aa7774.png#averageHue=%23fcf4f3&clientId=u3cc1ea76-db35-4&from=ui&id=u521a4e06&originHeight=294&originWidth=791&originalType=binary&ratio=2.5&rotation=0&showTitle=false&size=699170&status=done&style=none&taskId=u4b14f3af-e9e1-4398-95d1-1a99b14def7&title=)<br />应用在线程池中如下所示：重写它的线程工厂方法，在线程工厂创建线程的时候，都赋予`UncaughtExceptionHandler`处理器对象。
```java
public class ThreadPoolException {
    public static void main(String[] args) throws InterruptedException {


        //1.实现一个自己的线程池工厂
        ThreadFactory factory = (Runnable r) -> {
            //创建一个线程
            Thread t = new Thread(r);
            //给创建的线程设置UncaughtExceptionHandler对象 里面实现异常的默认逻辑
            t.setDefaultUncaughtExceptionHandler((Thread thread1, Throwable e) -> {
                System.out.println("线程工厂设置的exceptionHandler" + e.getMessage());
            });
            return t;
        };

        //2.创建一个自己定义的线程池，使用自己定义的线程工厂
        ExecutorService executorService = new ThreadPoolExecutor(
                1,
                1,
                0,
                TimeUnit.MILLISECONDS,
                new LinkedBlockingQueue(10),
                factory);

        // submit无提示
        executorService.submit(new task());

        Thread.sleep(1000);
        System.out.println("==================为检验打印结果，1秒后执行execute方法");

        // execute 方法被线程工厂factory 的UncaughtExceptionHandler捕捉到异常
        executorService.execute(new task());


    }


}

class task implements Runnable {
    @Override
    public void run() {
        System.out.println("进入了task方法！！！");
        int i = 1 / 0;
    }
}
```
打印结果如下：<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1676945142518-3bbc3601-2fde-45ec-ada5-1da86ee093e3.png#averageHue=%23f7e7e6&clientId=u3cc1ea76-db35-4&from=paste&id=u03346994&originHeight=165&originWidth=679&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u9ad35590-789e-4bd7-85db-d452dec1a7d&title=)<br />根据打印结果可以看到，`execute`方法被线程工厂factory中设置的 `UncaughtExceptionHandler`捕捉到异常，而submit方法却没有任何反应！说明`UncaughtExceptionHandler`在`submit`中并没有被调用。这是为什么呢？<br />在日常使用中，可以知道，`execute`和`submit`最大的区别就是`execute`没有返回值，`submit`有返回值。`submit`返回的是一个future ，可以通过这个future取到线程执行的结果或者异常信息。
```java
Future<?> submit = executorService.submit(new task());
//打印异常结果
System.out.println(submit.get());
```
![](https://cdn.nlark.com/yuque/0/2023/png/396745/1676945142726-b23438f8-a86f-4e3d-a96d-9f2274cf7942.png#averageHue=%23f5f5f5&clientId=u3cc1ea76-db35-4&from=paste&id=u83ef7cda&originHeight=93&originWidth=789&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u36854e4a-6efa-42fb-8afb-d036d4aceae&title=)<br />从结果看出：submit并不是丢失了异常，使用`future.get()`还是有异常打印的！！那为什么线程工厂factory 的`UncaughtExceptionHandler`没有打印异常呢？猜测是submit方法内部已经捕获了异常， 只是没有打印出来，也因为异常已经被捕获，因此jvm也就不会去调用Thread的`UncaughtExceptionHandler`去处理异常。<br />接下来，验证猜想：<br />首先看一下submit和execute的源码：<br />`submit`源码在底层还是调用的`execute`方法，只不过多一层`Future`封装，并返回了这个`Future`，这也解释了为什么`submit`会有返回值
```java
//submit()方法
 public <T> Future<T> submit(Callable<T> task) {
     if (task == null) throw new NullPointerException();
     
     //execute内部执行这个对象内部的逻辑，然后将结果或者异常 set到这个ftask里面
     RunnableFuture<T> ftask = newTaskFor(task); 
     // 执行execute方法
     execute(ftask); 
     //返回这个ftask
     return ftask;
 }
```
可以看到`submit`也是调用的`execute`，在`execute`方法中，任务被提交到了`addWorker(command, true)` ，然后为每一个任务创建一个Worker去处理这个线程，这个Worker也是一个线程，执行任务时调用的就是Worker的run方法！run方法内部又调用了`runworker`方法！如下所示：
```java
public void run() {
        runWorker(this);
 }
     
final void runWorker(Worker w) {
     Thread wt = Thread.currentThread();
     Runnable task = w.firstTask;
     w.firstTask = null;
     w.unlock(); // allow interrupts
     boolean completedAbruptly = true;
     try {
      //这里就是线程可以重用的原因，循环+条件判断，不断从队列中取任务        
      //还有一个问题就是非核心线程的超时删除是怎么解决的
      //主要就是getTask方法()见下文③
         while (task != null || (task = getTask()) != null) {
             w.lock();
             if ((runStateAtLeast(ctl.get(), STOP) ||
                  (Thread.interrupted() &&
                   runStateAtLeast(ctl.get(), STOP))) &&
                 !wt.isInterrupted())
                 wt.interrupt();
             try {
                 beforeExecute(wt, task);
                 Throwable thrown = null;
                 try {
                  //执行线程
                     task.run();
                     //异常处理
                 } catch (RuntimeException x) {
                     thrown = x; throw x;
                 } catch (Error x) {
                     thrown = x; throw x;
                 } catch (Throwable x) {
                     thrown = x; throw new Error(x);
                 } finally {
                  //execute的方式可以重写此方法处理异常
                     afterExecute(task, thrown);
                 }
             } finally {
                 task = null;
                 w.completedTasks++;
                 w.unlock();
             }
         }
         //出现异常时completedAbruptly不会被修改为false
         completedAbruptly = false;
     } finally {
      //如果如果completedAbruptly值为true，则出现异常，则添加新的Worker处理后边的线程
         processWorkerExit(w, completedAbruptly);
     }
 }
```
核心就在 `task.run();` 这个方法里面了， 期间如果发生异常会被抛出。

- 如果用`execute`提交的任务，会被封装成了一个runable任务，然后进去 再被封装成一个worker，最后在worker的`run`方法里面调用`runWoker`方法， `runWoker`方法里面执行任务任务，如果任务出现异常，用try-catch捕获异常往外面抛，在最外层使用try-catch捕获到了 `runWoker`方法中抛出的异常。因此在`execute`中看到了任务的异常信息。
- 那么为什么`submit`没有异常信息呢？因为submit是将任务封装成了一个futureTask ，然后这个futureTask被封装成worker，在woker的run方法里面，最终调用的是futureTask的run方法， 猜测里面是直接吞掉了异常，并没有抛出异常，因此在worker的`runWorker`方法里面无法捕获到异常。

下面来看一下futureTask的`run`方法，果不其然，在try-catch中吞掉了异常，将异常放到了 `setException(ex);`里面
```java
public void run() {
    if (state != NEW ||
        !UNSAFE.compareAndSwapObject(this, runnerOffset,
                                     null, Thread.currentThread()))
        return;
    try {
        Callable<V> c = callable;
        if (c != null && state == NEW) {
            V result;
            boolean ran;
            try {
                result = c.call();
                ran = true;
            } catch (Throwable ex) {
                result = null;
                ran = false;
                //在此方法中设置了异常信息
                setException(ex);
            }
            if (ran)
                set(result);
        }
        //省略下文
        //。。。。。。
        //setException(ex)`方法如下：将异常对象赋予`outcome
        protected void setException(Throwable t) {
            if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) {
            //将异常对象赋予outcome，记住这个outcome，
            outcome = t;
            UNSAFE.putOrderedInt(this, stateOffset, EXCEPTIONAL); // final state
            finishCompletion();
        }
    }
}
```
将异常对象赋予outcome有什么用呢？这个outcome是什么呢？当使用submit返回Future对象，并使用`Future.get()`时， 会调用内部的report方法！
```java
public V get() throws InterruptedException, ExecutionException {
    int s = state;
    if (s <= COMPLETING)
        s = awaitDone(false, 0L);
    //注意这个方法
    return report(s);
}
```
reoport里面实际上返回的是outcome，刚好之前的异常就set到了这个outcome里面
```java
private V report(int s) throws ExecutionException {
 //设置`outcome`
    Object x = outcome;
    if (s == NORMAL)
     //返回`outcome`
        return (V)x;
    if (s >= CANCELLED)
        throw new CancellationException();
    throw new ExecutionException((Throwable)x);
}
```
因此，在用`submit`提交的时候，runable对象被封装成了future ，future 里面的 run方法在处理异常时， try-catch了所有的异常，通过`setException(ex);`方法设置到了变量outcome里面， 可以通过`future.get`获取到outcome。<br />所以在submit提交的时候，里面发生了异常， 是不会有任何抛出信息的。而通过`future.get()`可以获取到submit抛出的异常！在submit里面，除了从返回结果里面取到异常之外，没有其他方法。因此，在不需要返回结果的情况下，最好用execute ，这样就算没有写try-catch，疏漏了异常捕捉，也不至于丢掉异常信息。
<a name="h0pM1"></a>
### 方案三：重写`afterExecute`进行异常处理
通过上述源码分析，在`excute`的方法里面，可以通过重写`afterExecute`进行异常处理，但是注意！这个也只适用于`excute`提交(`submit`的方式比较麻烦，下面说)，因为`submit`的`task.run`里面把异常吞了，根本不会跑出来异常，因此也不会有异常进入到`afterExecute`里面。<br />在`runWorker`里面，调用task.run之后，会调用线程池的 `afterExecute(task, thrown)` 方法
```java
final void runWorker(Worker w) {
    //当前线程
    Thread wt = Thread.currentThread();
    //我们的提交的任务
    Runnable task = w.firstTask;
    w.firstTask = null;
    w.unlock(); // allow interrupts
    boolean completedAbruptly = true;
    try {
        while (task != null || (task = getTask()) != null) {
            w.lock();
            if ((runStateAtLeast(ctl.get(), STOP) ||
                 (Thread.interrupted() &&
                  runStateAtLeast(ctl.get(), STOP))) &&
                !wt.isInterrupted())
                wt.interrupt();
            try {
                beforeExecute(wt, task);
                Throwable thrown = null;
                try {
                    //直接就调用了task的run方法 
                    task.run(); //如果是futuretask的run,里面是吞掉了异常，不会有异常抛出，
                    // 因此Throwable thrown = null;  也不会进入到catch里面
                } catch (RuntimeException x) {
                    thrown = x; throw x;
                } catch (Error x) {
                    thrown = x; throw x;
                } catch (Throwable x) {
                    thrown = x; throw new Error(x);
                } finally {
                    //调用线程池的afterExecute方法 传入了task和异常
                    afterExecute(task, thrown);
                }
            } finally {
                task = null;
                w.completedTasks++;
                w.unlock();
            }
        }
        completedAbruptly = false;
    } finally {
        processWorkerExit(w, completedAbruptly);
    }
}
```
重写`afterExecute`处理`execute`提交的异常
```java
public class ThreadPoolException3 {
    public static void main(String[] args) throws InterruptedException, ExecutionException {


        //1.创建一个自己定义的线程池
        ExecutorService executorService = new ThreadPoolExecutor(
                2,
                3,
                0,
                TimeUnit.MILLISECONDS,
                new LinkedBlockingQueue(10)
        ) {
            //重写afterExecute方法
            @Override
            protected void afterExecute(Runnable r, Throwable t) {
                System.out.println("afterExecute里面获取到异常信息，处理异常" + t.getMessage());
            }
        };
        
        //当线程池抛出异常后 execute
        executorService.execute(new task());
    }
}

class task3 implements Runnable {
    @Override
    public void run() {
        System.out.println("进入了task方法！！！");
        int i = 1 / 0;
    }
}
```
执行结果：可以在`afterExecute`方法内部对异常进行处理<br />![2023-02-21-10-15-57.508403500.png](https://cdn.nlark.com/yuque/0/2023/png/396745/1676945931246-4e82e384-43c1-473f-b782-9d86590eb257.png#averageHue=%23f9f0f0&clientId=u3cc1ea76-db35-4&from=ui&id=u2ecbc7d7&originHeight=203&originWidth=980&originalType=binary&ratio=2.5&rotation=0&showTitle=false&size=598061&status=done&style=none&taskId=u6da05be7-c69e-474a-b229-e4d61df2806&title=)<br />如果要用这个`afterExecute`处理`submit`提交的异常， 要额外处理。判断`Throwable`是否是`FutureTask`，如果是代表是`submit`提交的异常，代码如下：
```java
public class ThreadPoolException3 {
    public static void main(String[] args) throws InterruptedException, ExecutionException {


        //1.创建一个自己定义的线程池
        ExecutorService executorService = new ThreadPoolExecutor(
                2,
                3,
                0,
                TimeUnit.MILLISECONDS,
                new LinkedBlockingQueue(10)
        ) {
            //重写afterExecute方法
            @Override
            protected void afterExecute(Runnable r, Throwable t) {
                //这个是excute提交的时候
                if (t != null) {
                    System.out.println("afterExecute里面获取到excute提交的异常信息，处理异常" + t.getMessage());
                }
                //如果r的实际类型是FutureTask 那么是submit提交的，所以可以在里面get到异常
                if (r instanceof FutureTask) {
                    try {
                        Future<?> future = (Future<?>) r;
                        //get获取异常
                        future.get();

                    } catch (Exception e) {
                        System.out.println("afterExecute里面获取到submit提交的异常信息，处理异常" + e);
                    }
                }
            }
        };
        //当线程池抛出异常后 execute
        executorService.execute(new task());
        
        //当线程池抛出异常后 submit
        executorService.submit(new task());
    }
}

class task3 implements Runnable {
    @Override
    public void run() {
        System.out.println("进入了task方法！！！");
        int i = 1 / 0;
    }
}
```
处理结果如下：<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1676945142716-7e338e80-c2e2-40d5-94c2-f0917a1a85df.png#averageHue=%23f7f4f4&clientId=u3cc1ea76-db35-4&from=paste&id=u27cd0f18&originHeight=152&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u36c69c52-28cb-4ecf-ae0c-c8826369a28&title=)<br />可以看到使用重写`afterExecute`这种方式，既可以处理`execute`抛出的异常，也可以处理`submit`抛出的异常。
