Java 线程安全<br />线程安全是指某个方法或某段代码，在多线程中能够正确的执行，不会出现数据不一致或数据污染的情况，把这样的程序称之为线程安全的，反之则为非线程安全的。在 Java 中，解决线程安全问题有以下 3 种手段：

1. 使用线程安全类，比如 `AtomicInteger`。
2. 加锁排队执行
   1. 使用 `synchronized` 加锁。
   2. 使用 `ReentrantLock` 加锁。
3. 使用线程本地变量 `ThreadLocal`。

接下来逐个来看它们的实现。
<a name="MiNDX"></a>
## 线程安全问题演示
创建一个变量 number 等于 0，之后创建线程 1，执行 100 万次 ++ 操作，同时再创建线程 2 执行 100 万次 -- 操作，等线程 1 和线程 2 都执行完之后，打印 number 变量的值，如果打印的结果为 0，则说明是线程安全的，否则则为非线程安全的，示例代码如下：
```java
public class ThreadSafeTest {
    // 全局变量
    private static int number = 0;
    // 循环次数(100W)
    private static final int COUNT = 1_000_000;

    public static void main(String[] args) throws InterruptedException {
        // 线程1：执行 100W 次 ++ 操作
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < COUNT; i++) {
                number++;
            }
        });
        t1.start();

        // 线程2：执行 100W 次 -- 操作
        Thread t2 = new Thread(() -> {
            for (int i = 0; i < COUNT; i++) {
                number--;
            }
        });
        t2.start();

        // 等待线程 1 和线程 2，执行完，打印 number 最终的结果
        t1.join();
        t2.join();
        System.out.println("number 最终结果：" + number);
    }
}
```
以上程序的执行结果如下图所示：![](https://cdn.nlark.com/yuque/0/2022/png/396745/1650959714688-82fe5d83-6322-420d-95c0-f89d6f95c01d.png#clientId=u599aaf1f-e505-4&from=paste&id=u6cb3abce&originHeight=239&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u4871c7e9-07a0-4a72-aac1-50024dc8000&title=)从上述执行结果可以看出，number 变量最终的结果并不是 0，和预期的正确结果不相符，这就是多线程中的线程安全问题。
<a name="rBWf5"></a>
## 解决线程安全问题
<a name="YyaQT"></a>
### 1、原子类`AtomicInteger`
`AtomicInteger` 是线程安全的类，使用它可以将 ++ 操作和 -- 操作，变成一个原子性操作，这样就能解决非线程安全的问题了，如下代码所示：
```java
import java.util.concurrent.atomic.AtomicInteger;

public class AtomicIntegerExample {
    // 创建 AtomicInteger
    private static AtomicInteger number = new AtomicInteger(0);
    // 循环次数
    private static final int COUNT = 1_000_000;

    public static void main(String[] args) throws InterruptedException {
        // 线程1：执行 100W 次 ++ 操作
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < COUNT; i++) {
                // ++ 操作
                number.incrementAndGet();
            }
        });
        t1.start();

        // 线程2：执行 100W 次 -- 操作
        Thread t2 = new Thread(() -> {
            for (int i = 0; i < COUNT; i++) {
                // -- 操作
                number.decrementAndGet();
            }
        });
        t2.start();

        // 等待线程 1 和线程 2，执行完，打印 number 最终的结果
        t1.join();
        t2.join();
        System.out.println("最终结果：" + number.get());
    }
}
```
以上程序的执行结果如下图所示：![](https://cdn.nlark.com/yuque/0/2022/png/396745/1650959714817-26483b79-36e8-4c5e-b5f2-22ab6210261d.png#clientId=u599aaf1f-e505-4&from=paste&id=u30d9e849&originHeight=257&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8c8781dd-62f5-444a-8a23-a2d525fff29&title=)
<a name="ZQ6Mf"></a>
### 2、加锁排队执行
Java 中有两种锁：`synchronized` 同步锁和 `ReentrantLock` 可重入锁。
<a name="UZ8bX"></a>
#### 2.1 同步锁`synchronized`
`synchronized` 是 JVM 层面实现的自动加锁和自动释放锁的同步锁，它的实现代码如下：
```java
public class SynchronizedExample {
    // 全局变量
    private static int number = 0;
    // 循环次数(100W)
    private static final int COUNT = 1_000_000;

    public static void main(String[] args) throws InterruptedException {
        // 线程1：执行 100W 次 ++ 操作
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < COUNT; i++) {
                // 加锁排队执行
                synchronized (SynchronizedExample.class) {
                    number++;
                }
            }
        });
        t1.start();

        // 线程2：执行 100W 次 -- 操作
        Thread t2 = new Thread(() -> {
            for (int i = 0; i < COUNT; i++) {
                // 加锁排队执行
                synchronized (SynchronizedExample.class) {
                    number--;
                }
            }
        });
        t2.start();

        // 等待线程 1 和线程 2，执行完，打印 number 最终的结果
        t1.join();
        t2.join();
        System.out.println("number 最终结果：" + number);
    }
}
```
以上程序的执行结果如下图所示：![](https://cdn.nlark.com/yuque/0/2022/png/396745/1650959714700-04ccc642-7be0-4efb-9aa1-7f2cec52e9a6.png#clientId=u599aaf1f-e505-4&from=paste&id=u05e5d2e8&originHeight=254&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2e5bc3cc-0002-48c0-bd66-83c1fbedbf6&title=)
<a name="ozJls"></a>
#### 2.2 可重入锁`ReentrantLock`
`ReentrantLock` 可重入锁需要程序员自己加锁和释放锁，它的实现代码如下：
```java
import java.util.concurrent.locks.ReentrantLock;

/**
 * 使用 ReentrantLock 解决非线程安全问题
 */
public class ReentrantLockExample {
    // 全局变量
    private static int number = 0;
    // 循环次数(100W)
    private static final int COUNT = 1_000_000;
    // 创建 ReentrantLock
    private static ReentrantLock lock = new ReentrantLock();

    public static void main(String[] args) throws InterruptedException {
        // 线程1：执行 100W 次 ++ 操作
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < COUNT; i++) {
                lock.lock();    // 手动加锁
                number++;       // ++ 操作
                lock.unlock();  // 手动释放锁
            }
        });
        t1.start();

        // 线程2：执行 100W 次 -- 操作
        Thread t2 = new Thread(() -> {
            for (int i = 0; i < COUNT; i++) {
                lock.lock();    // 手动加锁
                number--;       // -- 操作
                lock.unlock();  // 手动释放锁
            }
        });
        t2.start();

        // 等待线程 1 和线程 2，执行完，打印 number 最终的结果
        t1.join();
        t2.join();
        System.out.println("number 最终结果：" + number);
    }
}
```
以上程序的执行结果如下图所示：![](https://cdn.nlark.com/yuque/0/2022/png/396745/1650959714787-e6aed570-d52e-4d6d-b9dd-0632ac02ac96.png#clientId=u599aaf1f-e505-4&from=paste&id=uc5062676&originHeight=260&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u54f1b1db-354f-4615-abc1-c997da01551&title=)
<a name="dtRrX"></a>
### 3、线程本地变量`ThreadLocal`
使用 `ThreadLocal` 线程本地变量也可以解决线程安全问题，它是给每个线程独自创建了一份属于自己的私有变量，不同的线程操作的是不同的变量，所以也不会存在非线程安全的问题，它的实现代码如下：
```java
public class ThreadSafeExample {
    // 创建 ThreadLocal（设置每个线程中的初始值为 0）
    private static ThreadLocal<Integer> threadLocal = ThreadLocal.withInitial(() -> 0);
    // 全局变量
    private static int number = 0;
    // 循环次数(100W)
    private static final int COUNT = 1_000_000;

    public static void main(String[] args) throws InterruptedException {
        // 线程1：执行 100W 次 ++ 操作
        Thread t1 = new Thread(() -> {
            try {
                for (int i = 0; i < COUNT; i++) {
                    // ++ 操作
                    threadLocal.set(threadLocal.get() + 1);
                }
                // 将 ThreadLocal 中的值进行累加
                number += threadLocal.get();
            } finally {
                threadLocal.remove(); // 清除资源，防止内存溢出
            }
        });
        t1.start();

        // 线程2：执行 100W 次 -- 操作
        Thread t2 = new Thread(() -> {
            try {
                for (int i = 0; i < COUNT; i++) {
                    // -- 操作
                    threadLocal.set(threadLocal.get() - 1);
                }
                // 将 ThreadLocal 中的值进行累加
                number += threadLocal.get();
            } finally {
                threadLocal.remove(); // 清除资源，防止内存溢出
            }
        });
        t2.start();

        // 等待线程 1 和线程 2，执行完，打印 number 最终的结果
        t1.join();
        t2.join();
        System.out.println("最终结果：" + number);
    }
}
```
以上程序的执行结果如下图所示：![](https://cdn.nlark.com/yuque/0/2022/png/396745/1650959714772-67bf9be3-4f1e-41e5-a9f0-1f1413ee05f1.png#clientId=u599aaf1f-e505-4&from=paste&id=u22517bf0&originHeight=269&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1a1da67e-9832-459a-91ae-c14621cdac7&title=)
<a name="YfeEG"></a>
## 总结
在 Java 中，解决线程安全问题的手段有 3 种：

1. 使用线程安全的类，如 `AtomicInteger` 类；
2. 使用锁 `synchronized` 或 `ReentrantLock` 加锁排队执行；
3. 使用线程本地变量 ThreadLocal 来处理。
