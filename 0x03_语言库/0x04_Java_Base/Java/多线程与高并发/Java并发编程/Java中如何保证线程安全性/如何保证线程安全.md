Java 线程安全
<a name="tIxRC"></a>
## 一、线程安全等级
一般常说某某类是线程安全的，某某是非线程安全的。其实线程安全并不是一个“非黑即白”单项选择题。<br />按照“线程安全”的安全程度由强到弱来排序，可以将java语言中各种操作共享的数据分为以下5类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。<br />![](https://cdn.nlark.com/yuque/0/2022/webp/396745/1642725231841-51873e35-c504-41cf-956d-caea0478f42a.webp#clientId=u764f2afd-4332-4&from=paste&id=ubc6a8c93&originHeight=387&originWidth=577&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u25717beb-e1f0-4c07-9326-c0cb96baf59&title=)
<a name="PLy5L"></a>
### 1、不可变
在java语言中，不可变的对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再采取任何的线程安全保障措施。如`final`关键字修饰的数据不可修改，可靠性最高。
<a name="f2Fkw"></a>
### 2、绝对线程安全
绝对的线程安全完全满足Brian GoetZ给出的线程安全的定义，这个定义其实是很严格的，一个类要达到“不管运行时环境如何，调用者都不需要任何额外的同步措施”通常需要付出很大的代价。
<a name="jBy4Z"></a>
### 3、相对线程安全
相对线程安全就是通常意义上所讲的一个类是“线程安全”的。<br />它需要保证对这个对象单独的操作是线程安全的，在调用的时候不需要做额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。<br />在java语言中，大部分的线程安全类都属于相对线程安全的，例如Vector、HashTable、Collections的`synchronizedCollection()`方法保证的集合。
<a name="BSIKg"></a>
### 4、线程兼容
线程兼容就是通常意义上所讲的一个类不是线程安全的。<br />线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境下可以安全地使用。Java API中大部分的类都是属于线程兼容的。如与前面的Vector和HashTable相对应的集合类ArrayList和HashMap等。
<a name="OUKAS"></a>
### 5、线程对立
线程对立是指无论调用端是否采取了同步错误，都无法在多线程环境中并发使用的代码。由于java语言天生就具有多线程特性，线程对立这种排斥多线程的代码是很少出现的。<br />一个线程对立的例子是Thread类的supend()和resume()方法。如果有两个线程同时持有一个线程对象，一个尝试去中断线程，另一个尝试去恢复线程，如果并发进行的话，无论调用时是否进行了同步，目标线程都有死锁风险。正因此如此，这两个方法已经被废弃啦。
<a name="lWALp"></a>
## 二、线程安全的实现方法
保证线程安全以是否需要同步手段分类，分为同步方案和无需同步方案。<br />![](https://cdn.nlark.com/yuque/0/2022/webp/396745/1642725231918-f377e604-9545-4476-8d88-13b170ad4559.webp#clientId=u764f2afd-4332-4&from=paste&id=ubed7f41d&originHeight=272&originWidth=628&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u9d52132f-779a-4efe-9227-dd2c768b48b&title=)
<a name="w0Zj5"></a>
### 1、互斥同步
互斥同步是最常见的一种并发正确性保障手段。同步是指在多线程并发访问共享数据时，保证共享数据在同一时刻只被一个线程使用（同一时刻，只有一个线程在操作共享数据）。<br />而互斥是实现同步的一种手段，临界区、互斥量和信号量都是主要的互斥实现方式。因此，在这4个字里面，互斥是因，同步是果；互斥是方法，同步是目的。<br />在java中，最基本的互斥同步手段就是`synchronized`关键字，`synchronized`关键字编译之后，会在同步块的前后分别形成`monitorenter`和`monitorexit`这两个字节码质量，这两个字节码指令都需要一个reference类型的参数来指明要锁定和解锁的对象。<br />此外，ReentrantLock也是通过互斥来实现同步。在基本用法上，`ReentrantLock`与`synchronized`很相似，他们都具备一样的线程重入特性。<br />互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能问题，因此这种同步也成为阻塞同步。从处理问题的方式上说，互斥同步属于一种悲观的并发策略，总是认为只要不去做正确地同步措施（例如加锁），那就肯定会出现问题，无论共享数据是否真的会出现竞争，它都要进行加锁。
<a name="EmLS5"></a>
### 2、非阻塞同步
随着硬件指令集的发展，出现了基于冲突检测的乐观并发策略，通俗地说，就是先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，那就再采用其他的补偿措施。（最常见的补偿错误就是不断地重试，直到成功为止），这种乐观的并发策略的许多实现都不需要把线程挂起，因此这种同步操作称为非阻塞同步。<br />非阻塞的实现CAS（compareandswap）：CAS指令需要有3个操作数，分别是内存地址（在java中理解为变量的内存地址，用V表示）、旧的预期值（用A表示）和新值（用B表示）。<br />CAS指令执行时，CAS指令指令时，当且仅当V处的值符合旧预期值A时，处理器用B更新V处的值，否则它就不执行更新，但是无论是否更新了V处的值，都会返回V的旧值，上述的处理过程是一个原子操作。<br />CAS缺点：<br />ABA问题：因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。<br />ABA问题的解决思路就是使用版本号。在变量前面追加版本号，每次变量更新的时候把版本号加一，那么A-B-A就变成了1A-2B-3C。JDK的atomic包里提供了一个类`AtomicStampedReference`来解决ABA问题。<br />这个类的`compareAndSet`方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。
<a name="UCAIm"></a>
### 3、无需同步方案
要保证线程安全，并不是一定就要进行同步，两者没有因果关系。同步只是保证共享数据争用时的正确性的手段，如果一个方法本来就不涉及共享数据，那它自然就无需任何同步操作去保证正确性，因此会有一些代码天生就是线程安全的。
<a name="cBNUK"></a>
#### 1）可重入代码
可重入代码（ReentrantCode）也称为纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码，而在控制权返回后，原来的程序不会出现任何错误。所有的可重入代码都是线程安全的，但是并非所有的线程安全的代码都是可重入的。<br />可重入代码的特点是不依赖存储在堆上的数据和公用的系统资源、用到的状态量都是由参数中传入、不调用 非可重入的方法等。<br />（类比：`synchronized`拥有锁重入的功能，也就是在使用`synchronized`时，当一个线程得到一个对象锁后，再次请求此对象锁时时可以再次得到该对象的锁）
<a name="mQwv7"></a>
#### 2）线程本地存储
如果一段代码中所需的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行？如果能保证，就可以把共享数据的可见范围限制在同一个线程之内。这样无需同步也能保证线程之间不出现数据的争用问题。<br />符合这种特点的应用并不少见，大部分使用消费队列的架构模式（如“生产者-消费者”模式）都会将产品的消费过程尽量在一个线程中消费完。<br />其中最重要的一个应用实例就是经典的Web交互模型中的“一个请求对应一个服务器线程（Thread-per-Request）”的处理方式，这种处理方式的广泛应用使得很多Web服务器应用都可以使用线程本地存储来解决线程安全问题。
