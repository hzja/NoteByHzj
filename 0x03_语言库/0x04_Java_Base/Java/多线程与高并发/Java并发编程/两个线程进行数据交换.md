Java
<a name="PsUyl"></a>
## Exchanger 简介
Exchanger 就是线程之间的数据交换器，只能用于两个线程之间的数据交换。<br />Exchanger 提供了两个公开方法：<br />![2022-06-10-15-40-40-162069.png](https://cdn.nlark.com/yuque/0/2022/png/396745/1654846870828-33eb1b65-a223-4c8c-b2da-21af6aec4c9d.png#clientId=ucfecffdd-7fa7-4&from=ui&id=ua57895cb&originHeight=280&originWidth=552&originalType=binary&ratio=1&rotation=0&showTitle=false&size=464791&status=done&style=shadow&taskId=ub2ab2b47-37a1-49ed-9418-9d25fe48068&title=)<br />1、只带泛型 V（交换的数据对象）的方法，线程一直阻塞，直到其他任意线程和它交换数据，或者被线程中断。<br />2、另外一个带时间的方法，如果超过设置时间还没有线程和它交换数据，就会抛出 `TimeoutException` 异常；
<a name="XFXP0"></a>
## Exchanger 实战
<a name="FdivP"></a>
### 简单数据交换
来一个两个线程正常数据交换的简单示例：
```java
private static void test1() {
	Exchanger exchanger = new Exchanger();
	
	new Thread(() -> {
		try {
			Object data = "-AAA";
			System.out.println(Thread.currentThread().getName() + data);
			
			// 开始交换数据
			data = exchanger.exchange(data);
			System.out.println(Thread.currentThread().getName() + data);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}).start();
	
	new Thread(() -> {
		try {
			Object data = "-BBB";
			System.out.println(Thread.currentThread().getName() + data);
			
			// 开始交换数据
			data = exchanger.exchange(data);
			System.out.println(Thread.currentThread().getName() + data);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}).start();
}
```
**这段代码的逻辑：**<br />1、创建并启动两个线程；<br />2、进行数据交换前先打印出自己线程的数据；<br />3、进行数据交换；<br />4、打印数据交换之后的数据；<br />**输出结果：**<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/396745/1654847025155-7be84c5a-bc03-41ac-bc67-58935502648a.png#clientId=ucfecffdd-7fa7-4&from=paste&height=246&id=uc0cb3bfb&originHeight=614&originWidth=1794&originalType=binary&ratio=1&rotation=0&showTitle=false&size=59294&status=done&style=shadow&taskId=ub14aa185-5465-4b45-92ec-7dbc75d988b&title=&width=717.6)<br />从结果可以看出，线程 0、1 分别先打印出 A、B，数据交换之后，打印出了 B、A，数据交换正常！
<a name="sjZWj"></a>
### 超时数据交换
上面演示了两个线程的正常交换，下面再来一个带超时的示例：
```java
private static void test2() {
    Exchanger exchanger = new Exchanger();

    new Thread(() -> {
        try {
            Object data = "-AAA";
            System.out.println(Thread.currentThread().getName() + data);

            // 开始交换数据
            data = exchanger.exchange(data, 3000L, TimeUnit.MILLISECONDS);
            System.out.println(Thread.currentThread().getName() + data);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }).start();
}
```
现在只启动了一个线程，并且设置了超时时间 3 秒。<br />首先线程输出了自己的数据，然后 3 秒后，并没有其他线程和它交换数据，所以抛出了超时异常，最后线程结束运行。
<a name="SxQ0E"></a>
### 中断数据交换
线程开始交换数据后，会一直阻塞直到其他任意线程和它交换数据，或者被中断、超时，上面演示了超时，下面这个示例演示一下中断。
```java
private static void test3() {
    Exchanger exchanger = new Exchanger();

    new Thread(() -> {
        try {
            Object data = "-AAA";
            System.out.println(Thread.currentThread().getName() + data);

            // 开始交换数据
            data = exchanger.exchange(data);
            System.out.println(Thread.currentThread().getName() + data);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }).start();
}
```
默认情况下不带超时设置会一直阻塞运行中……<br />现在再加入一段中断的逻辑：
```java
private static void test3() throws InterruptedException {
    Exchanger exchanger = new Exchanger();

    Thread thread = new Thread(() -> {
        try {
            Object data = "-AAA";
            System.out.println(Thread.currentThread().getName() + data);

            // 开始交换数据
            data = exchanger.exchange(data);
            System.out.println(Thread.currentThread().getName() + data);
        } catch (Exception e) {
            e.printStackTrace();
        }
    });

    thread.start();

    // 线程中断
    Thread.sleep(3000L);
    thread.interrupt();
}
```
主线程休眠 3 秒后，中断该线程。<br />输出结果：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/396745/1654847709034-4602f945-cfe6-4a2e-8536-fb9eb8ef5510.png#clientId=ucfecffdd-7fa7-4&from=paste&height=97&id=uf9f12ea5&originHeight=242&originWidth=2240&originalType=binary&ratio=1&rotation=0&showTitle=false&size=72977&status=done&style=shadow&taskId=ub82541e6-a39c-4e58-9dd5-a08f6974e01&title=&width=896)<br />输出结果 3 秒后，线程被中断了，抛出了中断异常，线程也停止阻塞，最后线程结束运行。
<a name="lZZQs"></a>
### 两两数据交换
另外需要知道是，Exchanger 只能用于两个线程之间的数据交换，一个线程开启数据交换之后，会阻塞直到其他任意线程同样开启数据交换达到交换点。<br />最后来个示例，开启 10 个线程，看它们是怎么两两交换的：
```java
private static void test4() {
    Exchanger exchanger = new Exchanger();

    for (int i = 1; i <= 10; i++) {
        Integer data = i;
        new Thread(() -> {
            try {
                Object exchange = exchanger.exchange(data);
                System.out.println(Thread.currentThread().getName() + "-" + exchange);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "Java" + i).start();
    }
}
```
输出结果：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/396745/1654847764863-183bc2e0-2047-4f68-876d-c568f7ed8a6b.png#clientId=ucfecffdd-7fa7-4&from=paste&height=331&id=uf88657d0&originHeight=828&originWidth=1864&originalType=binary&ratio=1&rotation=0&showTitle=false&size=82518&status=done&style=shadow&taskId=ud1fa2551-c777-47fb-addd-984838e044a&title=&width=745.6)<br />可以看到，10 个线程，都两两交换彼此的数据了。
