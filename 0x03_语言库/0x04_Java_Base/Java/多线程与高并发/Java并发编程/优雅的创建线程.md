Java线程<br />这里整理了 RocketMQ 源码中创建线程的几点技巧。<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1678064451709-36a1a92b-0bd3-4337-bae6-72266671bb62.png#averageHue=%23f8f6f5&clientId=u68d76e5b-ef14-4&from=paste&id=u0ed0fc5d&originHeight=299&originWidth=293&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=uf3ffa74a-a3f5-4850-a6ab-2309a5fc5a4&title=)
<a name="raKvI"></a>
## 1、创建单线程
首先温习下常用的创建单线程的两种方式：

- 实现 Runnable 接口
- 继承 Thread 类
<a name="QG4p2"></a>
### ▍一、实现 Runnable 接口
![](https://cdn.nlark.com/yuque/0/2023/png/396745/1678064451717-5bf1d6c0-1354-43d1-9fe1-65eaea69c186.png#averageHue=%232b383f&clientId=u68d76e5b-ef14-4&from=paste&id=uda23617b&originHeight=429&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u59e13a7e-a9f3-4e39-9e57-d922e811a5f&title=)<br />图中，MyRunnable 类实现了 Runnable 接口的 run 方法，run 方法中定义具体的任务代码或处理逻辑，而Runnable 对象是作为线程构造函数的参数。
<a name="xHoBE"></a>
### ▍二、 继承 Thread 类
![](https://cdn.nlark.com/yuque/0/2023/png/396745/1678064451728-5bc5ee36-bb3a-4708-b964-49d5b2c44ce5.png#averageHue=%232b383f&clientId=u68d76e5b-ef14-4&from=paste&id=u02688487&originHeight=429&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u26f03223-e57e-45c6-b82d-dd349009bcc&title=)<br />线程实现类直接继承 Thread ，本质上也是实现 Runnable 接口的 run 方法。
<a name="mfeKP"></a>
## 2、单线程抽象类
创建单线程的两种方式都很简单，但每次创建线程代码显得有点冗余，于是 RocketMQ 里实现了一个抽象类 ServiceThread 。<br />![抽象类 ServiceThread](https://cdn.nlark.com/yuque/0/2023/png/396745/1678064451772-fa6c22c2-d28a-4c0b-91ae-094220d77af8.png#averageHue=%2329353b&clientId=u68d76e5b-ef14-4&from=paste&id=BDCMi&originHeight=1073&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=ufc1e4fe3-586a-4ec3-9389-c7c9aed07c4&title=%E6%8A%BD%E8%B1%A1%E7%B1%BB%20ServiceThread "抽象类 ServiceThread")抽象类 ServiceThread<br />可以看到抽象类中包含了如下核心方法：

1. 定义线程名；
2. 启动线程；
3. 关闭线程。

下图展示了 RocketMQ 众多的单线程实现类。<br />![](https://cdn.nlark.com/yuque/0/2023/jpeg/396745/1678064451700-955365fc-e76a-4ed9-8c12-5078e461ed93.jpeg#averageHue=%23393d38&clientId=u68d76e5b-ef14-4&from=paste&id=u57b6e560&originHeight=570&originWidth=1000&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=uab03389a-4dd7-44f2-a23c-37a89833649&title=)<br />实现类的编程模版类似 ：<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1678064452129-51715dc8-06fb-4fa6-b145-19e2e93f0554.png#averageHue=%232a373d&clientId=u68d76e5b-ef14-4&from=paste&id=ud4eddc7c&originHeight=729&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u72567a84-7860-4bba-a101-2824db092c5&title=)<br />仅仅需要继承抽象类，并实现 **getServiceName** 和 **run** 方法即可。启动的时候，调用 **start** 方法 ， 关闭的时候调用 **shutdown** 方法。
<a name="zM4PH"></a>
## 3、线程池原理
线程池是一种基于池化思想管理线程的工具，线程池维护着多个线程，等待着监督管理者分配可并发执行的任务。这避免了在处理短时间任务时创建与销毁线程的代价。线程池不仅能够保证内核的充分利用，还能防止过分调度。<br />JDK中提供的 **ThreadPoolExecutor** 类，是最常使用的线程池类。<br />![ThreadPoolExecutor构造函数](https://cdn.nlark.com/yuque/0/2023/png/396745/1678064452214-9ad20855-0226-41bf-a34b-3e8ed881be1a.png#averageHue=%232d3a42&clientId=u68d76e5b-ef14-4&from=paste&id=u367346e9&originHeight=852&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=u77415f48-eab5-4077-80c2-dd87ae30dd5&title=ThreadPoolExecutor%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0 "ThreadPoolExecutor构造函数")

| 参数名 | 作用 |
| --- | --- |
| corePoolSize | 队列没满时，线程最大并发数 |
| maximumPoolSizes | 队列满后线程能够达到的最大并发数 |
| keepAliveTime | 空闲线程过多久被回收的时间限制 |
| unit | keepAliveTime 的时间单位 |
| workQueue | 阻塞的队列类型 |
| threadPoolFactory | 改变线程的名称、线程组、优先级、守护进程状态 |
| RejectedExecutionHandler | 超出 maximumPoolSizes + workQueue 时，任务会交给RejectedExecutionHandler来处理 |

![](https://cdn.nlark.com/yuque/0/2023/png/396745/1678064452158-60988fcb-49f1-45ca-b0d2-b6cb626a3dda.png#averageHue=%232b383f&clientId=u68d76e5b-ef14-4&from=paste&id=uf8be71c3&originHeight=1378&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u1f1553ea-df59-488a-9a75-2e83ae1bc13&title=)<br />任务的调度通过执行 `execute`方法完成，方法的核心流程如下：

1. 如果 workerCount < corePoolSize，创建并启动一个线程来执行新提交的任务。
2. 如果 workerCount >= corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中。
3. 如果 workerCount >= corePoolSize && workerCount < maximumPoolSize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务。
4. 如果 workerCount >= maximumPoolSize，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。

![](https://cdn.nlark.com/yuque/0/2023/png/396745/1678064452305-928ca3cc-07eb-4626-b843-63471259d303.png#averageHue=%23faf7f4&clientId=u68d76e5b-ef14-4&from=paste&id=uafa8e14c&originHeight=421&originWidth=579&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=ua6ddab21-37e2-41ad-9772-03e6ee0bef0&title=)
<a name="LmwDP"></a>
## 4、线程池封装
在 RocketMQ 里 ，网络请求都会携带命令编码，每种命令映射对应的处理器，而处理器又会注册对应的线程池。<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1678064452528-beeb03e4-41b0-4d7d-90bc-219363735c93.png#averageHue=%232d3943&clientId=u68d76e5b-ef14-4&from=paste&id=u07726945&originHeight=304&originWidth=951&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u3fe1dd85-014e-42f8-a497-adb29a8a61b&title=)<br />当服务端 Broker 接收到发送消息命令时，都会有单独的线程池 sendMessageExecutor 来处理这种命令请求。<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1678064452625-5b694aaf-9967-4dae-aef4-e3473550020d.png#averageHue=%232c3942&clientId=u68d76e5b-ef14-4&from=paste&id=u45fb4586&originHeight=443&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=ud73764e6-4113-4257-b0cc-9541035b8dd&title=)<br />基于 ThreadPoolExecutor 做了一个简单的封装 ，BrokerFixedThreadPoolExecutor 构造函数包含六个核心参数：

1. 核心线程数和最大线程数相同 ，数量是：cpu核数和4比较后的最小值；
2. 空闲线程的回收的时间限制，默认1分钟；
3. 发送消息队列，有界队列，默认10000；
4. 线程工厂 `ThreadFactoryImpl` ，定义了线程名前缀：`SendMessageThread_` 。

RocketMQ 实现了一个简单的线程工厂：`**ThreadFactoryImpl**`，线程工厂可以定义线程名称，以及是否是守护线程 。<br />![线程工厂](https://cdn.nlark.com/yuque/0/2023/png/396745/1678064452727-4134d4b6-a7ea-443c-a079-868fa99bbaa2.png#averageHue=%232b383f&clientId=u68d76e5b-ef14-4&from=paste&id=AUn0h&originHeight=619&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=udb29af09-bddb-4d36-8d69-f16bcc5fa33&title=%E7%BA%BF%E7%A8%8B%E5%B7%A5%E5%8E%82 "线程工厂")<br />开源项目 Cobar ，Xmemcached，Metamorphosis 中都有类似线程工厂的实现 。
<a name="RIY3N"></a>
## 5、线程名很重要
**线程名很重要，线程名很重要，线程名很重要** ，重要的事情说三遍。<br />可以看到 RocketMQ 中，无论是单线程抽象类还是多线程的封装都会配置线程名 ，因为通过线程名，非常容易定位问题，从而大大提升解决问题的效率。<br />定位的媒介常见有两种：**日志文件**和**堆栈记录**。
<a name="YX2SZ"></a>
### ▍一、日志文件
经常处理业务问题的同学，一定都经常与日志打交道。<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1678064452908-9ba82dd4-2abe-4bc6-8d1b-f858247f8f9f.png#averageHue=%232e3b46&clientId=u68d76e5b-ef14-4&from=paste&id=uf6a2c61c&originHeight=87&originWidth=987&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=ubf4d9ca8-8986-45cd-82b9-0267f3b64e9&title=)

- 查看 ERROR 日志，追溯到执行线程， 要是线程池隔离做的好，基本可以判断出哪种业务场景出了问题；
- 通过查看线程打印的日志，推断线程调度是否正常，比如有的定时任务线程打印了开始，没有打印结束，推论当前线程可能已经挂掉或者阻塞。
<a name="cFWaM"></a>
### ▍二、堆栈记录
jstack 是 java 虚拟机自带的一种堆栈跟踪工具 ，主要用来查看 Java 线程的调用堆栈，线程快照包含当前 java 虚拟机内每一条线程正在执行的方法堆栈的集合，可以用来分析线程问题。
```bash
jstack -l 进程pid
```
![](https://cdn.nlark.com/yuque/0/2023/png/396745/1678064452864-7f95caa9-e551-47bb-8f40-d2fb882a22bb.png#averageHue=%232c3841&clientId=u68d76e5b-ef14-4&from=paste&id=u5549fde3&originHeight=736&originWidth=982&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u2d55ebe6-1424-41b1-9641-36cd7de604e&title=)<br />查看线程堆栈，一般关注如下几点：

1. 当前 jvm 进程中的线程数量和线程分类是否在预期的范围内；
2. 系统接口超时或者定时任务停止的异常场景下 ，分析堆栈中是否有锁未释放，或者线程一直等待网络通讯响应；
3. 分析 jvm 进程中哪个线程占用的 CPU 最高。
<a name="Lr0DR"></a>
## 6、总结
RocketMQ 源码里创建线程的技巧。

1. 单线程抽象类 ServiceThread使用者只需要实现业务逻辑以及定义线程名即可 ，不需要写冗余的代码。
2. 线程池封装适当封装，定义线程工厂，并合理配置线程池参数。
3. 线程名很重要文件日志，堆栈记录配合线程名能大大提升解决问题的效率。

RocketMQ 的多线程编程技巧很多，比如线程通讯，并发控制，线程模型等等
