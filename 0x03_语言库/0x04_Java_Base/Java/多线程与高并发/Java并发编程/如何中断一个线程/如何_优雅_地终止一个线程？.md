Java<br />系统中有些线程为了保证业务需要是要常驻后台的，一般它们不会自己终止，需要通过手动来终止它们。都知道启动一个线程是`start`方法，自然有一个对应的终止线程的`stop`方法，通过`stop`方法可以很快速、方便地终止一个线程，来看看`stop`的源代码。<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/396745/1654848572851-74c708ee-cb9a-48ca-b0d6-bb02399cef0b.png#clientId=u72682546-dfff-4&from=paste&height=431&id=u2f197e65&originHeight=1078&originWidth=2695&originalType=binary&ratio=1&rotation=0&showTitle=false&size=219566&status=done&style=shadow&taskId=ub1d7d3d6-b95d-4189-a592-0bc52d2b36d&title=&width=1078)<br />通过注解`@Deprecated`可以看出`stop`方法被标为废弃的方法，jdk在以后的版本中可能被移除，不建议大家使用这种API。<br />那为什么这么好的一个方法怎么不推荐使用，还要标注为废弃呢？<br />假设有这样的一个业务场景，一个线程正在处理一个复杂的业务流程，突然间线程被调用stop而意外终止，这个业务数据还有可能是一致的吗？这样是肯定会出问题的，stop会释放锁并强制终止线程，造成执行一半的线程终止，带来的后果也是可想而知的，这就是为什么jdk不推荐使用stop终止线程的方法的原因，因为它很暴力会带来数据不一致性的问题。<br />正因为stop方法太过暴力，所以一般不推荐使用，除非非常清楚自己的业务场景，用stop终止不会给业务带来影响。<br />说了这么多，那如何优雅地终止一个线程呢？看看下面的程序。
```java
public class TaskThread extends Thread {
    private static volatile boolean stop = false;
    @Override
    public void run() {
        while (!stop) {
            // ...
            // ...
        }
    }
    public static void main(String[] args) throws InterruptedException {
        TaskThread thread = new TaskThread();
        thread.start();
        Thread.sleep(1000);
        stop = true;
    }
}
```
其实也不难，只需要添加一个变量，判断这个变量在某个值的时候就退出循环，这时候每个循环为一个整合不被强行终止就不会影响单个业务的执行结果。
