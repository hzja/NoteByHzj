Java
<a name="pPkty"></a>
## 基本概念
在 Java 中通常有两种线程：守护线程（Daemon Thread）和用户线程（User Thread）<br />守护线程：是一种特殊的线程，在后台默默地完成一些系统性的服务，比如垃圾回收线程、JIT 线程都是守护线程<br />用户线程：可以理解为是系统的工作线程，它会完成这个程序需要完成的业务操作。如使用 Thread 创建的线程在默认情况下都属于用户线程
<a name="Dv5rL"></a>
## 怎样使线程成为用户线程与守护线程

- 通过 `Thread.setDaemon(false)` 设置为用户线程
- 通过 `Thread.setDaemon(true)` 设置为守护线程
- 如果不设置线程属性，那么默认为用户线程

线程属性的设置要在线程启动之前，否则会报 `IllegalThreadStateException` 异常
<a name="f3tkz"></a>
## 守护线程与用户线程的区别
<a name="gJIJP"></a>
### 用户线程
```java
public class UserThread {

    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(() -> {
            while (true) {
                try {
                    Thread.sleep(1000);
                    System.out.println("我是用户线程......");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });
        thread.start();

        Thread.sleep(3000);
        System.out.println("主线程执行完毕......");
    }
}
```
运行上面代码，结果如下<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/396745/1692540401585-3f2000c1-e2cb-498d-9710-3518aea27cf2.png#averageHue=%23f9f9f9&clientId=u8e812d4a-ea0b-4&from=paste&height=288&id=u1d4adca2&originHeight=721&originWidth=1963&originalType=binary&ratio=2.5&rotation=0&showTitle=false&size=148424&status=done&style=none&taskId=uf1bce2e5-8c3f-4621-919c-61d32f7a59c&title=&width=785.2)<br />可以看到主线程已经结束了，但是程序无法退出；原因：用户线程的内部有个死循环，一直处于运行状态，无法结束
<a name="nzBHi"></a>
### 守护线程
```java
public class UserThread {

    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(() -> {
            while (true) {
                try {
                    Thread.sleep(1000);
                    System.out.println("我是用户线程......");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });
        // 设置为守护线程
        thread.setDaemon(true);
        thread.start();

        Thread.sleep(3000);
        System.out.println("主线程执行完毕......");
    }
}
```
运行上面代码，结果如下<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/396745/1692540505222-8200b63b-e19c-4581-b71d-7d9c6d6efd21.png#averageHue=%23fcfcfc&clientId=u8e812d4a-ea0b-4&from=paste&height=316&id=ufb1b10ea&originHeight=790&originWidth=2014&originalType=binary&ratio=2.5&rotation=0&showTitle=false&size=96156&status=done&style=none&taskId=u856f5e3b-e34e-4396-a689-2751c33cd26&title=&width=805.6)<br />程序可以正常结束了，代码中通过 `thread.setDaemon(true)` 将 thread 线程设置为守护线程，main 方法所在的主线程执行完毕之后，程序就退出了
<a name="tPg6o"></a>
## 区别
主线程结束后，用户线程还是会继续运行的，此时 JVM 是存活的<br />如果没有用户线程，都是守护线程，那么 JVM 结束，则所有的线程都会结束<br />如果用户线程全部结束了，意味着程序需要完成的业务操作已经结束了，系统可以退出了。所以当系统只剩下守护进程的时候，JVM 会自动退出的
<a name="JQJ3W"></a>
## 守护线程适用场景
针对于守护线程的特点，Java 守护线程通常可用于开发一些为其它用户线程服务的功能。比如说心跳检测，事件监听等。Java 中最有名的守护进程当属 GC 垃圾回收
<a name="eEvSx"></a>
## 总结
Java 中的线程分为用户线程和守护线程<br />程序中的所有的用户线程结束之后，不管守护线程处于什么状态，JVM 都会自动退出<br />调用线程的实例方法 `setDaemon()` 来设置线程是否是守护线程<br />`setDaemon()` 方法必须在线程的 `start()` 方法之前调用，在后面调用会报异常，并且不起效
