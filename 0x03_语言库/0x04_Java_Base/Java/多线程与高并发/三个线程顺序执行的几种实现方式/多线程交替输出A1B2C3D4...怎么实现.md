Java<br />两个线程依次交替输出A~Z，1到26，形如A1B2C3D4...
<a name="LKeUP"></a>
## 1、使用线程方法
`wait()`方法会使当前线程释放锁，并进入等待状态，直到以下情况之一发生：

1. 被其他线程调用`notify()`方法唤醒；
2. 被其他线程调用`notifyAll()`方法唤醒；
3. 被其他线程中断。

`notify()`方法用于唤醒一个正在等待的线程，使其从`wait()`方法中返回。<br />结合一个出让等待的机制，就这样交替实现。
```java
public class T06_00_sync_wait_notify {
    public static void main(String[] args) {
        final Object o = new Object();

        char[] aI = "1234567".toCharArray();
        char[] aC = "ABCDEFG".toCharArray();

        new Thread(()->{
            synchronized (o) {
                for(char c : aI) {
                    System.out.print(c);
                    try {
                        o.notify();
                        o.wait(); //让出锁
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }

                o.notify(); //必须，否则无法停止程序
            }

        }, "t1").start();

        new Thread(()->{
            synchronized (o) {
                for(char c : aC) {
                    System.out.print(c);
                    try {
                        o.notify();
                        o.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }

                o.notify();
            }
        }, "t2").start();
    }
}
```
**思考：**伙伴们，如果我想保证t2在t1之前打印，也就是说保证首先输出的是A而不是1，这个时候该如何做？
<a name="bVbYN"></a>
## 2、使用`CountDownLatch`铁门闩
`CountDownLatch`是Java多线程中的一个同步工具类，它可以让一个或多个线程等待其他线程完成操作后再继续执行。<br />具体来说，`CountDownLatch`有两个主要方法：

1. `await()`方法：调用该方法的线程会进入等待状态，直到计数器的值为0或者被中断；
2. `countDown()`方法：调用该方法会将计数器减1，当计数器的值为0时，会唤醒所有等待的线程。
```java
public class T07_00_sync_wait_notify {

    private static CountDownLatch latch = new CountDownLatch(1);

    public static void main(String[] args) {
        final Object o = new Object();



        char[] aI = "1234567".toCharArray();
        char[] aC = "ABCDEFG".toCharArray();

        new Thread(()->{
            try {
                latch.await();
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }

            synchronized (o) {
                for(char c : aI) {
                    System.out.print(c);
                    try {
                        o.notify();
                        o.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }

                o.notify();
            }
        }, "t1").start();

        new Thread(()->{

            synchronized (o) {
                for(char c : aC) {
                    System.out.print(c);
                    latch.countDown();
                    try {
                        o.notify();
                        o.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                o.notify();
            }
        }, "t2").start();
    }
}
```
<a name="tZNip"></a>
## 3、使用`ReentrantLock`
可以通过`ReentrantLock`获取条件锁，通过它提供的方法来实现。<br />具体来说，`ReentrantLock`的`Condition`接口提供了以下三个方法：

1. `await()`方法：当前线程进入等待状态，并释放锁，直到其他线程使用`signal()`或`signalAll()`方法唤醒它；
2. `signal()`方法：唤醒一个等待在该条件上的线程；
3. `signalAll()`方法：唤醒所有等待在该条件上的线程。
```java
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class T08_00_lock_condition {

    public static void main(String[] args) {

        char[] aI = "1234567".toCharArray();
        char[] aC = "ABCDEFG".toCharArray();

        Lock lock = new ReentrantLock();
        Condition condition = lock.newCondition();

        new Thread(()->{
            try {
                lock.lock();

                for(char c : aI) {
                    System.out.print(c);
                    condition.signal();
                    condition.await();
                }

                condition.signal();

            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
            }

        }, "t1").start();

        new Thread(()->{
            try {
                lock.lock();

                for(char c : aC) {
                    System.out.print(c);
                    condition.signal();
                    condition.await();
                }

                condition.signal();

            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
            }

        }, "t2").start();
    }
}
```
`Condition`本质是锁资源上不同的等待队列，也可以获取不同的等待队列来实现。
```java
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class T09_00_lock_condition {

    public static void main(String[] args) {

        char[] aI = "1234567".toCharArray();
        char[] aC = "ABCDEFG".toCharArray();

        Lock lock = new ReentrantLock();
        Condition conditionT1 = lock.newCondition();
        Condition conditionT2 = lock.newCondition();

        new Thread(()->{
            try {
                lock.lock();

                for(char c : aI) {
                    System.out.print(c);
                    conditionT2.signal();
                    conditionT1.await();
                }

                conditionT2.signal();

            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
            }

        }, "t1").start();

        new Thread(()->{
            try {
                lock.lock();

                for(char c : aC) {
                    System.out.print(c);
                    conditionT1.signal();
                    conditionT2.await();
                }

                conditionT1.signal();

            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
            }

        }, "t2").start();
    }
}
```
<a name="uank9"></a>
## 4、使用`TransferQueue`阻塞队列
`TransferQueue`是Java并发包中的一个阻塞队列，它可以用于多线程之间的数据交换和同步。<br />`LinkedTransferQueue`继承自`TransferQueue`，并且还可以支持异步操作。<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/396745/1690164640725-02c44894-357f-4287-bd2e-eaec720684dd.png#averageHue=%23f8f8f8&clientId=ud24ee687-7b3f-4&from=paste&height=562&id=u7083bd0a&originHeight=1406&originWidth=1452&originalType=binary&ratio=2.5&rotation=0&showTitle=false&size=100383&status=done&style=none&taskId=u9e73cd79-09e3-4b22-bbdd-31a900239d3&title=&width=580.8)<br />`LinkedTransferQueue`的`take()`方法和`transfer()`方法都是用于从队列中取出元素的方法，但它们的使用场景和行为有所不同。<br />`take()`方法是一个阻塞方法，它会一直阻塞直到队列中有可用元素，才将队列中的元素取出并返回。<br />`transfer()`方法也是一个阻塞方法，它会将指定的元素插入到队列中，并等待另一个线程从队列中取出该元素。如果队列中没有等待的线程，则当前线程会一直阻塞，直到有其他线程从队列中取走该元素为止。<br />那么就利用这一点它必须要另外一个线程来取进而实现把值交替输出。
```java
import java.util.concurrent.LinkedTransferQueue;
import java.util.concurrent.TransferQueue;

public class T13_TransferQueue {
    public static void main(String[] args) {
        char[] aI = "1234567".toCharArray();
        char[] aC = "ABCDEFG".toCharArray();

        TransferQueue<Character> queue = new LinkedTransferQueue<Character>();
        new Thread(()->{
            try {
                for (char c : aI) {
                    System.out.print(queue.take());
                    queue.transfer(c);
                }

            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "t1").start();

        new Thread(()->{
            try {
                for (char c : aC) {
                    queue.transfer(c);
                    System.out.print(queue.take());
                }

            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "t2").start();
    }
}
```
<a name="kBIEo"></a>
## 5、使用`LockSupport`
`LockSupport`是Java并发包中的一个工具类，它可以用于线程的阻塞和唤醒。<br />可以把它类比成Object的`wait()`和`notify()`方法，但`LockSupport`是比它们更加灵活和可控的。<br />`LockSupport`提供了`park()`和`unpark()`方法：<br />当一个线程调用`park()`方法时，它会被阻塞，直到另一个线程调用该线程的`unpark()`方法才会被唤醒。<br />如果调用`unpark()`方法时，该线程还没有调用`park()`方法，则该线程调用`park()`方法时不会被阻塞，可以直接返回。
```java
import java.util.concurrent.locks.LockSupport;

//Locksupport park 当前线程阻塞（停止）
//unpark(Thread t)

public class T02_00_LockSupport {
    static Thread t1 = null, t2 = null;

    public static void main(String[] args) throws Exception {
        char[] aI = "1234567".toCharArray();
        char[] aC = "ABCDEFG".toCharArray();

        t1 = new Thread(() -> {
            for(char c : aI) {
                System.out.print(c);
                LockSupport.unpark(t2); //叫醒T2
                LockSupport.park(); //T1阻塞
            }
        }, "t1");

        t2 = new Thread(() -> {
            for(char c : aC) {
                LockSupport.park(); //t2阻塞
                System.out.print(c);
                LockSupport.unpark(t1); //叫醒t1
            }
        }, "t2");
        t1.start();
        t2.start();
    }
}
```
<a name="fxxOs"></a>
## 6、使用枚举类作同步标志
创建一个枚举类`ReadyToRun`，利用`while(true)`死等和枚举类指向对象不同作标志位交替输出。
```java
public class T03_00_cas {

    enum ReadyToRun {T1, T2}

    static volatile ReadyToRun r = ReadyToRun.T1; 

    public static void main(String[] args) {

        char[] aI = "1234567".toCharArray();
        char[] aC = "ABCDEFG".toCharArray();

        new Thread(() -> {

            for (char c : aI) {
                while (r != ReadyToRun.T1) {}
                System.out.print(c);
                r = ReadyToRun.T2;
            }

        }, "t1").start();

        new Thread(() -> {

            for (char c : aC) {
                while (r != ReadyToRun.T2) {}
                System.out.print(c);
                r = ReadyToRun.T1;
            }
        }, "t2").start();
    }
}
```
