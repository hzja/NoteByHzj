Java Thread
<a name="GEoMp"></a>
## 使用`stop`方法
调用`stop()`方法，会让正在运行的线程直接中止，有可能会让一些清理性的工作得不到完成。并且`stop`已经被标记为废弃的方法，不建议使用。<br />正确的使用姿势是使用两阶段终止的模式，即一个线程发送终止指令，另一个线程接收指令，并且决定自己在何时停止。
<a name="aqSj3"></a>
## 使用标志位
```java
public class RunTask {
    private volatile boolean stopFlag;
    private Thread taskThread;
    public void start() {
        taskThread = new Thread(() -> {
            while (!stopFlag) {
                System.out.println("doSomething");
            }
        });
        taskThread.start();
    }
    public void stop() {
        stopFlag = true;
    }
}
```
**「**`**stopFlag**`**上加**`**volatile**`**是保证可见性。这个例子用了**`**while**`**循环不断判断，如果项目中用不到**`**while**`**的话，可以在关键节点判断，然后退出run方法即可」**
<a name="1uwoO"></a>
## 使用`interrupt`方法
假如任务中有阻塞的逻辑，如调用了`Thread.sleep()`方法，如何让线程停止呢？<br />从线程状态转换图中寻找答案<br />![640.webp](https://cdn.nlark.com/yuque/0/2021/webp/396745/1614042766581-f705bf25-03ee-4613-b720-de48fe566a2a.webp#height=471&id=uPxE8&originHeight=471&originWidth=953&originalType=binary&size=22146&status=done&style=shadow&width=953)<br />从图中可以看到如果想让线程进入终止状态的前提是这个线程处于运行状态。想要终止一个线程的时候，如果此时线程处于阻塞状态，如何把它转换到运行状态呢？<br />可以通过调用`Thread.interrupt()`方法，将阻塞状态的线程转换到就绪状态，进入由操作系统调度成运行状态，即可终止。<br />那线程在运行状态中调用interrupt方法，会发生什么呢？
```java
public class RunTaskCase1 {
    private Thread taskThread;
    public void start() {
        taskThread = new Thread(() -> {
            while (true) {
                System.out.println("doSomething");
            }
        });
        taskThread.start();
    }
    public void stop() {
        taskThread.interrupt();
    }
}
```
依次调用`start`方法和`stop`方法，发现线程并没有停止。<br />**「其实当线程处于运行状态时，**`**interrupt**`**方法只是在当前线程打了一个停止的标记，停止的逻辑需要自己去实现」**<br />**「Thread类提供了如下2个方法来判断线程是否是中断状态」**

1. `isInterrupted`
2. `interrupted`

这2个方法虽然都能判断状态，但是有细微的差别
```java
@Test
 public void testInterrupt() throws InterruptedException {
     Thread thread = new Thread(() -> {
         while (true) {}
     });
     thread.start();
     TimeUnit.MICROSECONDS.sleep(100);
     thread.interrupt();
     // true
     System.out.println(thread.isInterrupted());
     // true
     System.out.println(thread.isInterrupted());
     // true
     System.out.println(thread.isInterrupted());
 }
```
```java
@Test
 public void testInterrupt2() {
     Thread.currentThread().interrupt();
     // true
     System.out.println(Thread.interrupted());
     // false
     System.out.println(Thread.interrupted());
     // false
     System.out.println(Thread.interrupted());
 }
```
<a name="d98ea7a0"></a>
### `isInterrupted`和`interrupted`的方法区别
`Thread.isInterrupted`：测试线程是否是中断状态，执行后不更改状态标志 <br />`Thread.interrupted`：测试线程是否是中断状态，执行后将中断标志更改为false<br />**「所以此时不需要自已定义状态，直接用中断标志即可，之前的代码可以改为如下」**
```java
public class RunTaskCase2 {
    private Thread taskThread;
    public void start() {
        taskThread = new Thread(() -> {
            while (!Thread.currentThread().isInterrupted()) {
                System.out.println("doSomething");
            }
        });
        taskThread.start();
    }
    public void stop() {
        taskThread.interrupt();
    }
}
```
当线程处于阻塞状态时，调用`interrupt`方法，会抛出`InterruptedException`，也能终止线程的执行
:::danger
**「注意：发生异常时线程的中断标志为会由**`**true**`**更改为**`**false**`**。」**
:::
所以有如下实现 当线程处于运行状态：用自己定义的标志位来退出 当线程处于阻塞状态：用抛异常的方式来退出
```java
public class RunTaskCase3 {
    private volatile boolean stopFlag;
    private Thread taskThread;
    public void start() {
        taskThread = new Thread(() -> {
            while (stopFlag) {
                try {
                    System.out.println("doSomething");
                    TimeUnit.MICROSECONDS.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });
        taskThread.start();
    }
    public void stop() {
        stopFlag = true;
        taskThread.interrupt();
    }
}
```
当然也可以一直用中断标志来退出，
:::danger
**「注意，当发生异常的时候需要重置中断标志位」**。
:::
```java
public class RunTaskCase4 {
    private Thread taskThread;
    public void start() {
        taskThread = new Thread(() -> {
            while (!Thread.currentThread().isInterrupted()) {
                try {
                    System.out.println("doSomething");
                    TimeUnit.MICROSECONDS.sleep(100);
                } catch (InterruptedException e) {
                    // 重置中断标志位为true
                    Thread.currentThread().interrupt();
                    e.printStackTrace();
                }
            }
        });
        taskThread.start();
    }
    public void stop() {
        taskThread.interrupt();
    }
}
```
<a name="D6jZo"></a>
### 对比一下RunTaskCase3和RunTaskCase4哪种实现方式比较好呢？
:::success
**「虽然RunTaskCase4代码看起来更简洁，但是RunTaskCase4不建议使用，因为如果在run方法中调用了第三方类库，发生了InterruptedException异常，但是没有重置中断标志位，会导致线程一直运行下去，同理RunTaskCase2也不建议使用」**。
:::
