Java<br />像素图其实有点类似于类似于打马赛克的功能。通过像素的变化，演示一个像素画的功能。像素画在 NFT 中特别的流行。使用OpenCV来处理像素图。
<a name="xQtxT"></a>
### 准备工作
先引入 JavaCV 的依赖库
```xml
<dependency>
	<groupId>org.bytedeco</groupId>
	<artifactId>javacv-platform</artifactId>
	<version>1.5.6</version>
</dependency>
```
这种方式引入，会把javacv 所有包含的都引入进来。平时测试使用的时候，可以这样操作。但是到真实项目中，还是需要做一次精简才行。这里准备了一个图片。<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1646353372267-46a7663d-1758-407a-921c-dcb79258fe0e.png#clientId=uc1bb116f-83ba-4&from=paste&id=u0c4d996c&originHeight=1001&originWidth=1005&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6b0d6cc8-2284-4d99-b62c-6bba27c0500&title=)
<a name="ER5qV"></a>
### 代码实现
读取文件
```kotlin
val path ="path/to/img/"
val img = opencv_imgcodecs.imread(path + "meinv.jpeg")
```
获取原图的像素宽高，然后进行像素比缩放。
```kotlin
val size = img.size()
val height = size.height()
val width = size.width()

val pixelSize = 10

val newWidth = width / pixelSize
val newHeight = height / pixelSize
```
根据设定的像素比， 对原图进行缩小，再放大的两次 resize 操作。这样就完成了像素图的处理。
```kotlin
val imgTmp: Mat? = null
opencv_imgproc.resize(img, imgTmp, Size(newWidth, newHeight),0.0, 0.0, opencv_imgproc.INTER_NEAREST)
opencv_imgproc.resize(img, imgTmp, Size(width, height),0.0, 0.0, opencv_imgproc.INTER_NEAREST)
```
来看下处理过之后的图像效果吧<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1646353372254-e8a90406-7340-4370-9bfe-7617b1fbce6e.png#clientId=uc1bb116f-83ba-4&from=paste&id=ue28438b8&originHeight=493&originWidth=495&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u366ebbf7-892f-49a0-af36-0a2034302ae&title=)<br />效果看起来还可以，图片颜色单一图片尺寸稍微小一些的效果会好很多。
<a name="eclKH"></a>
### 完整代码
```kotlin
import org.bytedeco.opencv.global.opencv_highgui
import org.bytedeco.opencv.global.opencv_imgcodecs
import org.bytedeco.opencv.global.opencv_imgproc
import org.bytedeco.opencv.opencv_core.Mat
import org.bytedeco.opencv.opencv_core.Size

fun main(args: Array<String>) {

    val path = "path/to/img/"
    val img = opencv_imgcodecs.imread(path + "meinv.jpeg")

    val size = img.size()
    val height = size.height()
    val width = size.width()

    val pixelSize = 10

    val newWidth = width / pixelSize
    val newHeight = height / pixelSize

    val imgTmp: Mat? = null
    opencv_imgproc.resize(img, imgTmp, Size(newWidth, newHeight), 0.0, 0.0, opencv_imgproc.INTER_NEAREST)
    opencv_imgproc.resize(img, imgTmp, Size(width, height), 0.0, 0.0, opencv_imgproc.INTER_NEAREST)


    opencv_highgui.imshow("meinv", img);
    opencv_highgui.waitKey(0)

}
```
