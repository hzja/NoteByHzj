分布式定时任务
<a name="itlC9"></a>
## 一、单机指定时间执行定时任务实现方式
<a name="RJ05Q"></a>
### 1、Timer运行机制
![](https://cdn.nlark.com/yuque/0/2021/webp/396745/1640348266893-bb04ca23-2484-4329-bc3c-4f1635c62c39.webp#averageHue=%23b3d3a6&clientId=u3c240b6a-4330-4&from=paste&id=u19aadbee&originHeight=540&originWidth=960&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=u85b93af5-b345-4e64-aef0-e6e6b20ed48&title=)
<a name="rfOQR"></a>
### 2、`ScheduledThreadPoolExecutor`的运行机制
<a name="d9yI5"></a>
#### 1.原理图
![](https://cdn.nlark.com/yuque/0/2021/webp/396745/1640348266986-bde4758f-3086-400a-842a-d2a8cf1b40da.webp#averageHue=%23fbf5ee&clientId=u3c240b6a-4330-4&from=paste&id=uec5d9094&originHeight=540&originWidth=960&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=ub7eee315-c080-4a24-ab5f-236332552af&title=)
<a name="sr2Kd"></a>
#### 2.Leader/Follower模式
<a name="LFPJB"></a>
#### 3.`Timer`和`ScheduledThreadPoolExucutor`区别

- `Timer`是基于绝对时间，`ScheduledThreadPoolExucutor`基于相对时间
- `Timer`是单线程，`ScheduledThreadPoolExucutor`是多线程
- `Timer`运行发生异常，整个`TimerThread`崩溃，而`ScheduledThreadPoolExucutor`对异常进行捕获
<a name="Gnmuz"></a>
#### 4.自行实现指定时间执行的定时任务

- 建立数据库定时任务表，用户存入要执行的定时任务，业务ID
- 定义Producer类，用于生产指定定时任务，往延迟队列里写入数据，指定的毫秒时间戳
- 定义Consumer接口，自身业务可以通过实现Consumer接口消费队列中的数据
- 定义SpringBoot自启动方法，死循环从延迟队列中取最小时间戳数据，与当前时间进行对比如果小于则开始执行，休眠100ms继续下一次循环
<a name="JtImA"></a>
#### 5.Quartz实现
参考文档：[https://www.w3cschool.cn/quartz_doc/quartz_doc-2put2clm.html](https://www.w3cschool.cn/quartz_doc/quartz_doc-2put2clm.html)
<a name="sdw6J"></a>
## 二、分布式指定时间执行的定时任务实现方式（自行Redis实现）
<a name="FH0tc"></a>
### 流程设计分析

- 因为是应用是分布式部署，所以需要考虑分布式锁处理分布式一致性
- 使用Redis的有序集合（Sorted Set）将要执行任务的ID和毫秒时间戳ZAdd到有序集合中
- 使用SpringBoot的定时任务，定时1秒去执行消费定任务任务方法
- 消费方法加分布式锁，避免重复消息，通过死循环获取有序集合最小的时间戳与当前时间戳做对比，如果小于则执行，如果大于等线程等待100ms后继续下一次循环。
```java
/**
 * 获得分布式锁
 *
 * @param redisClientId Redis客户端ID
 * @return bool
 */
public boolean redisDistributedLock(String key, String redisClientId, long timeout, TimeUnit unit) {
    ValueOperations<String, String> ops = redisTemplate.opsForValue();
    if (ops.setIfAbsent(key, redisClientId, timeout, unit)) {
        return true;
    }
    String cacheClientId = ops.get(key);
    if (cacheClientId.equals(redisClientId)) {
        redisExpire(key, timeout, unit);
        return true;
    }
    return false;
}

/**
 * 执行定时任务
 */
public void runBenchGameDelayTask(BenchDelayTaskType type) {
    while (true) {
        Set<ZSetOperations.TypedTuple<String>> typedTuples = benchGameCacheService.benchGameTaskZRange(type);
        if (typedTuples.size() > 0) {
            benchGameTaskProcess(type, typedTuples);
        }
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            e.printStackTrace();
            log.error("[runBenchGameDelayTask] type={}, error={}", type.getData(), e);
        }
    }
}
```
<a name="JP1YJ"></a>
## 三、分布式指定时间执行的定时任务实现方式（三方框架）
<a name="iR3NP"></a>
### 1、Quartz集群解决方案
在quartz的集群解决方案里有张表scheduler_locks，quartz采用了悲观锁的方式对triggers表进行行加锁，以保证任务同步的正确性。一旦某一个节点上面的线程获取了该锁，那么这个Job就会在这台机器上被执行，同时这个锁就会被这台机器占用。同时另外一台机器也会想要触发这个任务，但是锁已经被占用了，就只能等待，直到这个锁被释放<br />quartz的分布式调度策略是以数据库为边界资源的一种异步策略。各个调度器都遵守一个基于数据库锁的操作规则从而保证了操作的唯一性<br />原理图<br />![](https://cdn.nlark.com/yuque/0/2021/webp/396745/1640348266913-af0966ab-85a3-4cf8-b2df-6963a0d69254.webp#averageHue=%23f8f8f8&clientId=u3c240b6a-4330-4&from=paste&id=u0e8ad1d1&originHeight=196&originWidth=506&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=u377accdf-bd4e-4e56-933a-f4821f90506&title=)<br />缺点：quartz的分布式只是解决了高可用的问题，并没有解决任务分片的问题，还是会有单机处理的极限
<a name="gtHeo"></a>
### 2、TBSchedule
TBSchedule是一款非常优秀的高性能分布式调度框架，广泛应用于阿里巴巴、淘宝、支付宝、京东、聚美、汽车之家、国美等很多互联网企业的流程调度系统。tbschedule在时间调度方面虽然没有quartz强大，但是它支持分片功能。和quartz不同的是，tbschedule使用ZooKeeper来实现任务调度的高可用和分片<br />原理图<br />![](https://cdn.nlark.com/yuque/0/2021/webp/396745/1640348266933-8562e465-a2e0-40fe-994e-75397284e5a6.webp#averageHue=%23bff7c0&clientId=u3c240b6a-4330-4&from=paste&id=ufb9b9696&originHeight=381&originWidth=539&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=u5a9cd54b-ca65-4acc-9ad0-39a241ddba8&title=)<br />TBSchedule的分布式机制是通过灵活的Sharding方式实现的，分片的规则由客户端决定，比如可以按所有数据的ID按10取模分片、按月份分片等等<br />BSchedule会定时扫描当前服务器的数量，重新进行任务分配。TBSchedule不仅提供了服务端的高性能调度服务，还提供了一个scheduleConsole的war包，随着宿主应用的部署直接部署到服务器，可以通过web的方式对调度的任务、策略进行监控管理，以及实时更新调整
<a name="oYMcl"></a>
### 3、elastic-job
Elastic-Job当当开源的分布式调度解决方案，由两个相互独立的子项目Elastic-Job-Lite和Elastic-Job-Cloud组成。Elastic-Job-Lite定位为轻量级无中心化解决方案，使用jar包的形式提供分布式任务的协调服务<br />原理图：<br />![2021-12-24-20-17-58-898923.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1640348476985-ad53823e-9fe6-4ad9-b018-3a19edf596b1.png#averageHue=%23d3debc&clientId=u3c240b6a-4330-4&from=ui&id=u5007573e&originHeight=643&originWidth=1080&originalType=binary&ratio=1&rotation=0&showTitle=false&size=2087410&status=done&style=shadow&taskId=u5272a36c-a04f-4357-9cbd-13b8c0a2cab&title=)![2021-12-24-20-17-59-060471.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1640348477004-2687d664-c692-45a8-bf7b-dfb0c32920b1.png#averageHue=%23cec886&clientId=u3c240b6a-4330-4&from=ui&id=u9b58f9a0&originHeight=653&originWidth=1080&originalType=binary&ratio=1&rotation=0&showTitle=false&size=2119873&status=done&style=shadow&taskId=u70495ac7-3e00-4686-8f88-ee7bcb5f175&title=)<br />特点：

- 分布式调度协调
- 弹性扩容缩容
- 失效转移
- 错过执行作业重触发
- 作业分片一致性，保证同一分片在分布式环境中仅一个执行实例
- 自诊断并修复分布式不稳定造成的问题
- 支持并行调度
- 支持作业生命周期操作
- 丰富的作业类型
- Spring整合以及命名空间提供
- 运维平台
<a name="olQ8i"></a>
### 4、唯品会开源框架Sature
特性如下：

- Time based and language unrestricted job
- Easy job implmentation and web based management
- Parallel subtask(shard) scheduling
- 1-second-level scheduling supported
- Intelligent load based job allocation
- Fail detection & failover support
- Statistical data visualization
- All-around monitoring and easy troubleshooting
- Multi-active cluster deployment support
- Container friendly
- Stand the test of billion times scheduling per day
