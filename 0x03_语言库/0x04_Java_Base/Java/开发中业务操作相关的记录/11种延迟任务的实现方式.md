Java<br />延迟任务在日常生活中比较常见，比如订单支付超时取消订单功能，又比如自动确定收货的功能等等。<br />所以这里从实现到原理来盘点延迟任务的11种实现方式，这些方式并没有绝对的好坏之分，只是适用场景的不大相同。<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1677550370671-f3f48788-0efa-45e5-8449-a0d90b413214.png#averageHue=%23f7f8f7&clientId=u0f230e27-a772-4&from=paste&id=u3f2f1a7c&originHeight=430&originWidth=1022&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u0baabd39-fb14-4a06-b683-2887d2c29b4&title=)
<a name="snEb1"></a>
## `DelayQueue`
`DelayQueue`是JDK提供的api，是一个延迟队列<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1677550370660-3530afb9-c457-469c-a7be-d8d30f5e2039.png#averageHue=%232d2c2b&clientId=u0f230e27-a772-4&from=paste&id=uab27af51&originHeight=327&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u3d6e769e-0729-49f3-95ce-3a7198c6542&title=)<br />`DelayQueue`泛型参数得实现Delayed接口，Delayed继承了Comparable接口。<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1677550370695-e9e1c8a7-b11b-4b11-bc60-43f86ce32c47.png#averageHue=%232c2b2b&clientId=u0f230e27-a772-4&from=paste&id=u3c5cdab6&originHeight=304&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=ucdf6a2da-5d57-470a-acd1-72d1dbfddc1&title=)<br />`getDelay`方法返回这个任务还剩多久时间可以执行，小于0的时候说明可以这个延迟任务到了执行的时间了。<br />`compareTo`这个是对任务排序的，保证最先到延迟时间的任务排到队列的头。
<a name="BGX1v"></a>
### 案例Demo
```java
@Getter
public class SanYouTask implements Delayed {

    private final String taskContent;

    private final Long triggerTime;

    public SanYouTask(String taskContent, Long delayTime) {
        this.taskContent = taskContent;
        this.triggerTime = System.currentTimeMillis() + delayTime * 1000;
    }

    @Override
    public long getDelay(TimeUnit unit) {
        return unit.convert(triggerTime - System.currentTimeMillis(), TimeUnit.MILLISECONDS);
    }

    @Override
    public int compareTo(Delayed o) {
        return this.triggerTime.compareTo(((SanYouTask) o).triggerTime);
    }

}
```
SanYouTask实现了Delayed接口，构造参数

- `taskContent`：延迟任务的具体的内容
- `delayTime`：延迟时间，秒为单位

测试
```java
@Slf4j
public class DelayQueueDemo {

    public static void main(String[] args) {
        DelayQueue<SanYouTask> sanYouTaskDelayQueue = new DelayQueue<>();

        new Thread(() -> {
            while (true) {
                try {
                    SanYouTask sanYouTask = sanYouTaskDelayQueue.take();
                    log.info("获取到延迟任务:{}", sanYouTask.getTaskContent());
                } catch (Exception e) {
                }
            }
        }).start();

        log.info("提交延迟任务");
        sanYouTaskDelayQueue.offer(new SanYouTask("Tom5s", 5L));
        sanYouTaskDelayQueue.offer(new SanYouTask("Tom3s", 3L));
        sanYouTaskDelayQueue.offer(new SanYouTask("Tom8s", 8L));
    }
}
```
开启一个线程从`DelayQueue`中获取任务，然后提交了三个任务，延迟时间分为别5s，3s，8s。<br />从运行结果可以看到成功实现了延迟任务。
<a name="uJRTF"></a>
### 实现原理
![](https://cdn.nlark.com/yuque/0/2023/png/396745/1677550370660-0a5efa48-0e92-4d05-a622-796d54f65ccd.png#averageHue=%23211e1a&clientId=u0f230e27-a772-4&from=paste&id=u53c8531d&originHeight=121&originWidth=421&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u7fe1bb6f-97e1-4315-bc6f-e48096601ef&title=)<br />offer方法在提交任务的时候，会通过根据compareTo的实现对任务进行排序，将最先需要被执行的任务放到队列头。<br />take方法获取任务的时候，会拿到队列头部的元素，也就是队列中最早需要被执行的任务，通过getDelay返回值判断任务是否需要被立刻执行，如果需要的话，就返回任务，如果不需要就会等待这个任务到延迟时间的剩余时间，当时间到了就会将任务返回。
<a name="UVBkM"></a>
## Timer
Timer也是JDK提供的api
<a name="IPUZq"></a>
### 案例Demo
```java
@Slf4j
public class TimerDemo {

    public static void main(String[] args) {
        Timer timer = new Timer();
        
        log.info("提交延迟任务");
        timer.schedule(new TimerTask() {
            @Override
            public void run() {
                log.info("执行延迟任务");
            }
        }, 5000);
    }

}
```
通过`schedule`提交一个延迟时间为5s的延迟任务<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1677550371145-3fad39ec-ecf9-43d3-93db-2da31194bf1b.png#averageHue=%23343434&clientId=u0f230e27-a772-4&from=paste&id=u3e774096&originHeight=269&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u4d62667c-93f7-4906-841a-cb322e38aab&title=)
<a name="LVOFB"></a>
### 实现原理
提交的任务是一个TimerTask
```java
public abstract class TimerTask implements Runnable {
    //忽略其它属性
    
    long nextExecutionTime;
}
```
TimerTask内部有一个`nextExecutionTime`属性，代表下一次任务执行的时间，在提交任务的时候会计算出`nextExecutionTime`值。<br />Timer内部有一个TaskQueue对象，用来保存TimerTask任务的，会根据`nextExecutionTime`来排序，保证能够快速获取到最早需要被执行的延迟任务。<br />在Timer内部还有一个执行任务的线程TimerThread，这个线程就跟DelayQueue demo中开启的线程作用是一样的，用来执行到了延迟时间的任务。<br />所以总的来看，Timer有点像整体封装了DelayQueue demo中的所有东西，让用起来简单点。<br />虽然Timer用起来比较简单，但是在阿里规范中是不推荐使用的，主要是有以下几点原因：

- Timer使用单线程来处理任务，长时间运行的任务会导致其他任务的延时处理
- Timer没有对运行时异常进行处理，一旦某个任务触发运行时异常，会导致整个Timer崩溃，不安全
<a name="hUgJA"></a>
## `ScheduledThreadPoolExecutor`
由于Timer在使用上有一定的问题，所以在JDK1.5版本的时候提供了`ScheduledThreadPoolExecutor`，这个跟Timer的作用差不多，并且他们的方法的命名都是差不多的，但是`ScheduledThreadPoolExecutor`解决了单线程和异常崩溃等问题。
<a name="HAowf"></a>
### 案例Demo
```java
@Slf4j
public class ScheduledThreadPoolExecutorDemo {

    public static void main(String[] args) {
        ScheduledThreadPoolExecutor executor = new ScheduledThreadPoolExecutor(2, new ThreadPoolExecutor.CallerRunsPolicy());

        log.info("提交延迟任务");
        executor.schedule(() -> log.info("执行延迟任务"), 5, TimeUnit.SECONDS);
    }

}
```
结果<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1677550371279-1b0e760e-f73c-479a-8ec4-6f82a7d76b1c.png#averageHue=%23353535&clientId=u0f230e27-a772-4&from=paste&id=u42a60979&originHeight=174&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u6e6c5234-bf3a-47cf-9c0d-072766cd73f&title=)
<a name="cqzYy"></a>
### 实现原理
`ScheduledThreadPoolExecutor`继承了`ThreadPoolExecutor`，也就是继承了线程池，所以可以有很多个线程来执行任务。<br />`ScheduledThreadPoolExecutor`在构造的时候会传入一个`DelayedWorkQueue`阻塞队列，所以线程池内部的阻塞队列是`DelayedWorkQueue`。<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1677550371354-b7063063-eea3-4e6d-946c-2eb0a01b0a32.png#averageHue=%232f2c2b&clientId=u0f230e27-a772-4&from=paste&id=u9991932a&originHeight=317&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=uf584a7f0-a494-4e2b-9494-6bc11616fad&title=)<br />在提交延迟任务的时候，任务会被封装一个任务会被封装成`ScheduledFutureTask`对象，然后放到`DelayedWorkQueue`阻塞队列中。<br />![ScheduledFutureTask](https://cdn.nlark.com/yuque/0/2023/png/396745/1677550371588-484ebfbd-017f-4281-b301-d127905055ea.png#averageHue=%23343130&clientId=u0f230e27-a772-4&from=paste&id=u1a2c6ea3&originHeight=492&originWidth=624&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=u1c6a70f2-966d-4eaa-a1cc-a8a197d96cb&title=ScheduledFutureTask "ScheduledFutureTask")<br />`ScheduledFutureTask`实现了前面提到的Delayed接口，所以其实可以猜到DelayedWorkQueue会根据`ScheduledFutureTask`对于Delayed接口的实现来排序，所以线程能够获取到最早到延迟时间的任务。<br />当线程从`DelayedWorkQueue`中获取到需要执行的任务之后就会执行任务。
<a name="JKIGk"></a>
## RocketMQ
RocketMQ是阿里开源的一款消息中间件，实现了延迟消息的功能。<br />RocketMQ延迟消息的延迟时间默认有18个等级。<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1677550371701-72fb1f64-26a0-4839-a97e-7a087e4ef56a.png#averageHue=%23322d2b&clientId=u0f230e27-a772-4&from=paste&id=u2a6469c8&originHeight=437&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=uc351be95-20fb-4a47-bf7c-925e99a8cee&title=)<br />当发送消息的时候只需要指定延迟等级即可。如果这18个等级的延迟时间不符和你的要求，可以修改RocketMQ服务端的配置文件。
<a name="JqOHb"></a>
### 案例Demo
依赖
```xml
<dependency>
    <groupId>org.apache.rocketmq</groupId>
    <artifactId>rocketmq-spring-boot-starter</artifactId>
    <version>2.2.1</version>
  
<!--web依赖-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
    <version>2.2.5.RELEASE</version>
</dependency>
```
配置文件
```yaml
rocketmq:
  name-server: 192.168.200.144:9876 #服务器ip:nameServer端口
  producer:
    group: sanyouProducer
```
controller类，通过`DefaultMQProducer`发送延迟消息到sanyouDelayTaskTopic这个topic，延迟等级为2，也就是延迟时间为5s的意思。
```java
@RestController
@Slf4j
public class RocketMQDelayTaskController {

    @Resource
    private DefaultMQProducer producer;

    @GetMapping("/rocketmq/add")
    public void addTask(@RequestParam("task") String task) throws Exception {
        Message msg = new Message("sanyouDelayTaskTopic", "TagA", task.getBytes(RemotingHelper.DEFAULT_CHARSET));
        msg.setDelayTimeLevel(2);
        // 发送消息并得到消息的发送结果，然后打印
        log.info("提交延迟任务");
        producer.send(msg);
    }

}
```
创建一个消费者，监听`sanyouDelayTaskTopic`的消息。
```java
@Component
@RocketMQMessageListener(consumerGroup = "sanyouConsumer", topic = "sanyouDelayTaskTopic")
@Slf4j
public class SanYouDelayTaskTopicListener implements RocketMQListener<String> {

    @Override
    public void onMessage(String msg) {
        log.info("获取到延迟任务:{}", msg);
    }

}
```
启动应用，浏览器输入以下链接添加任务<br />http://localhost:8080/rocketmq/add?task=sanyou<br />测试结果：<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1677550371726-7f858759-ed50-4fa4-ae97-6b63154a5edc.png#averageHue=%23665a45&clientId=u0f230e27-a772-4&from=paste&id=ua9cf2698&originHeight=186&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u54cb7dd9-eb2d-45da-9532-3e0a70ec591&title=)
<a name="PZuHZ"></a>
### 实现原理
![](https://cdn.nlark.com/yuque/0/2023/png/396745/1677550371862-782e11f6-e4f5-41d8-b072-7e542df3458f.png#averageHue=%238a7d6f&clientId=u0f230e27-a772-4&from=paste&id=u222008f6&originHeight=251&originWidth=646&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u43e9bf28-a66f-4fce-a225-0e44ed5ddc3&title=)<br />生产者发送延迟消息之后，RocketMQ服务端在接收到消息之后，会去根据延迟级别是否大于0来判断是否是延迟消息

- 如果不大于0，说明不是延迟消息，那就会将消息保存到指定的topic中
- 如果大于0，说明是延迟消息，此时RocketMQ会进行一波偷梁换柱的操作，将消息的topic改成`SCHEDULE_TOPIC_XXXX`中，XXXX不是占位符，然后存储。

在BocketMQ内部有一个延迟任务，相当于是一个定时任务，这个任务就会获取`SCHEDULE_TOPIC_XXXX`中的消息，判断消息是否到了延迟时间，如果到了，那么就会将消息的topic存储到原来真正的topic(拿例子来说就是`sanyouDelayTaskTopic`)中，之后消费者就可以从真正的topic中获取到消息了。<br />![定时任务](https://cdn.nlark.com/yuque/0/2023/png/396745/1677550372068-bcd41b49-4d89-4852-aace-fd2511bb84bb.png#averageHue=%232e2c2b&clientId=u0f230e27-a772-4&from=paste&id=ue0bf5803&originHeight=205&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=u846e2bad-25ec-4ba8-bb88-ea332eefe4c&title=%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1 "定时任务")<br />RocketMQ这种实现方式相比于前面提到的三种更加可靠，因为前面提到的三种任务内容都是存在内存的，服务器重启任务就丢了，如果要实现任务不丢还得自己实现逻辑，但是RocketMQ消息有持久化机制，能够保证任务不丢失。
<a name="XhrBm"></a>
## RabbitMQ
RabbitMQ也是一款消息中间件，通过RabbitMQ的死信队列也可以是先延迟任务的功能。
<a name="vMvPG"></a>
### 案例Demo
引入RabbitMQ的依赖
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-amqp</artifactId>
    <version>2.2.5.RELEASE</version>
</dependency>
```
配置文件
```yaml
spring:
  rabbitmq:
    host: 192.168.200.144 #服务器ip
    port: 5672
    virtual-host: /
```
RabbitMQ死信队列的配置类，后面说原理的时候会介绍干啥的
```java
@Configuration
public class RabbitMQConfiguration {
    
    @Bean
    public DirectExchange sanyouDirectExchangee() {
        return new DirectExchange("sanyouDirectExchangee");
    }

    @Bean
    public Queue sanyouQueue() {
        return QueueBuilder
                //指定队列名称，并持久化
                .durable("sanyouQueue")
                //设置队列的超时时间为5秒，也就是延迟任务的时间
                .ttl(5000)
                //指定死信交换机
                .deadLetterExchange("sanyouDelayTaskExchangee")
                .build();
    }

    @Bean
    public Binding sanyouQueueBinding() {
        return BindingBuilder.bind(sanyouQueue()).to(sanyouDirectExchangee()).with("");
    }

    @Bean
    public DirectExchange sanyouDelayTaskExchange() {
        return new DirectExchange("sanyouDelayTaskExchangee");
    }

    @Bean
    public Queue sanyouDelayTaskQueue() {
        return QueueBuilder
                //指定队列名称，并持久化
                .durable("sanyouDelayTaskQueue")
                .build();
    }

    @Bean
    public Binding sanyouDelayTaskQueueBinding() {
        return BindingBuilder.bind(sanyouDelayTaskQueue()).to(sanyouDelayTaskExchange()).with("");
    }

}
```
`RabbitMQDelayTaskController`用来发送消息，这里没指定延迟时间，是因为在声明队列的时候指定了延迟时间为5s
```java
@RestController
@Slf4j
public class RabbitMQDelayTaskController {

    @Resource
    private RabbitTemplate rabbitTemplate;

    @GetMapping("/rabbitmq/add")
    public void addTask(@RequestParam("task") String task) throws Exception {
        // 消息ID，需要封装到CorrelationData中
        CorrelationData correlationData = new CorrelationData(UUID.randomUUID().toString());
        log.info("提交延迟任务");
        // 发送消息
        rabbitTemplate.convertAndSend("sanyouDirectExchangee", "", task, correlationData);
    }

}
```
启动应用，浏览器输入以下链接添加任务<br />http://localhost:8080/rabbitmq/add?task=sanyou<br />测试结果，成功实现5s的延迟任务<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1677550372194-dc7583d6-c7d2-4cb8-929c-85f7e1a9fe67.png#averageHue=%232f2c2c&clientId=u0f230e27-a772-4&from=paste&id=u90cae0c2&originHeight=165&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u7cdb097b-5bcd-4024-9ab4-876471057d2&title=)
<a name="qFVCt"></a>
### 实现原理
![](https://cdn.nlark.com/yuque/0/2023/png/396745/1677550372319-e2bb62b4-2940-4fbc-8f9d-5374d55936d8.png#averageHue=%237d7163&clientId=u0f230e27-a772-4&from=paste&id=ua19daf14&originHeight=251&originWidth=646&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u00c2fcc6-2b1a-4540-94f7-e44cd9f6a88&title=)<br />整个工作流程如下:

- 消息发送的时候会将消息发送到`sanyouDirectExchange`这个交换机上
- 由于`sanyouDirectExchange`绑定了`sanyouQueue`，所以消息会被路由到`sanyouQueue`这个队列上
- 由于`sanyouQueue`没有消费者消费消息，并且又设置了5s的过期时间，所以当消息过期之后，消息就被放到绑定的`sanyouDelayTaskExchange`死信交换机中
- 消息到达`sanyouDelayTaskExchange`交换机后，由于跟`sanyouDelayTaskQueue`进行了绑定，所以消息就被路由到`sanyouDelayTaskQueue`中，消费者就能从`sanyouDelayTaskQueue`中拿到消息了

上面说的队列与交换机的绑定关系，就是上面的配置类所干的事。<br />其实从这个单从消息流转的角度可以看出，RabbitMQ跟RocketMQ实现有相似之处。<br />消息最开始都并没有放到最终消费者消费的队列中，而都是放到一个中间队列中，等消息到了过期时间或者说是延迟时间，消息就会被放到最终的队列供消费者消息。<br />只不过RabbitMQ需要你显示的手动指定消息所在的中间队列，而RocketMQ是在内部已经做好了这块逻辑。<br />除了基于RabbitMQ的死信队列来做，RabbitMQ官方还提供了延时插件，也可以实现延迟消息的功能，这个插件的大致原理也跟上面说的一样，延时消息会被先保存在一个中间的地方，叫做Mnesia，然后有一个定时任务去查询最近需要被投递的消息，将其投递到目标队列中。
<a name="Dceya"></a>
## 监听Redis过期key
在Redis中，有个发布订阅的机制<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1677550372392-24092cb1-20a8-4034-b28f-323964358dfd.png#averageHue=%234c453e&clientId=u0f230e27-a772-4&from=paste&id=uf71bb2b4&originHeight=167&originWidth=426&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u0a04cfaf-bf24-40b8-8923-8c0165a05ec&title=)<br />生产者在消息发送时需要到指定发送到哪个channel上，消费者订阅这个channel就能获取到消息。图中channel理解成MQ中的topic。<br />并且在Redis中，有很多默认的channel，只不过向这些channel发送消息的生产者不是我们写的代码，而是Redis本身。这里面就有这么一个channel叫做`__keyevent@<db>__:expired`，db是指Redis数据库的序号。<br />当某个Redis的key过期之后，Redis内部会发布一个事件到`__keyevent@<db>__:expired`这个channel上，只要监听这个事件，那么就可以获取到过期的key。<br />所以基于监听Redis过期key实现延迟任务的原理如下：

- 将延迟任务作为key，过期时间设置为延迟时间
- 监听`__keyevent@<db>__:expired`这个channel，那么一旦延迟任务到了过期时间（延迟时间），那么就可以获取到这个任务
<a name="NGGIa"></a>
### 案例Demo
Spring已经实现了监听`__keyevent@*__:expired`这个channel这个功能，`__keyevent@*__:expired`中的`*`代表通配符的意思，监听所有的数据库。<br />所以demo写起来就很简单了，只需4步即可<br />依赖
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
    <version>2.2.5.RELEASE</version>
</dependency>
```
配置文件
```yaml
spring:
  redis:
    host: 192.168.200.144
    port: 6379
```
配置类
```java
@Configuration
public class RedisConfiguration {

    @Bean
    public RedisMessageListenerContainer redisMessageListenerContainer(RedisConnectionFactory connectionFactory) {
        RedisMessageListenerContainer redisMessageListenerContainer = new RedisMessageListenerContainer();
        redisMessageListenerContainer.setConnectionFactory(connectionFactory);
        return redisMessageListenerContainer;
    }

    @Bean
    public KeyExpirationEventMessageListener redisKeyExpirationListener(RedisMessageListenerContainer redisMessageListenerContainer) {
        return new KeyExpirationEventMessageListener(redisMessageListenerContainer);
    }

}
```
`KeyExpirationEventMessageListener`实现了对`__keyevent@*__:expired`channel的监听<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1677550372499-fae6e501-24f7-46c5-94c2-f5abd270ba92.png#averageHue=%232e2c2b&clientId=u0f230e27-a772-4&from=paste&id=ua5880ca1&originHeight=392&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u7496041c-1c1b-4a64-a4ff-0e7ec8665a3&title=)<br />当`KeyExpirationEventMessageListener`收到Redis发布的过期Key的消息的时候，会发布`RedisKeyExpiredEvent`事件<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1677550372616-47408ee3-641b-4b19-ad99-31957d7b1f38.png#averageHue=%23302c2b&clientId=u0f230e27-a772-4&from=paste&id=ue3fe954f&originHeight=695&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=uba87cdd8-a914-4bc1-93ea-09527b419f2&title=)<br />所以只需要监听`RedisKeyExpiredEvent`事件就可以拿到过期消息的Key，也就是延迟消息。<br />对`RedisKeyExpiredEvent`事件的监听实现`MyRedisKeyExpiredEventListener`
```java
@Component
public class MyRedisKeyExpiredEventListener implements ApplicationListener<RedisKeyExpiredEvent> {

    @Override
    public void onApplicationEvent(RedisKeyExpiredEvent event) {
        byte[] body = event.getSource();
        System.out.println("获取到延迟消息：" + new String(body));
    }

}
```
代码写好，启动应用<br />之后直接通过Redis命令设置消息，就没通过代码发送消息了，消息的key为sanyou，值为task，值不重要，过期时间为5s
```
set sanyou task 

expire sanyou 5
```
成功获取到延迟任务<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1677550372673-c681f728-cc87-4b81-840e-8ff499ee9b6e.png#averageHue=%23469b3b&clientId=u0f230e27-a772-4&from=paste&id=u585084ec&originHeight=292&originWidth=622&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=ub33c3024-2f1a-4dfd-ad5b-2724c7dff13&title=)<br />虽然这种方式可以实现延迟任务，但是这种方式**坑**比较多<br />**任务存在延迟**<br />Redis过期事件的发布不是指key到了过期时间就发布，而是key到了过期时间被清除之后才会发布事件。<br />而Redis过期key的两种清除策略，就是面试八股文常背的两种：

- 惰性清除。当这个key过期之后，访问时，这个Key才会被清除
- 定时清除。后台会定期检查一部分key，如果有key过期了，就会被清除

所以即使key到了过期时间，Redis也不一定会发送key过期事件，这就到导致虽然延迟任务到了延迟时间也可能获取不到延迟任务。<br />**丢消息太频繁**<br />Redis实现的发布订阅模式，消息是没有持久化机制，当消息发布到某个channel之后，如果没有客户端订阅这个channel，那么这个消息就丢了，并不会像MQ一样进行持久化，等有消费者订阅的时候再给消费者消费。<br />所以说，假设服务重启期间，某个生产者或者是Redis本身发布了一条消息到某个channel，由于服务重启，没有监听这个channel，那么这个消息自然就丢了。<br />**消息消费只有广播模式**<br />Redis的发布订阅模式消息消费只有广播模式一种。<br />所谓的广播模式就是多个消费者订阅同一个channel，那么每个消费者都能消费到发布到这个channel的所有消息。<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1677550372928-cbda8bdf-f43b-42db-be72-18e57267ec3d.png#averageHue=%233f3933&clientId=u0f230e27-a772-4&from=paste&id=ue4f8e923&originHeight=197&originWidth=436&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=ub64ee1ec-aa8b-4e44-adc4-145b08fefc4&title=)<br />如图，生产者发布了一条消息，内容为sanyou，那么两个消费者都可以同时收到sanyou这条消息。<br />所以，如果通过监听channel来获取延迟任务，那么一旦服务实例有多个的话，还得保证消息不能重复处理，额外地增加了代码开发量。<br />**接收到所有key的某个事件**<br />这个不属于Redis发布订阅模式的问题，而是Redis本身事件通知的问题。<br />当监听了`__keyevent@<db>__:expired`的channel，那么所有的Redis的key只要发生了过期事件都会被通知给消费者，不管这个key是不是消费者想接收到的。<br />所以如果只想消费某一类消息的key，那么还得自行加一些标记，比如消息的key加个前缀，消费的时候判断一下带前缀的key就是需要消费的任务。
<a name="BC7hW"></a>
## Redisson的`RDelayedQueue`
Redisson他是Redis的儿子（Redis son），基于Redis实现了非常多的功能，其中最常使用的就是Redis分布式锁的实现，但是除了实现Redis分布式锁之外，它还实现了延迟队列的功能。
<a name="dFxFL"></a>
### 案例Demo
引入pom
```xml
<dependency>
    <groupId>org.redisson</groupId>
    <artifactId>redisson</artifactId>
    <version>3.13.1</version>
</dependency>
```
封装了一个`RedissonDelayQueue`类
```java
@Component
@Slf4j
public class RedissonDelayQueue {

    private RedissonClient redissonClient;

    private RDelayedQueue<String> delayQueue;
    private RBlockingQueue<String> blockingQueue;

    @PostConstruct
    public void init() {
        initDelayQueue();
        startDelayQueueConsumer();
    }

    private void initDelayQueue() {
        Config config = new Config();
        SingleServerConfig serverConfig = config.useSingleServer();
        serverConfig.setAddress("redis://localhost:6379");
        redissonClient = Redisson.create(config);

        blockingQueue = redissonClient.getBlockingQueue("SANYOU");
        delayQueue = redissonClient.getDelayedQueue(blockingQueue);
    }

    private void startDelayQueueConsumer() {
        new Thread(() -> {
            while (true) {
                try {
                    String task = blockingQueue.take();
                    log.info("接收到延迟任务:{}", task);
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }, "SANYOU-Consumer").start();
    }

    public void offerTask(String task, long seconds) {
        log.info("添加延迟任务:{} 延迟时间:{}s", task, seconds);
        delayQueue.offer(task, seconds, TimeUnit.SECONDS);
    }

}
```
这个类在创建的时候会去初始化延迟队列，创建一个`RedissonClient`对象，之后通过`RedissonClient`对象获取到`RDelayedQueue`和`RBlockingQueue`对象，传入的队列名字叫SANYOU，这个名字无所谓。<br />当延迟队列创建之后，会开启一个延迟任务的消费线程，这个线程会一直从`RBlockingQueue`中通过take方法阻塞获取延迟任务。<br />添加任务的时候是通过`RDelayedQueue`的`offer`方法添加的。<br />controller类，通过接口添加任务，延迟时间为5s
```java
@RestController
public class RedissonDelayQueueController {

    @Resource
    private RedissonDelayQueue redissonDelayQueue;

    @GetMapping("/add")
    public void addTask(@RequestParam("task") String task) {
        redissonDelayQueue.offerTask(task, 5);
    }

}
```
启动项目，在浏览器输入如下连接，添加任务<br />http://localhost:8080/add?task=sanyou<br />静静等待5s，成功获取到任务。<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1677550372926-28de6691-979b-4e82-bec9-ae6380a9c392.png#averageHue=%23312f2f&clientId=u0f230e27-a772-4&from=paste&id=u7e3ac606&originHeight=232&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u56715955-2905-4b3e-8a25-c920711219a&title=)
<a name="xrZgO"></a>
### 实现原理
如下是Redisson延迟队列的实现原理<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1677550373173-b132ed79-f113-4b30-a034-54020d84f297.png#averageHue=%23fae0c4&clientId=u0f230e27-a772-4&from=paste&id=u72d109ca&originHeight=521&originWidth=574&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u5944cc4c-5e98-44aa-84b1-a2182359183&title=)<br />SANYOU前面的前缀都是固定的，Redisson创建的时候会拼上前缀。

- `redisson_delay_queue_timeout:SANYOU`，sorted set数据类型，存放所有延迟任务，按照延迟任务的到期时间戳（提交任务时的时间戳 + 延迟时间）来排序的，所以列表的最前面的第一个元素就是整个延迟队列中最早要被执行的任务，这个概念很重要
- `redisson_delay_queue:SANYOU`，list数据类型，也是存放所有的任务，但是研究下来发现好像没什么用。。
- SANYOU，list数据类型，被称为目标队列，这个里面存放的任务都是已经到了延迟时间的，可以被消费者获取的任务，所以上面demo中的RBlockingQueue的take方法是从这个目标队列中获取到任务的
- `redisson_delay_queue_channel:SANYOU`，是一个channel，用来通知客户端开启一个延迟任务

任务提交的时候，Redisson会将任务放到`redisson_delay_queue_timeout:SANYOU`中，分数就是提交任务的时间戳+延迟时间，就是延迟任务的到期时间戳<br />Redisson客户端内部通过监听`redisson_delay_queue_channel:SANYOU`这个channel来提交一个延迟任务，这个延迟任务能够保证将`redisson_delay_queue_timeout:SANYOU`中到了延迟时间的任务从`redisson_delay_queue_timeout:SANYOU`中移除，存到SANYOU这个目标队列中。<br />于是消费者就可以从SANYOU这个目标队列获取到延迟任务了。<br />所以从这可以看出，Redisson的延迟任务的实现跟前面说的MQ的实现都是殊途同归，最开始任务放到中间的一个地方，叫做`redisson_delay_queue_timeout:SANYOU`，然后会开启一个类似于定时任务的一个东西，去判断这个中间地方的消息是否到了延迟时间，到了再放到最终的目标的队列供消费者消费。<br />Redisson的这种实现方式比监听Redis过期key的实现方式更加可靠，因为消息都存在list和sorted set数据类型中，所以消息很少丢。
<a name="VyLgT"></a>
## Netty的`HashedWheelTimer`
<a name="CsgTK"></a>
### 案例Demo
```java
@Slf4j
public class NettyHashedWheelTimerDemo {

    public static void main(String[] args) {
        HashedWheelTimer timer = new HashedWheelTimer(100, TimeUnit.MILLISECONDS, 8);
        timer.start();

        log.info("提交延迟任务");
        timer.newTimeout(timeout -> log.info("执行延迟任务"), 5, TimeUnit.SECONDS);
    }

}
```
测试结果<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1677550373344-f245f6fe-95c2-4a83-a308-92aee1e37805.png#averageHue=%233c3b3b&clientId=u0f230e27-a772-4&from=paste&id=uae722aab&originHeight=182&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u9fe5e3db-564c-4d3f-846f-fae70549fe7&title=)
<a name="MHMRH"></a>
### 实现原理
![](https://cdn.nlark.com/yuque/0/2023/png/396745/1677550373320-3c8d96e4-a231-4663-9349-f270571b56b8.png#averageHue=%23232323&clientId=u0f230e27-a772-4&from=paste&id=u1b44fe24&originHeight=271&originWidth=471&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=uf5dcfa28-42e2-4eb0-ba5c-2088dfd2c2d&title=)<br />如图，时间轮会被分成很多格子（上述demo中的8就代表了8个格子），一个格子代表一段时间（上述demo中的100就代表一个格子是100ms），所以上述demo中，每800ms会走一圈。<br />当任务提交的之后，会根据任务的到期时间进行hash取模，计算出这个任务的执行时间所在具体的格子，然后添加到这个格子中，通过如果这个格子有多个任务，会用链表来保存。所以这个任务的添加有点像HashMap储存元素的原理。<br />`HashedWheelTimer`内部会开启一个线程，轮询每个格子，找到到了延迟时间的任务，然后执行。<br />由于`HashedWheelTimer`也是单线程来处理任务，所以跟Timer一样，长时间运行的任务会导致其他任务的延时处理。<br />前面Redisson中提到的客户端延迟任务就是基于Netty的`HashedWheelTimer`实现的。
<a name="uUXqT"></a>
## Hutool的`SystemTimer`
Hutool工具类也提供了延迟任务的实现`SystemTimer`
<a name="isLrX"></a>
### 案例Demo
```java
@Slf4j
public class SystemTimerDemo {

    public static void main(String[] args) {
        SystemTimer systemTimer = new SystemTimer();
        systemTimer.start();

        log.info("提交延迟任务");
        systemTimer.addTask(new TimerTask(() -> log.info("执行延迟任务"), 5000));
    }

}
```
执行结果<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1677550373412-d62e4bde-704c-4dab-bffb-ee6ee68b5759.png#averageHue=%23373635&clientId=u0f230e27-a772-4&from=paste&id=u00aec49c&originHeight=260&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u577c23e8-900e-44a4-a17c-80d78eb31bf&title=)<br />Hutool底层其实也用到了时间轮。
<a name="UHPMe"></a>
## Qurtaz
Qurtaz是一款开源作业调度框架，基于Qurtaz提供的api也可以实现延迟任务的功能。
<a name="YxU4F"></a>
### 案例Demo
依赖
```xml
<dependency>
    <groupId>org.quartz-scheduler</groupId>
    <artifactId>quartz</artifactId>
    <version>2.3.2</version>
</dependency>
```
SanYouJob实现Job接口，当任务到达执行时间的时候会调用`execute`的实现，从`context`可以获取到任务的内容
```java
@Slf4j
public class SanYouJob implements Job {
    @Override
    public void execute(JobExecutionContext context) throws JobExecutionException {
        JobDetail jobDetail = context.getJobDetail();
        JobDataMap jobDataMap = jobDetail.getJobDataMap();
        log.info("获取到延迟任务:{}", jobDataMap.get("delayTask"));
    }
}
```
测试类
```java
public class QuartzDemo {

    public static void main(String[] args) throws SchedulerException, InterruptedException {
        // 1.创建Scheduler的工厂
        SchedulerFactory sf = new StdSchedulerFactory();
        // 2.从工厂中获取调度器实例
        Scheduler scheduler = sf.getScheduler();

        // 6.启动 调度器
        scheduler.start();

        // 3.创建JobDetail，Job类型就是上面说的SanYouJob
        JobDetail jb = JobBuilder.newJob(SanYouJob.class)
                .usingJobData("delayTask", "这是一个延迟任务")
                .build();

        // 4.创建Trigger
        Trigger t = TriggerBuilder.newTrigger()
                //任务的触发时间就是延迟任务到的延迟时间
                .startAt(DateUtil.offsetSecond(new Date(), 5))
                .build();

        // 5.注册任务和定时器
        log.info("提交延迟任务");
        scheduler.scheduleJob(jb, t);
    }
}
```
执行结果：<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1677550373744-26adde33-d3c9-4090-92b2-91df043017a1.png#averageHue=%233d3b3b&clientId=u0f230e27-a772-4&from=paste&id=u688261e6&originHeight=185&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=uf7acf543-411b-4d69-b546-1d447400900&title=)
<a name="WFVFf"></a>
### 实现原理
核心组件

- `Job`：表示一个任务，`execute`方法的实现是对任务的执行逻辑
- `JobDetail`：任务的详情，可以设置任务需要的参数等信息
- `Trigger`：触发器，是用来触发业务的执行，比如说指定5s后触发任务，那么任务就会在5s后触发
- `Scheduler`：调度器，内部可以注册多个任务和对应任务的触发器，之后会调度任务的执行

![](https://cdn.nlark.com/yuque/0/2023/png/396745/1677550373704-99a9264c-8338-49e4-832e-93665a56a71a.png#averageHue=%234a443d&clientId=u0f230e27-a772-4&from=paste&id=u21fa4aef&originHeight=226&originWidth=441&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=uee0a32ce-3f2d-4208-942e-0a45d6977dd&title=)<br />启动的时候会开启一个`QuartzSchedulerThread`调度线程，这个线程会去判断任务是否到了执行时间，到的话就将任务交给任务线程池去执行。
<a name="KXS6c"></a>
## 无限轮询延迟任务
无限轮询的意思就是开启一个线程不停的去轮询任务，当这些任务到达了延迟时间，那么就执行任务。
<a name="zf9i6"></a>
### 案例Demo
```java
@Slf4j
public class PollingTaskDemo {

    private static final List<DelayTask> DELAY_TASK_LIST = new CopyOnWriteArrayList<>();

    public static void main(String[] args) {
        new Thread(() -> {
            while (true) {
                try {
                    for (DelayTask delayTask : DELAY_TASK_LIST) {
                        if (delayTask.triggerTime <= System.currentTimeMillis()) {
                            log.info("处理延迟任务:{}", delayTask.taskContent);
                            DELAY_TASK_LIST.remove(delayTask);
                        }
                    }
                    TimeUnit.MILLISECONDS.sleep(100);
                } catch (Exception e) {
                }
            }
        }).start();

        log.info("提交延迟任务");
        DELAY_TASK_LIST.add(new DelayTask("Tom", 5L));
    }

    @Getter
    @Setter
    public static class DelayTask {

        private final String taskContent;

        private final Long triggerTime;

        public DelayTask(String taskContent, Long delayTime) {
            this.taskContent = taskContent;
            this.triggerTime = System.currentTimeMillis() + delayTime * 1000;
        }
    }

}
```
任务可以存在数据库又或者是内存，看具体的需求，这里为了简单就放在内存里了。<br />这种操作简单，但是就是效率低下，每次都得遍历所有的任务。
<a name="z0Z3U"></a>
## 最后
所有示例代码地址：[https://github.com/sanyou3/delay-task-demo.git](https://github.com/sanyou3/delay-task-demo.git)
