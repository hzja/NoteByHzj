<a name="zIjd2"></a>
# 1、Spring默认是单例模式，实例对象注入时作为全局变量容易在多线程情况下出现脏读
<a name="46wsP"></a>
# 2、SimpleDateFormat
`SimpleDateFormat`是线程不安全的类，一般不要定义为`static`变量，如果定义为`static`，必须加锁，或者使用DateUtils工具类。<br />正例:注意线程安全，使用DateUtils，亦推荐如下处理:
```java
private static final ThreadLocal< DateFormat> df = new ThreadLocal < DateFormat>(){
    @Override
    protected DateFormat initialValue() {
        return new SimpleDateFormat("yyyy-MM-dd*);
    }
};
```
说明：如果是JDK8的应用，可以使用Instant代替Date，LocalDate Time代替`Calendar `<br />`DateTimeFormatter`代替`SimpleDateFormat `，官方给出的解释: simple beautiful strong immutable thread-safe.
<a name="WLE3D"></a>
# 3、资源连接
资源连接包括数据库连接、FTP连接、Redis连接等，这种也要慎用全局变量，一旦使用全局变量，就会遇到以下问题：<br />1）关闭连接的时候，就可能把别人正在操作的连接给关了，导致其他线程的业务中断；<br />2）因为是全局变量，创建的时候可能会创建多个实例，在关闭连接的时候，就可能只关闭了一个对象的连接，造成其他连接没有被关闭，最后导致连接耗光系统不可用；
<a name="aNSjw"></a>
# 4、数字运算
这也是个很经典的问题了，如果要用多线程对一个数字进行累加等其他运算处理，千万不要用全局基础类型的变量，如下所示：
```java
private long count;
```
多线程情况下，某个线程获取到的值可能已经被其他线程修改了，最后得到的值就不准确了。<br />当然，上面的示例可以通过加锁的方式来解决，也可以使用全局的原子类（java.util.concurrent.atomic.Atom*）进行处理，比如：
```java
private AtomicInteger count = new AtomicInteger();
```
注意，这种原子类使用全局变量就没有线程安全的问题，它使用了 CAS 算法保证了数据一致性。<br />不过，阿里推荐使用LongAdder，因为性能更好：
> java.util.concurrent.atomic.LongAdder

<a name="xfvsr"></a>
# 5、全局session
来看下面的例子：
```java
@Autowired
protected HttpSession session;
```
全局注入一个 Session 对象，在 Spring 中，这样全局注入使用上面是默认没问题的，包括 request, response 对象，都可以通过全局注入来获取。<br />这样会存在线程安全性吗？<br />不会！<br />使用这种方式，当 Bean 初始化时，Spring 并没有注入真实对象，而是注入了一个代理对象，真正使用的时候通过该代理对象获取真正的对象。<br />并且，在注入此类对象时，Spring使用了线程局部变量（ThreadLocal），这就保证了 request/response/session 对象的线程安全性了。<br />既然是线程安全，但也得小心，如果在方法中主动使 session 对象失效并重建了：
```java
session.invalidate();
session = request.getSession();
```
这样，session对象就变成了真实对象了，不再是代理对象，就变成了文章最开始的时候多线程安全问题了，如果线上出现 session 会话混乱，用户 A 就可能看到用户 B 的数据。
