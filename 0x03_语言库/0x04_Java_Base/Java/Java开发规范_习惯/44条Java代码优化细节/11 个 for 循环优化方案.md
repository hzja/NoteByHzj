日常开发中，经常会遇到一些循环耗时计算的操作，一般也都会采用 for 循环来处理，for 作为编程入门基础，主要是处理重复的计算操作，虽然简单好用，但在写法上也有很多的考究，如果处理不好，可能成为拖垮程序的罪魁祸首，下面总结 10 多条 for 循环的常见优化方式，让代码优雅起来。<br />首先，初始化一个集合 list，如下：
```java
List<String> list = new ArrayList<String>();
```
<a name="LzMcy"></a>
### 方式一：最常规的不加思考的写法
```java
for (int i = 0; i < list.size(); i++) {
    System.out.println(list.get(i));
}
```

- 优点：较常见，易于理解
- 缺点：每次都要计算`list.size()`
<a name="lVsh6"></a>
### 方式二：数组长度提取出来
```java
int m = list.size();
for (int i = 0; i < m; i++) {
    System.out.println(list.get(i));
}
```

- 优点：不必每次都计算
- 缺点：
   1. m的作用域不够小，违反了最小作用域原则
   2. 不能在for循环中操作list的大小，比如除去或新加一个元素
<a name="M31x0"></a>
### 方式三：数组长度提取出来
```java
for (int i = 0, n = list.size(); i < n; i++) {
    System.out.println(list.get(i));
}
```

- 优点：不必每次都计算 ，变量的作用域遵循最小范围原则
- 缺点：
   1. m的作用域不够小，违反了最小作用域原则
   2. 不能在for循环中操作list的大小，比如除去或新加一个元素
<a name="dTjf8"></a>
### 方式四：采用倒序的写法
```java
for (int i = list.size() - 1; i >= 0; i--) {
    System.out.println(list.get(i));
}
```

- 优点：不必每次都计算 ，变量的作用域遵循最小范围原则
- 缺点：
   1. 结果的顺序会反
   2. 看起来不习惯，不易读懂
- 适用场合：与显示结果顺序无关的地方：比如保存之前数据的校验
<a name="pL7nJ"></a>
### 方式五：Iterator 遍历
```java
for (Iterator<String> it = list.iterator(); it.hasNext();) {
    System.out.println(it.next());
}
```

- 优点：简洁
<a name="VTctZ"></a>
### 方式六：jdk1.5后的写法
```java
for (Object o : list) {
    System.out.println(o);
}
```

- 优点：简洁结合泛型使用更简洁
- 缺点：
   1. jdk1.4向下不兼容
   2. 无法直接拿到索引
<a name="EbZYg"></a>
### 方式七：循环嵌套外小内大原则
```java
for (int i = 0; i < 10; i++) {
    for (int j = 0; j < 10000; j++) {
    }
}
```
原因
> <a name="aK0a8"></a>
### 分支优化规则
> 引人流水线工作机制以后，为了配合流水线工作，处理器增加了一个分支目标缓冲器(Branch Target Buffer)。在流水线工作模式下，如果遇到分支结构，就可以利用分支目标缓冲器预测并读取指令的目标地址。分支目标缓冲器在程序运行时将动态记录和调整转移指令的目标地址，可以记录多个地址，对其进行表格化管理。当发生转移时，如果分支目标缓冲器中有记录，下一条指令在取指令阶段就会将其作为目标地址。如果记录地址等于实际目标地址，则并行成功﹔如果记录地址不等于实际目标地址，则流水线被冲洗。同一个分支，多次预测失败，则更新记录的目标地址。因此，分支预测属于“经验主义”或“机会主义"，会存在一定的误测。
> 基于上述原因，大家以后在编写多重循环时应该把大循环放到内层，这样可以增加分支预测的准确度，如下面的示例所示：

```java
for (int i = 0; i < 10; i++) {
    // 下面每次循环会预测成功9999次
    // 第1次没有预测，最后退出循环时预测失败1次
    // 这样的过程重复10次
    for (int j = 0; j < 10000; j++) {
        a[i][j]++;
    }
}

for (int j = 0; j < 10000; j++) {
    // 下面每次循环会预测成功9次
    // 第1次没有预测，最后退出循环时预测失败1次
    // 这样的过程重复10000次
    for (int j = 0; j < 10000; j++) {
        a[i][j]++;
    }
}
```
<a name="gljLB"></a>
### 方式八：循环嵌套提取不需要循环的逻辑
```java
//前：
int a = 10, b = 11;
for (int i = 0; i < 10; i++) {
    i = i * a * b;
} 


//后：
int c = a * b;
for (int i = 0; i < 10; i++) {
    i = i * c;
}
```
<a name="mjyC0"></a>
### 方式九：异常处理写在循环外面
反例
```java
for (int i = 0; i < 10; i++) {
    try {

    } catch (Exception e) {

    }
}
```
正例
```java
try {
    for (int i = 0; i < 10; i++) {
    }
} catch (Exception e) {
}
```
不过这种写法也不是绝对，需要考虑循环过程中如果出现异常是否要中止流程，如果不需要中止循环，就需要将异常处理放在循环体内，用来捕获单次循环出现的异常，避免因为单词异常导致整个for循环后续中止
<a name="SFVoz"></a>
### 方式十：倒序删除
如果不使用迭代器遍历删除时，可以采用倒叙的方式遍历删除元素，避免因为索引变化导致异常
```java
for (int i = list.size()-1; i >= 0; i--) {
    // 循环体
    list.remove(i);
}
```
优化后的代码：
```java
for (int i = list.size()-1; i >= 0; i--) {
    // 循环体
    list.remove(i);
}
```
<a name="rHZxd"></a>
### 方式十一：减少方法调用
在循环体内部尽可能减少方法的调用，可以避免重复的方法调用开销。对于频繁调用的方法，可以将结果缓存起来。
```java
int size = list.size();
for (int i = 0; i < size; i++) {
    // 频繁调用的方法
    // 这部分调用和当前的循环没有直接性关系，就可以不放在循环体内
    int result = calculateResult();
    // 循环体
}
```
优化后的代码：
```java
int size = list.size();
int result = calculateResult();
for (int i = 0; i < size; i++) {
    // 使用缓存的结果
    // 循环体
}
```
以上是一些常见的for循环，很多都是一些不起眼的小细节，改或不改都不会影响代码的正常执行，但用户多了之后，众多小问题累积起来可能就影响到整个系统的运行，所以，需要在日常开发中多注意这些小细节，避免日后再来还技术债...
