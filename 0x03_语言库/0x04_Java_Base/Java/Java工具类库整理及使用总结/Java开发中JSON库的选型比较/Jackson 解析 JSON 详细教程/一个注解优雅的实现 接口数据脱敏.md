通常接口返回值中的一些敏感数据也是要脱敏的，比如**身份证号**、**手机号码**、**地址**.....通常的手段就是用*隐藏一部分数据，当然也可以根据自己需求定制。<br />言归正传，如何优雅的实现呢？有两种实现方案，如下：

- **整合Mybatis插件，在查询的时候针对特定的字段进行脱敏**
- **整合Jackson，在序列化阶段对特定字段进行脱敏**
- **基于Sharding Sphere实现数据脱敏**

第一种方案网上很多实现方式，下面演示第二种，整合Jackson。
<a name="kuHvc"></a>
### 1、自定义一个Jackson注解
需要自定义一个脱敏注解，一旦有属性被标注，则进行对应得脱敏，如下：
```java
/**
 * 自定义jackson注解，标注在属性上
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
@JacksonAnnotationsInside
@JsonSerialize(using = SensitiveJsonSerializer.class)
public @interface Sensitive {
    //脱敏策略
    SensitiveStrategy strategy();
}
```
<a name="CRXBV"></a>
### 2、定制脱敏策略
针对项目需求，定制不同字段的脱敏规则，比如手机号中间几位用*替代，如下：
```java
/**
 * 脱敏策略，枚举类，针对不同的数据定制特定的策略
 */
public enum SensitiveStrategy {
    /**
     * 用户名
     */
    USERNAME(s -> s.replaceAll("(\\S)\\S(\\S*)", "$1*$2")),
    /**
     * 身份证
     */
    ID_CARD(s -> s.replaceAll("(\\d{4})\\d{10}(\\w{4})", "$1****$2")),
    /**
     * 手机号
     */
    PHONE(s -> s.replaceAll("(\\d{3})\\d{4}(\\d{4})", "$1****$2")),
    /**
     * 地址
     */
    ADDRESS(s -> s.replaceAll("(\\S{3})\\S{2}(\\S*)\\S{2}", "$1****$2****"));


    private final Function<String, String> desensitizer;

    SensitiveStrategy(Function<String, String> desensitizer) {
        this.desensitizer = desensitizer;
    }

    public Function<String, String> desensitizer() {
        return desensitizer;
    }
}
```
以上只是提供了部分，具体根据自己项目要求进行配置。
<a name="nXdoX"></a>
### 3、定制JSON序列化实现
下面将是重要实现，对标注注解`@Sensitive`的字段进行脱敏，实现如下：
```java
/**
 * 序列化注解自定义实现
 * JsonSerializer<String>：指定String 类型，serialize()方法用于将修改后的数据载入
 */
public class SensitiveJsonSerializer extends JsonSerializer<String> implements ContextualSerializer {
    private SensitiveStrategy strategy;

    @Override
    public void serialize(String value, JsonGenerator gen, SerializerProvider serializers) throws IOException {
        gen.writeString(strategy.desensitizer().apply(value));
    }

    /**
     * 获取属性上的注解属性
     */
    @Override
    public JsonSerializer<?> createContextual(SerializerProvider prov, BeanProperty property) throws JsonMappingException {

        Sensitive annotation = property.getAnnotation(Sensitive.class);
        if (Objects.nonNull(annotation)&&Objects.equals(String.class, property.getType().getRawClass())) {
            this.strategy = annotation.strategy();
            return this;
        }
        return prov.findValueSerializer(property.getType(), property);

    }
}
```
<a name="BYSBX"></a>
### 4、定义Person类，对其数据脱敏
使用注解`@Sensitive`注解进行数据脱敏，代码如下：
```java
@Data
public class Person {
    /**
     * 真实姓名
     */
    @Sensitive(strategy = SensitiveStrategy.USERNAME)
    private String realName;
    /**
     * 地址
     */
    @Sensitive(strategy = SensitiveStrategy.ADDRESS)
    private String address;
    /**
     * 电话号码
     */
    @Sensitive(strategy = SensitiveStrategy.PHONE)
    private String phoneNumber;
    /**
     * 身份证号码
     */
    @Sensitive(strategy = SensitiveStrategy.ID_CARD)
    private String idCard;
}
```
<a name="WJnlN"></a>
### 5、模拟接口测试
以上4个步骤完成了数据脱敏的Jackson注解，下面写个controller进行测试，代码如下：
```java
@RestController
public class TestController {
    @GetMapping("/test")
    public Person test(){
        Person user = new Person();
        user.setRealName("Json");
        user.setPhoneNumber("19796328206");
        user.setAddress("浙江省杭州市....");
        user.setIdCard("4333333333334334333");
        return user;
    }
}
```
调用接口查看数据有没有正常脱敏，结果如下：
```json
{
  "realName": "J*on",
  "address": "浙江省****市..****",
  "phoneNumber": "197****8206",
  "idCard": "4333****34333"
}
```
<a name="pN3oR"></a>
### 6、总结
数据脱敏有很多种实现方式，关键是哪种更加适合，哪种更加优雅.....
