Java
<a name="m5FaU"></a>
## 前言
在Java的庞大体系中，其实有很多不错的小工具，也就是平常说的：轮子。<br />如果在日常工作当中，能够将这些轮子用户，再配合一下idea的快捷键，可以极大得提升开发效率。<br />这里分享17个日常工作中一定会用得到的小工具，主要内容如下：<br />![2022-06-01-17-54-22-898983.png](https://cdn.nlark.com/yuque/0/2022/png/396745/1654077299908-a3ed8762-8b02-429d-baaf-5f7e7062120c.png#clientId=u463d6be7-b2c8-4&from=ui&height=734&id=uc16891c3&originHeight=1468&originWidth=824&originalType=binary&ratio=1&rotation=0&showTitle=false&size=3636314&status=done&style=none&taskId=ufcf7575b-976d-4dc6-8495-aa6ce5d1598&title=&width=412)
<a name="pqhOT"></a>
## 1、Collections
首先出场的是java.util包下的Collections类，该类主要用于操作集合或者返回集合。
<a name="h5eez"></a>
### 1.1 排序
在工作中经常有对集合排序的需求。<br />看看使用`Collections`工具是如何实现升序和降序的：
```java
List<Integer> list = new ArrayList<>();
list.add(2);
list.add(1);
list.add(3);
Collections.sort(list);//升序
System.out.println(list);
Collections.reverse(list);//降序
System.out.println(list);
```
执行结果：
```java
[1, 2, 3]
[3, 2, 1]
```
<a name="SfpIz"></a>
### 1.2 获取最大或最小值
有时候需要找出集合中的最大值或者最小值，这时可以使用Collections的`max`和`min`方法。例如：
```java
List<Integer> list = new ArrayList<>();
list.add(2);
list.add(1);
list.add(3);
Integer max = Collections.max(list);//获取最大值
Integer min = Collections.min(list);//获取最小值
System.out.println(max);
System.out.println(min);
```
执行结果：
```java
3
1
```
<a name="qpfLw"></a>
### 1.3 转换线程安全集合
都知道，Java中的很多集合，比如：ArrayList、LinkedList、HashMap、HashSet等，都是线程不安全的。<br />换句话说，这些集合在多线程的环境中，添加数据会出现异常。<br />这时，可以用Collections的`synchronizedxxx`方法，将这些线程不安全的集合，直接转换成线程安全集合。例如：
```java
List<Integer> list = new ArrayList<>();
list.add(2);
list.add(1);
list.add(3);

List<Integer> integers = Collections.synchronizedList(list);//将ArrayList转换成线程安全集合
System.out.println(integers);
```
它的底层会创建`SynchronizedRandomAccessList`或者`SynchronizedList`类，这两个类的很多方法都会用`synchronized`加锁。
<a name="RD4WM"></a>
### 1.4 返回空集合
有时，在判空之后，需要返回空集合，就可以使用`emptyList`方法，例如：
```java
private List<Integer> fun(List<Integer> list) {
    if (list == null || list.size() == 0) {
        return Collections.emptyList();
    }
    //业务处理
    return list;
}
```
<a name="WLBcQ"></a>
### 1.5 二分查找
`binarySearch`方法提供了一个非常好用的二分查找功能，只用传入指定集合和需要找到的key即可。例如：
```java
List<Integer> list = new ArrayList<>();
list.add(2);
list.add(1);
list.add(3);

int i = Collections.binarySearch(list, 3);//二分查找
System.out.println(i );
```
执行结果：
```java
2
```
<a name="od8lq"></a>
### 1.6 转换成不可修改集合
为了防止后续的程序把某个集合的结果修改了，有时候需要把某个集合定义成不可修改的，使用Collections的`unmodifiablexxx`方法就能轻松实现：
```java
List<Integer> list = new ArrayList<>();
list.add(2);
list.add(1);
list.add(3);

List<Integer> integers = Collections.unmodifiableList(list);
integers.add(4);
System.out.println(integers);
```
执行结果：
```java
Exception in thread "main" java.lang.UnsupportedOperationException
 at java.util.Collections$UnmodifiableCollection.add(Collections.java:1055)
 at com.sue.jump.service.test1.UtilTest.main(UtilTest.java:19)
```
当然Collections工具类中还有很多常用的方法，在这里就不一一介绍了，需要自己去探索。<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1654075249994-e71c5796-80cf-4c0c-add2-e0dc312c5388.png#clientId=u463d6be7-b2c8-4&from=paste&id=u805b4936&originHeight=1140&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8e480d1c-ce43-4574-9478-5545e57b311&title=)<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1654075250035-0bab6207-2793-4ac8-b446-d50bab2c9d7a.png#clientId=u463d6be7-b2c8-4&from=paste&id=u3fe48dca&originHeight=1030&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u29a9a048-2fc8-4cb2-a928-8819ef932c3&title=)
<a name="C6XvW"></a>
## 2、CollectionUtils
对集合操作，除了前面说的`Collections`工具类之后，`CollectionUtils`工具类也非常常用。<br />目前比较主流的是Spring的org.springframework.util包下的CollectionUtils工具类。![](https://cdn.nlark.com/yuque/0/2022/png/396745/1654075249993-2084e6eb-7b03-48cb-ba0a-7ad3ccae2abf.png#clientId=u463d6be7-b2c8-4&from=paste&id=ub169c71a&originHeight=728&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ue83b26a2-8c47-44d2-8a26-c814f7bf9a8&title=)<br />和apache的org.apache.commons.collections包下的CollectionUtils工具类。<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1654075250150-73263e9c-d42e-43b9-9e7d-7c65029d1cb4.png#clientId=u463d6be7-b2c8-4&from=paste&id=u21157b00&originHeight=1107&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6a3b44b6-aaa5-4ef1-a282-d549ade23ad&title=)<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1654075250461-92eef10d-b507-4635-950a-79af023c1855.png#clientId=u463d6be7-b2c8-4&from=paste&id=u7f27c915&originHeight=432&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uac3b18c2-5790-4975-848d-10ccf371001&title=)<br />更推荐使用apache的包下的`CollectionUtils`工具类，因为它的工具更多更全面。<br />举个简单的例子，Spring的`CollectionUtils`工具类没有判断集合不为空的方法。而apache的CollectionUtils工具类却有。<br />下面以apache的`CollectionUtils`工具类为例，介绍一下常用方法。
<a name="wmJpV"></a>
### 2.1 集合判空
通过`CollectionUtils`工具类的`isEmpty`方法可以轻松判断集合是否为空，`isNotEmpty`方法判断集合不为空。
```java
List<Integer> list = new ArrayList<>();
list.add(2);
list.add(1);
list.add(3);

if (CollectionUtils.isEmpty(list)) {
    System.out.println("集合为空");
}

if (CollectionUtils.isNotEmpty(list)) {
    System.out.println("集合不为空");
}
```
<a name="FBRyk"></a>
### 2.2 对两个集合进行操作
有时候需要对已有的两个集合进行操作，比如取交集或者并集等。
```java
List<Integer> list = new ArrayList<>();
list.add(2);
list.add(1);
list.add(3);

List<Integer> list2 = new ArrayList<>();
list2.add(2);
list2.add(4);

//获取并集
Collection<Integer> unionList = CollectionUtils.union(list, list2);
System.out.println(unionList);

//获取交集
Collection<Integer> intersectionList = CollectionUtils.intersection(list, list2);
System.out.println(intersectionList);

//获取交集的补集
Collection<Integer> disjunctionList = CollectionUtils.disjunction(list, list2);
System.out.println(disjunctionList);

//获取差集
Collection<Integer> subtractList = CollectionUtils.subtract(list, list2);
System.out.println(subtractList);
```
执行结果：
```java
[1, 2, 3, 4]
[2]
[1, 3, 4]
[1, 3]
```
说句实话，对两个集合的操作，在实际工作中用得挺多的，特别是很多批量的场景中。以前需要写一堆代码，但没想到有现成的轮子。
<a name="kT8FT"></a>
## 3、Lists
如果引入com.google.guava的pom文件，会获得很多好用的小工具。这里推荐一款com.google.common.collect包下的集合工具：Lists。<br />它是在太好用了。
<a name="vSyHX"></a>
### 3.1 创建空集合
有时候，想创建一个空集合。这时可以用Lists的`newArrayList`方法，例如：
```java
List<Integer> list = Lists.newArrayList();
```
<a name="qfpRY"></a>
### 3.2 快速初始化集合
有时候，想给一个集合中初始化一些元素。这时可以用Lists的`newArrayList`方法，例如：
```java
List<Integer> list = Lists.newArrayList(1, 2, 3);
```
执行结果：
```java
[1, 2, 3]
```
<a name="jIaHP"></a>
### 3.3 笛卡尔积
如果想将两个集合做笛卡尔积，Lists的`cartesianProduct`方法可以实现：
```java
List<Integer> list1 = Lists.newArrayList(1, 2, 3);
List<Integer> list2 = Lists.newArrayList(4,5);
List<List<Integer>> productList = Lists.cartesianProduct(list1,list2);
System.out.println(productList);
```
执行结果：
```java
[[1, 4], [1, 5], [2, 4], [2, 5], [3, 4], [3, 5]]
```
<a name="ltJIh"></a>
### 3.4 分页
如果想将一个大集合分成若干个小集合，可以使用Lists的`partition`方法：
```java
List<Integer> list = Lists.newArrayList(1, 2, 3, 4, 5);
List<List<Integer>> partitionList = Lists.partition(list, 2);
System.out.println(partitionList);
```
执行结果：
```java
[[1, 2], [3, 4], [5]]
```
这个例子中，list有5条数据，将list集合按大小为2，分成了3页，即变成3个小集合。<br />比如有个需求：现在有5000个id，需要调用批量用户查询接口，查出用户数据。但如果直接查5000个用户，单次接口响应时间可能会非常慢。如果改成分页处理，每次只查500个用户，异步调用10次接口，就不会有单次接口响应慢的问题。
<a name="zfID3"></a>
### 3.5 流处理
如果想把某个集合转换成另外一个接口，可以使用Lists的`transform`方法。例如：
```java
List<String> list = Lists.newArrayList("a","b","c");
List<String> transformList = Lists.transform(list, x -> x.toUpperCase());
System.out.println(transformList);
```
将小写字母转换成了大写字母。
<a name="vjsQs"></a>
### 3.6 颠倒顺序
Lists的有颠倒顺序的方法`reverse`。例如：
```java
List<Integer> list = Lists.newArrayList(3, 1, 2);
List<Integer> reverseList = Lists.reverse(list);
System.out.println(reverseList);
```
执行结果：
```java
[2, 1, 3]
```
list的原始顺序是312，使用`reverse`方法颠倒顺序之后，变成了213。<br />Lists还有其他的好用的工具，在这里只是抛砖引玉，有兴趣的朋友，可以仔细研究一下。![](https://cdn.nlark.com/yuque/0/2022/png/396745/1654075250994-cead9de6-6115-460d-998c-d1b916297dfb.png#clientId=u463d6be7-b2c8-4&from=paste&id=uaea897cc&originHeight=849&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u344888d8-4322-421e-b761-7f82f8e5f8e&title=)
<a name="CtG08"></a>
## 4、Objects
在jdk7之后，提供了Objects工具类，可以通过它操作对象。
<a name="SxVC4"></a>
### 4.1 对象判空
在Java中万事万物皆对象，对象的判空可以说无处不在。Objects的`isNull`方法判断对象是否为空，而nonNull方法判断对象是否不为空。例如：
```java
Integer integer = new Integer(1);

if (Objects.isNull(integer)) {
	System.out.println("对象为空");
}

if (Objects.nonNull(integer)) {
	System.out.println("对象不为空");
}
```
<a name="P7ClU"></a>
### 4.2 对象为空抛异常
如果想在对象为空时，抛出空指针异常，可以使用Objects的`requireNonNull`方法。例如：
```java
Integer integer1 = new Integer(128);

Objects.requireNonNull(integer1);
Objects.requireNonNull(integer1, "参数不能为空");
Objects.requireNonNull(integer1, () -> "参数不能为空");
```
<a name="iCPse"></a>
### 4.3 判断两个对象是否相等
经常需要判断两个对象是否相等，Objects提供了`equals`方法，能非常方便的实现：
```java
Integer integer1 = new Integer(1);
Integer integer2 = new Integer(1);

System.out.println(Objects.equals(integer1, integer2));
```
执行结果：
```java
true
```
但使用这个方法有坑，比如例子改成：
```java
Integer integer1 = new Integer(1);
Long integer2 = new Long(1);

System.out.println(Objects.equals(integer1, integer2));
```
执行结果：
```java
false
```
<a name="YbVNp"></a>
### 4.4 获取对象的`hashCode`
如果想获取某个对象的hashCode，可以使用Objects的`hashCode`方法。例如：
```java
String str = new String("abc");
System.out.println(Objects.hashCode(str));
```
执行结果：
```java
96354
```
Objects的内容先介绍到这里，有兴趣的小伙们，可以看看下面更多的方法：![](https://cdn.nlark.com/yuque/0/2022/png/396745/1654075251026-b9befb47-d7f5-429b-919a-fa58b5021e01.png#clientId=u463d6be7-b2c8-4&from=paste&id=ua058eba3&originHeight=568&originWidth=858&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u3c777ef1-4bdb-4a3b-943b-e9815b6db51&title=)
<a name="wn49H"></a>
## 5、`BooleanUtils`
在Java中布尔值，随处可见。<br />如果使用了布尔的包装类：Boolean，总感觉有点麻烦，因为它有三种值：null、true、false。在处理Boolean对象时，需要经常判空。<br />头疼！！！<br />但如果使用`BooleanUtils`类处理布尔值，心情一下子就愉悦起来了。
<a name="WzEcb"></a>
### 5.1 判断true或false
如果想判断某个参数的值是true或false，可以直接使用`isTrue`或`isFalse`方法。例如：
```java
Boolean aBoolean = new Boolean(true);
System.out.println(BooleanUtils.isTrue(aBoolean));
System.out.println(BooleanUtils.isFalse(aBoolean));
```
<a name="uh46g"></a>
### 5.2 判断不为true或不为false
有时候，需要判断某个参数不为true，即是null或者false。或者判断不为false，即是null或者true。<br />可以使用`isNotTrue`或`isNotFalse`方法。例如：
```java
Boolean aBoolean = new Boolean(true);
Boolean aBoolean1 = null;
System.out.println(BooleanUtils.isNotTrue(aBoolean));
System.out.println(BooleanUtils.isNotTrue(aBoolean1));
System.out.println(BooleanUtils.isNotFalse(aBoolean));
System.out.println(BooleanUtils.isNotFalse(aBoolean1));
```
执行结果：
```java
false
true
true
true
```
<a name="rHBow"></a>
### 5.3 转换成数字
如果想将true转换成数字1，false转换成数字0，可以使用`toInteger`方法：
```java
Boolean aBoolean = new Boolean(true);
Boolean aBoolean1 = new Boolean(false);
System.out.println(BooleanUtils.toInteger(aBoolean));
System.out.println(BooleanUtils.toInteger(aBoolean1));
```
执行结果：
```java
1
0
```
<a name="twAPM"></a>
### 5.4 `Boolean`转换成布尔值
有时候需要将包装类`Boolean`对象，转换成原始的`boolean`对象，可以使用`toBoolean`方法。例如：
```java
Boolean aBoolean = new Boolean(true);
Boolean aBoolean1 = null;
System.out.println(BooleanUtils.toBoolean(aBoolean));
System.out.println(BooleanUtils.toBoolean(aBoolean1));
System.out.println(BooleanUtils.toBooleanDefaultIfNull(aBoolean1, false));
```
无需额外的判空了，而且还可以设置Boolean对象为空时返回的默认值。<br />`BooleanUtils`类的方法还有很多，有兴趣的小伙伴可以看看下面的内容：![](https://cdn.nlark.com/yuque/0/2022/png/396745/1654075251367-f3948a5e-799d-4331-9478-95ac4ef067dc.png#clientId=u463d6be7-b2c8-4&from=paste&id=uc5676e76&originHeight=1214&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uf1ff67bc-d14e-4950-8b99-aff103570c5&title=)
<a name="HWyXR"></a>
## 6、StringUtils
字符串（String）在日常工作中，用得非常非常非常多。<br />在代码中经常需要对字符串判空，截取字符串、转换大小写、分隔字符串、比较字符串、去掉多余空格、拼接字符串、使用正则表达式等等。<br />如果只用String类提供的那些方法，需要手写大量的额外代码，不然容易出现各种异常。<br />现在有个好消息是：org.apache.commons.lang3包下的StringUtils工具类提供了非常丰富的选择。
<a name="jbTK3"></a>
### 6.1 字符串判空
其实空字符串，不只是null一种，还有""，" "，"null"等等，多种情况。<br />StringUtils提供了多个判空的静态方法，例如：
```java
 String str1 = null;
String str2 = "";
String str3 = " ";
String str4 = "abc";
System.out.println(StringUtils.isEmpty(str1));
System.out.println(StringUtils.isEmpty(str2));
System.out.println(StringUtils.isEmpty(str3));
System.out.println(StringUtils.isEmpty(str4));
System.out.println("=====");
System.out.println(StringUtils.isNotEmpty(str1));
System.out.println(StringUtils.isNotEmpty(str2));
System.out.println(StringUtils.isNotEmpty(str3));
System.out.println(StringUtils.isNotEmpty(str4));
System.out.println("=====");
System.out.println(StringUtils.isBlank(str1));
System.out.println(StringUtils.isBlank(str2));
System.out.println(StringUtils.isBlank(str3));
System.out.println(StringUtils.isBlank(str4));
System.out.println("=====");
System.out.println(StringUtils.isNotBlank(str1));
System.out.println(StringUtils.isNotBlank(str2));
System.out.println(StringUtils.isNotBlank(str3));
System.out.println(StringUtils.isNotBlank(str4));
```
执行结果：
```java
true
true
false
false
=====
false
false
true
true
=====
true
true
true
false
=====
false
false
false
true
```
示例中的：`isEmpty`、`isNotEmpty`、`isBlank`和`isNotBlank`，这4个判空方法可以根据实际情况使用。<br />优先推荐使用`isBlank`和`isNotBlank`方法，因为它会把`" "`也考虑进去。
<a name="Hsi3f"></a>
### 6.2 分隔字符串
分隔字符串是常见需求，如果直接使用String类的`split`方法，就可能会出现空指针异常。
```java
String str1 = null;
System.out.println(StringUtils.split(str1,","));
System.out.println(str1.split(","));
```
执行结果：
```java
null
Exception in thread "main" java.lang.NullPointerException
 at com.sue.jump.service.test1.UtilTest.main(UtilTest.java:21)
```
使用StringUtils的`split`方法会返回null，而使用String的`split`方法会报指针异常。
<a name="VzVjk"></a>
### 6.3 判断是否纯数字
给定一个字符串，判断它是否为纯数字，可以使用`isNumeric`方法。例如：
```java
String str1 = "123";
String str2 = "123q";
String str3 = "0.33";
System.out.println(StringUtils.isNumeric(str1));
System.out.println(StringUtils.isNumeric(str2));
System.out.println(StringUtils.isNumeric(str3));
```
执行结果：
```java
true
false
false
```
<a name="lO7z1"></a>
### 6.4 将集合拼接成字符串
有时候，需要将某个集合的内容，拼接成一个字符串，然后输出，这时可以使用`join`方法。例如：
```java
List<String> list = Lists.newArrayList("a", "b", "c");
List<Integer> list2 = Lists.newArrayList(1, 2, 3);
System.out.println(StringUtils.join(list, ","));
System.out.println(StringUtils.join(list2, " "));
```
执行结果：
```java
a,b,c
1 2 3
```
当然还有很多实用的方法，在这里就不一一介绍了。![](https://cdn.nlark.com/yuque/0/2022/png/396745/1654075251111-cf4e13c7-4784-4ed6-9bfc-b48f95dfed70.png#clientId=u463d6be7-b2c8-4&from=paste&id=u55bdcb78&originHeight=977&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1726692d-fd28-4dc0-8e61-baba6982f91&title=)<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1654075251272-e83d8c2c-8c62-4183-9534-3c2a5d487e8e.png#clientId=u463d6be7-b2c8-4&from=paste&id=u709ca8c6&originHeight=1075&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u39275588-2174-41ba-8c2a-a8d6e25f10b&title=)
<a name="TOP8o"></a>
## 7、Assert
很多时候，需要在代码中做判断：如果不满足条件，则抛异常。<br />有没有统一的封装呢?<br />其实Spring提供了Assert类，它表示断言。
<a name="GqJAv"></a>
### 7.1 断言参数是否为空
断言参数是否空，如果不满足条件，则直接抛异常。
```java
String str = null;
Assert.isNull(str, "str必须为空");
Assert.isNull(str, () -> "str必须为空");
Assert.notNull(str, "str不能为空");
```
如果不满足条件就会抛出`IllegalArgumentException`异常。
<a name="zYJn8"></a>
### 7.2 断言集合是否为空
断言集合是否空，如果不满足条件，则直接抛异常。
```java
List<String> list = null;
Map<String, String> map = null;
Assert.notEmpty(list, "list不能为空");
Assert.notEmpty(list, () -> "list不能为空");
Assert.notEmpty(map, "map不能为空");
```
如果不满足条件就会抛出`IllegalArgumentException`异常。
<a name="ocUQq"></a>
### 7.3 断言条件是否为空
断言是否满足某个条件，如果不满足条件，则直接抛异常。
```java
List<String> list = null;
Assert.isTrue(CollectionUtils.isNotEmpty(list), "list不能为空");
Assert.isTrue(CollectionUtils.isNotEmpty(list), () -> "list不能为空");
```
当然`Assert`类还有一些其他的功能，这里就不多介绍了。![](https://cdn.nlark.com/yuque/0/2022/png/396745/1654075251360-4b301024-bd64-4789-bd3b-5dddc77b39ba.png#clientId=u463d6be7-b2c8-4&from=paste&id=uc446d24f&originHeight=1347&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ubcd8bf0d-9e47-40c4-b61a-4c0d6172c4c&title=)
<a name="xgUHh"></a>
## 8、IOUtils
IO流在日常工作中也用得比较多，尽管Java已经提供了丰富的API。<br />但不得不每次读取文件，或者写入文件之后，写一些重复的的代码。手动在`finally`代码块中关闭流，不然可能会造成内存溢出。<br />有个好消息是：如果使用org.apache.commons.io包下的IOUtils类，会节省大量的时间。
<a name="xtXKs"></a>
### 8.1 读取文件
如果想将某个txt文件中的数据，读取到字符串当中，可以使用IOUtils类的`toString`方法。例如：
```java
String str = IOUtils.toString(new FileInputStream("/temp/a.txt"), StandardCharsets.UTF_8);
System.out.println(str);
```
<a name="APn0b"></a>
### 8.2 写入文件
如果想将某个字符串的内容，写入到指定文件当中，可以使用IOUtils类的`write`方法。例如：
```java
String str = "abcde";
IOUtils.write(str, new FileOutputStream("/temp/b.tx"), StandardCharsets.UTF_8);
```
<a name="JTUJe"></a>
### 8.3 文件拷贝
如果想将某个文件中的所有内容，都拷贝到另一个文件当中，可以使用IOUtils类的`copy`方法。例如：
```java
IOUtils.copy(new FileInputStream("/temp/a.txt"), new FileOutputStream("/temp/b.txt"));
```
<a name="XWLdx"></a>
### 8.4 读取文件内容到字节数组
如果想将某个文件中的内容，读取字节数组中，可以使用IOUtils类的`toByteArray`方法。例如：
```java
byte[] bytes = IOUtils.toByteArray(new FileInputStream("/temp/a.txt"));
```
IOUtils类非常实用，感兴趣的小伙们，可以看看下面内容。![](https://cdn.nlark.com/yuque/0/2022/png/396745/1654075251692-1344cfdd-1de9-4429-8a44-e5f4424f3047.png#clientId=u463d6be7-b2c8-4&from=paste&id=u40f98e7a&originHeight=1249&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ufda6ce86-b5e3-41df-b39d-6b768052fee&title=)
<a name="LbHRd"></a>
## 9、MDC
MDC是org.slf4j包下的一个类，它的全称是Mapped Diagnostic Context，可以认为它是一个线程安全的存放诊断日志的容器。<br />MDC的底层是用了`ThreadLocal`来保存数据的。<br />可以用它传递参数。<br />例如现在有这样一种场景：使用`RestTemplate`调用远程接口时，有时需要在header中传递信息，比如：traceId，source等，便于在查询日志时能够串联一次完整的请求链路，快速定位问题。<br />这种业务场景就能通过`ClientHttpRequestInterceptor`接口实现，具体做法如下：<br />第一步，定义一个LogFilter拦截所有接口请求，在MDC中设置traceId：
```java
public class LogFilter implements Filter {
	@Override
	public void init(FilterConfig filterConfig) throws ServletException {
	}

	@Override
	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
		MdcUtil.add(UUID.randomUUID().toString());
		System.out.println("记录请求日志");
		chain.doFilter(request, response);
		System.out.println("记录响应日志");
	}

	@Override
	public void destroy() {
	}
}
```
第二步，实现`ClientHttpRequestInterceptor`接口，MDC中获取当前请求的traceId，然后设置到header中：
```java
public class RestTemplateInterceptor implements ClientHttpRequestInterceptor {

	@Override
	public ClientHttpResponse intercept(HttpRequest request, byte[] body, ClientHttpRequestExecution execution) throws IOException {
		request.getHeaders().set("traceId", MdcUtil.get());
		return execution.execute(request, body);
	}
}
```
第三步，定义配置类，配置上面定义的`RestTemplateInterceptor`类：
```java
@Configuration
public class RestTemplateConfiguration {

	@Bean
	public RestTemplate restTemplate() {
		RestTemplate restTemplate = new RestTemplate();
		restTemplate.setInterceptors(Collections.singletonList(restTemplateInterceptor()));
		return restTemplate;
	}

	@Bean
	public RestTemplateInterceptor restTemplateInterceptor() {
		return new RestTemplateInterceptor();
	}
}
```
其中MdcUtil其实是利用MDC工具在ThreadLocal中存储和获取traceId
```java
public class MdcUtil {

    private static final String TRACE_ID = "TRACE_ID";

    public static String get() {
        return MDC.get(TRACE_ID);
    }

    public static void add(String value) {
        MDC.put(TRACE_ID, value);
    }
}
```
当然，这个例子中没有演示MdcUtil类的`add`方法具体调的地方，可以在`filter`中执行接口方法之前，生成traceId，调用MdcUtil类的add方法添加到MDC中，然后在同一个请求的其他地方就能通过MdcUtil类的get方法获取到该traceId。<br />能使用MDC保存traceId等参数的根本原因是，用户请求到应用服务器，Tomcat会从线程池中分配一个线程去处理该请求。<br />那么该请求的整个过程中，保存到MDC的`ThreadLocal`中的参数，也是该线程独享的，所以不会有线程安全问题。
<a name="uk1W2"></a>
## 10、ClassUtils
Spring的org.springframework.util包下的`ClassUtils`类，它里面有很多惊喜的功能。<br />它里面包含了类和对象相关的很多非常实用的方法。
<a name="nN7G1"></a>
### 10.1 获取对象的所有接口
如果想获取某个对象的所有接口，可以使用ClassUtils的`getAllInterfaces`方法。例如：
```java
Class<?>[] allInterfaces = ClassUtils.getAllInterfaces(new User());
```
<a name="obKiW"></a>
### 10.2 获取某个类的包名
如果想获取某个类的包名，可以使用ClassUtils的`getPackageName`方法。例如：
```java
String packageName = ClassUtils.getPackageName(User.class);
System.out.println(packageName);
```
<a name="ntaJH"></a>
### 10.3 判断某个类是否内部类
如果想判断某个类是否内部类，可以使用ClassUtils的`isInnerClass`方法。例如：
```java
System.out.println(ClassUtils.isInnerClass(User.class));
```
<a name="gMb2S"></a>
### 10.4 判断对象是否代理对象
如果想判断对象是否代理对象，可以使用ClassUtils的`isCglibProxy`方法。例如：
```java
System.out.println(ClassUtils.isCglibProxy(new User()));
```
ClassUtils还有很多有用的方法，等着去发掘。感兴趣的朋友，可以看看下面内容：![](https://cdn.nlark.com/yuque/0/2022/png/396745/1654075251937-f1007da0-4950-4079-8889-a00e56c80db2.png#clientId=u463d6be7-b2c8-4&from=paste&id=u2b6bce14&originHeight=1264&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u80dcf82a-3842-4281-bc27-48001ee5fb9&title=)
<a name="kYFOe"></a>
## 11. BeanUtils
Spring提供了一个JavaBean的工具类，它在org.springframework.beans包下面，它的名字叫做：`BeanUtils`。<br />一起看看这个工具有哪些惊喜。
<a name="a2S3t"></a>
### 11.1 拷贝对象的属性
曾几何时，有没有这样的需求：把某个对象中的所有属性，都拷贝到另外一个对象中。这时就能使用BeanUtils的`copyProperties`方法。例如：
```java
User user1 = new User();
user1.setId(1L);
user1.setName("Fcant");
user1.setAddress("成都");

User user2 = new User();
BeanUtils.copyProperties(user1, user2);
System.out.println(user2);
```
<a name="hrguM"></a>
### 11.2 实例化某个类
如果想通过反射实例化一个类的对象，可以使用BeanUtils的`instantiateClass`方法。例如：
```java
User user = BeanUtils.instantiateClass(User.class);
System.out.println(user);
```
<a name="tAu1S"></a>
### 11.3 获取指定类的指定方法
如果想获取某个类的指定方法，可以使用BeanUtils的`findDeclaredMethod`方法。例如：
```java
Method declaredMethod = BeanUtils.findDeclaredMethod(User.class, "getId");
System.out.println(declaredMethod.getName());
```
<a name="gLYk5"></a>
### 11.4 获取指定方法的参数
如果想获取某个方法的参数，可以使用BeanUtils的`findPropertyForMethod`方法。例如：
```java
Method declaredMethod = BeanUtils.findDeclaredMethod(User.class, "getId");
PropertyDescriptor propertyForMethod = BeanUtils.findPropertyForMethod(declaredMethod);
System.out.println(propertyForMethod.getName());
```
如果对BeanUtils比较感兴趣，可以看看下面内容：![](https://cdn.nlark.com/yuque/0/2022/png/396745/1654075251996-9616c047-bd84-4c88-91a2-3d71a57f18fd.png#clientId=u463d6be7-b2c8-4&from=paste&id=ue5e490fc&originHeight=945&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u06efae11-374a-4826-aedc-07fd943cfb1&title=)
<a name="c2TWi"></a>
## 12、ReflectionUtils
有时候，需要在项目中使用反射功能，如果使用最原始的方法来开发，代码量会非常多，而且很麻烦，它需要处理一大堆异常以及访问权限等问题。<br />好消息是Spring提供了一个`ReflectionUtils`工具，它在org.springframework.util包下面。
<a name="bSVR8"></a>
### 12.1 获取方法
如果想获取某个类的某个方法，可以使用ReflectionUtils类的`findMethod`方法。例如：
```java
Method method = ReflectionUtils.findMethod(User.class, "getId");
```
<a name="rH9hL"></a>
### 12.2 获取字段
如果想获取某个类的某个字段，可以使用ReflectionUtils类的`findField`方法。例如：
```java
Field field = ReflectionUtils.findField(User.class, "id");
```
<a name="dPljN"></a>
### 12.3 执行方法
如果想通过反射调用某个方法，传递参数，可以使用ReflectionUtils类的`invokeMethod`方法。例如：
```java
ReflectionUtils.invokeMethod(method, springContextsUtil.getBean(beanName), param);
```
<a name="bTJW6"></a>
### 12.4 判断字段是否常量
如果想判断某个字段是否常量，可以使用`ReflectionUtils`类的`isPublicStaticFinal`方法。例如：
```java
Field field = ReflectionUtils.findField(User.class, "id");
System.out.println(ReflectionUtils.isPublicStaticFinal(field));
```
<a name="MCVwz"></a>
### 12.5 判断是否`equals`方法
如果想判断某个方法是否equals方法，可以使用ReflectionUtils类的`isEqualsMethod`方法。例如：
```java
Method method = ReflectionUtils.findMethod(User.class, "getId");
System.out.println(ReflectionUtils.isEqualsMethod(method));
```
当然这个类还有不少有趣的方法，感兴趣的朋友，可以看看下面内容：![](https://cdn.nlark.com/yuque/0/2022/png/396745/1654075251974-7c1e4fc1-a68d-422d-b325-a3303c0052d4.png#clientId=u463d6be7-b2c8-4&from=paste&id=ud4c5a8f2&originHeight=1152&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ub3e5f41e-c568-4e15-9c06-0c6c13adebe&title=)
<a name="J0yge"></a>
## 13、Base64Utils
有时候，为了安全考虑，需要将参数只用base64编码。<br />这时就能直接使用org.springframework.util包下的`Base64Utils`工具类。<br />它里面包含：`encode`和`decode`方法，用于对数据进行加密和解密。例如：
```java
String str = "abc";
String encode = new String(Base64Utils.encode(str.getBytes()));
System.out.println("加密后：" + encode);
try {
	String decode = new String(Base64Utils.decode(encode.getBytes()), "utf8");
	System.out.println("解密后：" + decode);
} catch (UnsupportedEncodingException e) {
	e.printStackTrace();
}
```
执行结果：
```java
加密后：YWJj
解密后：abc
```
<a name="cKJet"></a>
## 14、StandardCharsets
在做字符转换的时候，经常需要指定字符编码，比如：UTF-8、ISO-8859-1等等。<br />这时就可以直接使用java.nio.charset包下的`StandardCharsets`类中静态变量。<br />例如：
```java
String str = "abc";
String encode = new String(Base64Utils.encode(str.getBytes()));
System.out.println("加密后：" + encode);
String decode = new String(Base64Utils.decode(encode.getBytes())
, StandardCharsets.UTF_8);
System.out.println("解密后：" + decode);
```
<a name="z9p1R"></a>
## 15、DigestUtils
有时候，需要对数据进行加密处理，比如：md5或sha256。<br />可以使用apache的org.apache.commons.codec.digest包下的`DigestUtils`类。
<a name="bZYWE"></a>
### 15.1 md5加密
如果想对数据进行md5加密，可以使用`DigestUtils`的`md5Hex`方法。例如：
```java
String md5Hex = DigestUtils.md5Hex("Fcant");
System.out.println(md5Hex);
```
<a name="viwwi"></a>
### 15.2 sha256加密
如果想对数据进行sha256加密，可以使用DigestUtils的`sha256Hex`方法。例如：
```java
String md5Hex = DigestUtils.sha256Hex("Fcant");
System.out.println(md5Hex);
```
当然这个工具还有很多其他的加密方法：![](https://cdn.nlark.com/yuque/0/2022/png/396745/1654075253126-00e97ae0-8b1b-4c30-bd0a-75c1a9cad470.png#clientId=u463d6be7-b2c8-4&from=paste&id=u10abe39f&originHeight=1436&originWidth=874&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ub4e5bb08-63ca-42b7-b1b9-1ee6a2567ab&title=)
<a name="ICW5c"></a>
## 16. SerializationUtils
有时候，需要把数据进行序列化和反序列化处理。<br />传统的做法是某个类实现`Serializable`接口，然后重新它的`writeObject`和`readObject`方法。<br />但如果使用org.springframework.util包下的`SerializationUtils`工具类，能更轻松实现序列化和反序列化功能。例如：
```java
Map<String, String> map = Maps.newHashMap();
map.put("a", "1");
map.put("b", "2");
map.put("c", "3");
byte[] serialize = SerializationUtils.serialize(map);
Object deserialize = SerializationUtils.deserialize(serialize);
System.out.println(deserialize);
```
<a name="tuFc3"></a>
## 17、HttpStatus
很多时候，会在代码中定义http的返回码，比如：接口正常返回200，异常返回500，接口找不到返回404，接口不可用返回502等。
```java
private int SUCCESS_CODE = 200;
private int ERROR_CODE = 500;
private int NOT_FOUND_CODE = 404;
```
其实org.springframework.http包下的HttpStatus枚举，或者org.apache.http包下的`HttpStatus`接口，已经把常用的http返回码定义好了，直接拿来用就可以了，真的不用再重复定义了。<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1654075252272-5e3e4cc2-7659-41c9-869f-5ac48b37ba19.png#clientId=u463d6be7-b2c8-4&from=paste&id=ubd45de4d&originHeight=1218&originWidth=848&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ue0d5db71-4752-4c7f-8b65-df955b03341&title=)
