介绍一款轻量、快速、稳定可编排的组件式规则引擎框架LiteFlow。
<a name="qaBEb"></a>
## 一、LiteFlow的介绍
LiteFlow官方网站和代码仓库地址<br />官方网站：[https://yomahub.com/liteflow](https://yomahub.com/liteflow)<br />Gitee托管仓库：[https://gitee.com/dromara/liteFlow](https://gitee.com/dromara/liteFlow)<br />Github托管仓库：[https://github.com/dromara/liteflow](https://github.com/dromara/liteflow)
<a name="HMdRl"></a>
### 前言
在每个公司的系统中，总有一些拥有复杂业务逻辑的系统，这些系统承载着核心业务逻辑，几乎每个需求都和这些核心业务有关，这些核心业务业务逻辑冗长，涉及内部逻辑运算，缓存操作，持久化操作，外部资源调取，内部其他系统RPC调用等等。时间一长，项目几经易手，维护的成本就会越来越高。各种硬代码判断，分支条件越来越多。代码的抽象，复用率也越来越低，各个模块之间的耦合度很高。一小段逻辑的变动，会影响到其他模块，需要进行完整回归测试来验证。如要灵活改变业务流程的顺序，则要进行代码大改动进行抽象，重新写方法。实时热变更业务流程，几乎很难实现。
<a name="e9Hr6"></a>
### LiteFlow框架的作用
LiteFlow就是为解耦复杂逻辑而生，如果要对复杂业务逻辑进行新写或者重构，用LiteFlow最合适不过。它是一个轻量，快速的组件式流程引擎框架，组件编排，帮助解耦业务代码，让每一个业务片段都是一个组件，并支持热加载规则配置，实现即时修改。<br />使用LiteFlow，需要去把复杂的业务逻辑按代码片段拆分成一个个小组件，并定义一个规则流程配置。这样，所有的组件，就能按照规则配置去进行复杂的流转。
<a name="uQ57f"></a>
### LiteFlow的设计原则
LiteFlow是基于工作台模式进行设计的，何谓工作台模式？<br />n个工人按照一定顺序围着一张工作台，按顺序各自生产零件，生产的零件最终能组装成一个机器，每个工人只需要完成自己手中零件的生产，而无需知道其他工人生产的内容。每一个工人生产所需要的资源都从工作台上拿取，如果工作台上有生产所必须的资源，则就进行生产，若是没有，就等到有这个资源。每个工人所做好的零件，也都放在工作台上。<br />这个模式有几个好处：

- 每个工人无需和其他工人进行沟通。工人只需要关心自己的工作内容和工作台上的资源。这样就做到了每个工人之间的解耦和无差异性。
- 即便是工人之间调换位置，工人的工作内容和关心的资源没有任何变化。这样就保证了每个工人的稳定性。
- 如果是指派某个工人去其他的工作台，工人的工作内容和需要的资源依旧没有任何变化，这样就做到了工人的可复用性。
- 因为每个工人不需要和其他工人沟通，所以可以在生产任务进行时进行实时工位更改：替换，插入，撤掉一些工人，这样生产任务也能实时地被更改。这样就保证了整个生产任务的灵活性。

这个模式映射到LiteFlow框架里，工人就是组件，工人坐的顺序就是流程配置，工作台就是上下文，资源就是参数，最终组装的这个机器就是这个业务。正因为有这些特性，所以LiteFlow能做到统一解耦的组件和灵活的装配。
<a name="snr2P"></a>
## **二、LiteFlow的使用**
<a name="sizok"></a>
### 1）非Spring环境下
引入pom依赖
```xml
<dependency>
   <groupId>com.yomahub</groupId>
   <artifactId>liteflow-core</artifactId>
   <version>2.6.13</version>
</dependency>
```
第一步构建自己的业务Node，也就是继承`NodeComponent`，重写`process`方法，业务执行的过程中，会调用`process`来执行节点的业务。<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1698801596715-fa72c48c-3e02-4c66-9be8-5fc8a3dd502e.png#averageHue=%232e2d2c&clientId=ud3cac966-4481-4&from=paste&id=u3d4e2394&originHeight=364&originWidth=988&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u8c64d236-553b-415f-adc0-8d3e566ff7c&title=)<br />这里写了三个<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1698801596698-e55a4589-a91e-4b80-8c88-d2d2c6d60c3d.png#averageHue=%233e4245&clientId=ud3cac966-4481-4&from=paste&id=u033a86e7&originHeight=258&originWidth=564&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u64b83a97-3492-4d24-ad9c-117842874a8&title=)<br />然后编写xml文件，直接放在resources底下<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1698801596725-3848704d-b9c9-4c17-83e2-3bb9ab4fb96b.png#averageHue=%232f2e2d&clientId=ud3cac966-4481-4&from=paste&id=uad207120&originHeight=493&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u1861aa1c-8c0c-497a-9b00-38e8690793f&title=)<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1698801596674-0cbbeabb-afc1-4ab5-8264-54e05a8e9f3d.png#averageHue=%233e4244&clientId=ud3cac966-4481-4&from=paste&id=ubfc5169c&originHeight=226&originWidth=484&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=ub0fa054b-fd7c-47f9-ac7b-7e723ee80c7&title=)<br />`<nodes/>`配置了每个业务的节点，这里配置了写的那几个，`<chain/>`标签代表了每一个业务的执行流程，配置了`<when/>`和`<then/>`标签，然后value标签设置了上面配置的`<node/>`的id，至于为什么这么配置，后面会解析。<br />然后执行这个demo<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1698801596706-f2909b7e-a088-4e12-8ae6-c7120e7aeea8.png#averageHue=%232c2c2b&clientId=ud3cac966-4481-4&from=paste&id=ub9ae515f&originHeight=409&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u82d545e0-bc99-4fc1-91e4-d4bfec46b1a&title=)<br />构建了一个`LiteflowConfig`，传入xml的路径，然后构建`FlowExecutor`，最后调用`FlowExecutor`的execute2Resp，传入需要执行的业务流程名字 chain1 ，就是xml中配置的，执行业务流程。<br />结果<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1698801597010-a3c34854-6605-4d7b-ade4-9c07a869569d.png#averageHue=%23393131&clientId=ud3cac966-4481-4&from=paste&id=ufdbeca69&originHeight=388&originWidth=966&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u5cd3155c-467a-4ade-937d-9b423363f98&title=)<br />如果业务变动，现在不需要执行B流程了，那么直接修改规则文件就行了，如图。<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1698801597094-c948b79b-d45e-4579-9aa3-c2b2d46247e3.png#averageHue=%23312e2d&clientId=ud3cac966-4481-4&from=paste&id=u34dce144&originHeight=531&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u434b179c-9c0b-4396-bbbd-9bc860bb45b&title=)<br />运行结果<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1698801597076-6e7520ca-1a4d-4167-8da4-ba58a00257f8.png#averageHue=%23383333&clientId=ud3cac966-4481-4&from=paste&id=u0b15a4de&originHeight=388&originWidth=862&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u494783cf-d31b-446a-9baa-8e08b3190ae&title=)<br />这里发现B就没执行了。
<a name="Lt72y"></a>
### 2）SpringBoot环境下
引入pom依赖
```xml
<dependency>
   <groupId>com.yomahub</groupId>
   <artifactId>liteflow-spring-boot-starter</artifactId>
   <version>2.6.13</version>
</dependency>
```
构建自己的业务Node，只不过在Spring的环境底下，可以不需要在xml配置`<node/>`标签，直接使用`@LiteflowComponent`注解即可<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1698801597316-d3ebf708-5bc3-4fed-8e0b-e9fe65e31760.png#averageHue=%232d2c2b&clientId=ud3cac966-4481-4&from=paste&id=u208bdef0&originHeight=388&originWidth=908&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u2c809eae-8cac-4069-a8f5-f7b9ab1ba50&title=)<br />xml中没有声明`<node/>`标签<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1698801597311-effc5d53-6fb6-45df-835f-1d2f1f389644.png#averageHue=%232f2f2d&clientId=ud3cac966-4481-4&from=paste&id=u91b9f483&originHeight=348&originWidth=696&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u5eafae31-47ce-47b4-9ec7-04abeceec62&title=)<br />application.properties中配置xml文件的路径<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1698801597411-3bb78d8d-88aa-4d99-b37a-0ae7939ac2f6.png#averageHue=%23976d3b&clientId=ud3cac966-4481-4&from=paste&id=u3576f96d&originHeight=260&originWidth=730&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u1bd0fdc7-5100-40ba-ba3e-c1a9297e786&title=)<br />测试代码<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1698801597462-ce6e3fa5-3b79-48b2-a585-bf6bcc0b47b5.png#averageHue=%232c2b2b&clientId=ud3cac966-4481-4&from=paste&id=ue1df0dab&originHeight=315&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=ue0d05574-9b2a-4447-98a0-f729f1d57b5&title=)<br />执行结果<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1698801597591-0beed844-d990-454d-9854-a925fd51691d.png#averageHue=%23333333&clientId=ud3cac966-4481-4&from=paste&id=u60acee57&originHeight=246&originWidth=582&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=udfdad22f-22c1-413a-9c2d-6d0bc5273d1&title=)<br />跟非spring的环境结果一致。<br />通过上面的例子可以看出，其实每个业务节点之间是没有耦合的，用户只需要按照一定的业务规则配置节点的执行顺序，LiteFlow就能实现业务的执行。
<a name="d1beV"></a>
## 三、LiteFlow核心组件讲解
讲解核心组件的时候如果有什么不是太明白的，可以继续往下看，后面会有源码解析。<br />下图为LiteFlow整体架构图<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1698801597754-1ec93922-90c4-4424-a0e2-33bd72d82f4a.png#averageHue=%232c2d37&clientId=ud3cac966-4481-4&from=paste&id=u96cbda72&originHeight=879&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=uec66d4f5-bdf7-4ba9-afe8-013e5d2b977&title=)
<a name="WOqDR"></a>
### 1）Parser
这个组件的作用就是用来解析流程配置的规则，也就是将配置的规则文件解析成Java代码来运行。支持的文件格式有xml、json、yaml，其实不论是什么格式，只是形式的不同，用户可根据自身配置的习惯来选择规则文件的格式。<br />同时，规则文件的存储目前官方支持基于zk或者本地文件的形式，同时也支持自定义的形式。<br />对于xml来说，`Parser`会将`<node/>`标签解析成Node对象，将`<chain/>`解析成`Chain`对象，将`<chain/>`内部的比如`<when/>`、`<then/>`等标签都会解析成`Condition`对象。<br />如下图所示。<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1698801597896-fd5658b8-c2ab-410f-8924-8df3b6e4fec5.png#averageHue=%23f3ece2&clientId=ud3cac966-4481-4&from=paste&id=ub7d7d1e4&originHeight=771&originWidth=1030&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=ud8c34958-ba98-4670-8d5a-55948902a75&title=)

- Node其实就是代表了具体业务执行的节点，就是真正的业务是在Node中执行的
- Condition可以理解为一种条件，比如前置条件，后置条件，里面一个Condition可以包含许多需要执行的Node
- Chain可以理解成整个业务执行的流程，按照一定的顺序来执行Condition中的Node也就是业务节点

Condition和Node的关系<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1698801597797-7dada595-2ab3-42b5-83f8-3a3891d29035.png#averageHue=%23ede2c9&clientId=ud3cac966-4481-4&from=paste&id=u597ac730&originHeight=251&originWidth=572&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=ua3b0b0de-1613-4761-afba-5a9c2d83a73&title=)<br />`Condition`分为以下几种

- `PreCondition`：在整个业务执行前执行，就是前置的作用
- `ThenCondition`：内部的Node是串行执行的
- `WhenCondition`：内部的Node是并行执行的
- `FinallyCondition`：当前面的Condition中的Node都执行完成之后，就会执行这个Condition中的Node节点

Chain和Condition的关系<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1698801597895-48a2bc4a-0422-4e6c-ad94-6e9f53f6e24e.png#averageHue=%23f6f6f6&clientId=ud3cac966-4481-4&from=paste&id=u10a77ad3&originHeight=336&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u9627a3bd-557d-4b81-8f50-b792cfa763c&title=)<br />Chain内部其实就是封装了一堆Condition，Chain的执行就是指从不同的Condition中拿出里面的Node来执行，首先会拿出来`PreCondition`中的Node节点来执行，执行完之后会执行`ThenCondition`和`WhenCondition`中的Node节点，最后执行完之后才会执行`FinallyCondition`中的Node节点。
<a name="otbfe"></a>
### 2）FlowBus
这个组件主要是用来存储上一步骤解析出来的Node和Chain的<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1698801597986-46265be2-a19b-4481-921a-784c26adbd67.png#averageHue=%23eee7cf&clientId=ud3cac966-4481-4&from=paste&id=u0b5abf60&originHeight=842&originWidth=602&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u929a1a15-5682-472d-a115-028688a9475&title=)
<a name="e0B0b"></a>
### 3）FlowExecutor
这个其实是用来执行上面解析出来的业务流程，从FlowBus找到需要执行的业务流程Chain，然后执行Chain，也就是按照Condition的顺序来分别执行每个Condition的Node，也就是业务节点。<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1698801598138-094b568f-7fe7-4579-b19a-b657d6cd8985.png#averageHue=%23f3efe2&clientId=ud3cac966-4481-4&from=paste&id=ub57fff37&originHeight=672&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=udba0df94-1c9a-404b-a1e8-6c2f94a997f&title=)
<a name="AIq1m"></a>
### 4）Slot
Slot可以理解为业务的上下文，在一个业务流程中，这个Slot是共享的。<br />Slot有个默认的实现`DefaultSlot`，`DefaultSlot`虽然可以用，但是在实际业务中，用这个会存在大量的弱类型，存取数据的时候都要进行强转，颇为不方便。所以官方建议自己去实现自己的Slot，可以继承AbsSlot。<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1698801598173-aef55d50-03b1-4015-ab50-47875e1a5db3.png#averageHue=%23f2f2f2&clientId=ud3cac966-4481-4&from=paste&id=ufee6487c&originHeight=392&originWidth=819&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u4164d636-9adf-4b7b-9227-83c39bd092c&title=)
<a name="RONG1"></a>
### 5）DataBus
用来管理Slot的，从这里面可以获取当前业务流程执行的Slot。
<a name="NcNvL"></a>
## 四、LiteFlow源码探究
说完核心的组件，接下来就来剖析一下源码，来看一看LiteFlow到底是如何实现规则编排的。
<a name="JifUV"></a>
### 1）FlowExecutor的构造流程
这里就以非Spring环境的例子来说，因为在SpringBoot环境底下，`FlowExecutor`是由Spring创建的，但是创建的过程跟非Spring的例子是一样的。<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1698801598340-45aa8d4e-f348-48ae-bfe8-33c08ef30c79.png#averageHue=%23312c2b&clientId=ud3cac966-4481-4&from=paste&id=u622d81dc&originHeight=398&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=ua03fdbde-d4c1-4af1-80d9-99b30fd87e9&title=)<br />这里在构建`FlowExecutor`，传入了一个规则的路径flow.xml，也就是`ruleSource`属性值。<br />进入`loadInstance`这个方法，其实就是直接new了一个`FlowExecutor`。<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1698801598428-b5c9611f-807d-4acb-ba9c-3ec429491a3a.png#averageHue=%23312e2d&clientId=ud3cac966-4481-4&from=paste&id=u49565429&originHeight=546&originWidth=1074&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=uf0e65379-7e16-46c9-a863-b6defca8cf3&title=)<br />进入`FlowExecutor`构造方法，前面就是简单的赋值操作。然后调用`liteflowConfig.isParseOnStart()`，这个方法默认是返回true的，接下来会调用`init`方法，也就是在启动时，就去解析规则文件，保证运行时的效率。<br />接下来进入`init`方法。<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1698801598396-5480f765-b0c2-417c-bf11-43f1acd4fc65.png#averageHue=%232c2b2b&clientId=ud3cac966-4481-4&from=paste&id=uebc6a08b&originHeight=2128&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u4a9a7853-0b1a-4d66-9531-05221399b87&title=)<br />init方法非常长，来一步一步解析<br />前面就是校验，不用care
```java
List<String> sourceRulePathList = Lists.newArrayList(liteflowConfig.getRuleSource().split(",|;"));
```
这行代码的意思就是将传入的规则文件路径进行分割成多个路径，从这可以看出支持配置多个规则的文件。对这个demo来说其实就是只有一个，那就是flow.xml。<br />分割完之后，就会遍历每个路径，然后判断文件的格式，比如xml、json、yaml，然后根据文件格式找到对应的`FlowParser`。<br />随后根据`liteflowConfig.isSupportMultipleType()`判断是不是支持多类型的，什么叫多类型，就是指规则文件配置了多个并且文件的格式不同，如果支持的话，需要每个规则文件单独去解析，如果不支持，那就说明文件的格式一定是相同的，相同可以在最后统一解析，解析是通过调用`FlowParser`的`parseMain`来解析的。<br />剖析完之后整个init方法就会结束，然后继续调用`DataBus`的init方法，其实就是初始化`DataBus`。<br />到这其实构建`FlowExecutor`就完成了，从上面得出一个结论，那就是在构造`FlowExecutor`的时候会通过FlowParser的`parseMain`来处理对应规则文件的路径，所以接下来分析一下这个`FlowParser`是如何解析xml的，并且解析了之后干了什么。
<a name="u8X1D"></a>
### 2）FlowParser规则解析流程
接下来进入`FlowParser`来看看一个是如何解析规则的。<br />以本文的例子为例，因为是配置本地的xml文件，找到的`FlowParser`的实现是`LocalXmlFlowParser`。<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1698801598458-bfa57281-405a-45db-bcb6-d8d599e5ce87.png#averageHue=%232d2c2b&clientId=ud3cac966-4481-4&from=paste&id=u79e126c5&originHeight=205&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=uaac09b5b-bb38-4a6b-8ef5-4d47345d25b&title=)<br />接下会调用`parseMain`方法，`parseMain`的方法的实现很简单，首先根据`PathContentParserHolder`拿到一个`PathContentParser`来解析路径，对上面案例来说，就是flow.xml路径，拿到路径对应文件的内容，其实就是拿到了flow.xml内容。然后调用父类的`parse`方法来解析xml的内容，所以`parse`方法才是解析xml的核心方法。<br />这里有个细节说一下，`PathContentParserHolder`其实内部使用了Java的SPI机制来加载`PathContentParser`的实现，然后解析路径，拿到内容，在Spring环境中默认基于Spring的实现的优先级高点，但是不论是怎么实现，作用都是一样的，那就是拿到路径对应的xml文件的内容，这里就不继续研究`PathContentParser`是如何加载文件的源码了。<br />其实不光是`PathContentParser`，LiteFlow内部使用了很多SPI机制，但是基本上整合Spring的实现的优先级都高于框架本身的实现。<br />接下来就来看一下`LocalXmlFlowParser`父类中的`parse`方法的实现。<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1698801598574-89065e5c-3295-4ee2-926a-aaffca3547e9.png#averageHue=%23332d2b&clientId=ud3cac966-4481-4&from=paste&id=ufdfa35df&originHeight=493&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u69308a3d-5b25-4cc7-b838-7f840e9966f&title=)<br />首先遍历每个文件中的内容，然后转成Document，Document其实是dom4j的包，其实就是将xml转成Java对象，这样可以通过Java中的方法来获取xml中每个标签的数据。<br />将文件都转换成Document之后，调用`parseDocument`方法。<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1698801598805-5c041d9f-e0a3-4627-8d1f-63aea4fdca12.png#averageHue=%232c2c2c&clientId=ud3cac966-4481-4&from=paste&id=u124631fc&originHeight=1953&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u1469b741-662b-4379-a953-a502f4b7b76&title=)<br />首先调用了`ContextCmpInitHolder.loadContextCmpInit().initCmp()` ，这行代码也是通过SPI机制来加载`ContextCmpInit`，调用initCmp方法。框架本身对于`initCmp`的实现是空实现，但是在Spring环境中，主要是用来整合Spring中的Node节点的，将Node节点添加到`FlowBus`中，这也是为什么在Spring环境中的那个案例中不需要在xml文件中配置`<nodes/>`的原因，因为LiteFlow会自动识别这些Node节点的Spring Bean。至于怎么整合Spring的，有兴趣的同学可以看一下`ComponentScanner`类的实现，主要在Bean初始化之后进行判断的，这里画一张图来总结一下`initCmp`方法的作用。<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1698801598828-38964a85-fd04-4c20-ac7c-f0d3b0f13b14.png#averageHue=%23f7f1e1&clientId=ud3cac966-4481-4&from=paste&id=ua9148dc7&originHeight=377&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u9a62b759-211f-45aa-a981-8a82315a0e0&title=)<br />至于为什么需要先将Spring中的Node节点添加到FlowBus，其实很简单，主要是因为构建Chain是需要Node，需要保证构建Chain之前，Spring中的Node节点都已经添加到了FlowBus中。<br />接下来就会继续遍历每个Document，也就是每个xml，然后拿到解析`<nodes></nodes>`中的每个`<node></node>`标签，拿出每个node标签中的属性，通过`LiteFlowNodeBuilder`构建Node，然后放入到FlowBus中，至于如何放入到FlowBus中，可以看一下`LiteFlowNodeBuilder`的build方法的实现。<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1698801598910-8e8adb12-4525-40b6-8473-8fda5e1dda31.png#averageHue=%23f4efe5&clientId=ud3cac966-4481-4&from=paste&id=u529bc89f&originHeight=270&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u7c928c23-acfa-41a4-b4e9-c97ca85a293&title=)<br />解析完Node之后，接下来就是解析<chain/>标签，拿到每一个`<chain/>`标签对应的Element之后，调用`parseOneChain`来解析`<chain/>`标签的内容。<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1698801599460-cb95d878-0f18-4fd7-97bb-ac3bedab8c40.png#averageHue=%232c2b2b&clientId=ud3cac966-4481-4&from=paste&id=ufcf4514b&originHeight=1365&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u1a536c34-995e-4000-a98a-6327798a7d7&title=)<br />`parseOneChain`方法，先拿到<chain/>底下所有的标签，然后判断标签类型，标签的类型主要有四种类型：`then`、`when`、`pre`、`finally`，然后拿到每个标签的值，构建对应的Condition，就是上文提到的`ThenCondition`、`WhenCondition`、`PreCondition`、`FinallyCondition`，然后加入到Chain中，至于如何将Node设置到Condition中，主要是通过`LiteFlowConditionBuilder`的`setValue`方法来实现的，`setValue`这个方式设置的值是条件标签的value属性值，然后解析value属性值，然后从`FlowBus`中clone一个新的Node，加入到Condition中，至于为什么需要clone一下新的Node，因为同一个业务节点，可能在不同的执行链中，为了保证不同业务中的同一个业务节点不相互干扰，所以得重新clone一个新的Node对象。<br />构建好Condition之后，都设置到了对应的Chain中，最后将Chain添加到FlowBus中。<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1698801599467-f1e7768a-4ffb-4111-bea8-82696e20a89b.png#averageHue=%23f4efe6&clientId=ud3cac966-4481-4&from=paste&id=u2d18f9c7&originHeight=281&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=ua39194be-b0e6-482e-bf48-c03cde49f2f&title=)<br />到这里，其实整个xml就解析完了，FlowParser的最主要的作用就是解析xml，根据配置构建Node、Condition和Chain对象，有了这些基础的组件之后，后面才能运行业务流程。其实从这里也可以看出是如何流程编排的，其实就是根据配置，将一个个Node添加到Condition中，Condition再添加到Chain中，这样相同的业务节点，可能分布在不同的Chain中，这样就实现了业务代码的复用和流程的编排。
<a name="ET3By"></a>
### 3）Chain的执行流程
剖析完`FlowParser`的作用，也就是Node和Chain的构造流程之后，接下来看一下Chain是如何执行的。<br />流程执行是通过`FlowExecutor`来执行的，`FlowExecutor`执行的方法很多，以上面demo调用的`execute2Resp`为例，最终会走到如下图的重载方法。<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1698801600174-e7ee1e30-d5e6-446c-804d-eaa11a337489.png#averageHue=%232d2b2b&clientId=ud3cac966-4481-4&from=paste&id=u488170a0&originHeight=366&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u5bb09d08-f15a-4a74-87fd-2aba530286f&title=)<br />`execute2Resp`方法就会调用`doExecute`方法的实现，然后拿到Slot，封装成一个`LiteflowResponse`返回回去，所以从这里可以看出，`doExecute`是核心方法。<br />接下来看看`doExecute`方法的实现。<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1698801600219-48b8b799-4163-4e3a-aee2-91e09aa7a8b2.png#averageHue=%232c2b2b&clientId=ud3cac966-4481-4&from=paste&id=ud3989141&originHeight=921&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u59503ba6-b891-464a-82a6-34ed327048e&title=)<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1698801600267-fd517d95-69d4-4ef2-8e87-54e11eba5acd.png#averageHue=%232e2b2b&clientId=ud3cac966-4481-4&from=paste&id=uedb0d019&originHeight=906&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=ubc726f98-c8ee-42fa-befd-f24633766e7&title=)<br />`doExecute`方法比较长，截了两张图<br />首先从`DataBus`中获取一个Slot，也就是当前业务执行的上下文。之后从FlowBus中获取需要执行的Chain，最后分别调用了Chain的`executePre`、`execute`、`executeFinally`方法，其实不用看也知道这些方法干了什么，其实就是调用不同的`Condition`中Node方法。<br />`executePre`和`executeFinally`方法<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1698801600337-3a8ede15-082c-4456-8773-fd8705a1617e.png#averageHue=%232f2c2c&clientId=ud3cac966-4481-4&from=paste&id=ua7683f7a&originHeight=467&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=ub5ae3241-45da-434d-b6fe-0a41cd81d5e&title=)<br />这两个方法最后调用的是同一个方法，就是分别找到`PreCondition`和`FinallyCondition`，取出里面的Node节点，执行`excute`方法。<br />这里有重点说明一下，其实在`Condition`中存的不是直接的Node，而是`Executable`，`Executable`的有两个实现，一个就是所说的Node，还有一个就是一直说的Chain，为了方便大家理解，一直说的是Node，其实这里的`Executable`是有可能为Chain的，取决于规则的配置。当是一个Chain的时候，其实就是一个嵌套的子流程，也就是在一个流程中嵌套另一个流程的意思，大家注意一下就行了，其实不论怎么嵌套，流程执行到最后一定是Node，因为如果是Chain，那么还会继续执行，不会停止，只有最后一个流程的`Executable`都是Node的时候流程才能执行完。<br />`executePre`和`executeFinally`方法说完之后，看一看`execute`方法的实现。<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1698801601109-549153a6-448a-4545-99d5-6c78a8850710.png#averageHue=%232c2b2b&clientId=ud3cac966-4481-4&from=paste&id=uac688cf9&originHeight=498&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u0788a87a-8691-4570-8416-96804b1a56c&title=)<br />`execute`方法主要是判断`Condition`的类型，然后判断是`ThenCondition`还是`WhenCondition`，`ThenCondition`的话其实也就是拿出Node直接执行，如果是`WhenCondition`的话，其实就是并行执行每个Node节点。这也是`ThenCondition`和`WhenCondition`的主要区别。<br />画图总结一下Chain的执行流程<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1698801601330-70496778-fac9-4da7-b981-0fd86777c8d9.png#averageHue=%23f3f3f3&clientId=ud3cac966-4481-4&from=paste&id=ud870267b&originHeight=453&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u38178cda-2151-4ea1-b26e-308f37e81f8&title=)
<a name="WDRiT"></a>
### 4）Node的执行流程
从上面可以看出，Chain的执行其实最终都是交给Node来执行的，只不过是不同阶段调用不同的Node而已，其实最终也就是会调用Node的`execute`方法，所以就来着重看一下Node的`execute`方法。<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1698801601573-118fa82b-e9a7-4c0d-b56f-220347efa8ca.png#averageHue=%232f2d2d&clientId=ud3cac966-4481-4&from=paste&id=uc03a7458&originHeight=857&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u7a40f96e-4790-4e50-9db5-2a75e2f7d26&title=)<br />`instance`就是`NodeComponent`对象，也就是自定义实现的节点对象，好家伙，终于要执行到业务了。有人可能好奇`NodeComponent`是如何设置到Node对象中的，其实就是在往FlowBus添加Node的时候设置的，不清楚的小伙伴可以翻一下那块相关的源码，在解析xml那块有说过。<br />先调用`NodeComponent`的`isAccess`方法来判断业务要不要执行，默认是true，可以重写这个方法，自己根据其它节点执行的情况来判断当前业务的节点要不要执行，因为Slot是公共的，每个业务节点的执行结果可以放在Slot中。<br />随后通过这个方法获取了`NodeExecutor`，`NodeExecutor`可以通过`execute`方法来执行`NodeComponent`的，也就是来执行业务的，`NodeExecutor`默认是使用`DefaultNodeExecutor`子类的，当然也可以自定义`NodeExecutor`来执行`NodeComponent`
```java
NodeExecutor nodeExecutor = NodeExecutorHelper.loadInstance().buildNodeExecutor(instance.getNodeExecutorClass());
```
`DefaultNodeExecutor`的`execute`方法也是直接调用父类`NodeExecutor`的`execute`方法，接下来看一下`NodeExecutor`的`execute`方法。<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1698801601920-d68626d9-6dff-445e-b510-e8e3ec967627.png#averageHue=%232d2c2c&clientId=ud3cac966-4481-4&from=paste&id=ua33ed609&originHeight=701&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=uac5fe8c4-0baf-4ec0-9553-11198ef53d1&title=)<br />从这个方法的实现可以看出，LiteFlow对于业务的执行是支持重试功能的，但是不论怎么重试，最终一定调用的是`NodeComponent`的`execute`方法。<br />进入`NodeComponent`的`execute`方法<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1698801602136-c87ec4fb-03ba-4aa2-9f90-6b69eb639aca.png#averageHue=%232d2b2b&clientId=ud3cac966-4481-4&from=paste&id=ufd54301d&originHeight=838&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u6b19d18e-f89c-4532-9ab8-3cbcd2ca7da&title=)<br />红框圈出来的，就是核心代码，self是一个变量，指的是当前这个`NodeComponent`对象，所以就直接调用当前这个`NodeComponent`的`process`方法，也就是用来执行业务的方法。<br />在执行`NodeComponent`的`process`方法前后其实有回调的，也就是可以实现拦截的效果，在Spring环境中会生效。<br />至于这里为什么要使用self变量而不是直接使用this，其实源码也有注释，简单点说就是如果process方法被动态代理了，那么直接使用this的话，动态代理会不生效，所以为了防止动态代理不生效，就单独使用了self变量来引用自己。至于为什么不生效，这是属于Spring的范畴了，这里就不过多赘述了。<br />其实到这里，一个Node就执行完成了，Node的执行其实就是在执行`NodeComponent`，而`NodeComponent`其实最终是交给`NodeExecutor`来执行的。<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1698801602360-e2663098-7327-49fa-9459-773b30f7dc98.png#averageHue=%23f6f1ee&clientId=ud3cac966-4481-4&from=paste&id=u5fa51a69&originHeight=505&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=ub60810f4-bfaa-4098-8bb5-14023b112a0&title=)<br />每个Condition中的Node执行完之后，就将Slot返回，这样就能在调用方就能通过Slot拿到整个流程的执行结果了。<br />到这里，其实核心流程源码剖析就完成了，总的来说就是将规则配置文件翻译成代码，生成Node和Chain，然后通过调用Chain来执行业务流程，最终其实就是执行实现的`NodeComponent`的`process`方法。<br />最终画一张图来总结整个核心源码。<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1698801602643-18c5271a-b279-4088-b8d2-eba3d2c5e1de.png#averageHue=%23f6f4f0&clientId=ud3cac966-4481-4&from=paste&id=ue8d0d91c&originHeight=502&originWidth=922&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=ud1632b11-351f-4f30-9841-a0d98c79dba&title=)<br />图中省略了Condition的示意图，因为Condition其实最终也是执行Node的。
