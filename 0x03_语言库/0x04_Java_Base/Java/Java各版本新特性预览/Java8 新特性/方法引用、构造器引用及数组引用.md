Java 方法引用 构造器引用 数组引用
<a name="Oj4ZO"></a>
## 一、方法引用
若Lambda体中的内容有方法已经实现了，可以使用“方法引用”（可以理解为方法引用是Lambda表达式的另外一种表现形式）代替Lambda表达式。<br />方法引用使用一对冒号`::`，通过方法的名字来指向一个方法。<br />方法引用可以使语言的构造更紧凑简洁，减少冗余代码。<br />以前的Lambda表达式的实现写法
```java
Consumer consumer = (x) -> System.out.println(x);
```
可以看出Lambda体中的内容已经由`println()`方法做了实现，那么可以直接引用该方法，而不用再写他的实现进行调用
```java
Consumer<String> consumer = (x) -> System.out.println(x);
consumer.accept("一般的Lambda实现");
Consumer<String> stringConsumer = System.out::println;
stringConsumer.accept("使用同类型的方法进行引用实现");
```
:::danger
注意：引用的方法必须和函数式接口的参数返回值保持一致性
:::
![image.png](https://cdn.nlark.com/yuque/0/2020/png/396745/1582168664662-22973b1c-7ec7-4785-98b4-3993703727fd.png#height=728&id=bte17&originHeight=728&originWidth=1366&originalType=binary&size=180514&status=done&style=none&width=1366)
<a name="vlit2"></a>
### 语法格式
<a name="wt5FF"></a>
#### ①对象实例方法引用-`对象::实例方法名`
```java
// 对象::实例方法名
@Test
public void methodTest() {
    Consumer<String> consumer = (x) -> System.out.println(x);
    consumer.accept("一般的Lambda实现");
    Consumer<String> stringConsumer = System.out::println;
    stringConsumer.accept("使用同类型的方法进行引用实现");

    // getName()是employee对象的实例方法
    Employee employee = new Employee("Fcant", 16, 1600);
    Supplier<String> stringSupplier = employee::getName;
    System.out.println(stringSupplier.get());
}
```
<a name="PsSmf"></a>
#### ②静态方法引用-`类::静态方法名`
```java
// 类::静态方法名
@Test
public void methodStaticTest() {
    Comparator<Integer> comparator = (x, y) -> Integer.compare(x, y);
    Comparator<Integer> integerComparator = Integer::compare;
}
```
![image.png](https://cdn.nlark.com/yuque/0/2020/png/396745/1582176963479-cc256aed-f795-498e-b9be-eb07457cd01d.png#height=728&id=ZJ9ld&originHeight=728&originWidth=1366&originalType=binary&size=127126&status=done&style=none&width=1366)
<a name="uFDjb"></a>
#### ③类实例方法引用-`类::实例方法名`
若Lambda参数列表中的第一参数是实例方法的调用者，而第二个参数是实例方法的参数时，可以使用类名::方法名
```java
// 类::实例方法名
@Test
public void Test() {
    BiPredicate<String, String> biPredicate = (x, y) -> x.equals(y);
    // 实例方法的第一个参数作为调用者，第二个参数作为调用者的参数，就可以使用类::实例方法名进行调用
    BiPredicate<String, String> stringBiPredicate = String::equals;
}
```
<a name="uEPGV"></a>
## 二、构造器引用
<a name="Ajjdy"></a>
### 语法格式：`ClassName::new;`
需要调用的构造器的参数列表与函数式接口中抽象方法的参数列表保持一致。
```java
// 构造器引用
@Test
public void constructTest() {
    Supplier<Employee> supplier = () -> new Employee();
    Supplier<Employee> employeeSupplier = Employee::new;
    System.out.println(employeeSupplier.get());

    Function<String, Employee> function = (x) -> new Employee(x);
    Function<String, Employee> employeeStringFunction = Employee::new;
    System.out.println(employeeStringFunction.apply("Fcant"));
}
```
Employee.java添加新的构造器
```java
public Employee(String name) {
    this.name = name;
}
```
<a name="OCO8o"></a>
## 三、数组引用
<a name="n96Lr"></a>
### 语法格式：`Type[]::new`；
```java
// 数组引用
@Test
public void typeTest() {
    Function<Integer, String[]> function = (x) -> new String[x];
    String[] strings = function.apply(10);
    System.out.println(strings.length);

    Function<Integer, String[]> integerFunction = String[]::new;
    String[] s = integerFunction.apply(20);
    System.out.println(s.length);
}
```
