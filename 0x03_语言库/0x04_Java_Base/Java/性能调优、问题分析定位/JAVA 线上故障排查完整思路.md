Java<br />线上故障主要会包括cpu、磁盘、内存以及网络问题，而大多数故障可能会包含不止一个层面的问题，所以进行排查时候尽量四个方面依次排查一遍。<br />同时例如jstack、jmap等工具也是不囿于一个方面的问题的，基本上出问题就是df、free、top 三连，然后依次jstack、jmap伺候，具体问题具体分析即可。
<a name="FUH4s"></a>
## CPU
一般来讲首先会排查cpu方面的问题。cpu异常往往还是比较好定位的。原因包括业务逻辑问题(死循环)、频繁gc以及上下文切换过多。而最常见的往往是业务逻辑(或者框架逻辑)导致的，可以使用jstack来分析对应的堆栈情况。
<a name="vJ7NR"></a>
### 使用jstack分析cpu问题
先用ps命令找到对应进程的pid(如果有好几个目标进程，可以先用top看一下哪个占用比较高)。<br />接着用`top -H -p pid`来找到cpu使用率比较高的一些线程<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1675127026962-ad251834-25b9-4699-8273-eb7e8aeb2569.png#averageHue=%23454545&clientId=ue10165c8-0e0c-4&from=paste&id=uf5db1ca6&originHeight=382&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1acb00e9-bd62-47be-9739-ba12a9be0a1&title=)<br />然后将占用最高的pid转换为16进制`printf '%x\n' pid`得到nid<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1675127027049-5b335614-ab50-4a52-822f-5a2facb9829a.png#averageHue=%23353535&clientId=ue10165c8-0e0c-4&from=paste&id=u154b6ed5&originHeight=76&originWidth=510&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6af52503-f1cd-4948-8df7-f16d942af92&title=)<br />接着直接在jstack中找到相应的堆栈信息`jstack pid |grep 'nid' -C5 –color`<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1675127027059-a977095a-a72b-454b-a225-07009bd65092.png#averageHue=%23373737&clientId=ue10165c8-0e0c-4&from=paste&id=u00a53686&originHeight=263&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ubccaf7ef-f5f5-4217-9e7f-e8bac3c54ad&title=)<br />可以看到已经找到了nid为0x42的堆栈信息，接着只要仔细分析一番即可。<br />当然更常见的是对整个jstack文件进行分析，通常会比较关注WAITING和TIMED_WAITING的部分，BLOCKED就不用说了。可以使用命令`cat jstack.log | grep "java.lang.Thread.State" | sort -nr | uniq -c`来对jstack的状态有一个整体的把握，如果WAITING之类的特别多，那么多半是有问题啦。<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1675127027012-56f465f3-c8d0-43d1-af26-d392dae0dbd2.png#averageHue=%233c3c3c&clientId=ue10165c8-0e0c-4&from=paste&id=u30c0f5c2&originHeight=220&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u58766b4f-24e0-42ac-bc06-edcd2c60446&title=)
<a name="GxMc3"></a>
### 频繁gc
当然还是会使用jstack来分析问题，但有时候可以先确定下gc是不是太频繁，使用jstat -gc pid 1000命令来对gc分代变化情况进行观察，1000表示采样间隔(ms)，S0C/S1C、S0U/S1U、EC/EU、OC/OU、MC/MU分别代表两个Survivor区、Eden区、老年代、元数据区的容量和使用量。YGC/YGT、FGC/FGCT、GCT则代表YoungGc、FullGc的耗时和次数以及总耗时。如果看到gc比较频繁，再针对gc方面做进一步分析。<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1675127027013-b544be5f-9089-43bb-9abe-a4a5c7ac0d19.png#averageHue=%233d3d3d&clientId=ue10165c8-0e0c-4&from=paste&id=u11c21bb5&originHeight=122&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1475df5b-1d32-40df-9f30-00e9339ef44&title=)
<a name="U88jq"></a>
### 上下文切换
针对频繁上下文问题，可以使用vmstat命令来进行查看<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1675127027416-ee9883dd-694e-48e8-abff-f6b5817a9490.png#averageHue=%23393939&clientId=ue10165c8-0e0c-4&from=paste&id=uc7093c6e&originHeight=240&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u5bd22ae0-3f0f-4641-a6bf-4480763a2ad&title=)<br />cs(context switch)一列则代表了上下文切换的次数。<br />如果希望对特定的pid进行监控那么可以使用 `pidstat -w pid`命令，cswch和nvcswch表示自愿及非自愿切换。<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1675127027406-b69e47d5-49fb-46e8-b81f-7ae4a3481f06.png#averageHue=%23363636&clientId=ue10165c8-0e0c-4&from=paste&id=uad10165c&originHeight=432&originWidth=922&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ufa08c76b-a28f-4736-873f-25d223a0259&title=)
<a name="tw4Ln"></a>
## 磁盘
磁盘问题和cpu一样是属于比较基础的。首先是磁盘空间方面，直接使用`df -hl`来查看文件系统状态<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1675127027398-fb3f6614-c8eb-4e33-a326-75fea80433be.png#averageHue=%233a3a3a&clientId=ue10165c8-0e0c-4&from=paste&id=uf39f8dce&originHeight=137&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uebec425f-11d3-4fdc-80c2-e7fd0f8a666&title=)<br />更多时候，磁盘问题还是性能上的问题。可以通过`iostatiostat -d -k -x`来进行分析<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1675127027462-47c5f7d9-deaf-46e6-bc19-ae4d33f74c0d.png#averageHue=%23373737&clientId=ue10165c8-0e0c-4&from=paste&id=u8e8817e1&originHeight=241&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ub11f99ff-1b8a-440e-bf6b-6dae260caab&title=)<br />最后一列%util可以看到每块磁盘写入的程度，而rrqpm/s以及wrqm/s分别表示读写速度，一般就能帮助定位到具体哪块磁盘出现问题了。<br />另外还需要知道是哪个进程在进行读写，一般来说开发自己心里有数，或者用iotop命令来进行定位文件读写的来源。<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1675127027534-94e24be8-9a31-4a46-b152-0cf93b4b169c.png#averageHue=%233d3d3d&clientId=ue10165c8-0e0c-4&from=paste&id=ue43c79cd&originHeight=273&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u4efd3f6b-22eb-4695-92d1-0ada7641e0f&title=)<br />不过这边拿到的是tid，要转换成pid，可以通过readlink来找到`pidreadlink -f /proc/*/task/tid/../..`。<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1675127027828-20f017b2-b31f-4f06-b373-c3182327788f.png#averageHue=%23383838&clientId=ue10165c8-0e0c-4&from=paste&id=ucacdc797&originHeight=84&originWidth=944&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8f599a8c-d025-4fc1-9ad2-d1890142f94&title=)<br />找到pid之后就可以看这个进程具体的读写情况cat /proc/pid/io<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1675127027840-87ae2447-ec4e-4528-bd95-a14b5625ac1e.png#averageHue=%233b3b3b&clientId=ue10165c8-0e0c-4&from=paste&id=u3a7e9040&originHeight=282&originWidth=660&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua84092c2-31e9-4495-860b-31818a554bf&title=)<br />还可以通过lsof命令来确定具体的文件读写情况`lsof -p pid`<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1675127027787-598cd5db-220e-413e-94ad-1c94fd27c301.png#averageHue=%233c3c3c&clientId=ue10165c8-0e0c-4&from=paste&id=u00e2c0e2&originHeight=614&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ubb31ab0b-1776-49f8-b8de-dd653f6ae71&title=)
<a name="PXUtr"></a>
## 内存
内存问题排查起来相对比CPU麻烦一些，场景也比较多。主要包括OOM、GC问题和堆外内存。一般来讲，会先用free命令先来检查一发内存的各种情况。<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1675127027835-020cac15-01b1-45a2-8427-d133f5f6fb19.png#averageHue=%23363636&clientId=ue10165c8-0e0c-4&from=paste&id=uf32566c8&originHeight=125&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ued23dff1-2c5e-488d-a146-e7e2d225e20&title=)
<a name="vgisk"></a>
### 堆内内存
内存问题大多还都是堆内内存问题。表象上主要分为OOM和StackOverflow。
<a name="mnivF"></a>
#### OOM
JMV中的内存不足，OOM大致可以分为以下几种：<br />Exception in thread "main" java.lang.OutOfMemoryError: unable to create new native thread<br />这个意思是没有足够的内存空间给线程分配java栈，基本上还是线程池代码写的有问题，比如说忘记shutdown，所以说应该首先从代码层面来寻找问题，使用jstack或者jmap。如果一切都正常，JVM方面可以通过指定Xss来减少单个thread stack的大小。<br />另外也可以在系统层面，可以通过修改/etc/security/limits.confnofile和nproc来增大os对线程的限制<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1675127027990-c7abd327-2752-4d94-9ec2-5abaa5a20115.png#averageHue=%233f3f3f&clientId=ue10165c8-0e0c-4&from=paste&id=u7d9a59e2&originHeight=152&originWidth=326&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uef5e7116-cb61-455f-b514-a03fa530cd5&title=)<br />Exception in thread "main" java.lang.OutOfMemoryError: Java heap space<br />这个意思是堆的内存占用已经达到-Xmx设置的最大值，应该是最常见的OOM错误了。解决思路仍然是先应该在代码中找，怀疑存在内存泄漏，通过jstack和jmap去定位问题。如果说一切都正常，才需要通过调整Xmx的值来扩大内存。<br />Caused by: java.lang.OutOfMemoryError: Meta space<br />这个意思是元数据区的内存占用已经达到XX:MaxMetaspaceSize设置的最大值，排查思路和上面的一致，参数方面可以通过XX:MaxPermSize来进行调整(这里就不说1.8以前的永久代了)。
<a name="cPfQ2"></a>
#### Stack Overflow
栈内存溢出，这个大家见到也比较多。<br />Exception in thread "main" java.lang.StackOverflowError<br />表示线程栈需要的内存大于Xss值，同样也是先进行排查，参数方面通过Xss来调整，但调整的太大可能又会引起OOM。
<a name="I2MZq"></a>
#### 使用JMAP定位代码内存泄漏
上述关于OOM和StackOverflow的代码排查方面，一般使用JMAP `jmap -dump:format=b,file=filename pid`来导出dump文件<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1675127028206-7b8656eb-23cd-418f-a0d9-efe82b6d71fa.png#averageHue=%23434543&clientId=ue10165c8-0e0c-4&from=paste&id=ud24e8fa8&originHeight=114&originWidth=742&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u66dbe8a1-fa4e-4e1c-966d-85baf49e7cb&title=)<br />通过mat(Eclipse Memory Analysis Tools)导入dump文件进行分析，内存泄漏问题一般直接选Leak Suspects即可，mat给出了内存泄漏的建议。另外也可以选择Top Consumers来查看最大对象报告。和线程相关的问题可以选择thread overview进行分析。除此之外就是选择Histogram类概览来自己慢慢分析，大家可以搜搜mat的相关教程。<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1675127028165-2ca9c470-c99f-4465-8877-65b12aae485a.png#averageHue=%23f2f2f2&clientId=ue10165c8-0e0c-4&from=paste&id=uaf55a0e0&originHeight=833&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u9a40d817-8d24-4656-ad53-3a9465ea4c8&title=)<br />日常开发中，代码产生内存泄漏是比较常见的事，并且比较隐蔽，需要开发者更加关注细节。比如说每次请求都new对象，导致大量重复创建对象；进行文件流操作但未正确关闭；手动不当触发gc；ByteBuffer缓存分配不合理等都会造成代码OOM。<br />另一方面，可以在启动参数中指定`-XX:+HeapDumpOnOutOfMemoryError`来保存OOM时的dump文件。
<a name="usNqj"></a>
#### gc问题和线程
gc问题除了影响cpu也会影响内存，排查思路也是一致的。一般先使用jstat来查看分代变化情况，比如youngGC或者fullGC次数是不是太多呀；EU、OU等指标增长是不是异常呀等。<br />线程的话太多而且不被及时gc也会引发oom，大部分就是之前说的unable to create new native thread。除了jstack细细分析dump文件外，一般先会看下总体线程，通过`pstreee -p pid |wc -l`。<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1675127028304-18d423d4-54ec-420e-9309-27de2e0fe86d.png#averageHue=%23363636&clientId=ue10165c8-0e0c-4&from=paste&id=u14d1d49c&originHeight=72&originWidth=454&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uecbc043e-3ba3-48c6-b48d-0c452841d92&title=)<br />或者直接通过查看/proc/pid/task的数量即为线程数量。<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1675127028395-ccec4841-143b-4174-9cdf-f0acb2f71757.png#averageHue=%23383838&clientId=ue10165c8-0e0c-4&from=paste&id=ue02ea710&originHeight=66&originWidth=518&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6265dcda-776a-4cf2-8d96-3cbb34e3fd7&title=)
<a name="LtXyb"></a>
### 堆外内存
如果碰到堆外内存溢出，那可真是太不幸了。首先堆外内存溢出表现就是物理常驻内存增长快，报错的话视使用方式都不确定，如果由于使用Netty导致的，那错误日志里可能会出现OutOfDirectMemoryError错误，如果直接是DirectByteBuffer，那会报OutOfMemoryError: Direct buffer memory。<br />堆外内存溢出往往是和NIO的使用相关，一般先通过pmap来查看下进程占用的内存情况`pmap -x pid | sort -rn -k3 | head -30`，这段意思是查看对应pid倒序前30大的内存段。这边可以再一段时间后再跑一次命令看看内存增长情况，或者和正常机器比较可疑的内存段在哪里。<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1675127028435-0fc881c5-ce78-4f59-8075-94fac760ee70.png#averageHue=%233e3e3e&clientId=ue10165c8-0e0c-4&from=paste&id=u9d255d5b&originHeight=1126&originWidth=1022&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u70bb06b6-be0e-427b-857f-a858ca8946b&title=)<br />如果确定有可疑的内存端，需要通过gdb来分析`gdb --batch --pid {pid} -ex "dump memory filename.dump` {内存起始地址} {内存起始地址+内存块大小}"<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1675127028642-6a35a4d4-1f2b-47a7-95cc-1c8992ff80d0.png#averageHue=%233f3f3f&clientId=ue10165c8-0e0c-4&from=paste&id=u45599a5c&originHeight=36&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u4eb854bc-0f87-4bb6-8d62-8395f9291a1&title=)<br />获取dump文件后可用heaxdump进行查看`hexdump -C filename | less`，不过大多数看到的都是二进制乱码。<br />NMT是Java7U40引入的HotSpot新特性，配合jcmd命令就可以看到具体内存组成了。需要在启动参数中加入 `-XX:NativeMemoryTracking=summary` 或者 `-XX:NativeMemoryTracking=detail`，会有略微性能损耗。<br />一般对于堆外内存缓慢增长直到爆炸的情况来说，可以先设一个基线jcmd pid VM.native_memory baseline。<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1675127028685-59c10d36-eccb-469e-a367-a587d4c790fa.png#averageHue=%23373737&clientId=ue10165c8-0e0c-4&from=paste&id=u7b45e70e&originHeight=114&originWidth=690&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u71d30f42-205b-45ba-8333-f6b8dcb81e0&title=)<br />然后等放一段时间后再去看看内存增长的情况，通过`jcmd pid VM.native_memory detail.diff`(summary.diff)做一下summary或者detail级别的diff。<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1675127028670-4b3cade4-e223-4500-b1d3-5a0f0789b7f4.png#averageHue=%233c3c3c&clientId=ue10165c8-0e0c-4&from=paste&id=u98dbf5ff&originHeight=50&originWidth=638&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=udee4f892-403d-4d53-89cf-2df038d640a&title=)<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1675127028816-551d475f-962d-4456-a14a-aaadc9e2a049.png#averageHue=%23353535&clientId=ue10165c8-0e0c-4&from=paste&id=ua48bbe7e&originHeight=1125&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u58084765-c8ac-4497-98a5-e933890fe57&title=)<br />可以看到jcmd分析出来的内存十分详细，包括堆内、线程以及gc(所以上述其他内存异常其实都可以用nmt来分析)，这边堆外内存重点关注Internal的内存增长，如果增长十分明显的话那就是有问题了。<br />detail级别的话还会有具体内存段的增长情况，如下图。<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1675127029014-b39d5073-415d-448b-8b48-28d590c5b08f.png#averageHue=%23363636&clientId=ue10165c8-0e0c-4&from=paste&id=u5ee728c1&originHeight=138&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua76533e7-9469-434b-b4a8-cabe7eb922b&title=)<br />此外在系统层面，还可以使用strace命令来监控内存分配 `strace -f -e "brk,mmap,munmap" -p pid`<br />这边内存分配信息主要包括了pid和内存地址。<br />![](https://cdn.nlark.com/yuque/0/2023/jpeg/396745/1675127028988-9b9e02a0-a1e8-4abe-852e-43139c560310.jpeg#averageHue=%234f4f4f&clientId=ue10165c8-0e0c-4&from=paste&id=u3d7f1930&originHeight=324&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u0def264f-acd9-4d81-9dc5-90840b644bf&title=)<br />不过其实上面那些操作也很难定位到具体的问题点，关键还是要看错误日志栈，找到可疑的对象，搞清楚它的回收机制，然后去分析对应的对象。比如`DirectByteBuffer`分配内存的话，是需要full GC或者手动`system.gc`来进行回收的(所以最好不要使用`-XX:+DisableExplicitGC`)。<br />那么其实可以跟踪一下DirectByteBuffer对象的内存情况，通过jmap -histo:live pid手动触发fullGC来看看堆外内存有没有被回收。如果被回收了，那么大概率是堆外内存本身分配的太小了，通过-XX:MaxDirectMemorySize进行调整。如果没有什么变化，那就要使用jmap去分析那些不能被gc的对象，以及和DirectByteBuffer之间的引用关系了。
<a name="RKRp1"></a>
## GC问题
堆内内存泄漏总是和GC异常相伴。不过GC问题不只是和内存问题相关，还有可能引起CPU负载、网络问题等系列并发症，只是相对来说和内存联系紧密些，所以在此单独总结一下GC相关问题。<br />在cpu章介绍了使用jstat来获取当前GC分代变化信息。而更多时候，是通过GC日志来排查问题的，在启动参数中加上`-verbose:gc -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps`来开启GC日志。<br />常见的Young GC、Full GC日志含义在此就不做赘述了。<br />针对gc日志，就能大致推断出youngGC与fullGC是否过于频繁或者耗时过长，从而对症下药。下面将对G1垃圾收集器来做分析，这边也建议大家使用G1-XX:+UseG1GC。
<a name="bCKda"></a>
### youngGC过频繁
youngGC频繁一般是短周期小对象较多，先考虑是不是Eden区/新生代设置的太小了，看能否通过调整`-Xmn`、`-XX:SurvivorRatio`等参数设置来解决问题。如果参数正常，但是young gc频率还是太高，就需要使用Jmap和MAT对dump文件进行进一步排查了。
<a name="KtDFs"></a>
### youngGC耗时过长
耗时过长问题就要看GC日志里耗时耗在哪一块了。以G1日志为例，可以关注Root Scanning、Object Copy、Ref Proc等阶段。Ref Proc耗时长，就要注意引用相关的对象。<br />Root Scanning耗时长，就要注意线程数、跨代引用。Object Copy则需要关注对象生存周期。而且耗时分析它需要横向比较，就是和其他项目或者正常时间段的耗时比较。比如说图中的Root Scanning和正常时间段比增长较多，那就是起的线程太多了。<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1675127029104-120ae3e8-4a74-493a-b169-20d27025f314.png#averageHue=%23d5eaf3&clientId=ue10165c8-0e0c-4&from=paste&id=u69bd7e93&originHeight=790&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uf06981a2-9134-4f27-8b98-b623438058d&title=)
<a name="jyXkP"></a>
### 触发fullGC
G1中更多的还是mixedGC，但mixedGC可以和youngGC思路一样去排查。触发fullGC了一般都会有问题，G1会退化使用Serial收集器来完成垃圾的清理工作，暂停时长达到秒级别，可以说是半跪了。<br />fullGC的原因可能包括以下这些，以及参数调整方面的一些思路：

- 并发阶段失败：在并发标记阶段，MixGC之前老年代就被填满了，那么这时候G1就会放弃标记周期。这种情况，可能就需要增加堆大小，或者调整并发标记线程数`-XX:ConcGCThreads`。
- 晋升失败：在GC的时候没有足够的内存供存活/晋升对象使用，所以触发了Full GC。这时候可以通过`-XX:G1ReservePercent`来增加预留内存百分比，减少`-XX:InitiatingHeapOccupancyPercent`来提前启动标记，`-XX:ConcGCThreads`来增加标记线程数也是可以的。
- 大对象分配失败：大对象找不到合适的region空间进行分配，就会进行fullGC，这种情况下可以增大内存或者增大-XX:G1HeapRegionSize。
- 程序主动执行`System.gc()`：不要随便写就对了。

另外，可以在启动参数中配置`-XX:HeapDumpPath=/xxx/dump.hprof`来dump fullGC相关的文件，并通过jinfo来进行gc前后的dump
```bash
jinfo -flag +HeapDumpBeforeFullGC pid 
jinfo -flag +HeapDumpAfterFullGC pid
```
这样得到2份dump文件，对比后主要关注被gc掉的问题对象来定位问题。
<a name="hcr96"></a>
## 网络
涉及到网络层面的问题一般都比较复杂，场景多，定位难，成为了大多数开发的噩梦，应该是最复杂的了。这里会举一些例子，并从tcp层、应用层以及工具的使用等方面进行阐述。
<a name="PYHMb"></a>
### 超时
超时错误大部分处在应用层面，所以这块着重理解概念。超时大体可以分为连接超时和读写超时，某些使用连接池的客户端框架还会存在获取连接超时和空闲连接清理超时。

- 读写超时。readTimeout/writeTimeout，有些框架叫做so_timeout或者socketTimeout，均指的是数据读写超时。注意这边的超时大部分是指逻辑上的超时。soa的超时指的也是读超时。读写超时一般都只针对客户端设置。
- 连接超时。connectionTimeout，客户端通常指与服务端建立连接的最大时间。服务端这边connectionTimeout就有些五花八门了，jetty中表示空闲连接清理时间，tomcat则表示连接维持的最大时间。
- 其他。包括连接获取超时connectionAcquireTimeout和空闲连接清理超时idleConnectionTimeout。多用于使用连接池或队列的客户端或服务端框架。

在设置各种超时时间中，需要确认的是尽量保持客户端的超时小于服务端的超时，以保证连接正常结束。<br />在实际开发中，关心最多的应该是接口的读写超时了。<br />如何设置合理的接口超时是一个问题。如果接口超时设置的过长，那么有可能会过多地占用服务端的tcp连接。而如果接口设置的过短，那么接口超时就会非常频繁。<br />服务端接口明明rt降低，但客户端仍然一直超时又是另一个问题。这个问题其实很简单，客户端到服务端的链路包括网络传输、排队以及服务处理等，每一个环节都可能是耗时的原因。
<a name="FO8jT"></a>
### TCP队列溢出
tcp队列溢出是个相对底层的错误，它可能会造成超时、rst等更表层的错误。因此错误也更隐蔽，所以单独说一说。<br />![](https://cdn.nlark.com/yuque/0/2023/jpeg/396745/1675127029069-ef496e57-46c7-43f5-9022-c7ad84e48ee5.jpeg#averageHue=%23fbf9f9&clientId=ue10165c8-0e0c-4&from=paste&id=u3da41cbd&originHeight=698&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=udfaf3c62-c485-457e-88d2-9696b8d6bea&title=)<br />如上图所示，这里有两个队列：syns queue(半连接队列）、accept queue（全连接队列）。三次握手，在server收到client的syn后，把消息放到syns queue，回复syn+ack给client，server收到client的ack，如果这时accept queue没满，那就从syns queue拿出暂存的信息放入accept queue中，否则按tcp_abort_on_overflow指示的执行。<br />tcp_abort_on_overflow 0表示如果三次握手第三步的时候accept queue满了那么server扔掉client发过来的ack。tcp_abort_on_overflow 1则表示第三步的时候如果全连接队列满了，server发送一个rst包给client，表示废掉这个握手过程和这个连接，意味着日志里可能会有很多connection reset / connection reset by peer。<br />那么在实际开发中，怎么能快速定位到tcp队列溢出呢？<br />netstat命令，执行`netstat -s | egrep "listen|LISTEN"`<br />![](https://cdn.nlark.com/yuque/0/2023/jpeg/396745/1675127029352-afc5c219-6d1d-4f3c-a7e7-aeb810ffbeef.jpeg#averageHue=%23393939&clientId=ue10165c8-0e0c-4&from=paste&id=ue2b9d1de&originHeight=117&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uff7893f4-d735-4657-939d-aea4fb1c3b7&title=)<br />如上图所示，overflowed表示全连接队列溢出的次数，sockets dropped表示半连接队列溢出的次数。
<a name="h1rWk"></a>
#### ss命令，执行ss -lnt
![](https://cdn.nlark.com/yuque/0/2023/jpeg/396745/1675127029473-5bf3ece0-e758-4109-83a7-0dc57568b93d.jpeg#averageHue=%23343434&clientId=ue10165c8-0e0c-4&from=paste&id=u68020b55&originHeight=93&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u07234674-712b-4af0-8b22-d2f6e9759eb&title=)<br />上面看到Send-Q 表示第三列的listen端口上的全连接队列最大为5，第一列Recv-Q为全连接队列当前使用了多少。<br />接着看看怎么设置全连接、半连接队列大小吧：<br />全连接队列的大小取决于min(backlog, somaxconn)。backlog是在socket创建的时候传入的，somaxconn是一个os级别的系统参数。而半连接队列的大小取决于max(64, /proc/sys/net/ipv4/tcp_max_syn_backlog)。<br />在日常开发中，往往使用servlet容器作为服务端，所以有时候也需要关注容器的连接队列大小。在tomcat中backlog叫做acceptCount，在jetty里面则是acceptQueueSize。
<a name="lgozT"></a>
### RST异常
RST包表示连接重置，用于关闭一些无用的连接，通常表示异常关闭，区别于四次挥手。<br />在实际开发中，往往会看到connection reset / connection reset by peer错误，这种情况就是RST包导致的。
<a name="bs5vD"></a>
#### 端口不存在
如果像不存在的端口发出建立连接SYN请求，那么服务端发现自己并没有这个端口则会直接返回一个RST报文，用于中断连接。
<a name="ONb1N"></a>
#### 主动代替FIN终止连接
一般来说，正常的连接关闭都是需要通过FIN报文实现，然而也可以用RST报文来代替FIN，表示直接终止连接。实际开发中，可设置SO_LINGER数值来控制，这种往往是故意的，来跳过TIMED_WAIT，提供交互效率，不闲就慎用。<br />**客户端或服务端有一边发生了异常，该方向对端发送RST以告知关闭连接**<br />上面讲的tcp队列溢出发送RST包其实也是属于这一种。这种往往是由于某些原因，一方无法再能正常处理请求连接了(比如程序崩了，队列满了)，从而告知另一方关闭连接。<br />**接收到的TCP报文不在已知的TCP连接内**<br />比如，一方机器由于网络实在太差TCP报文失踪了，另一方关闭了该连接，然后过了许久收到了之前失踪的TCP报文，但由于对应的TCP连接已不存在，那么会直接发一个RST包以便开启新的连接。<br />**一方长期未收到另一方的确认报文，在一定时间或重传次数后发出RST报文**<br />这种大多也和网络环境相关了，网络环境差可能会导致更多的RST报文。<br />之前说过RST报文多会导致程序报错，在一个已关闭的连接上读操作会报connection reset，而在一个已关闭的连接上写操作则会报connection reset by peer。通常可能还会看到broken pipe错误，这是管道层面的错误，表示对已关闭的管道进行读写，往往是在收到RST，报出connection reset错后继续读写数据报的错，这个在glibc源码注释中也有介绍。<br />在排查故障时候怎么确定有RST包的存在呢？当然是使用tcpdump命令进行抓包，并使用wireshark进行简单分析了。`tcpdump -i en0 tcp -w xxx.cap`，en0表示监听的网卡。<br />![](https://cdn.nlark.com/yuque/0/2023/jpeg/396745/1675127029565-a5e0d95e-6361-49f8-b248-d84862de810e.jpeg#averageHue=%233a3a3a&clientId=ue10165c8-0e0c-4&from=paste&id=uab5d923e&originHeight=69&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=udccab723-803c-4bec-b1ae-b93a3e6a09d&title=)<br />接下来通过wireshark打开抓到的包，可能就能看到如下图所示，红色的就表示RST包了。<br />![](https://cdn.nlark.com/yuque/0/2023/jpeg/396745/1675127029547-7ce53d00-9c46-4b6a-b5f0-a9fceff2603d.jpeg#averageHue=%23cadab5&clientId=ue10165c8-0e0c-4&from=paste&id=u94205500&originHeight=225&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u7b91ffc4-a3f5-4942-82e6-ab23d5fa028&title=)
<a name="oTTBj"></a>
### TIME_WAIT和CLOSE_WAIT
TIME_WAIT和CLOSE_WAIT是啥意思相信大家都知道。<br />在线上时，可以直接用命令`netstat -n | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}'`来查看time-wait和close_wait的数量<br />用ss命令会更快`ss -ant | awk '{++S[$1]} END {for(a in S) print a, S[a]}'`
<a name="pgznY"></a>
### ![](https://cdn.nlark.com/yuque/0/2023/png/396745/1675127030025-a97c0430-79e7-460e-aac9-e56ac7344299.png#averageHue=%23343331&clientId=ue10165c8-0e0c-4&from=paste&id=u1532fe06&originHeight=131&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u562f0f75-ebe5-4f2b-9e9d-9c92ff69499&title=)
<a name="UvsyV"></a>
### TIME_WAIT
time_wait的存在一是为了丢失的数据包被后面连接复用，二是为了在2MSL的时间范围内正常关闭连接。它的存在其实会大大减少RST包的出现。<br />过多的time_wait在短连接频繁的场景比较容易出现。这种情况可以在服务端做一些内核参数调优:
```
#表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭
net.ipv4.tcp_tw_reuse = 1
#表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭
net.ipv4.tcp_tw_recycle = 1
```
当然不要忘记在NAT环境下因为时间戳错乱导致数据包被拒绝的坑了，另外的办法就是改小tcp_max_tw_buckets，超过这个数的time_wait都会被干掉，不过这也会导致报time wait bucket table overflow的错。
<a name="IouSM"></a>
### CLOSE_WAIT
close_wait往往都是因为应用程序写的有问题，没有在ACK后再次发起FIN报文。close_wait出现的概率甚至比time_wait要更高，后果也更严重。往往是由于某个地方阻塞住了，没有正常关闭连接，从而渐渐地消耗完所有的线程。<br />想要定位这类问题，最好是通过jstack来分析线程堆栈来排查问题，具体可参考上述章节。这里仅举一个例子。<br />开发同学说应用上线后CLOSE_WAIT就一直增多，直到挂掉为止，jstack后找到比较可疑的堆栈是大部分线程都卡在了countdownlatch.await方法，找开发同学了解后得知使用了多线程但是确没有catch异常，修改后发现异常仅仅是最简单的升级sdk后常出现的class not found。
