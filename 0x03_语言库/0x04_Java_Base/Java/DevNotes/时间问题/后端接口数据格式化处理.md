Java SpringMVC SpringBoot

:::info
以下主要针对项目中时间日期类型的数据返回的处理和Long型数据返回至前端，超过17为被JavaScript补零失真的处理（由于 JavaScript 中 Number 类型的自身原因，并不能完全表示 Long 型的数字，在 Long 长度大于`17`位时会出现精度丢失的问题。）
:::
<a name="bAGKy"></a>
## 1、对于Long型数据返回前端的解决思路

- 第一种办法：在后台把 long 型改为String类型，但是代价有点大，只要涉及到的地方都需要改
- 第二种办法：使用工具进行转化把 long 型改为String类型，这种方法可以实现全局转化（推荐）
- 第三种办法：前端进行处理（目前没有很好的办法，不推荐）

因为项目涉及到的代码非常多，所以不可能把 long 型改为 String 类型，而且使用 Long 类型的方法非常多，改起来风险非常大，所以不推荐使用！<br />最理想的方法，就是使用aop代理拦截所有的方法，对返回参数进行统一处理，使用工具进行转化，过程如下！
<a name="Qm5GF"></a>
### A.Jackson 工具序列化对象
可以使用`Jackson`工具包来实现对象序列化。
<a name="EQUea"></a>
#### 首先在 maven 中添加必须的依赖
```xml
<!--jackson依赖-->
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-core</artifactId>
    <version>2.9.8</version>
</dependency>
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-annotations</artifactId>
    <version>2.9.8</version>
</dependency>
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-databind</artifactId>
    <version>2.9.8</version>
</dependency>
```
<a name="QA87g"></a>
#### 编写转化工具类`JsonUtil`
```java
public class JsonUtil {

    private static final Logger log = LoggerFactory.getLogger(JsonUtil.class);

    private static ObjectMapper objectMapper = new ObjectMapper();
    private static final String DATE_FORMAT = "yyyy-MM-dd HH:mm:ss";

    static {
        // 对象的所有字段全部列入
        objectMapper.setSerializationInclusion(JsonInclude.Include.ALWAYS);
        // 取消默认转换timestamps形式
        objectMapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);
        // 忽略空bean转json的错误
        objectMapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);
        //设置为东八区
        objectMapper.setTimeZone(TimeZone.getTimeZone("GMT+8"));
        // 统一日期格式
        objectMapper.setDateFormat(new SimpleDateFormat(DATE_FORMAT));
        // 反序列化时,忽略在json字符串中存在, 但在java对象中不存在对应属性的情况, 防止错误
        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
        // 序列换成json时,将所有的long变成string
        objectMapper.registerModule(new SimpleModule().addSerializer(Long.class, ToStringSerializer.instance).addSerializer(Long.TYPE, ToStringSerializer.instance));
    }

    /**
     * 对象序列化成json字符串
     * @param obj
     * @param <T>
     * @return
     */
    public static <T> String objToStr(T obj) {
        if (null == obj) {
            return null;
        }

        try {
            return obj instanceof String ? (String) obj : objectMapper.writeValueAsString(obj);
        } catch (Exception e) {
            log.warn("objToStr error: ", e);
            return null;
        }
    }

    /**
     * json字符串反序列化成对象
     * @param str
     * @param clazz
     * @param <T>
     * @return
     */
    public static <T> T strToObj(String str, Class<T> clazz) {
        if (StringUtils.isBlank(str) || null == clazz) {
            return null;
        }

        try {
            return clazz.equals(String.class) ? (T) str : objectMapper.readValue(str, clazz);
        } catch (Exception e) {
            log.warn("strToObj error: ", e);
            return null;
        }
    }

    /**
     * json字符串反序列化成对象(数组)
     * @param str
     * @param typeReference
     * @param <T>
     * @return
     */
    public static <T> T strToObj(String str, TypeReference<T> typeReference) {
        if (StringUtils.isBlank(str) || null == typeReference) {
            return null;
        }

        try {
            return (T) (typeReference.getType().equals(String.class) ? str : objectMapper.readValue(str, typeReference));
        } catch (Exception e) {
            log.warn("strToObj error", e);
            return null;
        }
    }
}
```
<a name="bwwPc"></a>
### B.SpringMVC 配置
如果是 SpringMVC 项目，操作也很简单。
<a name="e661a46a"></a>
#### 自定义一个实现类，继承自`ObjectMapper`
```java
/**
 * 继承ObjectMapper
 */
public class CustomObjectMapper extends ObjectMapper {

    public CustomObjectMapper() {
        super();
        SimpleModule simpleModule = new SimpleModule();
        simpleModule.addSerializer(Long.class, ToStringSerializer.instance);
        simpleModule.addSerializer(Long.TYPE, ToStringSerializer.instance);
        registerModule(simpleModule);
    }
}
```
<a name="nOZWI"></a>
#### SpringMVC 的配置文件中加上如下配置
```xml
<mvc:annotation-driven >
    <mvc:message-converters>
        <bean class="org.springframework.http.converter.StringHttpMessageConverter">
            <constructor-arg index="0" value="utf-8" />
            <property name="supportedMediaTypes">
                <list>
                    <value>application/json;charset=UTF-8</value>
                    <value>text/plain;charset=UTF-8</value>
                </list>
            </property>
        </bean>          
        <bean class="org.springframework.http.converter.json.MappingJackson2HttpMessageConverter">
            <property name="objectMapper">
                <bean class="com.example.util.CustomObjectMapper">
                    <property name="dateFormat">
						<-对日期进行统一转化->
                        <bean class="java.text.SimpleDateFormat">
                            <constructor-arg type="java.lang.String" value="yyyy-MM-dd HH:mm:ss" />
                        </bean>
                    </property>
                </bean>
            </property>
        </bean>
    </mvc:message-converters>
</mvc:annotation-driven>
```
<a name="bLGPT"></a>
### C.SpringBoot 配置
如果是 SpringBoot 项目，操作也类似。

- 编写一个`WebConfig`配置类，并实现自`WebMvcConfigurer`，重写`configureMessageConverters`方法
```java
/**
 * WebMvc配置
 */
@Configuration
@Slf4j
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

    /**
     *添加消息转化类
     * @param list
     */
    @Override
    public void configureMessageConverters(List<HttpMessageConverter<?>> list) {
        MappingJackson2HttpMessageConverter jsonConverter = new MappingJackson2HttpMessageConverter();
        ObjectMapper objectMapper = jsonConverter.getObjectMapper();
		//序列换成json时,将所有的long变成string
        SimpleModule simpleModule = new SimpleModule();
        simpleModule.addSerializer(Long.class, ToStringSerializer.instance);
        simpleModule.addSerializer(Long.TYPE, ToStringSerializer.instance);
        objectMapper.registerModule(simpleModule);
        list.add(jsonConverter);
    }
}
```
<a name="iSEW7"></a>
#### 编写实体类`Person`，用于测试
```java

@Data
public class Person implements Serializable {

    private static final long serialVersionUID = 1L;

    private Integer id;

    //Long型参数
    private Long uid;
    private String name;
    private String address;
    private String mobile;

    private Date createTime;
}
```
<a name="9SGYi"></a>
#### 编写一个测试类测试一下效果
```java
public static void main(String[] args) {
    Person person = new Person();
    person.setId(1);
    person.setUid(1111L);
    person.setName("hello");
    person.setAddress("");
    System.out.println(JsonUtil.objToStr(person));
}
```
只需要对 aop 拦截的方法返回的参数，进行序列化就可以自动实现将所有的Long 变成 String。
<a name="vleL5"></a>
## 2、对日期的格式化
<a name="OhXWl"></a>
### 对全局的日期格式
```java
//全局统一日期格式
objectMapper.setDateFormat(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"));
```
<a name="Zncrc"></a>
### 对单个日期属性格式化
某个属性进行设置，例如对`createTime`属性格式化为`yyyy-MM-dd`，只需要加上如下注解即可。
```java
@JsonFormat(pattern="yyyy-MM-dd", timezone="GMT+8")
private Date createTime;
```

