Java
<a name="KWVb6"></a>
## **背景**
在高性能的服务架构设计中，缓存是一个不可或缺的环节。在实际的项目中，通常会将一些热点数据存储到Redis或Memcached 这类缓存中间件中，只有当缓存的访问没有命中时再查询数据库。在提升访问速度的同时，也能降低数据库的压力。<br />随着不断的发展，这一架构也产生了改进，在一些场景下可能单纯使用Redis类的远程缓存已经不够了，还需要进一步配合本地缓存使用，例如Guava cache或Caffeine，从而再次提升程序的响应速度与服务性能。于是，就产生了使用本地缓存作为一级缓存，再加上远程缓存作为二级缓存的两级缓存架构。<br />在先不考虑并发等复杂问题的情况下，两级缓存的访问流程可以用下面这张图来表示：<br />![2023-01-13-08-30-30.565450700.png](https://cdn.nlark.com/yuque/0/2023/png/396745/1673569972058-17a1c5a3-08f3-4fe4-a88c-43f23d57efe6.png#averageHue=%23f6f6f6&clientId=u02c89380-d3c4-4&from=ui&id=u47b73104&originHeight=478&originWidth=1003&originalType=binary&ratio=1&rotation=0&showTitle=false&size=37415&status=done&style=none&taskId=uc8371039-1323-42f8-bf94-311aeddf8c1&title=)
<a name="UhvNX"></a>
## **为什么要使用本地缓存**

- 本地缓存基于本地环境的内存，访问速度非常快，对于一些变更频率低、实时性要求低的数据，可以放在本地缓存中，提升访问速度
- 使用本地缓存能够减少和Redis类的远程缓存间的数据交互，减少网络I/O开销，降低这一过程中在网络通信上的耗时
<a name="uB3lN"></a>
## **设计一个本地内存需要有什么功能**

- 存储，并可以读、写；
- 原子操作(线程安全)，如ConcurrentHashMap
- 可以设置缓存的最大限制；
- 超过最大限制有对应淘汰策略，如LRU、LFU
- 过期时间淘汰，如定时、懒式、定期；
- 持久化
- 统计监控
<a name="xCrsU"></a>
## **本地缓存方案选型**
<a name="pJhg0"></a>
### 1、使用ConcurrentHashMap实现本地缓存
缓存的本质就是存储在内存中的KV数据结构，对应的就是jdk中线程安全的ConcurrentHashMap，但是要实现缓存，还需要考虑淘汰、最大限制、缓存过期时间淘汰等等功能；<br />优点是实现简单，不需要引入第三方包，比较适合一些简单的业务场景。缺点是如果需要更多的特性，需要定制化开发，成本会比较高，并且稳定性和可靠性也难以保障。对于比较复杂的场景，建议使用比较稳定的开源工具。
<a name="YGFS1"></a>
### 2、基于Guava Cache实现本地缓存
Guava是Google团队开源的一款 Java 核心增强库，包含集合、并发原语、缓存、IO、反射等工具箱，性能和稳定性上都有保障，应用十分广泛。Guava Cache支持很多特性：

- 支持最大容量限制
- 支持两种过期删除策略（插入时间和访问时间）
- 支持简单的统计功能
- 基于LRU算法实现

使用代码如下：
```xml
<dependency>
  <groupId>com.google.guava</groupId>
  <artifactId>guava</artifactId>
  <version>31.1-jre</version>
</dependency>
```
```java
@Slf4j
public class GuavaCacheTest {
    public static void main(String[] args) throws ExecutionException {
        Cache<String, String> cache = CacheBuilder.newBuilder()
                .initialCapacity(5)  // 初始容量
                .maximumSize(10)     // 最大缓存数，超出淘汰
                .expireAfterWrite(60, TimeUnit.SECONDS) // 过期时间
                .build();

        String orderId = String.valueOf(123456789);
        // 获取orderInfo，如果key不存在，callable中调用getInfo方法返回数据
        String orderInfo = cache.get(orderId, () -> getInfo(orderId));
        log.info("orderInfo = {}", orderInfo);

    }

    private static String getInfo(String orderId) {
        String info = "";
        // 先查询redis缓存
        log.info("get data from redis");

        // 当redis缓存不存在查db
        log.info("get data from mysql");
        info = String.format("{orderId=%s}", orderId);
        return info;
    }
}
```
<a name="BVMOS"></a>
### 3、Caffeine
Caffeine是基于java8实现的新一代缓存工具，缓存性能接近理论最优。可以看作是Guava Cache的增强版，功能上两者类似，不同的是Caffeine采用了一种结合LRU、LFU优点的算法：W-TinyLFU，在性能上有明显的优越性<br />使用代码如下：
```xml
<dependency>
    <groupId>com.github.ben-manes.caffeine</groupId>
    <artifactId>caffeine</artifactId>
    <version>2.9.3</version>
</dependency>
```
```java
@Slf4j
public class CaffeineTest {
    public static void main(String[] args) {
        Cache<String, String> cache = Caffeine.newBuilder()
                .initialCapacity(5)
                // 超出时淘汰
                .maximumSize(10)
                //设置写缓存后n秒钟过期
                .expireAfterWrite(60, TimeUnit.SECONDS)
                //设置读写缓存后n秒钟过期,实际很少用到,类似于expireAfterWrite
                //.expireAfterAccess(17, TimeUnit.SECONDS)
                .build();

        String orderId = String.valueOf(123456789);
        String orderInfo = cache.get(orderId, key -> getInfo(key));
        System.out.println(orderInfo);
    }

    private static String getInfo(String orderId) {
        String info = "";
        // 先查询redis缓存
        log.info("get data from redis");

        // 当redis缓存不存在查db
        log.info("get data from mysql");
        info = String.format("{orderId=%s}", orderId);
        return info;
    }
}
```
<a name="RlBGJ"></a>
### 4、Encache
Encache是一个纯Java的进程内缓存框架，具有快速、精干等特点，是Hibernate中默认的`CacheProvider`。同Caffeine和Guava Cache相比，Encache的功能更加丰富，扩展性更强：

- 支持多种缓存淘汰算法，包括LRU、LFU和FIFO
- 缓存支持堆内存储、堆外存储、磁盘存储（支持持久化）三种
- 支持多种集群方案，解决数据共享问题

使用代码如下：
```xml
<dependency>
   <groupId>org.ehcache</groupId>
   <artifactId>ehcache</artifactId>
   <version>3.9.7</version>
</dependency>
```
```java
@Slf4j
public class EhcacheTest {
    private static final String ORDER_CACHE = "orderCache";
    public static void main(String[] args) {
        CacheManager cacheManager = CacheManagerBuilder.newCacheManagerBuilder()
                // 创建cache实例
                .withCache(ORDER_CACHE, CacheConfigurationBuilder
                        // 声明一个容量为20的堆内缓存
                        .newCacheConfigurationBuilder(String.class, String.class, ResourcePoolsBuilder.heap(20)))
                .build(true);
        // 获取cache实例
        Cache<String, String> cache = cacheManager.getCache(ORDER_CACHE, String.class, String.class);

        String orderId = String.valueOf(123456789);
        String orderInfo = cache.get(orderId);
        if (StrUtil.isBlank(orderInfo)) {
            orderInfo = getInfo(orderId);
            cache.put(orderId, orderInfo);
        }
        log.info("orderInfo = {}", orderInfo);
    }

    private static String getInfo(String orderId) {
        String info = "";
        // 先查询redis缓存
        log.info("get data from redis");

        // 当redis缓存不存在查db
        log.info("get data from mysql");
        info = String.format("{orderId=%s}", orderId);
        return info;
    }
}
```
<a name="AQQJw"></a>
## **本地缓存问题及解决**
<a name="Uuh8D"></a>
### 1、缓存一致性
两级缓存与数据库的数据要保持一致，一旦数据发生了修改，在修改数据库的同时，本地缓存、远程缓存应该同步更新。
<a name="iA6Af"></a>
#### 解决方案1: MQ
一般现在部署都是集群部署，有多个不同节点的本地缓存; 可以使用MQ的广播模式，当数据修改时向MQ发送消息，节点监听并消费消息，删除本地缓存，达到最终一致性；<br />![2023-01-13-08-30-30.750300100.png](https://cdn.nlark.com/yuque/0/2023/png/396745/1673570019581-d516416c-2996-4e7b-860d-07f2db9d3711.png#averageHue=%23f4f4f4&clientId=u02c89380-d3c4-4&from=ui&id=u29775184&originHeight=260&originWidth=946&originalType=binary&ratio=1&rotation=0&showTitle=false&size=18985&status=done&style=none&taskId=uf49ec1cd-7178-4c3c-a5e6-8e51c5959b5&title=)
<a name="dsPhC"></a>
#### 解决方案2：Canal + MQ
如果不想在业务代码发送MQ消息，还可以适用近几年比较流行的方法：订阅数据库变更日志，再操作缓存。Canal 订阅Mysql的 Binlog日志，当发生变化时向MQ发送消息，进而也实现数据一致性。<br />![2023-01-13-08-30-30.984713100.png](https://cdn.nlark.com/yuque/0/2023/png/396745/1673570019599-9f342ba1-8be1-4628-b97b-576c2e58da42.png#averageHue=%23f4f4f4&clientId=u02c89380-d3c4-4&from=ui&id=ABGcN&originHeight=436&originWidth=804&originalType=binary&ratio=1&rotation=0&showTitle=false&size=28154&status=done&style=none&taskId=ud36ac0d1-4e00-464d-aeb6-228f4ec9367&title=)
<a name="sv1kB"></a>
### 2、本地内存的技术选型问题

- 从易用性角度，Guava Cache、Caffeine和Encache都有十分成熟的接入方案，使用简单。
- 从功能性角度，Guava Cache和Caffeine功能类似，都是只支持堆内缓存，Encache相比功能更为丰富
- 从性能上进行比较，Caffeine最优、GuavaCache次之，Encache最差(下图是三者的性能对比结果）

![2023-01-13-08-30-31.122879100.png](https://cdn.nlark.com/yuque/0/2023/png/396745/1673570019629-f2bd2d17-f210-4aef-b08a-a5716b42a45b.png#averageHue=%23faf9f9&clientId=u02c89380-d3c4-4&from=ui&id=kZulU&originHeight=371&originWidth=631&originalType=binary&ratio=1&rotation=0&showTitle=false&size=48887&status=done&style=none&taskId=ub2b1c06d-5c0a-42de-bb96-574a71e0bd7&title=)<br />对于本地缓存的方案中，比较推荐Caffeine，性能上遥遥领先。<br />虽然Encache功能更为丰富，甚至提供了持久化和集群的功能，但是这些功能完全可以依靠其他方式实现。真实的业务工程中，建议使用Caffeine作为本地缓存，另外使用redis或者memcache作为分布式缓存，构造多级缓存体系，保证性能和可靠性。
