Java
<a name="zXNRM"></a>
### 1、多精度计算问题
多精度不能直接计算，会存在精度缺失的问题。
```java
public static void main (String[] args) {
    double num1 = 1;
    double num2 = 31.2;
    double num3 = 323.03;
    System.out.println (num1+num2+num3);
    /**
     * 355.22999999999996
     */
}
```
如上代码，3 个数值想加之后却得出了一个很长的数值。<br />在 java 开发中可以通过 `BigDecimal` 进行数值类型的计算，详细可到 `BigDecimal` 工具类。<br />数据库也是一样，MySQL中有`float`和`double`类型，通过sql直接累加数据也会有精度缺失的情况。如果要精确的数值计算，要使用MySQL的`decimal`类型。
<a name="rBWm8"></a>
### 2、包装类型比对
```java
public static void main(String[] args) {
    Integer i1 = 100;
    Integer i2 = 100;
    Integer i3 = 200;
    Integer i4 = 200;
    System.out.println(i1==i2); // true
    System.out.println(i3==i4);  // false
}
```
如上代码很神奇，同样是数值比对100的时候可以通过双等号返回`true`。200就返回`false`。<br />这是因为`Integer`的`valueOf()`方法。
```java
//Integer的valueOf方法
public static Integer valueOf(int i) {
    if (i >= IntegerCache.low && i <= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}
```
在`[-128,128]`之间的数，可以通过双等于比对成功，之外的数值就会返回一个`new`一个新的`Integer`，因此会返回false。<br />`Double`的比较就简单一点，双等于比对全是false。这是因为`Double`直接是返回了一个新的`Double`。
```java
//Double的valueOf方法
public static Double valueOf(String s) throws NumberFormatException {
    return new Double(parseDouble(s));
}
```
在数值比对的时候乱的样子，他们都有`eq`方法，通过这个方法比对可以吗？<br />可以的，不管是`Integer`还是`Double`都存在一个`equals`方法，通过这个方法即可进行数值比对。但是这个方法不是很完美。
```java
public static void main (String[] args){
    Double i1 = 100d;
    System.out.println(i1.equals("100")); 
    //false
}
```
如上所示，因为太多的人都知道字符串类型不能用双等号进行比对，要用eq方法进行比对其value。<br />这样会让很多人误以为`Integer`和`Double`类型也是如此，而且在编码的时候如上这种写法也没有报错，会认为都是100肯定会返回true。恰巧这种想法是错误的。
```java
public boolean equals(Object obj) {
    return (obj instanceof Double)
        && (doubleToLongBits(((Double)obj).value) ==
            doubleToLongBits(value));
}
```
`Double`的`eq`方法入参是`Object`类型，因此不管传入什么类型都不会报错。`i1.equals("100")`这种就是双精度和字符进行比对，这两个永远都不可能返回`true`。正确的写法应该是`i1.equals(100d)`。<br />但是尽管多次提醒，但是还是会有不认真的开发小伙伴错误，因此，可以使用`Double.compareTo`方法，这个方法和eq方法类似，但是有编译的异常，这样可有效的提醒开发人员。
```java
public static void main (String[] args){
    Double i1 = 100d;
    System.out.println(i1.compareTo (100d)); //0
    System.out.println(i1.compareTo (1d));  //1
}
```
<a name="dRQNc"></a>
### 3、除以0会怎样？
小学的时候就讲过，进行除法运算时，除以0是没有意义的，开发过程中也是如此， 发现可能存在除以0的场景要特别注意，程序不会抛出异常，竟然会返回一个字符串！虽然这种场景不多，但是还是需要了解一下。
<a name="e3HCK"></a>
#### 1除以0的场景
```java
public static void main(String[] args) {
    Double d = 1d;
    double v = d / 0d;
    System.out.println(v);
    //Infinity
}
```
<a name="StVgQ"></a>
#### 0除以0的场景
```java
public static void main(String[] args) {
    Double d = 0d;
    double v = d / 0d;
    System.out.println(v);
    //NaN
}
```
<a name="I5sn3"></a>
### 4、float转double
```java
public static void main(String[] args) {
    Float f = 12312.12f;
    System.out.println(f.doubleValue()); 
    System.out.println(Double.parseDouble (f.toString ())); 
    //12312.1201171875
    //12312.12
}
```
Float类中有一个`doubleValue`方法，返回值是一个`double`类型，这样会很容易的以为这是`float`转换`double`类型。但是转换之后精度缺失了，只能换一种方式转换。
