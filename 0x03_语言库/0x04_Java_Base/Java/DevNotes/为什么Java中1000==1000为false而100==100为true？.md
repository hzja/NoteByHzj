Java<br />众所周知阿里巴巴开发手册里面有一条强制的规则，说的是在包装类对象之间的值比较的时候需要使用 `equals` 方法，在 `-128` 和 `127` 之间的数值比较可以使用 `==`，如下图所示。具体的原因相信大家都知道，虽然规则中提到 `-128` 和 `127` 之间的数值比较可以使用 `==`，但建议还是不要这样，包装类统一使用 `equals`，特别是如果有些数值是通过 API 或者 RPC 接口过来的，一定要注意。<br />![](https://cdn.nlark.com/yuque/0/2021/webp/396745/1634113524335-535e26eb-f6d3-4550-a933-bbf7cb970a74.webp#averageHue=%23f7f6ec&clientId=u23bcf518-33a5-4&from=paste&id=u94dc8f91&originHeight=377&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=ue0069343-79df-45bf-a5ee-b7c849736ce&title=)<br />运行下面的代码：
```java
Integer a = 1000, b = 1000;  
System.out.println(a == b);//1
Integer c = 100, d = 100;  
System.out.println(c == d);//2
```
会得到
```
false
true
```
基本知识：如果两个引用指向同一个对象，用==表示它们是相等的。如果两个引用指向不同的对象，用==表示它们是不相等的，即使它们的内容相同。<br />因此，后面一条语句也应该是false 。<br />这就是它有趣的地方了。如果去看 Integer.java 类，会发现有一个内部私有类，IntegerCache.java，它缓存了从-128到127之间的所有的整数对象。<br />所有的小整数在内部缓存，然后当声明类似——
```java
Integer c = 100;
```
的时候，它实际上在内部做的是：
```java
Integer i = Integer.valueOf(100);
```
现在，如果去看`valueOf()`方法，可以看到
```java
public static Integer valueOf(int i) {
if (i >= IntegerCache.low && i
    return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}
```
如果值的范围在-128到127之间，它就从高速缓存返回实例。<br />所以…
```java
Integer c = 100, d = 100;
```
指向了同一个对象。<br />这就是为什么
```java
System.out.println(c == d);
```
可以得到true。<br />现在可能会问，为什么这里需要缓存？<br />合乎逻辑的理由是，在此范围内的“小”整数使用率比大整数要高，因此，使用相同的底层对象是有价值的，可以减少潜在的内存占用。<br />然而，通过反射API会误用此功能。
```java
public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException {
    Class cache = Integer.class.getDeclaredClasses()[0]; //1
    Field myCache = cache.getDeclaredField("cache"); //2
    myCache.setAccessible(true);//3
    Integer[] newCache = (Integer[]) myCache.get(cache); //4
    newCache[132] = newCache[133]; //5
    int a = 2;
    int b = a + a;
    System.out.printf("%d + %d = %d", a, a, b); //
}
```
