在Java中两个Integer对象做比较时，会产生意想不到的结果。<br />例如：
```java
Integer a = 100;
Integer b = 100;
System.out.println(a==b);
```
其运行结果是：true。<br />而如果改成下面这样：
```java
Integer a = 1000;
Integer b = 1000;
System.out.println(a==b);
```
其运行结果是：false。<br />看到这里，懵了没有？<br />为什么会产生这样的结果呢？
<a name="ilBH6"></a>
## 1、Integer对象
上面例子中的a和b，是两个Integer对象。<br />而非Java中的8种基本类型。<br />8种基本类型包括：

- byte
- short
- int
- long
- float
- double
- boolean
- char

Integer其实是int的包装类型。<br />在Java中，除了上面的这8种类型，其他的类型都是对象，保存的是引用，而非数据本身。
```java
Integer a = 1000;
Integer b = 1000;
```
可能有些人认为是下面的简写：
```java
Integer a = new Integer(1000);
Integer b = new Integer(1000);
```
这个想法表面上看起来是对的，但实际上有问题。<br />在JVM中的内存分布情况是下面这样的：![](https://cdn.nlark.com/yuque/0/2023/png/396745/1703065404260-85398d78-5d97-4097-a286-8e80070879b1.png#averageHue=%23f5f4f4&clientId=u75c6a545-d82b-4&from=paste&id=u83bb29a5&originHeight=440&originWidth=846&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=ua142173b-f5c5-491d-9f60-f3a351ff79e&title=)在栈中创建了两个局部变量a和b，同时在堆上new了两块内存区域，他们存放的值都是1000。<br />变量a的引用指向第一个1000的地址。<br />而变量b的引用指向第二个1000的地址。<br />很显然变量a和b的引用不相等。<br />既然两个Integer对象用==号，比较的是引用是否相等，但下面的这个例子为什么又会返回true呢？
```java
Integer a = 100;
Integer b = 100;
System.out.println(a==b);
```
不应该也返回false吗？<br />对象a和b的引用不一样。
```java
Integer a = 1000;
Integer b = 1000;
```
其实正确的简写是下面这样的：
```java
Integer a = Integer.valueOf(1000);
Integer b = Integer.valueOf(1000);
```
在定义对象a和b时，Java自动调用了`Integer.valueOf`将数字封装成对象。![](https://cdn.nlark.com/yuque/0/2023/png/396745/1703065404176-b283084f-7ca0-479c-91a3-e10b31fe1b5d.png#averageHue=%232f2d2b&clientId=u75c6a545-d82b-4&from=paste&id=u2695a661&originHeight=194&originWidth=874&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u3ad93354-ad93-462f-ab89-b40218732db&title=)而如果数字在low和high之间的话，是直接从`IntegerCache`缓存中获取的数据。<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1703065404236-9722a403-21ba-478d-a3dc-65852869ed80.png#averageHue=%232d2c2b&clientId=u75c6a545-d82b-4&from=paste&id=uc0c4a827&originHeight=1044&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=ue5d14f8b-8715-4b9b-88f8-5ae81ed81ac&title=)Integer类的内部，将-128~127之间的数字缓存起来了。<br />也就是说，如果数字在-128~127，是直接从缓存中获取的Integer对象。如果数字超过了这个范围，则是new出来的新对象。<br />文章示例中的1000，超出了-128~127的范围，所以对象a和b的引用指向了两个不同的地址。<br />而示例中的100，在-128~127的范围内，对象a和b的引用指向了同一个地址。<br />所以会产生开头的运行结果。<br />为什么Integer类会加这个缓存呢？<br />答：-128~127是使用最频繁的数字，如果不做缓存，会在内存中产生大量指向相同数据的对象，有点浪费内存空间。
```java
Integer a = 1000;
Integer b = 1000;
```
如果想要上面的对象a和b相等，该怎么判断呢？
<a name="z2Has"></a>
## 2、判断相等
在Java中，如果使用==号比较两个对象是否相等，比如：a==b，其实比较的是两个对象的引用是否相等。<br />很显然变量a和b的引用，指向的是两个不同的地址，引用肯定是不相等的。<br />因此下面的执行结果是：false。
```java
Integer a =  Integer.valueOf(1000);
Integer b = Integer.valueOf(1000);
System.out.println(a==b);
```
由于1000在Integer缓存的范围之外，因此上面的代码最终会变成这样：
```java
Integer a =  new Integer(1000);
Integer b = new Integer(1000);
System.out.println(a==b);
```
如果想要a和b比较时返回true，该怎么办呢？<br />答：调用equals方法。<br />代码改成这样的：
```java
Integer a = Integer.valueOf(1000);
Integer b = Integer.valueOf(1000);
System.out.println(a.equals(b));
```
执行结果是：true。<br />其实equals方法是Object类的方法，所有对象都有这个方法。![](https://cdn.nlark.com/yuque/0/2023/png/396745/1703065404189-37f319f1-7f9e-47ea-8203-d2ed76377093.png#averageHue=%232e2d2d&clientId=u75c6a545-d82b-4&from=paste&id=u465b63f5&originHeight=705&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u9031b1ef-9045-4d71-958a-78df0f4d284&title=)它的底层也是用的==号判断两个Object类型的对象是否相等。<br />不过Integer类对该方法进行了重写：![](https://cdn.nlark.com/yuque/0/2023/png/396745/1703065404180-0b8298ad-706f-4ae5-8d20-3ea8ea83602c.png#averageHue=%2369543d&clientId=u75c6a545-d82b-4&from=paste&id=u524717eb&originHeight=629&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u1a2e44a3-2a61-480a-8c6b-0f3645ca776&title=)它的底层会先调用Integer类的intValue方法获取int类型的数据，然后再通过==号进行比较。<br />此时，比较的不是两个对象的引用是否相等，而且比较的具体的数据是否相等。<br />使用equals方法，可以判断两个Integer对象的值是否相等，而不是判断引用是否相等。
<a name="ctXYF"></a>
## 总结
Integer类中有缓存，范围是：-128~127。
```java
Integer a = 1000;
```
其实默认调用了`Integer.valueOf`方法，将数字转换成`Integer`类型：
```java
Integer a = Integer.valueOf(1000);
```
如果数字在-128~127之间，则直接从缓存中获取Integer对象。<br />如果数字在-128~127之外，则该方法会new一个新的Integer对象。<br />在判断两个对象是否相等时，一定要多注意：

1. 判断两个对象的引用是否相等，用==号判断。
2. 判断两个对象的值是否相等，调用equals方法判断。
