Java
<a name="AeJom"></a>
## 1、概述
Java中的对象拷贝 ( Object Copy ) 是指将一个对象的所有属性（成员变量）拷贝到另一个有着相同类类型的对象中去。例如，对象 A 和对象 B 都属于类 S，具有属性 a 和 b。那么对对象 A 进行拷贝操作赋值给对象 B 就是：
```java
B.a = A.a;  
B.b = A.b;
```
拷贝对象是很常见的，主要是为了在新的上下文环境中复用现有对象的部分或全部数据。Java中的对象拷贝主要分为

- 浅拷贝( Shallow Copy )
- 深拷贝( Deep Copy )

Java中的数据类型分为**基本数据类型**和**引用数据类型**。对于这两种数据类型，在进行赋值操作、用作方法参数或返回值时，会有值传递和引用（地址）传递的差别。
<a name="g9S3x"></a>
### 浅拷贝（Shallow Copy）

- 对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象。因为是两份不同的数据，所以对其中一个对象的该成员变量值进行修改，不会影响另一个对象拷贝得到的数据。
- 对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值（内存地址）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值。

具体模型如下图所示，可以看到基本数据类型的成员变量，对其值创建了新的拷贝；而引用数据类型的成员变量的实例仍然是只有一份，两个对象的该成员变量都指向同一个实例。<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1649205997176-53029ce5-3ebe-45ad-9d8c-ddd86c17f5e9.png#clientId=u7e69212f-8031-4&from=paste&id=u5b0acee2&originHeight=743&originWidth=910&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=uc64d5a7d-0f6e-49c7-9d7a-07cd43ed895&title=)
<a name="oLfHD"></a>
## 2、浅拷贝的实现方式
<a name="JZFmX"></a>
### 拷贝构造方法实现浅拷贝
拷贝构造方法指的是该类的构造方法参数为该类的对象。使用拷贝构造方法可以很好地完成浅拷贝，直接通过一个现有的对象创建出与该对象属性相同的新的对象。
<a name="Ko6QG"></a>
### 重写`clone()`方法进行浅拷贝
Object类是类结构的根类，其中有一个方法
```java
protected Object clone() throws CloneNotSupportedException
```
这个方法就是进行的浅拷贝。有了这个浅拷贝模板，可以通过调用`clone()`方法来实现对象的浅拷贝。但是需要注意：<br />（1）Object类虽然有这个方法，但是这个方法是受保护的（被`protected`修饰），所以无法直接使用。<br />（2）使用`clone`方法的类必须实现`Cloneable`接口，否则会抛出异常`CloneNotSupportedException`。<br />对于这两点，解决方法是：在要使用`clone`方法的类中重写`clone()`方法，通过`super.clone()`调用Object类中的原`clone`方法。
<a name="QRg7f"></a>
## 3、深拷贝的实现方式
首先介绍对象图的概念。设想一下，一个类有一个对象，其成员变量中又有一个对象，该对象指向另一个对象，另一个对象又指向另一个对象，直到一个确定的实例。这就形成了对象图。那么对于深拷贝来说，不仅要复制对象的所有基本数据类型的成员变量值，还要为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象。也就是说，对象进行深拷贝要对整个对象图进行拷贝。<br />一句话，深拷贝对引用数据类型的成员变量的对象图中所有的对象都开辟了内存空间；而浅拷贝只是传递地址指向，新的对象并没有对引用数据类型创建内存空间。深拷贝模型如下图所示，可以看到所有的成员变量都进行了复制。<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1649205997272-2d587d9e-9672-474a-8704-d093542cd0bb.png#clientId=u7e69212f-8031-4&from=paste&id=ua315fa47&originHeight=752&originWidth=915&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=u821ff1dd-b143-4003-b1f0-4f62a0edd0b&title=)<br />因为创建内存空间和拷贝整个对象图，所以深拷贝相比于浅拷贝速度较慢并且花销较大。
<a name="UjMSw"></a>
### 重写`clone`方法来实现深拷贝
与通过重写`clone`方法实现浅拷贝的基本思路一样，只需要为对象图的每一层的每一个对象都实现`Cloneable`接口并重写`clone`方法，最后在最顶层的类的重写的`clone`方法中调用所有的`clone`方法即可实现深拷贝。**简单的说只要每一层的每个对象都进行浅拷贝，就等于实现了深拷贝。**
```java
@Override
public Object clone() {
	//深拷贝
	try {
		// 直接调用父类的clone()方法
		Student student = (Student) super.clone();
		student.引用对象 = (引用对象) 引用对象.clone();
		return student;
	} catch (CloneNotSupportedException e) {
		return null;
	}
}
```
<a name="MpP17"></a>
### 对象序列化实现深拷贝
虽然层次调用`clone`方法可以实现深拷贝，但是显然代码量实在太大。特别对于属性数量比较多、层次比较深的类而言，每个类都要重写`clone`方法太过繁琐。将对象序列化为字节序列后，默认会将该对象的整个对象图进行序列化，再通过反序列即可完美地实现深拷贝。
```java
//将对象写入流中
ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream);
objectOutputStream.writeObject(拷贝对象);

//从流中取出
ByteArrayInputStream inputStream = new ByteArrayInputStream(outputStream.toByteArray());
ObjectInputStream objectInputStream = new ObjectInputStream(inputStream);
return (拷贝对象)objectInputStream.readObject();
```
<a name="ra8Pq"></a>
### JSON或者XML方式实现深拷贝
因为一个POJO对象可以通过JSON库变成一个json字符串（通过XML库变成一个xml字符串），再通过对应的类库又反序列化成另外一个完整的对象。
```java
String json =JSON.toJSONString(src);
T object = JSON.parseObject(json, clazz);
```
