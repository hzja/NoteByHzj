

## 知识回顾
三目运算符大家都很熟悉了：
```java
<表达式1> ? <表达式2> : <表达式3>
```
需要注意的就是：一个三元表达式从不会既计算 <表达式 2>，又计算 <表达式 3>。条件运算符是右结合的，也就是说，从右向左分组计算。例如，a ? b : c ? d : e 将按 a ? b : (c ? d : e) 执行。







再来回顾下自动拆箱和装箱机制，Java 通过这种机制使得包装类和基本数据类型之间的转换更加方便：

- **装箱**：将基本数据类型转换成包装类（每个包装类的构造方法都可以接收各自数据类型的变量）。
- **拆箱**：从包装类之中取出被包装的基本类型数据（使用包装类的 xxxValue 方法）。

下面以 Integer 为例，来看看 Java 内置的包装类是如何进行拆装箱的：
```java
Integer obj = new Integer(10);  // 装箱
int temp = obj.intValue();   // 拆箱
```
这种形式的代码是 **JDK 1.5 以前**的，**JDK 1.5 之后**，Java 设计者为了方便开发提供了**自动装箱（Autoboxing）**与**自动拆箱**的机制，并且可以直接利用包装类的对象进行数学计算。

还是以 Integer 为例，来看看自动拆装箱的过程：

```java
Integer obj = 10;   // 自动装箱. 基本数据类型 int -> 包装类 Integer
int temp = obj;   // 自动拆箱. Integer -> int
obj ++; // 直接利用包装类的对象进行数学计算
System.out.println(temp * obj);
```
基本数据类型到包装类的转换，不需要像上面一样使用构造函数，直接 `=` 就完事儿；同样的，包装类到基本数据类型的转换，也不需要手动调用包装类的 xxxValue 方法了，直接 `=` 就能完成拆箱。这也是将它们称之为自动的原因。

![](https://cdn.nlark.com/yuque/0/2023/png/396745/1701310726980-6897d00a-f3f4-4387-9552-ac6731ac28fd.png#averageHue=%23f8f4f4&clientId=ucf3c945c-cc80-4&from=paste&id=uf0f4108b&originHeight=337&originWidth=906&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=uaebc157a-aa0c-4416-9fa3-efcd24a7f09&title=)

来看看这段代码反编译后的文件，底层到底是什么原理：

```java
Integer obj = Integer.valueOf(10);
int temp = obj.intValue();
```
可以看见，自动装箱的底层原理其实就是调用了包装类的 `valueOf` 方法，而自动拆箱的底层同样还是调用了包装类的 `intValue()` 方法。

![](https://cdn.nlark.com/yuque/0/2023/png/396745/1701310727029-458822da-fdab-4896-8db6-cf1ced64900d.png#averageHue=%23f6f3f3&clientId=ucf3c945c-cc80-4&from=paste&id=uee663af6&originHeight=372&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=ua8af28fd-eb56-439c-8e87-4b609c28e15&title=)



## 问题重现
实际的代码业务逻辑比较复杂，这里举一个相对简单一点的例子先来重现下这个问题：
```java
// 设置成true，保证条件表达式的表达式二一定可以执行
boolean flag = true;

//定义一个包装类对象类型的Boolean变量，值为null 
Boolean nullBoolean = null;

// 定义一个基本数据类型的boolean变量
boolean simpleBoolean = false; 

//使用三目运算符并给 x 变量赋值
boolean x = flag ? nullBoolean : simpleBoolean;
```
以上代码，在运行过程中，会抛出 NPE：
```
Exception in thread "main" java.lang.NullPointerException
```
而且，这个和使用的 JDK 版本是无关的，在 JDK 6、JDK 8 和 JDK 14 上做了测试，均会抛出 NPE。

尝试对以上代码进行反编译，使用 jad 工具进行反编译后，得到以下代码：

```java
boolean flag = true;
boolean simpleBoolean = false;
Boolean nullBoolean = null;

boolean x = flag ? nullBoolean.booleanValue() : simpleBoolean;
```
可以看到，反编译后的代码的最后一行，编译器做了一次自动拆箱（nullBoolean 是包装类，而 x 是基本类型），而 nullBoolean 是 null，这就出现了 `null.booleanValue`，从而抛出 NPE。

那么，为什么编译器会进行自动拆箱呢？什么情况下需要进行自动拆箱呢？



## 原理分析
关于为什么编辑器会在代码编译阶段对于三目运算符中的表达式进行自动拆箱，其实在《The Java Language Specification》（后文简称 JLS，是Java 语言规范，是一切 Java 编程的基础参照文档）的第 15.25 章节中是有相关介绍的。直接看 Java SE 1.7 JLS 中关于这部分的描述（因为 1.7 的表述更加简洁一些），原文地址 -> [https://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.25](https://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.25)：

![](https://cdn.nlark.com/yuque/0/2023/png/396745/1701310727004-161667c1-b9fa-4b21-a7ce-f953a4926c14.png#averageHue=%23f1eeee&clientId=ucf3c945c-cc80-4&from=paste&id=u14f584fc&originHeight=258&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u35d9268b-d47b-4be0-a0cb-26dda8e59f7&title=)

看框出来的两句话：

> 1. If the second and third operands have the same type (which may be the null type),then that is the type of the conditional expression. **当第二位和第三位操作数的类型相同时，则三目运算符表达式的结果和这两位操作数的类型相同。**
> 2. If one of the second and third operands is of primitive type T, and the type of the other is the result of applying boxing conversion (§5.1.7) to T, then the type of the conditional expression is T. **当第二，第三位操作数分别为基本类型和该基本类型对应的包装类型时，那么该表达式的结果的类型要求是基本类型。**

为了满足以上规定，又避免程序员过度感知这个规则，所以在编译过程中编译器如果发现三目操作符的第二位和第三位操作数的类型分别是基本数据类型（如 boolean）以及该基本类型对应的包装类型（如 Boolean）时，并且需要返回表达式为包装类型，那么就需要对该包装类进行自动拆箱。

理解下这句话，JLS 的规范是如果第二和第三位操作数分别是基本类型和包装类型，那么要求返回值是基本类型。那如果自己写的代码返回值是包装类型，那么编译器为了满足 JLS 规范，其实是会自动做一个拆箱的。

简单总结：**只要表达式 1 和表达式 2 的类型有一个是基本类型一个是包装类型，就会做触发类型对齐的拆箱操作**。

下面再列举几个例子加深下理解：

```java
boolean flag = true;
boolean simpleBoolean = false;
Boolean objectBoolean = Boolean.FALSE;
```
当第二位和第三位表达式都是包装类，表达式返回值也为包装类，编译器不需要做拆箱操作：
```java
Boolean x1 = flag ? objectBoolean : objectBoolean;

//反编译后代码（不需要做任何特殊操作）
Boolean x1 = flag ? objectBoolean : objectBoolean;
```
当第二位和第三位表达式都为基本类型时，表达式返回值也为基本类型，编译器不需要做拆箱操作：
```java
boolean x2 = flag ? simpleBoolean : simpleBoolean;

//反编译后代码（不需要做任何特殊操作）
boolean x2 = flag ? simpleBoolean : simpleBoolean;
```
当第二位和第三位表达式中一个为基本类型另一个为包装类型时，表达式返回值为基本类型，编译器需要做拆箱操作：
```java
boolean x3 = flag ? objectBoolean : simpleBoolean;

//反编译后代码（需要对其中的包装类进行拆箱）
boolean x3 = flag ? objectBoolean.booleanValue() : simpleBoolean;
```
如果清楚三目运算符的规则，那就会正确地按照以上方式去定义 x1、x2 和 x3 的类型。



但是，并不是所有人都熟知这个规则，所以在实际应用中，还会出现以下几种定义方式：

```java
boolean x4 = flag ? objectBoolean : objectBoolean;

// 反编译后代码（三元表达式的结果要求是包装类，而 x4 是基本类型，所以编译器需要做拆箱）
boolean x4 = (flag ? objectBoolean : objectBoolean).booleanValue();
```
```java
Boolean x5 = flag ? simpleBoolean : simpleBoolean;

// 反编译后代码（三元表达式的结果要求是基本类型，而 x5 是包装类型，所以编译器需要做装箱）
Boolean x5 = Boolean.valueOf(flag ? simpleBoolean : simpleBoolean);
```
```java
Boolean x6 = flag ? objectBoolean : simpleBoolean;

// 反编译后代码（三元表达式的结果要求是基本类型，而 x5 是包装类型，所以编译器需要做装箱）
Boolean x6 = Boolean.valueOf(flag ? objectBoolean.booleanValue() : simpleBoolean);
```
所以，日常开发中就有可能出现以上 6 种情况。在以上 6 种情况中，如果是涉及到自动拆箱的，一旦包装类的值为 null，即 `null.booleanValue()`，就必然会发生 NPE（装箱不会，因为装箱是 `Boolean.valueOf(null)`，这并不会抛 NPE）。



可以把以上的 x3、x4 以及 x6 中的的包装类设置成 null，看看是不是会抛 NPE：

```java
boolean flag = true;
boolean simpleBoolean = false;
Boolean objectBoolean = Boolean.FALSE;
// 将包装类设置为 null
Boolean nullBoolean = null;

boolean x3 = flag ? nullBoolean : simpleBoolean;
boolean x4 = flag ? nullBoolean : objectBoolean;
Boolean x6 = flag ? nullBoolean : simpleBoolean;
```
以上三种情况，都会在执行时发生 NPE:

- 其中 x3 和 x6 是三目运算符运算过程中，根据 JLS 的规则确定类型的过程中要做自动拆箱而导致的 NPE。由于使用了三目运算符，并且第二、第三位操作数分别是基本类型和对象。就需要对对象进行拆箱操作，由于该对象为 null，所以在拆箱过程中调用 null.booleanValue() 的时候就报了 NPE。
- 而 x4 是因为三目运算符运算结束后根据规则得到的是一个对象类型，但是在给变量赋值过程中进行自动拆箱所导致的 NPE。
