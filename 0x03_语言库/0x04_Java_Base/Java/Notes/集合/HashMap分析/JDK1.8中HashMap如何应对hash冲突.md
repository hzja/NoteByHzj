Java HashMap
<a name="kKUcE"></a>
## 1、什么是hash冲突
HashMap底层是由数组+链表/红黑树构成的，当通过`put(key, value)`向hashmap中添加元素时，需要通过散列函数确定元素究竟应该放置在数组中的哪个位置，当不同的元素被放置在了数据的同一个位置时，后放入的元素会以链表的形式，插在前一个元素的尾部，这个时候称发生了hash冲突。
<a name="Bey1M"></a>
## 2、如何解决hash冲突
事实上，想让hash冲突完全不发生，是不太可能的，能做的只是尽可能的降低hash冲突发生的概率：下面介绍在HashMap中是如何应对hash冲突的?<br />当向hashmap中`put`元素(key, value)时，最终会执行`putVal()`方法，而在`putVal()`方法中，又执行了`hash(key)`这个操作，并将执行结果作为参数传递给了putVal方法。那么先来看`hash(key)`方法干了什么。
```java
public V put(K key, V value) {
        return putVal(hash(key), key, value, false, true);
}

static final int hash(Object key) {
    int h;
   // 判断key是否为null, 如果为null,则直接返回0;
   // 如果不为null，则返回(h = key.hashCode()) ^ (h >>> 16)的执行结果
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```
(h = key.hashCode()) ^ (h >>> 16)执行了三步操作：一步一步来分析：
<a name="wGzO9"></a>
### 第1步：h = key.hashCode()
这一步会根据key值计算出一个int类型的h值也就是`hashcode`值，例如
```java
"helloWorld".hashCode() --> -1554135584
"123456".hashCode() --> 1450575459
"我爱java".hashCode() --> -1588929438
```
至于`hashCode()`是如何根据key计算出`hashcode`值的，要分几种情况进行分析:

1. 如果使用的自己创建的对象，在没有重写`hashCode()`方法的情况下，会调用Object类的`hashCode()`方法，而此时返回就是对象的内存地址值，所以如果对象不同，那么通过`hashcode()`计算出的`hashcode`就是不同的。
2. 如果是使用java中定义的引用类型例如String，Integer等作为key，这些类一般都会重写`hashCode()`方法，有兴趣可以翻看一下对应的源码。简单来说，Integer类的`hashCode()`返回的就是Integer值，而String类型的hashCode()方法稍稍复杂一点，这里不做展开。总的来说，`hashCode()`方法的作用就是要根据不同的key得到不同的`hashCode`值。
<a name="mF7Sp"></a>
### 第2步：h >>> 16
这一步将第1步计算出的h值无符号右移16位。<br />为什么要右移16位，当然是位了第三步的操作。
<a name="fkOVF"></a>
### 第3步：h ^ (h >>> 16)
将`hashcode`值的高低16位进行异或操作(同0得0、同1得0、不同得1)得到hash值，举例说明：

- 假设h值为：1290846991
- 它的二进制数为：01001100 11110000 11000011 00001111
- 右移十六位之后：00000000 00000000 01001100 11110000
- 进行异或操作后：01001100 11110000 10001100 11110000
- 最终得到的hash值：1290833136

那么问题来了：明明通过第一步得到的hashcode值就可以作为hash返回，为什么还要要进行第二步和第三步的操作呢？答案是为了减少hash冲突！<br />元素在数组中存放的位置是由下面这行代码决定的：
```bash
// 将(数组的长度-1)和hash值进行按位与操作：
i = (n - 1) & hash  // i为数组对应位置的索引  n为当前数组的大小
```
将上面这步操作作为第4步操作，来对比一下执行1、2、3、4四个步骤和只执行第1、4两个步骤所产生的不同效果。<br />向hashmap中put两个元素node1(key1, value1)、node2(key2, value2)，hashmap的数组长度n=16。<br />执行1、2、3、4 四个步骤：
<a name="Nx5zV"></a>
#### 1.h = key.hashCode()

- 假设计算的结果为：h = 3654061296
- 对应的二进制数为：01101100 11100110 10001100 11110000
<a name="H4ImW"></a>
#### 2.h >>> 16

- h无符号右移16位得到：00000000 00000000 01101100 11100110
<a name="hKGgw"></a>
#### 3.hash = h ^ (h >>> 16)

- 异或操作后得到hash：01101100 11110000 11100000 00000110
<a name="rbg5z"></a>
#### 4.i = (n-1) & hash

- n-1=15 对应二进制数：00000000 00000000 00000000 00001111
- hash：01101100 11110000 11100000 00000110
- hash & 15：00000000 00000000 00000000 00000110
- 转化为10进制：&ensp 5

最终得到i的值为5，也就是说node1存放在数组索引为5的位置。<br />同理对(key2, value2) 进行上述同样的操作过程：
<a name="Rfdr8"></a>
#### 1.h = key.hashCode()

- 假设计算的结果为：h = 3652881648
- 对应的二进制数为：01101100 11011101 10001100 11110000
<a name="iv5IP"></a>
#### 2.h >>> 16

- h无符号右移16位得到：00000000 00000000 01101100 11011101
<a name="na8VI"></a>
#### 3.hash = h ^ (h >>> 16)

- 异或操作后得到hash：01101100 11110000 11100000 00101101
<a name="CjKYA"></a>
#### 4.i = (n-1) & hash

- n-1=15 对应二进制数：00000000 00000000 00000000 00001111
- hash：01101100 11110000 11100000 00101101
- hash & 15：00000000 00000000 00000000 00001101
- 转化为10进制：&ensp 13

最终得到i的值为13，也就是说node2存放在数组索引为13的位置<br />node1和node2存储的位置如下图所示：<br />![](https://cdn.nlark.com/yuque/0/2021/webp/396745/1637581879099-18202635-18d6-4783-b428-1dc5ff613e12.webp#clientId=u844c0a1c-fd79-4&from=paste&id=u0243d849&originHeight=109&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=uc4a8c958-0979-4bc8-8e52-1cafc6115d1&title=)<br />执行1、4两个步骤：<br />1.h = key.hashCode()

- 计算的结果同样为：h = 3654061296
- 对应的二进制数为：01101100 11100110 10001100 11110000

4.i = (n-1) & hash

- n-1=15 对应二进制数：00000000 00000000 00000000 00001111
- hash(h)：01101100 11100110 10001100 11110000
- hash & 15：00000000 00000000 00000000 00000000
- 转化为10进制：0

最终得到i的值为0，也就是说node1存放在数组索引为0的位置<br />同理对(key2, value2) 进行上述同样的操作过程：<br />1.h = key.hashCode()

- 计算的结果同样为：h = 3652881648
- 对应的二进制数为：01101100 11011101 10001100 11110000

4.i = (n-1) & hash

- n-1=15 对应二进制数：00000000 00000000 00000000 00001111
- hash(h)：01101100 11110000 11100000 11110000
- hash & 15：00000000 00000000 00000000 00000000
- 转化为10进制：0

最终得到i的值为0，也就是说node2同样存放在数组索引为0的位置<br />node1和node2存储的位置如下图所示：<br />![2021-11-22-19-55-54-750933.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1637582217236-494fbe8f-fec5-402d-ab52-799b2bda403d.png#clientId=u844c0a1c-fd79-4&from=ui&id=u5955d584&originHeight=175&originWidth=1080&originalType=binary&ratio=1&rotation=0&showTitle=false&size=568172&status=done&style=shadow&taskId=udbf7d8d0-8fb0-4f33-850a-e71e0fd2ce0&title=)<br />相信大家已经看出区别了：<br />当数组长度n较小时，n-1的二进制数高16位全部位0，这个时候如果直接和h值进行&（按位与）操作，那么只能利用到h值的低16位数据，这个时候会大大增加hash冲突发生的可能性，因为不同的h值转化为2进制后低16位是有可能相同的，如上面所举例子中：`key1.hashCode()` 和`key2.hashCode()` 得到的h值不同，一个h1 = 3654061296 ，另一个h2 = 3652881648，但是不幸的是这h1、h2两个数转化为2进制后低16位是完全相同的，所以h1 & (n-1)和 h2 & (n-1) 会计算出相同的结果，这也导致了node1和node2 存储在了数组索引相同的位置，发生了hash冲突。<br />当使用进行 h ^ (h >>> 16) 操作时，会将h的高16位数据和低16位数据进行异或操作，最终得出的hash值的高16位保留了h值的高16位数据，而hash值的低16数据则是h值的高低16位数据共同作用的结果。所以即使h1和h2的低16位相同，最终计算出的hash值低16位也大概率是不同的，降低了hash冲突发生的概率。<br />ps：这里面还有一个值的注意的点：为什么是(n-1)?<br />n是hashmap中数组的长度，那么为要进行n-1的操作？答案同样是为了降低hash冲突发生的概率！<br />要理解这一点，首先要知道HashMap规定了数组的长度n必须为2的整数次幂，至于为什么是2的整数次幂，会在HashMap的扩容方法`resize()`里详细讲。<br />既然n为2的整数次幂，那么n一定是一个偶数。来比较`i = hash & n`和 `i = hash & (n-1)`有什么异同。<br />n为偶数，那么n转化为2进制后最低位一定为0，与hash进行按位与操作后最低位仍一定为0，这就导致i值只能为偶数，这样就浪费了数组中索引为奇数的空间，同时也增加了hash冲突发生的概率。<br />所以要执行n-1，得到一个奇数，这样n-1转化为二进制后低位一定为1，与hash进行按位与操作后最低位即可能位0也可能位1，这就是使得i值即可能为偶数，也可能为奇数，充分利用了数组的空间，降低hash冲突发生的概率。
