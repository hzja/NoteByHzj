Java 序列化和反序列化
<a name="VVIhD"></a>
## 一、序列化和反序列化的概念

- 序列化：把对象转换为字节序列的过程称为对象的序列化。
- 反序列化：把字节序列恢复为对象的过程称为对象的反序列化。

上面是专业的解释，现在来点通俗的解释。在代码运行的时候，可以看到很多的对象(debug过的都造吧)，可以是一个，也可以是一类对象的集合，很多的对象数据，这些数据中，有些信息想让他持久的保存起来，那么这个序列化。<br />就是把内存里面的这些对象给变成一连串的字节描述的过程。<br />常见的就是变成文件<br />不序列化也可以保存文件啥的，有什么影响呢？
<a name="IDVnk"></a>
## 二、什么情况下需要序列化

- 当要把的内存中的对象状态保存到一个文件中或者数据库中时候；
- 当用套接字在网络上传送对象的时候；
- 当通过RMI传输对象的时候；
<a name="akDYE"></a>
## 三、如何实现序列化
实现Serializable接口即可<br />上面这些理论都比较简单，下面实际代码看看这个序列化到底能干啥，以及会产生的bug问题。<br />先上对象代码，FlyPig.java
```java
package com.test;

import java.io.Serializable;

public class FlyPig implements Serializable {

//  private static final long serialVersionUID = 1L;
    private static String AGE = "269";
    private String name;
    private String color;
    transient private String car;
 
 private String addTip;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getColor() {
        return color;
    }

    public void setColor(String color) {
        this.color = color;
    }

    public String getCar() {
        return car;
    }

    public void setCar(String car) {
        this.car = car;
    }

 public String getAddTip() {
        return addTip;
    }

    public void setAddTip(String addTip) {
        this.addTip = addTip;
    }

    @Override
    public String toString() {
        return "FlyPig{" +
                "name='" + name + '\'' +
                ", color='" + color + '\'' +
                ", car='" + car + '\'' +
                ", AGE='" + AGE+ '\'' +
                '}';
    }
}
```
注意下，注释的代码，是一会儿要各种情况下使用的。<br />下面就是main方法
```java
package com.test;

import java.io.*;

public class SerializableTest {
    public static void main(String[] args) throws Exception {
        serializeFlyPig();
        FlyPig flyPig = deserializeFlyPig();
        System.out.println(flyPig.toString());
    }

    /**
     * 序列化
     */
    private static void serializeFlyPig() throws Exception {
        FlyPig flyPig = new FlyPig();
        flyPig.setColor("black");
        flyPig.setName("riemann");
        flyPig.setName("audi");
        // ObjectOutputStream 对象输出流，将 flyPig 对象存储到E盘的 flyPig.txt 文件中，完成对 flyPig 对象的序列化操作
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(new File("d:/flypig.txt")));
        oos.writeObject(flyPig);
        System.out.println("FlyPig 对象序列化成功！");
        oos.close();
    }

    /**
     * 反序列化
     */
    private static FlyPig deserializeFlyPig() throws Exception {
        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(new File("d:/flypig.txt")));
        FlyPig pig = (FlyPig) ois.readObject();
        System.out.println("FlyPig 对象反序列化成功！");
        return pig;
    }

}
```
对上面的2个操作文件流的类的简单说明<br />`**ObjectOutputStream**`**代表对象输出流：**<br />它的`writeObject(Object obj)`方法可对参数指定的obj对象进行序列化，把得到的字节序列写到一个目标输出流中。<br />`**ObjectInputStream**`**代表对象输入流：**<br />它的`readObject()`方法从一个源输入流中读取字节序列，再把它们反序列化为一个对象，并将其返回。<br />具体怎么看运行情况。
<a name="chI59"></a>
### 第一种：上来就这些代码，不动，直接run，看效果。
实际运行结果，他会在 d:/flyPig.txt 生成个文件。
```java
FlyPig 对象序列化成功！
FlyPig 对象反序列化成功！
FlyPig{name='audi', color='black', car='null', AGE='269'}
```
从运行结果上看：

1. 他实现了对象的序列化和反序列化。
2. `transient` 修饰的属性，是不会被序列化的。设置的奥迪四个圈的车不见啦，成了null。
3. 静态变量AGE也被序列化啦。这个得另测。
<a name="b8EDF"></a>
### 第二种：为了验证这个静态的属性能不能被序列化和反序列化，可如下操作。
```java
public class SerializableTest {
    public static void main(String[] args) throws Exception {
        serializeFlyPig();
        //      FlyPig flyPig = deserializeFlyPig();
        //      System.out.println(flyPig.toString());
    }
```
这个完了之后，意思也就是说，先序列化个对象到文件了。这个对象是带静态变量的`static`。<br />现在修改flyPig类里面的AGE的值，给改成26吧。<br />然后，看下图里面的运行代码和执行结果。
```java
public class SerializableTest {
    public static void main(String[] args) throws Exception {
        //      serializeFlyPig();
        FlyPig flyPig = deserializeFlyPig();
        System.out.println(flyPig.toString());
    }
```
输出结果：
```java
FlyPig 对象反序列化成功！
FlyPig{name='audi', color='black', car='null', AGE='26'}
```
可以看到，刚刚序列化的269，没有读出来。而是刚刚修改的26，如果可以的话，应该是覆盖这个26，是269才对。<br />所以，得出结论，这个静态`static`的属性，他不序列化。
<a name="q8NnQ"></a>
### 第三种：示范这个 serialVersionUID 的作用和用法
最暴力的改法，直接把model的类实现的这个接口去掉。然后执行后面的序列化和反序列化的方法。直接报错。<br />抛异常：NotSerializableException<br />这个太暴力啦，不推荐这么干。<br />然后就是，还和上面的操作差不多，先是单独执行序列化方法。生成文件。然后，打开属性 addTip ，这之后，再次执行反序列化方法，看现象。<br />抛异常：InvalidClassException 详情如下。
```java
InvalidClassException: com.lxk.model.FlyPig;
local class incompatible:
stream classdesc serialVersionUID = 7230772301104163489,
local class serialVersionUID = -2293195637094031536

Exception in thread "main" java.io.InvalidClassException: com.test.FlyPig; local class incompatible: stream classdesc serialVersionUID = 7230772301104163489, local class serialVersionUID = -2293195637094031536
 at java.io.ObjectStreamClass.initNonProxy(ObjectStreamClass.java:699)
 at java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:1885)
 at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1751)
 at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2042)
 at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1573)
 at java.io.ObjectInputStream.readObject(ObjectInputStream.java:431)
 at com.test.SerializableTest.deserializeFlyPig(SerializableTest.java:33)
 at com.test.SerializableTest.main(SerializableTest.java:8)
```
解释一下：<br />因为在model里面是没有明确的给这个 serialVersionUID 赋值，但是，Java会自动给赋值的，这个值跟这个model的属性相关计算出来的。<br />保存的时候，也就是序列化的时候，那时候还没有这个addTip属性呢，所以，自动生成的serialVersionUID 这个值，在反序列化的时候Java自动生成的这个serialVersionUID值是不同的，他就抛异常啦。<br />（还可以反过来，带ID去序列化，然后，没ID去反序列化。也是同样的问题。）<br />再来一次，就是先序列化，这个时候，把 `private static final long serialVersionUID = 1L;` 这行代码的注释打开。那个addTip属性先注释掉，序列化之后，再把这个属性打开，再反序列化。看看什么情况。
```java
FlyPig 对象反序列化成功！
FlyPig{name='audi', color='black', car='null', AGE='26', addTip='null'}
```
这个时候，代码执行OK，一切正常。序列化的时候，是没的那个属性的，在发序列化的时候，对应的model多了个属性，但是，反序列化执行OK，没出异常。<br />这个现象有什么意义：<br />首先，要是不知道这个序列化是干啥的，万一他真的如开头所讲的那样存数据库，socket传输，rmi传输。就给model bean 实现了个这个接口，没写这个 serialVersionUID 那么在后来扩展的时候，可能就会出现不认识旧数据的bug，那不就炸了。回忆一下上面的这个出错情况。<br />所以，有这么个理论，就是在实现这个Serializable 接口的时候，一定要给这个 serialVersionUID 赋值，就是这么个问题。<br />这也就解释了，刚刚开始编码的时候，实现了这个接口之后，为啥IDEA编辑器要黄色警告，需要添加个这个ID的值。而且还是一长串都不知道怎么来的数字。<br />**下面解释这个 serialVersionUID 的值到底怎么设置才OK。**<br />首先，可以不用自己去赋值，Java会赋值，但是，这个就会出现上面的bug，很不安全，所以，还得自己手动的来。<br />那么，该怎么赋值，eclipse可能会自动赋值个一长串数字。这个是没必要的。<br />可以简单的赋值个 1L，这就可以了。。这样可以确保代码一致时反序列化成功。<br />不同的`serialVersionUID`的值，会影响到反序列化，也就是数据的读取，写1L，注意L大些。计算机是不区分大小写的，所以说，这个值不要乱动，不然一个版本升级，旧数据就不兼容了，还不知道问题在哪。。。
<a name="X3vFF"></a>
### 第四种：当属性是对象的时候，没实现序列化接口
当属性是对象的时候，如果这个对象，没实现序列化接口，那么上面的方法在序列化的时候就在执行`oos.writeObject(flyPig)`时候，报错了“Exception in thread “main” java.io.NotSerializableException: com.lxk.model.Bird”。然后给刚刚的属性的对象加上实现序列化的接口之后，上面的测试就正常通过了。<br />下面是摘自 jdk api 文档里面关于接口 Serializable 的描述
> 类通过实现 java.io.Serializable 接口以启用其序列化功能。未实现此接口的类将无法使其任何状态序列化或反序列化。可序列化类的所有子类型本身都是可序列化的。因为实现接口也是间接的等同于继承。序列化接口没有方法或字段，仅用于标识可序列化的语义。

<a name="ptZsW"></a>
#### 关于 serialVersionUID 的描述
序列化运行时使用一个称为 serialVersionUID 的版本号与每个可序列化类相关联，该序列号在反序列化过程中用于验证序列化对象的发送者和接收者是否为该对象加载了与序列化兼容的类。<br />如果接收者加载的该对象的类的 serialVersionUID 与对应的发送者的类的版本号不同，则反序列化将会导致 InvalidClassException。可序列化类可以通过声明名为 “serialVersionUID” 的字段（该字段必须是静态 (static)、最终 (final) 的 long 型字段）显式声明其自己的 serialVersionUID：<br />如果可序列化类未显式声明 serialVersionUID，则序列化运行时将基于该类的各个方面计算该类的默认 serialVersionUID 值，如“Java™ 对象序列化规范”中所述。<br />不过，强烈建议 所有可序列化类都显式声明 serialVersionUID 值，原因是计算默认的 serialVersionUID 对类的详细信息具有较高的敏感性，根据编译器实现的不同可能千差万别，这样在反序列化过程中可能会导致意外的 InvalidClassException。<br />因此，为保证 serialVersionUID 值跨不同 java 编译器实现的一致性，序列化类必须声明一个明确的 serialVersionUID 值。还强烈建议使用 private 修饰符显示声明 serialVersionUID（如果可能），原因是这种声明仅应用于直接声明类 – serialVersionUID 字段作为继承成员没有用处。数组类不能声明一个明确的 serialVersionUID，因此它们总是具有默认的计算值，但是数组类没有匹配 serialVersionUID 值的要求。
