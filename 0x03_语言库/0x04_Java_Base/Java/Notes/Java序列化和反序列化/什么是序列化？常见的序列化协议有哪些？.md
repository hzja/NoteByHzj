Java序列化
<a name="nt90g"></a>
## 序列化和反序列化相关概念
<a name="TWimE"></a>
### 什么是序列化?什么是反序列化?
如果需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。<br />简单来说：

- **序列化**：将数据结构或对象转换成二进制字节流的过程
- **反序列化**：将在序列化过程中所生成的二进制字节流的过程转换成数据结构或者对象的过程

对于 Java 这种面向对象编程语言来说，序列化的都是对象（Object）也就是实例化后的类(Class)，但是在 C++这种半面向对象的语言中，struct(结构体)定义的是数据结构类型，而 class 对应的是对象类型。<br />维基百科是如是介绍序列化的：<br />**序列化**（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取字节的结果时，可以利用它来产生与原始对象相同语义的副本。对于许多对象，像是使用大量引用的复杂对象，这种序列化重建的过程并不容易。面向对象中的对象序列化，并不概括之前原始对象所关系的函数。这种过程也称为对象编组（marshalling）。从一系列字节提取数据结构的反向操作，是反序列化（也称为解编组、deserialization、unmarshalling）。<br />综上：**序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。**<br />![https://www.corejavaguru.com/java/serialization/interview-questions-1](https://cdn.nlark.com/yuque/0/2022/png/396745/1652335240395-572af48d-3b75-431f-a670-afae88c6ec7c.png#clientId=u569dc8f8-c796-4&from=paste&id=ud9ae9f78&originHeight=266&originWidth=664&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=shadow&taskId=ue7f4284e-44b0-4637-b48c-d84f7e4d5ea&title=https%3A%2F%2Fwww.corejavaguru.com%2Fjava%2Fserialization%2Finterview-questions-1 "https://www.corejavaguru.com/java/serialization/interview-questions-1")
<a name="aPgRg"></a>
### 实际开发中有哪些用到序列化和反序列化的场景？

1. 对象在进行网络传输（比如远程方法调用 RPC 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；
2. 将对象存储到文件中的时候需要进行序列化，将对象从文件中读取出来需要进行反序列化。
3. 将对象存储到缓存数据库（如 Redis）时需要用到序列化，将对象从缓存数据库中读取出来需要反序列化。
<a name="A53Vl"></a>
### 序列化协议对应于 TCP/IP 4 层模型的哪一层？
网络通信的双方必须要采用和遵守相同的协议。TCP/IP 四层模型是下面这样的，序列化协议属于哪一层呢？

1. 应用层
2. 传输层
3. 网络层
4. 网络接口层

![TCP/IP 4层模型](https://cdn.nlark.com/yuque/0/2022/png/396745/1652335240399-8f218ca3-e340-4676-b179-13855e77dacc.png#clientId=u569dc8f8-c796-4&from=paste&id=ub577c2f4&originHeight=425&originWidth=713&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=shadow&taskId=u6dcaa72b-708f-4cde-883f-4a1fea1b70a&title=TCP%2FIP%204%E5%B1%82%E6%A8%A1%E5%9E%8B "TCP/IP 4层模型")<br />如上图所示，OSI 七层协议模型中，表示层做的事情主要就是对应用层的用户数据进行处理转换为二进制流。反过来的话，就是将二进制流转换成应用层的用户数据。这不就对应的是序列化和反序列化么？<br />因为，OSI 七层协议模型中的应用层、表示层和会话层对应的都是 TCP/IP 四层模型中的应用层，所以序列化协议属于 TCP/IP 协议应用层的一部分。
<a name="FWZ5F"></a>
## 常见序列化协议对比
JDK 自带的序列化方式一般不会用 ，因为序列化效率低并且部分版本有安全漏洞。比较常用的序列化协议有 hessian、kyro、protostuff。<br />下面提到的都是基于二进制的序列化协议，像 JSON 和 XML 这种属于文本类序列化方式。虽然 JSON 和 XML 可读性比较好，但是性能较差，一般不会选择。
<a name="HIV3I"></a>
### JDK 自带的序列化方式
JDK 自带的序列化，只需实现 `java.io.Serializable`接口即可。
```java
@AllArgsConstructor
@NoArgsConstructor
@Getter
@Builder
@ToString
public class RpcRequest implements Serializable {
    private static final long serialVersionUID = 1905122041950251207L;
    private String requestId;
    private String interfaceName;
    private String methodName;
    private Object[] parameters;
    private Class<?>[] paramTypes;
    private RpcMessageTypeEnum rpcMessageTypeEnum;
}
```
序列化号 `serialVersionUID` 属于版本控制的作用。序列化的时候 `serialVersionUID` 也会被写入二级制序列，当反序列化时会检查 `serialVersionUID` 是否和当前类的 serialVersionUID 一致。如果 serialVersionUID 不一致则会抛出 InvalidClassException 异常。强烈推荐每个序列化类都手动指定其 `serialVersionUID`，如果不手动指定，那么编译器会动态生成默认的序列化号<br />很少或者说几乎不会直接使用这个序列化方式，主要原因有两个：

1. **不支持跨语言调用** : 如果调用的是其他语言开发的服务的时候就不支持了。
2. **性能差** ：相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。
<a name="nHwwp"></a>
### Kryo
Kryo 是一个高性能的序列化/反序列化工具，由于其变长存储特性并使用了字节码生成机制，拥有较高的运行速度和较小的字节码体积。<br />另外，Kryo 已经是一种非常成熟的序列化实现了，已经在 Twitter、Groupon、Yahoo 以及多个著名开源项目（如 Hive、Storm）中广泛的使用。<br />[**guide-rpc-framework**](https://github.com/Snailclimb/guide-rpc-framework) 就是使用的 kyro 进行序列化，序列化和反序列化相关的代码如下：
```java
/**
* Kryo serialization class, Kryo serialization efficiency is very high, but only compatible with Java language
*/
@Slf4j
public class KryoSerializer implements Serializer {
	
	/**
	* Because Kryo is not thread safe. So, use ThreadLocal to store Kryo objects
	*/
	private final ThreadLocal<Kryo> kryoThreadLocal = ThreadLocal.withInitial(() -> {
		Kryo kryo = new Kryo();
		kryo.register(RpcResponse.class);
		kryo.register(RpcRequest.class);
		return kryo;
	});
	
	@Override
	public byte[] serialize(Object obj) {
		try (ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
			 Output output = new Output(byteArrayOutputStream)) {
			Kryo kryo = kryoThreadLocal.get();
			// Object->byte:将对象序列化为byte数组
			kryo.writeObject(output, obj);
			kryoThreadLocal.remove();
			return output.toBytes();
		} catch (Exception e) {
			throw new SerializeException("Serialization failed");
		}
	}
	
	@Override
	public <T> T deserialize(byte[] bytes, Class<T> clazz) {
		try (ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes);
			 Input input = new Input(byteArrayInputStream)) {
			Kryo kryo = kryoThreadLocal.get();
			// byte->Object:从byte数组中反序列化出对对象
			Object o = kryo.readObject(input, clazz);
			kryoThreadLocal.remove();
			return clazz.cast(o);
		} catch (Exception e) {
			throw new SerializeException("Deserialization failed");
		}
	}
	
}
```
Github 地址：[https://github.com/EsotericSoftware/kryo](https://github.com/EsotericSoftware/kryo)。
<a name="Zi1oc"></a>
### Protobuf
Protobuf 出自于 Google，性能还比较优秀，也支持多种语言，同时还是跨平台的。就是在使用中过于繁琐，因为需要自己定义 IDL 文件和生成对应的序列化代码。这样虽然不然灵活，但是，另一方面导致 protobuf 没有序列化漏洞的风险。<br />Protobuf 包含序列化格式的定义、各种语言的库以及一个 IDL 编译器。正常情况下需要定义 proto 文件，然后使用 IDL 编译器编译成需要的语言<br />一个简单的 proto 文件如下：
```protobuf
// protobuf的版本
syntax = "proto3";
// SearchRequest会被编译成不同的编程语言的相应对象，比如Java中的class、Go中的struct
message Person {
  //string类型字段
  string name = 1;
  // int 类型字段
  int32 age = 2;
}
```
Github 地址：[https://github.com/protocolbuffers/protobuf](https://github.com/protocolbuffers/protobuf)。
<a name="k1m3a"></a>
### ProtoStuff
由于 Protobuf 的易用性，它的哥哥 Protostuff 诞生了。<br />protostuff 基于 Google protobuf，但是提供了更多的功能和更简易的用法。虽然更加易用，但是不代表 ProtoStuff 性能更差。<br />Github 地址：[https://github.com/protostuff/protostuff](https://github.com/protostuff/protostuff)。
<a name="kJUa0"></a>
### hession
hessian 是一个轻量级的,自定义描述的二进制 RPC 协议。hessian 是一个比较老的序列化实现了，并且同样也是跨语言的。<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1652335240415-e0c730fb-41ff-4012-8962-f536088e1882.png#clientId=u569dc8f8-c796-4&from=paste&id=ub2e98f74&originHeight=654&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=ub6e5f621-ba3e-4f4e-8004-611409322db&title=)<br />dubbo RPC 默认启用的序列化方式是 hession2，但是，Dubbo 对 hessian2 进行了修改，不过大体结构还是差不多。
<a name="JGXio"></a>
### 总结
Kryo 是专门针对 Java 语言序列化方式并且性能非常好，如果应用是专门针对 Java 语言的话可以考虑使用，并且 Dubbo 官网的一篇文章中提到说推荐使用 Kryo 作为生产环境的序列化方式。(文章地址：[https://dubbo.apache.org/zh/docs/v2.7/user/references/protocol/rest/](https://dubbo.apache.org/zh/docs/v2.7/user/references/protocol/rest/))<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1652335240442-05c516e3-c67a-4b86-a5ae-f224d8938f56.png#clientId=u569dc8f8-c796-4&from=paste&id=ud70790a5&originHeight=231&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=ue02ab660-057a-4123-b3b9-f53a66874ac&title=)<br />像 Protobuf、 ProtoStuff、hession 这类都是跨语言的序列化方式，如果有跨语言需求的话可以考虑使用。<br />除了上面介绍到的序列化方式的话，还有像 Thrift，Avro 这些。
<a name="PBl2U"></a>
## 其他推荐阅读

- 美团技术团队-序列化和反序列化：[https://tech.meituan.com/2015/02/26/serialization-vs-deserialization.html](https://tech.meituan.com/2015/02/26/serialization-vs-deserialization.html)
- 在 Dubbo 中使用高效的 Java 序列化（Kryo 和 FST）: [https://dubbo.apache.org/zh-cn/docs/user/serialization.html](https://dubbo.apache.org/zh-cn/docs/user/serialization.html)
<a name="lDmwq"></a>
## 参考资料
guide-rpc-framework: [https://github.com/Snailclimb/guide-rpc-framework](https://github.com/Snailclimb/guide-rpc-framework)<br />https://github.com/EsotericSoftware/kryo: [https://github.com/EsotericSoftware/kryo](https://github.com/EsotericSoftware/kryo)<br />https://github.com/protocolbuffers/protobuf: [https://github.com/protocolbuffers/protobuf](https://github.com/protocolbuffers/protobuf)<br />https://github.com/protostuff/protostuff: [https://github.com/protostuff/protostuff](https://github.com/protostuff/protostuff)<br />https://dubbo.apache.org/zh/docs/v2.7/user/references/protocol/rest/: [https://dubbo.apache.org/zh/docs/v2.7/user/references/protocol/rest/](https://dubbo.apache.org/zh/docs/v2.7/user/references/protocol/rest/)<br />https://tech.meituan.com/2015/02/26/serialization-vs-deserialization.html: [https://tech.meituan.com/2015/02/26/serialization-vs-deserialization.html](https://tech.meituan.com/2015/02/26/serialization-vs-deserialization.html)<br />https://dubbo.apache.org/zh-cn/docs/user/serialization.html: [https://dubbo.apache.org/zh-cn/docs/user/serialization.html](https://dubbo.apache.org/zh-cn/docs/user/serialization.html)
