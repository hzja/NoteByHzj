Java 序列化 反序列化
<a name="kDbmD"></a>
## 序列化是做什么的
序列化的原本意图是希望对一个Java对象作一下“变换”，变成字节序列，这样一来方便持久化存储到磁盘，避免程序运行结束后对象就从内存里消失，另外变换成字节序列也更便于网络运输和传播，所以概念上很好理解：

- 序列化：把Java对象转换为字节序列。
- 反序列化：把字节序列恢复为原先的Java对象。

![2021-10-07-11-25-50-491184.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1633577660957-de956e15-4368-4d9b-b146-d63255ae3ea5.png#clientId=u7b8a083c-e98d-4&from=ui&id=Yzz4P&originHeight=498&originWidth=1080&originalType=binary&ratio=1&size=1616711&status=done&style=shadow&taskId=u163468ec-9ae1-4d32-9345-8f18851d97e)<br />而且序列化机制从某种意义上来说也弥补了平台化的一些差异，毕竟转换后的字节流可以在其他平台上进行反序列化来恢复对象。
<a name="KhkKz"></a>
## 对象如何序列化？
然而Java目前并没有一个关键字可以直接去定义一个所谓的“可持久化”对象。<br />对象的持久化和反持久化需要靠程序员在代码里手动显式地进行序列化和反序列化还原的动作。<br />举个例子，假如要对Student类对象序列化到一个名为student.txt的文本文件中，然后再通过文本文件反序列化成Student类对象：<br />![2021-10-07-11-25-50-620185.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1633577416416-7f498641-01a8-46d0-bd6f-e89255f107d2.png#clientId=u7b8a083c-e98d-4&from=ui&id=I4PRs&originHeight=514&originWidth=1080&originalType=binary&ratio=1&size=44072&status=done&style=shadow&taskId=uc1042609-769a-4528-9c1f-3b42bb1365d)
<a name="NdntJ"></a>
### 1、Student类定义
```java
public class Student implements Serializable {

    private String name;
    private Integer age;
    private Integer score;
    
    @Override
    public String toString() {
        return "Student:" + 'n' +
        "name = " + this.name + 'n' +
        "age = " + this.age + 'n' +
        "score = " + this.score + 'n'
        ;
    }
    
    // ... 其他省略 ...
}
```
<a name="D1cYB"></a>
### 2、序列化
```java
public static void serialize(  ) throws IOException {

    Student student = new Student();
    student.setName("CodeSheep");
    student.setAge( 18 );
    student.setScore( 1000 );

    ObjectOutputStream objectOutputStream = 
        new ObjectOutputStream( new FileOutputStream( new File("student.txt") ) );
    objectOutputStream.writeObject( student );
    objectOutputStream.close();
    
    System.out.println("序列化成功！已经生成student.txt文件");
    System.out.println("==============================================");
}
```
<a name="ErrQS"></a>
### 3、反序列化
```java
public static void deserialize() throws IOException, ClassNotFoundException {
    ObjectInputStream objectInputStream = 
        new ObjectInputStream( new FileInputStream( new File("student.txt") ) );
    Student student = (Student) objectInputStream.readObject();
    objectInputStream.close();
    
    System.out.println("反序列化结果为：");
    System.out.println( student );
}
```
<a name="UDrUs"></a>
### 4、运行结果
控制台打印：
```java
序列化成功！已经生成student.txt文件
==============================================
反序列化结果为：
Student:
name = CodeSheep
age = 18
score = 1000
```
<a name="gxTXk"></a>
## Serializable接口有何用？
上面在定义Student类时，实现了一个`Serializable`接口，然而当点进`Serializable`接口内部查看，发现它竟然是一个空接口，并没有包含任何方法！<br />![2021-10-07-11-25-50-781357.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1633577491638-a81894c4-0595-4579-8aeb-996d5fbd520b.png#clientId=u7b8a083c-e98d-4&from=ui&id=u2ec9a627&originHeight=598&originWidth=724&originalType=binary&ratio=1&size=71963&status=done&style=none&taskId=uc62d1086-99e9-430e-b080-835d8167319)<br />试想，如果上面在定义Student类时忘了加`implements Serializable`时会发生什么呢？<br />实验结果是：此时的程序运行会报错，并抛出`NotSerializableException`异常：<br />![2021-10-07-11-25-51-004462.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1633577491648-f3facc34-0c69-4159-99d4-79d3975634c5.png#clientId=u7b8a083c-e98d-4&from=ui&id=pUjZD&originHeight=265&originWidth=1080&originalType=binary&ratio=1&size=112690&status=done&style=none&taskId=u668c3b0d-e1d9-4004-8b0e-dd5969cf09a)<br />按照错误提示，由源码一直跟到`ObjectOutputStream`的`writeObject0()`方法底层一看，才恍然大悟：<br />![2021-10-07-11-25-51-194447.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1633577491678-f0d901ca-2262-444f-8253-46394055368e.png#clientId=u7b8a083c-e98d-4&from=ui&id=qU2Gk&originHeight=791&originWidth=1080&originalType=binary&ratio=1&size=218038&status=done&style=none&taskId=uc1e7f43a-d07d-4cba-a301-5e989cb2ff1)<br />如果一个对象既不是字符串、数组、枚举，而且也没有实现`Serializable`接口的话，在序列化时就会抛出`NotSerializableException`异常！<br />原来`Serializable`接口也仅仅只是做一个标记用！！！<br />它告诉代码只要是实现了`Serializable`接口的类都是可以被序列化的！然而真正的序列化动作不需要靠它完成。
<a name="PVxlW"></a>
## `serialVersionUID`号有何用？
一定经常看到有些类中定义了如下代码行，即定义了一个名为`serialVersionUID`的字段：
```java
private static final long serialVersionUID = -4392658638228508589L;
```
知道这句声明的含义吗？为什么要搞一个名为`serialVersionUID`的序列号？<br />继续来做一个简单实验，还拿上面的Student类为例，并没有人为在里面显式地声明一个`serialVersionUID`字段。<br />首先还是调用上面的`serialize()`方法，将一个Student对象序列化到本地磁盘上的student.txt文件：
```java
public static void serialize() throws IOException {

    Student student = new Student();
    student.setName("CodeSheep");
    student.setAge( 18 );
    student.setScore( 100 );

    ObjectOutputStream objectOutputStream = 
        new ObjectOutputStream( new FileOutputStream( new File("student.txt") ) );
    objectOutputStream.writeObject( student );
    objectOutputStream.close();
}
```
接下来在Student类里面动点手脚，比如在里面再增加一个名为studentID的字段，表示学生学号：<br />![2021-10-07-11-25-51-315442.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1633577552188-295b83d1-34a4-440f-85bb-27809209054a.png#clientId=u7b8a083c-e98d-4&from=ui&id=uaa5c7e74&originHeight=412&originWidth=1018&originalType=binary&ratio=1&size=48039&status=done&style=none&taskId=ua8dc56ce-f7b2-429c-9424-3040300ffcf)<br />这时候，拿刚才已经序列化到本地的student.txt文件，还用如下代码进行反序列化，试图还原出刚才那个Student对象：
```java
public static void deserialize() throws IOException, ClassNotFoundException {
    ObjectInputStream objectInputStream = 
        new ObjectInputStream( new FileInputStream( new File("student.txt") ) );
    Student student = (Student) objectInputStream.readObject();
    objectInputStream.close();
    
    System.out.println("反序列化结果为：");
    System.out.println( student );
}
```
运行发现报错了，并且抛出了`InvalidClassException`异常：<br />![2021-10-07-11-25-51-488449.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1633577552294-27b97419-f26b-44db-bcb5-921bbd245ca3.png#clientId=u7b8a083c-e98d-4&from=ui&id=ZnXVK&originHeight=508&originWidth=1080&originalType=binary&ratio=1&size=235867&status=done&style=none&taskId=u31517481-cbf1-40f0-accd-a9875b91527)<br />这地方提示的信息非常明确了：序列化前后的`serialVersionUID`号码不兼容！<br />从这地方最起码可以得出两个重要信息：

- 1、`serialVersionUID`是序列化前后的唯一标识符
- 2、默认如果没有人为显式定义过`serialVersionUID`，那编译器会为它自动声明一个！

第1个问题： `serialVersionUID`序列化ID，可以看成是序列化和反序列化过程中的“暗号”，在反序列化时，JVM会把字节流中的序列号ID和被序列化类中的序列号ID做比对，只有两者一致，才能重新反序列化，否则就会报异常来终止反序列化的过程。<br />第2个问题： 如果在定义一个可序列化的类时，没有人为显式地给它定义一个`serialVersionUID`的话，则Java运行时环境会根据该类的各方面信息自动地为它生成一个默认的`serialVersionUID`，一旦像上面一样更改了类的结构或者信息，则类的`serialVersionUID`也会跟着变化！<br />所以，为了`serialVersionUID`的确定性，写代码时还是建议，凡是`implements Serializable`的类，都最好人为显式地为它声明一个`serialVersionUID`明确值！<br />当然，如果不想手动赋值，也可以借助IDE的自动添加功能，比如使用的IntelliJ IDEA，按alt + enter就可以为类自动生成和添加`serialVersionUID`字段，十分方便：<br />![2021-10-07-11-25-51-609441.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1633577552273-8f3db577-7fc9-4e03-95df-76af05dc6b27.png#clientId=u7b8a083c-e98d-4&from=ui&id=e7HZ2&originHeight=489&originWidth=1080&originalType=binary&ratio=1&size=132423&status=done&style=none&taskId=u7bb4dd9d-4719-4127-a0bd-be3a2356dac)<br />两种特殊情况

- 1、凡是被`static`修饰的字段是不会被序列化的
- 2、凡是被`transient`修饰符修饰的字段也是不会被序列化的

对于第一点，因为序列化保存的是对象的状态而非类的状态，所以会忽略`static`静态域也是理所应当的。<br />对于第二点，就需要了解一下`transient`修饰符的作用了。<br />如果在序列化某个类的对象时，就是不希望某个字段被序列化（比如这个字段存放的是隐私值，如：密码等），那这时就可以用`transient`修饰符来修饰该字段。<br />比如在之前定义的Student类中，加入一个密码字段，但是不希望序列化到txt文本，则可以：<br />![2021-10-07-11-25-51-701438.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1633577573572-b9664281-5611-405e-9124-42b636b23d50.png#clientId=u7b8a083c-e98d-4&from=ui&id=u556347b2&originHeight=356&originWidth=930&originalType=binary&ratio=1&size=46824&status=done&style=none&taskId=ue7cc8e97-2dc5-4f59-9d49-37421ffe62e)<br />这样在序列化Student类对象时，password字段会设置为默认值null，这一点可以从反序列化所得到的结果来看出：<br />![2021-10-07-11-25-51-807973.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1633577573590-f0ee2cce-84a4-4c6e-a0e0-15557e0a8678.png#clientId=u7b8a083c-e98d-4&from=ui&id=JZyxX&originHeight=456&originWidth=918&originalType=binary&ratio=1&size=61652&status=done&style=none&taskId=u8a25d69e-630f-4839-9b6e-b4b8011b9a7)<br />序列化的受控和加强
<a name="foP5q"></a>
### 约束性加持
从上面的过程可以看出，序列化和反序列化的过程其实是有漏洞的，因为从序列化到反序列化是有中间过程的，如果被别人拿到了中间字节流，然后加以伪造或者篡改，那反序列化出来的对象就会有一定风险了。<br />毕竟反序列化也相当于一种 “隐式的”对象构造 ，因此希望在反序列化时，进行受控的对象反序列化动作。<br />那怎么个受控法呢？<br />答案就是： 自行编写`readObject()`函数，用于对象的反序列化构造，从而提供约束性。<br />既然自行编写`readObject()`函数，那就可以做很多可控的事情：比如各种判断工作。<br />还以上面的Student类为例，一般来说学生的成绩应该在0 ~ 100之间，为了防止学生的考试成绩在反序列化时被别人篡改成一个奇葩值，可以自行编写`readObject()`函数用于反序列化的控制：
```java
private void readObject( ObjectInputStream objectInputStream ) throws IOException, ClassNotFoundException {

    // 调用默认的反序列化函数
    objectInputStream.defaultReadObject();

    // 手工检查反序列化后学生成绩的有效性，若发现有问题，即终止操作！
    if( 0 > score || 100 < score ) {
        throw new IllegalArgumentException("学生分数只能在0到100之间！");
    }
}
```
比如故意将学生的分数改为101，此时反序列化立马终止并且报错：<br />![2021-10-07-11-25-51-983000.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1633577573682-f52b1d0e-b8ff-4931-9c66-70e6e8dc5c41.png#clientId=u7b8a083c-e98d-4&from=ui&id=YCGMs&originHeight=368&originWidth=1080&originalType=binary&ratio=1&size=180101&status=done&style=none&taskId=ua9035cd2-2974-463d-b72c-ca0aa62e3d8)<br />对于上面的代码，有些小伙伴可能会好奇，为什么自定义的`private`的`readObject()`方法可以被自动调用，这就需要跟一下底层源码来一探究竟了，跟到了`ObjectStreamClass`类的最底层，看到这里一定恍然大悟：<br />![2021-10-07-11-25-52-216555.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1633577596866-a0492be7-f01d-4bfa-8eeb-7035c0748dd9.png#clientId=u7b8a083c-e98d-4&from=ui&id=ua8796865&originHeight=660&originWidth=1080&originalType=binary&ratio=1&size=233597&status=done&style=none&taskId=u8eb80c36-acb9-47e4-89df-c037b3117f6)<br />又是反射机制在起作用！是的，在Java里，果然万物皆可“反射”（滑稽），即使是类中定义的`private`私有方法，也能被抠出来执行了，简直引起舒适了。
<a name="Wc305"></a>
### 单例模式增强
一个容易被忽略的问题是：可序列化的单例类有可能并不单例！<br />举个代码小例子就清楚了。<br />比如这里先用java写一个常见的「静态内部类」方式的单例模式实现：
```java
public class Singleton implements Serializable {

    private static final long serialVersionUID = -1576643344804979563L;

    private Singleton() {
    }

    private static class SingletonHolder {
        private static final Singleton singleton = new Singleton();
    }

    public static synchronized Singleton getSingleton() {
        return SingletonHolder.singleton;
    }
}
```
然后写一个验证主函数：
```java
public class Test2 {

    public static void main(String[] args) throws IOException, ClassNotFoundException {

        ObjectOutputStream objectOutputStream =
                new ObjectOutputStream(
                    new FileOutputStream( new File("singleton.txt") )
                );
        // 将单例对象先序列化到文本文件singleton.txt中
        objectOutputStream.writeObject( Singleton.getSingleton() );
        objectOutputStream.close();

        ObjectInputStream objectInputStream =
                new ObjectInputStream(
                    new FileInputStream( new File("singleton.txt") )
                );
        // 将文本文件singleton.txt中的对象反序列化为singleton1
        Singleton singleton1 = (Singleton) objectInputStream.readObject();
        objectInputStream.close();

        Singleton singleton2 = Singleton.getSingleton();

        // 运行结果竟打印 false ！
        System.out.println( singleton1 == singleton2 );
    }

}
```
运行后发现：反序列化后的单例对象和原单例对象并不相等了，这无疑没有达到目标。<br />解决办法是：在单例类中手写`readResolve()`函数，直接返回单例对象，来规避之：
```java
private Object readResolve() {
    return SingletonHolder.singleton;
}
```
![2021-10-07-11-25-52-475083.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1633577661254-f9360b43-d95a-4cf4-a442-202e9e60df22.png#clientId=u7b8a083c-e98d-4&from=ui&id=u442ce2f2&originHeight=739&originWidth=1080&originalType=binary&ratio=1&size=2399052&status=done&style=none&taskId=uafab981d-22f5-40a4-8569-2e9f7c2e3bf)<br />这样一来，当反序列化从流中读取对象时，`readResolve()`会被调用，用其中返回的对象替代反序列化新建的对象。
