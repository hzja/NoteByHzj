Java 死锁<br />死锁（Dead Lock）指的是两个或两个以上的运算单元（进程、线程或协程），都在等待对方停止执行，以取得系统资源，但是没有一方提前退出，就称为死锁。<br />![2021-09-04-13-06-42-101736.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1630732010050-41be1462-c4e6-441c-8f44-e55d8682421a.png#clientId=u9e81bf32-1874-4&from=ui&id=u7d24d61a&originHeight=606&originWidth=938&originalType=binary&ratio=1&size=87182&status=done&style=shadow&taskId=u3597fcf3-72d5-4791-be90-a6dc19503b6)
<a name="loFPK"></a>
## 死锁示例
接下来，先来演示一下 Java 中最简单的死锁，创建两个锁和两个线程，让线程 1 先拥有锁 A，然后在 1s 后尝试获取锁 B，同时启动线程 2，让它先拥有锁 B，然后在 1s 之后尝试获取锁 A，这时就会出现相互等待对方释放锁的情况，从而造成死锁的问题，具体代码如下：
```java
public class DeadLockExample {
    public static void main(String[] args) {
        Object lockA = new Object(); // 创建锁 A
        Object lockB = new Object(); // 创建锁 B

        // 创建线程 1
        Thread t1 = new Thread(new Runnable() {
            @Override
            public void run() {
                // 先获取锁 A
                synchronized (lockA) {
                    System.out.println("线程 1:获取到锁 A!");
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    // 尝试获取锁 B
                    System.out.println("线程 1:等待获取 B...");
                    synchronized (lockB) {
                        System.out.println("线程 1:获取到锁 B!");
                    }
                }
            }
        });
        t1.start(); // 运行线程

        // 创建线程 2
        Thread t2 = new Thread(new Runnable() {
            @Override
            public void run() {
                // 先获取锁 B
                synchronized (lockB) {
                    System.out.println("线程 2:获取到锁 B!");
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    // 尝试获取锁 A
                    System.out.println("线程 2:等待获取 A...");
                    synchronized (lockA) {
                        System.out.println("线程 2:获取到锁 A!");
                    }
                }
            }
        });
        t2.start(); // 运行线程
    }
}
```
以上程序的执行结果如下：<br />![2021-09-04-13-06-42-467724.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1630732029398-13992479-b39a-4927-9fc7-dbca1d445733.png#clientId=u9e81bf32-1874-4&from=ui&id=uf53442f1&originHeight=316&originWidth=758&originalType=binary&ratio=1&size=20439&status=done&style=none&taskId=u216a35db-96bc-4429-a589-4215def4e0e)<br />从上述结果可以看出，线程 1 和线程 2 都在等待对方释放锁，这样就造成了死锁问题。
<a name="q3Ba8"></a>
## 死锁产生原因
通过以上示例，可以得出结论，要产生死锁需要满足以下 4 个条件：

1. 互斥条件：指运算单元（进程、线程或协程）对所分配到的资源具有排它性，也就是说在一段时间内某个锁资源只能被一个运算单元所占用。
2. 请求和保持条件：指运算单元已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它运算单元占有，此时请求运算单元阻塞，但又对自己已获得的其它资源保持不放。
3. 不可剥夺条件：指运算单元已获得的资源，在未使用完之前，不能被剥夺。
4. 环路等待条件：指在发生死锁时，必然存在运算单元和资源的环形链，即运算单元正在等待另一个运算单元占用的资源，而对方又在等待自己占用的资源，从而造成环路等待的情况。

只有以上 4 个条件同时满足，才会造成死锁问题。
<a name="cNHWq"></a>
## 死锁排查
如果程序出现死锁问题，可通过以下 4 种方案中的任意一种进行分析和排查。
<a name="Ve6yl"></a>
### 方案 1：jstack
在使用 jstack 之前，先要通过 jps 得到运行程序的进程 ID，使用方法如下：<br />![2021-09-04-13-06-42-645682.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1630732029413-4e59e952-6240-438e-949e-518da71fbf4b.png#clientId=u9e81bf32-1874-4&from=ui&id=lvXay&originHeight=669&originWidth=1080&originalType=binary&ratio=1&size=44814&status=done&style=none&taskId=u95298e10-ac2e-44ed-9459-79dddc7b9d6)<br />“jps -l”可以查询本机所有的 Java 程序，jps（Java Virtual Machine Process Status Tool）是 Java 提供的一个显示当前所有 Java 进程 pid 的命令，适合在 linux/unix/windows 平台上简单查看当前 Java 进程的一些简单情况，“-l”用于输出进程 pid 和运行程序完整路径名（包名和类名）。<br />有了进程 ID（PID）之后，就可以使用“jstack -l PID”来发现死锁问题了，如下图所示：<br />![2021-09-04-13-06-42-885716.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1630732056904-6d2669f5-433a-4f41-8313-06658d36f593.png#clientId=u9e81bf32-1874-4&from=ui&id=u2fcaa5a4&originHeight=836&originWidth=1080&originalType=binary&ratio=1&size=328092&status=done&style=none&taskId=uc895f745-240f-425c-ab3a-8ad8d75e6ed)<br />jstack 用于生成 Java 虚拟机当前时刻的线程快照，“-l”表示长列表（long），打印关于锁的附加信息。<br />PS：可以使用 jstack -help 查看更多命令使用说明。
<a name="DYaku"></a>
### 方案 2：jconsole
使用 jconsole 需要打开 JDK 的 bin 目录，找到 jconsole 并双击打开，如下图所示：<br />![2021-09-04-13-06-43-144085.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1630732056966-ef981d0f-b086-4f27-8817-36a1f27bc956.png#clientId=u9e81bf32-1874-4&from=ui&id=j2MAK&originHeight=751&originWidth=1080&originalType=binary&ratio=1&size=413663&status=done&style=none&taskId=u6c76419b-9f85-4d8b-b1e7-1980525afaa)<br />然后选择要调试的程序，如下图所示：<br />![2021-09-04-13-06-43-585082.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1630732056807-5a860eb2-2d45-41ca-9cff-7b5b02ec7bb4.png#clientId=u9e81bf32-1874-4&from=ui&id=L0295&originHeight=900&originWidth=1080&originalType=binary&ratio=1&size=100916&status=done&style=none&taskId=u4ac05c0e-1353-42a2-910e-8f01457d39e)<br />之后点击连接进入，选择“不安全的连接”进入监控主页，如下图所示：<br />![2021-09-04-13-06-43-774081.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1630732084749-8716c484-cfc9-4596-b6c0-1d5218cc574a.png#clientId=u9e81bf32-1874-4&from=ui&id=uadf9fd83&originHeight=900&originWidth=1080&originalType=binary&ratio=1&size=86367&status=done&style=none&taskId=u4b6a3e55-8ee4-42f2-b91e-a896e5ba083)![2021-09-04-13-06-43-943084.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1630732084776-4b9e0c02-766a-4bba-b927-fd18719e0acd.png#clientId=u9e81bf32-1874-4&from=ui&id=u61d62145&originHeight=900&originWidth=1080&originalType=binary&ratio=1&size=110266&status=done&style=none&taskId=ub5da1788-f223-4e25-b19b-0c39ba334e4)<br />之后切换到“线程”模块，点击“检测死锁”按钮，如下图所示：<br />![2021-09-04-13-06-44-156082.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1630732084788-00600985-c8e9-4631-b8b4-ad6e1818d0ed.png#clientId=u9e81bf32-1874-4&from=ui&id=MgM15&originHeight=900&originWidth=1080&originalType=binary&ratio=1&size=116810&status=done&style=none&taskId=uea2b96ed-2eee-4fb0-8258-ada920deb99)<br />之后稍等片刻就会检测出死锁的相关信息，如下图所示：<br />![2021-09-04-13-06-44-385088.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1630732108343-f264936e-1a12-4231-bac3-2beca10fef73.png#clientId=u9e81bf32-1874-4&from=ui&id=u2e96bff0&originHeight=900&originWidth=1080&originalType=binary&ratio=1&size=121203&status=done&style=none&taskId=uffb26a07-7b2f-4bae-8dac-f53d3030549)
<a name="IlwCT"></a>
### 方案 3：jvisualvm
jvisualvm 也在 JDK 的 bin 目录中，同样是双击打开：<br />![2021-09-04-13-06-44-786082.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1630732108521-a57081b0-9d9a-4b7d-b7e4-0bfd20c4ff71.png#clientId=u9e81bf32-1874-4&from=ui&id=RumJJ&originHeight=751&originWidth=1080&originalType=binary&ratio=1&size=403519&status=done&style=none&taskId=u67924424-82a5-4ae2-b361-0a68f6537ed)<br />稍等几秒之后，jvisualvm 中就会出现本地的所有 Java 程序，如下图所示：<br />![2021-09-04-13-06-44-902092.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1630732108368-7a86fb2e-738e-49e2-8625-e2debcdadafd.png#clientId=u9e81bf32-1874-4&from=ui&id=YGpUH&originHeight=668&originWidth=1080&originalType=binary&ratio=1&size=86042&status=done&style=none&taskId=u74924eb5-f84e-4b8b-a538-18f0fd3fcf5)<br />双击选择要调试的程序：<br />![2021-09-04-13-06-45-038076.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1630732133310-95c54e83-8388-4e2e-969f-dc4adc1ee97e.png#clientId=u9e81bf32-1874-4&from=ui&id=u5831c734&originHeight=668&originWidth=1080&originalType=binary&ratio=1&size=149217&status=done&style=none&taskId=u8c957900-5d7e-4114-a3ba-658421a15c9)<br />单击鼠标进入“线程”模块，如下图所示：<br />![2021-09-04-13-06-45-220084.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1630732133343-5d1e97ae-98e9-48cb-9b5f-159b0bb61e9a.png#clientId=u9e81bf32-1874-4&from=ui&id=agWjj&originHeight=668&originWidth=1080&originalType=binary&ratio=1&size=190741&status=done&style=none&taskId=ud785a324-d1ac-4df2-93a4-caf5d36590b)<br />从上图可以看出，当切换到线程一栏之后就会直接显示出死锁信息，之后点击“线程 Dump”生成死锁的详情信息，如下图所示：<br />![2021-09-04-13-06-45-770094.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1630732133363-0d8a8403-f6c6-423b-905e-9e584d546842.png#clientId=u9e81bf32-1874-4&from=ui&id=BvMJI&originHeight=668&originWidth=1080&originalType=binary&ratio=1&size=223520&status=done&style=none&taskId=uaf00da18-cfc8-4ac4-aae3-cc1b3121505)
<a name="i1w1r"></a>
### 方案 4：jmc
jmc 是 Oracle Java Mission Control 的缩写，是一个对 Java 程序进行管理、监控、概要分析和故障排查的工具套件。它也是在 JDK 的 bin 目录中，同样是双击启动，如下图所示：<br />![2021-09-04-13-06-47-216076.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1630732165309-9ef73cd9-f263-4647-94f2-db2b7cc73983.png#clientId=u9e81bf32-1874-4&from=ui&id=u8ca495e9&originHeight=751&originWidth=1080&originalType=binary&ratio=1&size=413148&status=done&style=none&taskId=ud279498b-b57a-46a6-b6f5-f96e7c7e408)<br />jmc 主页信息如下：<br />![2021-09-04-13-06-47-317082.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1630732165169-53efc8f9-d968-4531-bb79-e9f9787c99cc.png#clientId=u9e81bf32-1874-4&from=ui&id=LCSkQ&originHeight=657&originWidth=1080&originalType=binary&ratio=1&size=51449&status=done&style=none&taskId=ufe50e03d-007f-45f0-8e43-a0bc48c346d)<br />之后选中要排查的程序，右键“启动 JMX 控制台”查看此程序的详细内容，如下图所示：<br />![2021-09-04-13-06-47-446080.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1630732165166-1a9e6a4b-3116-4576-afe8-e70f646d03cc.png#clientId=u9e81bf32-1874-4&from=ui&id=vgL4P&originHeight=460&originWidth=706&originalType=binary&ratio=1&size=35522&status=done&style=shadow&taskId=u1fad256a-87bb-4597-ad1a-b4ec162931e)<br />![2021-09-04-13-06-47-722079.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1630732189733-1c992f76-cd7f-47f9-bc7a-86d86ab8a1d8.png#clientId=u9e81bf32-1874-4&from=ui&id=ubf293e01&originHeight=657&originWidth=1080&originalType=binary&ratio=1&size=218157&status=done&style=none&taskId=u96aaf9e3-d8cb-4cbe-a633-9820ba24bd3)<br />然后点击“线程”，勾中“死锁检测”就可以发现死锁和死锁的详情信息，如下图所示：<br />![2021-09-04-13-06-47-861103.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1630732189741-c0471c74-73cc-4838-b779-3e8bbe472047.png#clientId=u9e81bf32-1874-4&from=ui&id=ECQeP&originHeight=657&originWidth=1080&originalType=binary&ratio=1&size=220570&status=done&style=none&taskId=u9c1205c2-9a6c-41b9-9d68-24c01d0fc19)
<a name="XrllZ"></a>
## 总结
死锁是因为两个或两个以上的运算单元，都在等待对方停止执行，以取得系统资源，但没有一方提前退出，于是就出现了死锁。死锁的排查工具总共有 4 种：

- jstack
- jconsole
- jvisualvm
- jmc

从易用性和性能方面来考虑，推荐使用 jconsole 或 jvisualvm 来排查死锁。
