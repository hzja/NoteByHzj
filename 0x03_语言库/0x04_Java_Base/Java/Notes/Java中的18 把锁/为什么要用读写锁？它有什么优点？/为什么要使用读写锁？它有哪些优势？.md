<a name="ZxKEA"></a>
## 一、摘要
`ReentrantLock`可以保证了只有一个线程能执行加锁的代码。<br />但是有些时候，这种保护显的有点过头，比如下面这个方法，它仅仅就是只读取数据，不修改数据，它实际上允许多个线程同时调用的。
```java
public class Counter {

    private final Lock lock = new ReentrantLock();

    private int count;

    public int get() {
        // 加锁
        lock.lock();
        try {
            return count;
        } finally {
            // 释放锁
            lock.unlock();
        }
    }
}
```
站在程序性能的角度，实际上想要的是这样的效果。

1. 读和读之间不互斥，因为只读操作不会有数据安全问题
2. 写和写之间互斥，避免一个写操作影响另外一个写操作，引发数据计算错误问题
3. 读和写之间互斥，避免读操作的时候写操作修改了内容，引发数据脏读问题

总结起来就是，允许多个线程同时读，但只要有一个线程在写，其他线程就必须排队等待。<br />在 JDK 中有一个读写锁`ReadWriteLock`，使用它就可以解决这个问题，它可以保证以下两点：

1. 只允许一个线程写入，其他线程既不能写入也不能读取
2. 没有写入时，多个线程允许同时读，可以提高程序并发性能

实际上，读写锁`ReadWriteLock`里面有两个锁实现，一个是读操作相关的锁，称为共享锁，当多个线程同时操作时，不会让多个线程进行排队等待，大大的提升了程序并发读的执行效率；另一个是写操作相关的锁，称为排他锁，当多个线程同时操作时，只允许一个线程写入，其他线程进入排队等待；两者进行组合操作，就可以实现上面的预期效果。<br />下面一起来看看它的基本用法！
<a name="d1xgm"></a>
## 二、ReadWriteLock 基本用法
<a name="AzL0l"></a>
### 2.1、读和读共享
读和读之间不互斥，当多个线程进行读的时候，不会让多个线程进行排队等待。<br />可以看一个简单的例子！
```java
public class Counter {

    private final ReadWriteLock lock = new ReentrantReadWriteLock();

    private int count;

    public void read() {
        // 加读锁
        lock.readLock().lock();
        try {
            String time = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss:SSS").format(new Date());
            System.out.println(time + " 当前线程：" + Thread.currentThread().getName() + "获得了读锁，count:" + count);
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            // 释放读锁
            lock.readLock().unlock();
        }
    }
}
```
```java
public class MyThreadTest {

    public static void main(String[] args) {
        Counter counter = new Counter();
        Thread threadA = new Thread(new Runnable() {
            @Override
            public void run() {
                counter.read();
            }
        });

        Thread threadB = new Thread(new Runnable() {
            @Override
            public void run() {
                counter.read();
            }
        });

        threadA.start();
        threadB.start();
    }
}
```
看一下运行结果：
```
2023-10-23 16:12:28:119 当前线程：Thread-0获得了读锁，count:0
2023-10-23 16:12:28:119 当前线程：Thread-1获得了读锁，count:0
```
从日志时间上可以很清晰的看到，尽管加锁了，并且休眠了 5 秒，但是两个线程还是几乎同时执行`try()`方法里面的代码，证明了读和读之间是不互斥的，可以显著提高程序的运行效率。
<a name="bYCxG"></a>
### 2.2、写和写之间互斥
写和写之间互斥，当多个线程进行写的时候，只允许一个线程写入，其他线程进入排队等待。<br />可以看一个简单的例子！
```java
public class Counter {

    private final ReadWriteLock lock = new ReentrantReadWriteLock();

    private int count;

    public void write() {
        // 加写锁
        lock.writeLock().lock();
        try {
            count++;
            String time = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss:SSS").format(new Date());
            System.out.println(time + " 当前线程：" + Thread.currentThread().getName() + "获得了写锁，count:" + count);
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            // 释放写锁
            lock.writeLock().unlock();
        }
    }
}
```
```java
public class MyThreadTest {

    public static void main(String[] args) {
        Counter counter = new Counter();
        Thread threadA = new Thread(new Runnable() {
            @Override
            public void run() {
                counter.write();
            }
        });

        Thread threadB = new Thread(new Runnable() {
            @Override
            public void run() {
                counter.write();
            }
        });

        threadA.start();
        threadB.start();
    }
}
```
看一下运行结果：
```
2023-10-23 16:29:59:103 当前线程：Thread-0获得了写锁，count:1
2023-10-23 16:30:04:108 当前线程：Thread-1获得了写锁，count:2
```
从日志时间上可以很清晰的看到，两个线程进行串行执行，证明了写和写之间是互斥的。
<a name="AVMNv"></a>
### 2.3、读和写之间互斥
读和写之间互斥，当多个线程交替进行读写的时候，操作上互斥，只有一个线程能进入，其他线程进入排队等待。<br />可以看一个简单的例子！
```java
public class Counter {

    private final ReadWriteLock lock = new ReentrantReadWriteLock();

    private int count;

    public void read() {
        // 加读锁
        lock.readLock().lock();
        try {
            String time = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss:SSS").format(new Date());
            System.out.println(time + " 当前线程：" + Thread.currentThread().getName() + "获得了读锁，count:" + count);
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            // 释放读锁
            lock.readLock().unlock();
        }
    }

    public void write() {
        // 加写锁
        lock.writeLock().lock();
        try {
            count++;
            String time = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss:SSS").format(new Date());
            System.out.println(time + " 当前线程：" + Thread.currentThread().getName() + "获得了写锁，count:" + count);
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            // 释放写锁
            lock.writeLock().unlock();
        }
    }
}
```
```java
public class MyThreadTest {

    public static void main(String[] args) {
        Counter counter = new Counter();
        Thread threadA = new Thread(new Runnable() {
            @Override
            public void run() {
                counter.read();
            }
        });

        Thread threadB = new Thread(new Runnable() {
            @Override
            public void run() {
                counter.write();
            }
        });

        threadA.start();
        threadB.start();
    }
}
```
看一下运行结果：
```
2023-10-23 16:36:08:786 当前线程：Thread-0获得了读锁，count:0
2023-10-23 16:36:13:791 当前线程：Thread-1获得了写锁，count:1
```
从日志时间上可以很清晰的看到，两个线程进行串行执行，证明了读和写之间是互斥的。
<a name="QjVi1"></a>
## 三、有没有比读写锁更快的锁实现
使用ReadWriteLock可以解决多线程同时读，但只有一个线程能写的问题。<br />如果继续深入的分析ReadWriteLock，从锁的角度分析，会发现它有一个潜在的问题：如果有线程正在读数据，写线程准备修改数据的时候，需要等待读线程释放锁后才能获取写锁，简单的说就是，读的过程中不允许写，这其实是一种悲观的读锁。<br />为了进一步的提升程序并发执行效率，Java 8 引入了一个新的读写锁：StampedLock。<br />与ReadWriteLock相比，StampedLock最大的改进点在于：在原先读写锁的基础上，新增了一种叫乐观读的模式。该模式并不会加锁，因此不会阻塞线程，程序会有更高的执行效率。<br />什么是乐观锁和悲观锁呢？

- 乐观锁：就是乐观的估计读的过程中大概率不会有写入，因此被称为乐观锁
- 悲观锁：指的是读的过程中拒绝有写入，也就是写入必须等待

显然乐观锁的并发执行效率会更高，但一旦有数据的写入导致读取的数据不一致，需要能检测出来，再读一遍就行。<br />下面一起来了解一下StampedLock的用法！
<a name="VQcAr"></a>
## 四、StampedLock
StampedLock的使用方式比较简单，只需要实例化一个`StampedLock`对象，然后调用对应的读写方法即可，它有三个核心方法如下！

- `readLock()`：表示读锁，多个线程读不会阻塞，效果与`ReadWriteLock`的读锁模式类似
- `writeLock()`：表示写锁，同一时刻有且只有一个写线程能获取锁资源，效果与`ReadWriteLock`的写锁模式类似
- `tryOptimisticRead()`：表示乐观读，并没有加锁，它用于非常短的读操作，允许多个线程同时读

其中`readLock()`和`writeLock()`方法，与ReadWriteLock的效果完全一致，在此就不重复演示了。<br />下面来看一个`tryOptimisticRead()`方法的简单使用示例。
<a name="j0EyQ"></a>
### 4.1、`tryOptimisticRead` 方法
```java
public class CounterDemo {

    private final StampedLock lock = new StampedLock();

    private int count;

    public void write() {
        // 1.获取写锁
        long stamp = lock.writeLock();
        try {
            count++;
            // 方便演示，休眠一下
            sleep(200);
            println("获得了写锁，count:" + count);
        } finally {
            // 2.释放写锁
            lock.unlockWrite(stamp);
        }
    }

    public int read() {
        // 1.尝试通过乐观读模式读取数据，非阻塞
        long stamp = lock.tryOptimisticRead();
        // 2.假设x = 0，但是x可能被写线程修改为1
        int x = count;
        // 方便演示，休眠一下
        int millis = new Random().nextInt(500);
        sleep(millis);
        println("通过乐观读模式读取数据，value:" + x + ", 耗时：" + millis);
        // 3.检查乐观读后是否有其他写锁发生
        if(!lock.validate(stamp)){
            // 4.如果有，采用悲观读锁，并重新读取数据到当前线程局部变量
            stamp = lock.readLock();
            try {
                x = count;
                println("乐观读后检查到数据发生变化，获得了读锁，value:" + x);
            } finally{
                // 5.释放悲观读锁
                lock.unlockRead(stamp);
            }
        }
        // 6.返回读取的数据
        return x;
    }


    private void sleep(long millis){
        try {
            Thread.sleep(millis);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }


    private void println(String message){
        String time = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss:SSS").format(new Date());
        System.out.println(time + " 线程：" + Thread.currentThread().getName() + " " + message);
    }
}
```
```java
public class MyThreadTest {

    public static void main(String[] args) throws InterruptedException {
        CounterDemo counter = new CounterDemo();
        Runnable readRunnable = new Runnable() {
            @Override
            public void run() {
                counter.read();
            }
        };
        Runnable writeRunnable = new Runnable() {
            @Override
            public void run() {
                counter.write();
            }
        };
        // 启动3个读线程
        for (int i = 0; i < 3; i++) {
            new Thread(readRunnable).start();
        }
        // 停顿一下
        Thread.sleep(300);
        // 启动3个写线程
        for (int i = 0; i < 3; i++) {
            new Thread(writeRunnable).start();
        }
    }
}
```
看一下运行结果：
```
2023-10-25 13:47:16:952 线程：Thread-0 通过乐观读模式读取数据，value:0, 耗时：19
2023-10-25 13:47:17:050 线程：Thread-2 通过乐观读模式读取数据，value:0, 耗时：172
2023-10-25 13:47:17:247 线程：Thread-1 通过乐观读模式读取数据，value:0, 耗时：369
2023-10-25 13:47:17:382 线程：Thread-3 获得了写锁，count:1
2023-10-25 13:47:17:586 线程：Thread-4 获得了写锁，count:2
2023-10-25 13:47:17:788 线程：Thread-5 获得了写锁，count:3
2023-10-25 13:47:17:788 线程：Thread-1 乐观读后检查到数据发生变化，获得了读锁，value:3
```
从日志上可以分析得出，读线程Thread-0和Thread-2在启动写线程之前就已经执行完，因此没有进入竞争读锁阶段；而读线程Thread-1因为在启动写线程之后才执行完，这个时候检查到数据发生变化，因此进入读锁阶段，保证读取的数据是最新的。<br />和`ReadWriteLock`相比，`StampedLock`写入数据的加锁过程基本类似，不同的是读取数据。<br />读取数据大致的过程如下：

1. 尝试通过`tryOptimisticRead()`方法乐观读模式读取数据，并返回版本号
2. 数据读取完成后，再通过`lock.validate()`去验证版本号，如果在读取过程中没有写入，版本号不会变，验证成功，直接返回结果
3. 如果在读取过程中有写入，版本号会发生变化，验证将失败。在失败的时候，再通过悲观读锁再次读取数据，把读取的最新结果返回

对于读多写少的场景，由于写入的概率不高，程序在绝大部分情况下可以通过乐观读获取数据，极少数情况下使用悲观读锁获取数据，并发执行效率得到了大大的提升。<br />乐观锁实际用途也非常广泛，比如数据库的字段值修改，举个简单的例子。<br />在订单库存表上order_store，通常会增加了一个数值型版本号字段version，每次更新order_store这个表库存数据的时候，都将version字段加1，同时检查version的值是否满足条件。
```sql
select id，... ，version
from order_store
where id = 1000
```
```sql
update order_store
set version = version + 1,...
where id = 1000 and version = 1
```
数据库的乐观锁，就是查询的时候将version查出来，更新的时候利用version字段验证是否一致，如果相等，说明数据没有被修改，读取的数据安全；如果不相等，说明数据已经被修改过，读取的数据不安全，需要重新读取。<br />这里的version就类似于StampedLock的stamp值。
<a name="KW7RX"></a>
### 4.2、`tryConvertToWriteLock` 方法
其次，StampedLock还提供了将悲观读锁升级为写锁的功能，对应的核心方法是`tryConvertToWriteLock()`。<br />它主要使用在if-then-update的场景，即：程序先采用读模式，如果读的数据满足条件，就返回；如果读的数据不满足条件，再尝试写。<br />简单示例如下：
```java
public int readAndWrite(Integer newCount) {
    // 1.获取读锁，也可以使用乐观读
    long stamp = lock.readLock();
    int currentValue = count;
    try {
        // 2.检查是否读取数据
        while (Objects.isNull(currentValue)) {
            // 3.如果没有，尝试升级写锁
            long wl = lock.tryConvertToWriteLock(stamp);
            // 4.不为 0 升级写锁成功
            if (wl != 0L) {
                // 重新赋值
                stamp = wl;
                count = newCount;
                currentValue = count;
                break;
            } else {
                // 5.升级失败，释放之前加的读锁并上写锁，通过循环再试
                lock.unlockRead(stamp);
                stamp = lock.writeLock();
            }
        }
    } finally {
        // 6.释放最后加的锁
        lock.unlock(stamp);
    }
    // 7.返回读取的数据
    return currentValue;
}
```
<a name="bQ2qa"></a>
## 五、小结
总结下来，`ReadWriteLock`有以下特点：

- 允许多个线程在没有写入时同时读取，可以提高读取效率
- 当存在写入情况时，只允许一个线程写入，其他线程进入排队等待
- 适合读多写少的场景

对于同一个数据，有大量线程读取，但仅有少数线程修改，使用ReadWriteLock可以显著的提升程序并发执行效率。<br />例如，一个论坛的帖子，浏览可以看做读取操作，是非常频繁的，而回复可以看做写入操作，它是不频繁的，这种情况就可以使用ReadWriteLock来实现。<br />与ReadWriteLock相比，StampedLock进一步把读锁细分为乐观读和悲观读，能进一步提升了并发执行效率。<br />好处是非常明显的，系统性能得到提升，但是代价也不小，主要有以下几点：

1. 代码逻辑更加复杂，如果编程不当很容易出 bug
2. StampedLock是不可重入锁，不能在一个线程中反复获取同一个锁，如果编程不当，很容易出现死锁
3. 如果线程阻塞在StampedLock的`readLock()`或者`writeLock()`方法上时，此时试图通过`interrupt()`方法中断线程，会导致 CPU 飙升。因此，使用 StampedLock一定不要调用中断操作，如果需要支持中断功能，推荐使用可中断的读锁`readLockInterruptibly()`或者写锁`writeLockInterruptibly()`方法。

最后，在实际的使用过程中，乐观读编程模型，推荐可以按照以下固定模板编写。
```java
public int read() {
    // 1.尝试通过乐观读模式读取数据，非阻塞
    long stamp = lock.tryOptimisticRead();
    // 2.假设x = 0，但是x可能被写线程修改为1
    int x = count;
    // 3.检查乐观读后是否有其他写锁发生
    if(!lock.validate(stamp)){
        // 4.如果有，采用悲观读锁，并重新读取数据到当前线程局部变量
        stamp = lock.readLock();
        try {
            x = count;
        } finally{
            // 5.释放悲观读锁
            lock.unlockRead(stamp);
        }
    }
    // 6.返回读取的数据
    return x;
}
```
