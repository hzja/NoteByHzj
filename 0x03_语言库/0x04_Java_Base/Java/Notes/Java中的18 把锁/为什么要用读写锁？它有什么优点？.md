Java<br />读写锁（Readers-Writer Lock）顾名思义是一把锁分为两部分：读锁和写锁，其中读锁允许多个线程同时获得，因为读操作本身是线程安全的，而写锁则是互斥锁，不允许多个线程同时获得写锁，并且写操作和读操作也是互斥的。总结来说，读写锁的特点是：**读读不互斥、读写互斥、写写互斥**。
<a name="CMHew"></a>
## 1、读写锁使用
在 Java 语言中，读写锁是使用 `ReentrantReadWriteLock` 类来实现的，其中：

- `ReentrantReadWriteLock.ReadLock` 表示读锁，它提供了 `lock` 方法进行加锁、`unlock` 方法进行解锁。
- `ReentrantReadWriteLock.WriteLock` 表示写锁，它提供了 `lock` 方法进行加锁、`unlock` 方法进行解锁。

它的基础使用如下代码所示：
```java
// 创建读写锁
final ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();
// 获得读锁
final ReentrantReadWriteLock.ReadLock readLock = readWriteLock.readLock();
// 获得写锁
final ReentrantReadWriteLock.WriteLock writeLock = readWriteLock.writeLock();
// 读锁使用
readLock.lock();
try {
    // 业务代码...
} finally {
    readLock.unlock();
}
// 写锁使用
writeLock.lock();
try {
    // 业务代码...
} finally {
    writeLock.unlock();
}
```
<a name="be5ls"></a>
### 1.1 读读不互斥
多个线程可以同时获取到读锁，称之为读读不互斥，如下代码所示：
```java
// 创建读写锁
final ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();
// 创建读锁
final ReentrantReadWriteLock.ReadLock readLock = readWriteLock.readLock();
Thread t1 = new Thread(() -> {
    readLock.lock();
    try {
        System.out.println("[t1]得到读锁.");
        Thread.sleep(3000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    } finally {
        System.out.println("[t1]释放读锁.");
        readLock.unlock();
    }
});
t1.start();
Thread t2 = new Thread(() -> {
    readLock.lock();
    try {
        System.out.println("[t2]得到读锁.");
        Thread.sleep(3000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    } finally {
        System.out.println("[t2]释放读锁.");
        readLock.unlock();
    }
});
t2.start();
```
以上程序执行结果如下：![](https://cdn.nlark.com/yuque/0/2022/png/396745/1652171770816-8060b145-60ac-4c8e-8228-b2bc72ad21f0.png#clientId=uc9305949-6dc9-4&from=paste&id=u3ddc62fd&originHeight=300&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8a8a19c1-7e17-4953-a293-a1fe12ac7fc&title=)
<a name="iUWbB"></a>
### 1.2 读写互斥
读锁和写锁同时使用是互斥的（也就是不能同时获得），这称之为读写互斥，如下代码所示：
```java
// 创建读写锁
final ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();
// 创建读锁
final ReentrantReadWriteLock.ReadLock readLock = readWriteLock.readLock();
// 创建写锁
final ReentrantReadWriteLock.WriteLock writeLock = readWriteLock.writeLock();
// 使用读锁
Thread t1 = new Thread(() -> {
    readLock.lock();
    try {
        System.out.println("[t1]得到读锁.");
        Thread.sleep(3000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    } finally {
        System.out.println("[t1]释放读锁.");
        readLock.unlock();
    }
});
t1.start();
// 使用写锁
Thread t2 = new Thread(() -> {
    writeLock.lock();
    try {
        System.out.println("[t2]得到写锁.");
        Thread.sleep(3000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    } finally {
        System.out.println("[t2]释放写锁.");
        writeLock.unlock();
    }
});
t2.start();
```
以上程序执行结果如下：![](https://cdn.nlark.com/yuque/0/2022/png/396745/1652171770751-6eeb12eb-4994-4f69-9fc7-61249302f3d9.png#clientId=uc9305949-6dc9-4&from=paste&id=u8a1f675e&originHeight=308&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uf00a3432-e2cd-4f83-94cd-42a26c6bc81&title=)
<a name="D0nsc"></a>
### 1.3 写写互斥
多个线程同时使用写锁也是互斥的，这称之为写写互斥，如下代码所示：
```java
// 创建读写锁
final ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();
// 创建写锁
final ReentrantReadWriteLock.WriteLock writeLock = readWriteLock.writeLock();
Thread t1 = new Thread(() -> {
    writeLock.lock();
    try {
        System.out.println("[t1]得到写锁.");
        Thread.sleep(3000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    } finally {
        System.out.println("[t1]释放写锁.");
        writeLock.unlock();
    }
});
t1.start();

Thread t2 = new Thread(() -> {
    writeLock.lock();
    try {
        System.out.println("[t2]得到写锁.");
        Thread.sleep(3000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    } finally {
        System.out.println("[t2]释放写锁.");
        writeLock.unlock();
    }
});
t2.start();
```
以上程序执行结果如下：![](https://cdn.nlark.com/yuque/0/2022/png/396745/1652171770772-e2f470bc-ccca-407d-989e-60b924cda6ff.png#clientId=uc9305949-6dc9-4&from=paste&id=udc40d3f8&originHeight=306&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ucb0fec31-b35a-4f18-b6fc-47b88612115&title=)
<a name="hyoGH"></a>
## 2、优点分析

1. 提高了程序执行性能：多个读锁可以同时执行，相比于普通锁在任何情况下都要排队执行来说，读写锁提高了程序的执行性能。
2. 避免读到临时数据：读锁和写锁是互斥排队执行的，这样可以保证了读取操作不会读到写了一半的临时数据。
<a name="BW6Sk"></a>
## 3、适用场景
读写锁适合多读少写的业务场景，此时读写锁的优势最大。
<a name="TQJfV"></a>
## 总结
读写锁是一把锁分为两部分：读锁和写锁，其中读锁允许多个线程同时获得，而写锁则是互斥锁。它的完整规则是：读读不互斥、读写互斥、写写互斥。它适用于多读的业务场景，使用它可以有效的提高程序的执行性能，也能避免读取到操作了一半的临时数据。
