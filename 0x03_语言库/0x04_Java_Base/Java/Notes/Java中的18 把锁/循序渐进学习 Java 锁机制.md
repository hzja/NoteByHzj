Java 锁
<a name="YvfVl"></a>
## 前言
高效并发是从 JDK 1.5 到 JDK 1.6 的一个重要改进，HotSpot 虚拟机开发团队在这个版本上花费了大量的精力去实现各种锁优化技术，如适应性自旋（Adaptive Spinning）、锁消除（Lock Elimination）、锁粗化（Lock Coarsening）、轻量级锁（Lightweight Locking）和偏向锁（Biased Locking）等，这些技术都是为了在线程之间高效地共享数据，以及解决竞争问题，从而提交程序的执行效率。<br />针对 Java 提供的种类丰富的锁，介绍主流锁的知识点，以及不同的锁的适用场景。
<a name="ODkrf"></a>
## Java 主流锁
![](https://cdn.nlark.com/yuque/0/2021/webp/396745/1622955780475-c5df6955-8890-4b1a-be78-8485a72d6529.webp#clientId=u4ef645df-ea05-4&from=paste&id=u55104a04&originHeight=949&originWidth=1080&originalType=url&ratio=3&status=done&style=shadow&taskId=ub25181db-e761-4de3-89c9-d3fb0151a04)<br />Java 主流锁
<a name="HkzKl"></a>
### 乐观锁 VS 悲观锁
悲观锁：对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。Java 中，synchronized 关键字和 Lock 的实现类都是悲观锁。因此，悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。<br />乐观锁：对于同一个数据的并发操作，乐观锁认为在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。乐观锁在 Java 中是通过使用无锁编程来实现，最常采用的是 CAS 算法，Java 原子类中的递增操作就通过 CAS 自旋实现的。因此，乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。<br />![](https://cdn.nlark.com/yuque/0/2021/webp/396745/1622955780593-62006d43-d980-4b13-8205-2e569bb9f66c.webp#clientId=u4ef645df-ea05-4&from=paste&id=u41003ef1&originHeight=831&originWidth=1080&originalType=url&ratio=3&status=done&style=shadow&taskId=u72345d8f-be53-4500-9f57-ea5b85e0213)<br />乐观锁 VS 悲观锁<br />通过上图的流程图，可以发现悲观锁基本都是在显式的锁定之后再操作同步资源，而乐观锁则直接去操作同步资源。那么，为何乐观锁能够做到不锁定同步资源也可以正确的实现线程同步呢？通过介绍乐观锁的主要实现方式 “CAS” 的技术原理来为大家解惑。<br />CAS 全称 Compare And Swap（比较与交换），是一种无锁算法。在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。java.util.concurrent 包中的原子类就是通过 CAS 来实现了乐观锁。CAS 指令需要有 3 个操作数，分别是内存位置（在 Java 中可以简单理解为变量的内存地址，用 V 表示）、旧的预期值（用 A 表示）和新值（用 B 表示）。CAS 指令执行时，当且仅当 V 符合旧预期值 A 时，处理器用新值 B 更新 V 的值，否则它就不执行更新，但是无论是否更新了 V 的值，都会返回 V 的旧值，上述的处理过程是一个原子操作。<br />在 JDK 1.5 之后，Java 程序中才可以使用 CAS 操作，该操作由 sun.misc.Unsafe 类里面的 `compareAndSwapInt() `和 `compareAndSwapLong()` 等几个方法包装提供，虚拟机在内部对这些方法做了特殊处理，即时编译出来的结果就是一条平台相关的处理器 CAS 指令，没有方法调用的过程，或者可以认为是无条件内联进去了。<br />CAS 虽然很高效，但是它也存在三大问题：

- ABA 问题。CAS 需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是 A，后来变成了 B，然后又变成了 A，那么 CAS 进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA 问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从 “A－B－A” 变成了“1A－2B－3A”。JDK 从 1.5 开始提供了 `AtomicStampedReference` 类来解决 ABA 问题，具体操作封装在 `compareAndSet()` 中。`compareAndSet()` 首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。不过目前来说这个类比较鸡肋，大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步的可能会比原子类更高效。
- 循环时间长开销大。CAS 操作如果长时间不成功，会导致其一直自旋，给 CPU 带来非常大的开销。
- 只能保证一个共享变量的原子操作。对一个共享变量执行操作时，CAS 能够保证原子操作，但是对多个共享变量操作时，CAS 是无法保证操作的原子性的。JDK 从 1.5 开始提供了 `AtomicReference` 类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行 CAS 操作。
<a name="bwWpf"></a>
### 自旋锁 VS 适应性自旋锁
互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给系统的并发性能带来了很大的压力。同时，在许多应用上，共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得。如果物理机器有一个以上的处理器，能让两个或以上的线程同时并行执行，就可以让后面请求锁的那个线程 “稍等一下”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，只需让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。<br />自旋锁的实现原理同样是 CAS，`AtomicInteger` 中调用 unsafe 进行自增操作的源码中的 do-while 循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。<br />![](https://cdn.nlark.com/yuque/0/2021/webp/396745/1622955780319-4e3ba806-a957-4727-93c3-763606ee47db.webp#clientId=u4ef645df-ea05-4&from=paste&id=uad53062b&originHeight=1044&originWidth=1080&originalType=url&ratio=3&status=done&style=shadow&taskId=uf5c24247-5b8e-444f-b562-c61ef74a924)<br />自旋锁 VS 适应性自旋锁<br />自旋等待不能代替阻塞，且先不说对处理器数量的要求，自旋等待本身虽然避免了线程切换的开销，但它是要占用处理器时间的，因此，如果锁被占用的时间很短，自旋等待的效果就会非常好，反之，如果锁被占用的时间很长，那么自旋的线程只会白白消耗处理器资源，而不会做任何有用的工作，反而会带来性能上的浪费。因此，自旋等待的时间必须要有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程了。自旋次数的默认值是 10 次，用户可以使用参数 `-XX:PreBlockSpin` 来更改。<br />在 JDK 1.6 中引入了自适应的自旋锁。自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。另外，如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。有了自适应自旋，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状态预测就会越来越准确。
<a name="KV0qf"></a>
### 无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁
无锁、偏向锁、轻量级锁、重量级锁，这四种锁是指锁的状态，专门针对 Synchronized 的。在介绍这四种锁状态之前还需要介绍一些额外的知识。首先为什么 Synchronized 能实现线程同步？在回答这个问题之前需要了解两个重要的概念：“Java 对象头”、“Monitor”。<br />Java 对象头：Synchronized 是悲观锁，在操作同步资源之前需要给同步资源先加锁，这把锁就是存在 Java 对象头里的，而 Java 对象头又是什么呢？以 Hotspot 虚拟机为例，Hotspot 的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）。

- Mark Word（标记字段）：默认存储对象的 HashCode，分代年龄和锁标志位信息。这些信息都是与对象自身定义无关的数据，所以 Mark Word 被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间 Mark Word 里存储的数据会随着锁标志位的变化而变化。

![](https://cdn.nlark.com/yuque/0/2021/webp/396745/1622955780286-8a60b7ee-1341-4be4-8828-0d2e60403762.webp#clientId=u4ef645df-ea05-4&from=paste&id=u43d89874&originHeight=197&originWidth=603&originalType=url&ratio=3&status=done&style=shadow&taskId=u11fbb1ad-70f1-4e32-91a9-67b83836dd0)<br />无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁 存储内容对比

- Klass Pointer（类型指针）：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。

Monitor：Monitor 可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个 Java 对象就有一把看不见的锁，称为内部锁或者 Monitor 锁。Monitor 是线程私有的数据结构，每一个线程都有一个可用 monitor record 列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个 monitor 关联，同时 monitor 中有一个 Owner 字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。<br />现在话题回到 Synchronized，Synchronized 通过 Monitor 来实现线程同步，Monitor 是依赖于底层的操作系统的 Mutex Lock（互斥锁）来实现的线程同步。Synchronized 最初实现同步的方式，就是这种依赖于操作系统 Mutex Lock 所实现的锁称之为 “重量级锁”，JDK 1.6 中为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁” 和“轻量级锁”。所以目前锁一共有 4 种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁和重量级锁。锁状态只能升级不能降级。
<a name="agWsK"></a>
#### 无锁
无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。无锁的特点就是修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。上面介绍的 CAS 原理及应用即是无锁的实现。无锁无法全面代替有锁，但无锁在某些场合下的性能是非常高的。
<a name="azFos"></a>
#### 偏向锁
偏向锁是 JDK 1.6 中引入的一项锁优化，它的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。如果说轻量级锁是在竞争的情况下使用 CAS 操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连 CAS 操作都不做了。<br />偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次 CAS 原子指令，而偏向锁只需要在置换 ThreadID 的时候依赖一次 CAS 原子指令即可。<br />当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设为 “01”，即偏向模式。同时使用 CAS 操作把获取到这个锁的线程的 ID 记录在对象的 Mark Word 之中，如果 CAS 操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机 都可以不再进行任何同步操作（例如 Locking、Unlocking 以及对 Mark Word 的 Update 等）。<br />当有另外一个线程去尝试获取这个锁时，偏向模式就宣告结束。根据锁对象目前是否处于被锁定的状态，撤销偏向后恢复到未锁定（标志位为“01”）或者轻量级锁定（标志位为“00”）。<br />偏向锁在 JDK 1.6 及以后的 JVM 里是默认启用的。可以通过 JVM 参数关闭偏向锁：`-XX:-UseBiasedLocking=false`，关闭之后程序默认会进入轻量级锁状态。
<a name="WVWkJ"></a>
#### 轻量级锁
轻量级锁是 JDK 1.6 中引入的一项锁优化，它的目的是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统 互斥产生的性能消耗。<br />轻量级锁是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。<br />轻量级锁流程：

- 在代码进入同步块的时候，如果同步对象锁没有被锁定（锁标志位为 “01” 状态），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的 Mark Word 的拷贝，然后拷贝对象头中的 Mark Word 复制到锁记录中。
- 拷贝成功后，虚拟机将使用 CAS 操作尝试将对象的 Mark Word 更新为指向 Lock Record 的指针。如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象 Mark Word 的锁标志位设置为 “00”，表示此对象处于轻量级锁定状态。
- 如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的 Mark Word 是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其它线程抢占了。
- 若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁，锁标志的状态值变为 “10”，Mark Word 中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。

轻量级锁能提升程序同步性能的依据是 “对于绝大部分的锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据。如果没有竞争，轻量级锁使用 CAS 操作避免了使用互斥量的开销，但如果存在锁竞争，除了互斥量的开销外，还额外发生了 CAS 操作，因此在有竞争的情况下，轻量级锁会比传统的重量级锁更慢。
<a name="X5dtx"></a>
#### 重量级锁
重量级锁是依赖对象内部的 Monitor 锁来实现的，而 Monitor 又依赖操作系统的 MutexLock(互斥锁) 来实现的，所以重量级锁也称为互斥锁。升级为重量级锁时，锁标志的状态值变为“10”，此时 Mark Word 中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。<br />升级为重量级锁，就会向操作系统申请资源，线程挂起，进入到操作系统内核态的等待队列中，等待操作系统调度，然后映射回用户态。重量级锁中，由于需要做内核态到用户态的转换，而这个过程中需要消耗较多时间，也就是“重”的原因之一。
<a name="UTwK4"></a>
### 公平锁 VS 非公平锁
公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU 唤醒阻塞线程的开销比非公平锁大。<br />非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU 不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。<br />对于 Java ReentrantLock 而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大。<br />对于 Synchronized 而言，也是一种非公平锁。由于其并不像 ReentrantLock 是通过 AQS 的来实现线程调度，所以并没有任何办法使其变成公平锁。<br />接下来通过 ReentrantLock 的源码来讲解公平锁和非公平锁。<br />![](https://cdn.nlark.com/yuque/0/2021/png/396745/1622955780295-039ec726-d817-4755-b7db-61a46137d425.png#clientId=u4ef645df-ea05-4&from=paste&id=u9d93ddc9&originHeight=543&originWidth=1080&originalType=url&ratio=3&status=done&style=shadow&taskId=u7aa4050e-8f5f-4768-8bb9-16515558a08)<br />ReentrantLock 源码<br />根据代码可知，`ReentrantLock` 里面有一个内部类 Sync，Sync 继承 AQS（`AbstractQueuedSynchronizer`），添加锁和释放锁的大部分操作实际上都是在 Sync 中实现的。它有公平锁 `FairSync` 和非公平锁 NonfairSync 两个子类。`ReentrantLock` 默认使用非公平锁，也可以通过构造器来显示的指定使用公平锁。<br />![](https://cdn.nlark.com/yuque/0/2021/webp/396745/1622955781317-33254293-8a59-4982-a3dc-e398c0622581.webp#clientId=u4ef645df-ea05-4&from=paste&id=u7731985c&originHeight=450&originWidth=1080&originalType=url&ratio=3&status=done&style=shadow&taskId=ub5bab8ac-e208-4cfe-b86d-a3e4fde486c)<br />`ReentrantLock` 公平锁 VS 非公平锁 源码<br />通过上图中的源代码对比，可以明显的看出公平锁与非公平锁的 lock() 方法唯一的区别就在于公平锁在获取同步状态时多了一个限制条件：`hasQueuedPredecessors()`。`hasQueuedPredecessors()` 方法主要做一件事情：主要是判断当前线程是否位于同步队列中的第一个。如果是则返回 true，否则返回 false。<br />综上，公平锁就是通过同步队列来实现多个线程按照申请锁的顺序来获取锁，从而实现公平的特性。非公平锁加锁时不考虑排队等待问题，直接尝试获取锁，所以存在后申请却先获得锁的情况。
<a name="wV6gI"></a>
### 可重入锁 VS 非可重入锁
可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者 class），不会因为之前已经获取过还没释放而阻塞。Java 中 `ReentrantLock` 和 `synchronized` 都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。<br />之前说过 `ReentrantLock` 和 `synchronized` 都是重入锁，那么通过重入锁 `ReentrantLock` 以及非可重入锁 `NonReentrantLock` 的源码来对比分析一下为什么非可重入锁在重复调用同步资源时会出现死锁：

- 首先 `ReentrantLock` 和 `NonReentrantLock` 都继承父类 AQS，其父类 AQS 中维护了一个同步状态 status 来计数重入次数，status 初始值为 0。
- 当线程尝试获取锁时，可重入锁先尝试获取并更新 status 值，如果 status == 0 表示没有其他线程在执行同步代码，则把 status 置为 1，当前线程开始执行。如果 status != 0，则判断当前线程是否是获取到这个锁的线程，如果是的话执行 status+1，且当前线程可以再次获取锁。而非可重入锁是直接去获取并尝试更新当前 status 的值，如果 status != 0 的话会导致其获取锁失败，当前线程阻塞。
- 释放锁时，可重入锁同样先获取当前 status 的值，在当前线程是持有锁的线程的前提下。如果 status-1 == 0，则表示当前线程所有重复获取锁的操作都已经执行完毕，然后该线程才会真正释放锁。而非可重入锁则是在确定当前线程是持有锁的线程之后，直接将 status 置为 0，将锁释放。
<a name="UIoiP"></a>
### 独享锁 VS 共享锁
独享锁也叫排他锁，是指该锁一次只能被一个线程所持有。如果线程 T 对数据 A 加上排它锁后，则其他线程不能再对 A 加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。JDK 中的 `synchronized` 和 JUC 中 Lock 的实现类就是互斥锁。<br />共享锁是指该锁可被多个线程所持有。如果线程 T 对数据 A 加上共享锁后，则其他线程只能对 A 再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。<br />独享锁与共享锁也是通过 AQS 来实现的，通过实现不同的方法，来实现独享或者共享。<br />接下来通过 `ReentrantReadWriteLock` 的源码来介绍独享锁和共享锁。<br />`ReentrantReadWriteLock` 有两把锁：`ReadLock` 和 `WriteLock`，由词知意，一个读锁一个写锁，合称 “读写锁”。再进一步观察可以发现 `ReadLock` 和 `WriteLock` 是靠内部类 Sync 实现的锁。Sync 是 AQS 的一个子类，这种结构在 `CountDownLatch`、`ReentrantLock`、`Semaphore` 里面也都存在。在 `ReentrantReadWriteLock` 里面，读锁和写锁的锁主体都是 Sync，但读锁和写锁的加锁方式不一样。读锁是共享锁，写锁是独享锁。读锁的共享锁可保证并发读非常高效，而读写、写读、写写的过程互斥，因为读锁和写锁是分离的。所以 `ReentrantReadWriteLock` 的并发性相比一般的互斥锁有了很大提升。<br />AQS 类中 state 字段（int 类型，32 位），该字段用来描述有多少线程获持有锁。在独享锁中这个值通常是 0 或者 1（如果是重入锁的话 state 值就是重入的次数），在共享锁中 state 就是持有锁的数量。但是在 `ReentrantReadWriteLock` 中有读、写两把锁，所以需要在一个整型变量 state 上分别描述读锁和写锁的数量（或者也可以叫状态）。于是将 state 变量 “按位切割” 切分成了两个部分，高 16 位表示读锁状态（读锁个数），低 16 位表示写锁状态（写锁个数）。<br />了解了概念之后再来看代码，先看写锁的加锁源码：
```java
protected final boolean tryAcquire(int acquires) {
    Thread current = Thread.currentThread();
    // 取到当前锁的个数
    int c = getState();
    // 取写锁的个数w
    int w = exclusiveCount(c);
    // 如果已经有线程持有了锁(c!=0)
    if (c != 0) {
        // 如果写线程数（w）为0（换言之存在读锁） 或者持有锁的线程不是当前线程就返回失败
        if (w == 0 || current != getExclusiveOwnerThread())
            return false;
        // 如果写入锁的数量大于最大数（65535，2的16次方-1）就抛出一个Error。
        if (w + exclusiveCount(acquires) > MAX_COUNT)
            throw new Error("Maximum lock count exceeded");
        // Reentrant acquire
        setState(c + acquires);
        return true;
    }
    // 如果当且写线程数为0，并且当前线程需要阻塞那么就返回失败；或者如果通过CAS增加写线程数失败也返回失败。
    if (writerShouldBlock() || !compareAndSetState(c, c + acquires))
        return false;
    // 如果c=0，w=0或者c>0，w>0（重入），则设置当前线程为锁的拥有者
    setExclusiveOwnerThread(current);
    return true;
}
```
`tryAcquire()` 除了重入条件（当前线程为获取了写锁的线程）之外，增加了一个读锁是否存在的判断。如果存在读锁，则写锁不能被获取，原因在于：必须确保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。因此，只有等待其他读线程都释放了读锁，写锁才能被当前线程获取，而写锁一旦被获取，则其他读写线程的后续访问均被阻塞。写锁的释放与 ReentrantLock 的释放过程基本类似，每次释放均减少写状态，当写状态为 0 时表示写锁已被释放，然后等待的读写线程才能够继续访问读写锁，同时前次写线程的修改对后续的读写线程可见。<br />接下来再看看读锁的加锁源码：
```java
protected final int tryAcquireShared(int unused) {
    Thread current = Thread.currentThread();
    int c = getState();
    // 如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态
    if (exclusiveCount(c) != 0 &&
            getExclusiveOwnerThread() != current)
        return -1;                                  
    int r = sharedCount(c);
    if (!readerShouldBlock() &&
            r < MAX_COUNT &&
            compareAndSetState(c, c + SHARED_UNIT)) {
        if (r == 0) {
            firstReader = current;
            firstReaderHoldCount = 1;
        } else if (firstReader == current) {
            firstReaderHoldCount++;
        } else {
            HoldCounter rh = cachedHoldCounter;
            if (rh == null || rh.tid != getThreadId(current))
                cachedHoldCounter = rh = readHolds.get();
            else if (rh.count == 0)
                readHolds.set(rh);
            rh.count++;
        }
        return 1;
    }
    return fullTryAcquireShared(current);
}
```
可以看到在 `tryAcquireShared(int unused)` 方法中，如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态。如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，依靠 CAS 保证）增加读状态，成功获取读锁。读锁的每次释放（线程安全的，可能有多个读线程同时释放读锁）均减少读状态，减少的值是 “1<<16”。所以读写锁才能实现读读的过程共享，而读写、写读、写写的过程互斥。
<a name="VoVgX"></a>
### 锁消除 VS 锁粗化
锁消除：指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持，如果判断一段代码中，堆上的所有数据都不会逃逸出去从而被其它线程访问到，就可以把它们当做栈上数据对待，认为它们是线程私有的而无须同步。<br />锁粗化：原则上，在编写代码的时候，需要将同步块的作用范围限制得尽量小，只在共享数据的实际作用域中进行同步，这是为了使等待锁的线程尽快拿到锁。但如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，即使没有线程竞争也会导致不必要的性能消耗。因此如果虚拟机探测到有一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展到整个操作序列的外部。
