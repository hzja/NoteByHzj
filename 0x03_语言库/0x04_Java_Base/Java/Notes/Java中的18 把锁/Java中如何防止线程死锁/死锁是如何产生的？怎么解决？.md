Java<br />死锁（Dead Lock）指的是两个或两个以上的运算单元（进程、线程或协程），都在等待对方释放资源，但没有一方提起释放资源，从而造成了一种阻塞的现象就称为死锁。<br />比如线程 1 拥有了锁 A 的情况下试图获取锁 B，而线程 2 又在拥有了锁 B 的情况下试图获取锁 A，这样双方就进入相互阻塞等待的情况，如下图所示：![](https://cdn.nlark.com/yuque/0/2023/png/396745/1675862792316-cd70d29e-3b00-48f6-996a-678485a48f25.png#averageHue=%23faf8f7&clientId=u5ee4577c-b1d1-4&from=paste&id=u5a307633&originHeight=606&originWidth=938&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u21c540ef-7f79-4d9e-bd21-a51ccc15496&title=)死锁的代码实现如下：
```java
import java.util.concurrent.TimeUnit;

public class DeadLockTest {
    public static void main(String[] args) {
        Object lockA = new Object();
        Object lockB = new Object();
        // 创建线程 1
        Thread t1 = new Thread(() -> {
            // 1.占有锁 A
            synchronized (lockA) {
                System.out.println("线程1：获得锁A。");
                // 休眠 1s（让线程 2 有时间先占有锁 B）
                try {
                    TimeUnit.SECONDS.sleep(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                // 2.获取线程 2 的锁 B
                synchronized (lockB) {
                    System.out.println("线程1：获得锁B。");
                }
            }
        });
        t1.start();
        // 创建线程 2
        Thread t2 = new Thread(() -> {
            // 1.占有锁 B
            synchronized (lockB) {
                System.out.println("线程2：获得锁B。");
                // 休眠 1s（保证线程 1 能有充足的时间得到锁 A）
                try {
                    TimeUnit.SECONDS.sleep(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                // 2.获取线程 1 的锁 A
                synchronized (lockA) {
                    System.out.println("线程2：获得锁A。");
                }
            }
        });
        t2.start();
    }
}
```
以上程序的执行结果如下图所示：![](https://cdn.nlark.com/yuque/0/2023/png/396745/1675862792364-0a8e088d-194c-427a-b4a4-3066095594eb.png#averageHue=%232d2d2d&clientId=u5ee4577c-b1d1-4&from=paste&id=ua0d6bc54&originHeight=292&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u71f6a7ec-7471-4d6d-94fa-83a58c1e550&title=)从上述结果可以看出，线程 1 和线程 2 都在等待对方释放锁，这样就造成了死锁问题。
<a name="O85f5"></a>
## 死锁产生原因
死锁的产生需要满足以下 4 个条件：

1. **互斥条件**：指运算单元（进程、线程或协程）对所分配到的资源具有排它性，也就是说在一段时间内某个锁资源只能被一个运算单元所占用。
2. **请求和保持条件**：指运算单元已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它运算单元占有，此时请求运算单元阻塞，但又对自己已获得的其它资源保持不放。
3. **不可剥夺条件**：指运算单元已获得的资源，在未使用完之前，不能被剥夺。
4. **环路等待条件**：指在发生死锁时，必然存在运算单元和资源的环形链，即运算单元正在等待另一个运算单元占用的资源，而对方又在等待自己占用的资源，从而造成环路等待的情况。

只有以上 4 个条件同时满足，才会造成死锁。
<a name="H8e6x"></a>
## 解决死锁
死锁产生要满足以上 4 个必要条件，那么只需要改变其中的 1 个或多个条件就可以解决死锁的问题了，比如可以通过修改获取锁的顺序来改变环路等待条件。<br />在未修改获取锁的顺序前，程序的执行流程是这样的：![](https://cdn.nlark.com/yuque/0/2023/png/396745/1675862792328-2129b6c0-df5b-45e9-8af4-b3f5e185e35d.png#averageHue=%23faf8f7&clientId=u5ee4577c-b1d1-4&from=paste&id=udff04a33&originHeight=618&originWidth=914&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6cae39d6-4d99-4881-87f7-d58dac3b64a&title=)其中 ① 表示先执行，② 表示后执行。而改变锁的获取顺序之后的执行流程是这样的：![](https://cdn.nlark.com/yuque/0/2023/png/396745/1675862792345-2a5b6fc4-1c3f-40c6-a301-e9945ec4226a.png#averageHue=%23f9f7f6&clientId=u5ee4577c-b1d1-4&from=paste&id=u1b6902ae&originHeight=789&originWidth=778&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8a5a9b03-a5b3-4601-85b5-cfba67bb366&title=)此时线程 1 和线程 2 获取锁的顺序是一致的，都是先获取锁 A，再获取锁 B，此时它们的执行流程如下：

1. 线程 1 先获取到锁 A；
2. 线程 1 获取到锁 B；
3. 线程 1 释放了锁 B；
4. 线程 1 释放了锁 A；
5. 线程 2 获取到了锁 A；
6. 线程 2 获取到了锁 B；
7. 线程 2 释放了锁 B；
8. 线程 2 释放了锁 A。

对应的实现代码如下：
```java
import java.util.concurrent.TimeUnit;

class DeadLockTest {
    public static void main(String[] args) {
        Object lockA = new Object();
        Object lockB = new Object();
        // 创建线程 1
        Thread t1 = new Thread(() -> {
            // 1.获取锁 A
            synchronized (lockA) {
                System.out.println("线程1：获得锁A。");
                // 休眠 1s
                try {
                    TimeUnit.SECONDS.sleep(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                // 2.获取锁 B
                synchronized (lockB) {
                    System.out.println("线程1：获得锁B。");
                    System.out.println("线程1：释放锁B。");
                }
                System.out.println("线程1：释放锁A。");
            }
        });
        t1.start();
        // 创建线程 2
        Thread t2 = new Thread(() -> {
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            // 1.获取锁 A
            synchronized (lockA) {
                System.out.println("线程2：获得锁A。");
                // 2.获取锁
                synchronized (lockB) {
                    System.out.println("线程2：获得锁B。");
                    System.out.println("线程2：释放锁B。");
                }
                System.out.println("线程2：释放锁A。");
            }
        });
        t2.start();
    }
}
```
以上程序的执行结果如下图所示：![](https://cdn.nlark.com/yuque/0/2023/png/396745/1675862792323-dc9b665c-9b65-4210-a663-b3f0e33eafcb.png#averageHue=%232d2d2d&clientId=u5ee4577c-b1d1-4&from=paste&id=ub160d220&originHeight=432&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ueef93b40-45e4-4a15-8422-4158383a5f4&title=)
<a name="qSRJW"></a>
## 总结
死锁（Dead Lock）指的是两个或两个以上的运算单元（进程、线程或协程），都在等待对方释放资源，但没有一方提前释放资源，从而造成了一种阻塞的现象就称为死锁。**产生死锁需要同时满足 4 个条件：互斥条件、请求和保持条件、不可剥夺条件、环路等待条件，因此只需要破坏其中 1 个或多个条件就可以解决死锁的问题了**。
