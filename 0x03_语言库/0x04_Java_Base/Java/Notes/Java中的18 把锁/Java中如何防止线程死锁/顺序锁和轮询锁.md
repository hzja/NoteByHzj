Java<br />死锁（Dead Lock）指的是两个或两个以上的运算单元（进程、线程或协程），都在等待对方停止执行，以取得系统资源，但是没有一方提前退出，就称为死锁。<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1676106256515-fa0cbcba-8ae1-4ef5-88ae-e03c19430ebf.png#averageHue=%23faf8f7&clientId=u387f8697-2009-4&from=paste&id=u50d3132c&originHeight=606&originWidth=938&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u33adea91-72d6-49b4-a3af-5d6288240f2&title=)<br />死锁示例代码如下：
```java
publicclass DeadLockExample {
    public static void main(String[] args) {
        Object lockA = new Object(); // 创建锁 A
        Object lockB = new Object(); // 创建锁 B

        // 创建线程 1
        Thread t1 = new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (lockA) {
                    System.out.println("线程 1:获取到锁 A!");
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println("线程 1:等待获取 B...");
                    synchronized (lockB) {
                        System.out.println("线程 1:获取到锁 B!");
                    }
                }
            }
        });
        t1.start(); // 运行线程

        // 创建线程 2
        Thread t2 = new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (lockB) {
                    System.out.println("线程 2:获取到锁 B!");
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println("线程 2:等待获取 A...");
                    synchronized (lockA) {
                        System.out.println("线程 2:获取到锁 A!");
                    }
                }
            }
        });
        t2.start(); // 运行线程
    }
}
```
以上程序的执行结果如下：<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1676106256492-2a351b0b-9b37-4716-a33f-a7f709c52906.png#averageHue=%23383838&clientId=u387f8697-2009-4&from=paste&id=uaf894746&originHeight=316&originWidth=758&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=ue8b02910-85d2-4d1c-99f4-a162f94004e&title=)<br />从上述结果可以看出，线程 1 和线程 2 都进入了死锁状态，相互都在等待对方释放锁。<br />从上述示例分析可以得出，产生死锁需要满足以下 4 个条件：

1. **互斥条件：指运算单元（进程、线程或协程）对所分配到的资源具有排它性，也就是说在一段时间内某个锁资源只能被一个运算单元所占用。**
2. **请求和保持条件：指运算单元已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它运算单元占有，此时请求运算单元阻塞，但又对自己已获得的其它资源保持不放。**
3. **不可剥夺条件：指运算单元已获得的资源，在未使用完之前，不能被剥夺。**
4. **环路等待条件：指在发生死锁时，必然存在运算单元和资源的环形链，即运算单元正在等待另一个运算单元占用的资源，而对方又在等待自己占用的资源，从而造成环路等待的情况。**

只有这 4 个条件同时满足，才会造成死锁的问题。<br />那么也就是说，要产生死锁必须要同时满足以上 4 个条件才行，那就可以通过破坏任意一个条件来解决死锁问题了。
<a name="d89cM"></a>
## 死锁解决方案分析
接下来分析一下，产生死锁的 4 个条件，哪些是可以破坏的？哪些是不能被破坏的？

- **互斥条件：系统特性，不能被破坏。**
- **请求和保持条件：可以被破坏。**
- **不可剥夺条件：系统特性，不能被破坏。**
- **环路等待条件：可以被破坏。**

通过上述分析，可以得出结论，只能通过破坏请求和保持条件或者是环路等待条件，从而来解决死锁的问题，那上线，就先从破坏“环路等待条件”开始来解决死锁问题。
<a name="NK9vB"></a>
## 解决方案1：顺序锁
所谓的顺序锁指的是通过有顺序的获取锁，从而避免产生环路等待条件，从而解决死锁问题的。<br />当没有使用顺序锁时，程序的执行可能是这样的：<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1676106256498-b60c605e-f497-4745-8e1e-5902fe4626ee.png#averageHue=%23faf8f7&clientId=u387f8697-2009-4&from=paste&id=u286fc3a2&originHeight=606&originWidth=938&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u1fa31c47-d1bb-41d6-a32f-e43767ad826&title=)<br />线程 1 先获取了锁 A，再获取锁 B，线程 2 与 线程 1 同时执行，线程 2 先获取锁 B，再获取锁 A，这样双方都先占用了各自的资源（锁 A 和锁 B）之后，再尝试获取对方的锁，从而造成了环路等待问题，最后造成了死锁的问题。<br />此时只需要将线程 1 和线程 2 获取锁的顺序进行统一，也就是线程 1 和线程 2 同时执行之后，都先获取锁 A，再获取锁 B，执行流程如下图所示：<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1676106256498-5a447340-2e44-4910-9bae-666f86a1ad62.png#averageHue=%23faf8f7&clientId=u387f8697-2009-4&from=paste&id=u140aeea5&originHeight=828&originWidth=758&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=uf3c1849a-d849-4e02-936c-8ecefc10404&title=)<br />因为只有一个线程能成功获取到锁 A，没有获取到锁 A 的线程就会等待先获取锁 A，此时得到锁 A 的线程继续获取锁 B，因为没有线程争抢和拥有锁 B，那么得到锁 A 的线程就会顺利的拥有锁 B，之后执行相应的代码再将锁资源全部释放，然后另一个等待获取锁 A 的线程就可以成功获取到锁资源，执行后续的代码，这样就不会出现死锁的问题了。<br />顺序锁的实现代码如下所示：
```java
public class SolveDeadLockExample {
    public static void main(String[] args) {
        Object lockA = new Object(); // 创建锁 A
        Object lockB = new Object(); // 创建锁 B
        // 创建线程 1
        Thread t1 = new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (lockA) {
                    System.out.println("线程 1:获取到锁 A!");
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println("线程 1:等待获取 B...");
                    synchronized (lockB) {
                        System.out.println("线程 1:获取到锁 B!");
                    }
                }
            }
        });
        t1.start(); // 运行线程
        // 创建线程 2
        Thread t2 = new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (lockA) {
                    System.out.println("线程 2:获取到锁 A!");
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println("线程 2:等待获取B...");
                    synchronized (lockB) {
                        System.out.println("线程 2:获取到锁 B!");
                    }
                }
            }
        });
        t2.start(); // 运行线程
    }
}
```
以上程序的执行结果如下：<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1676106256499-9d6ae5c1-c35a-492c-8fc0-d92fcf0e3fa3.png#averageHue=%23363636&clientId=u387f8697-2009-4&from=paste&id=u883ecc38&originHeight=528&originWidth=918&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u9ef0615d-e6cd-4fee-b49d-79e075b356d&title=)<br />从上述执行结果可以看出，程序并没有出现死锁的问题。
<a name="CO1YZ"></a>
## 解决方案2：轮询锁
轮询锁是通过打破“请求和保持条件”来避免造成死锁的，它的实现思路简单来说就是通过轮询来尝试获取锁，如果有一个锁获取失败，则释放当前线程拥有的所有锁，等待下一轮再尝试获取锁。<br />轮询锁的实现需要使用到 ReentrantLock 的 `tryLock` 方法，具体实现代码如下：
```java
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class SolveDeadLockExample {

    public static void main(String[] args) {
        Lock lockA = new ReentrantLock(); // 创建锁 A
        Lock lockB = new ReentrantLock(); // 创建锁 B

        // 创建线程 1(使用轮询锁)
        Thread t1 = new Thread(new Runnable() {
            @Override
            public void run() {
                // 调用轮询锁
                pollingLock(lockA, lockB);
            }
        });
        t1.start(); // 运行线程

        // 创建线程 2
        Thread t2 = new Thread(new Runnable() {
            @Override
            public void run() {
                lockB.lock(); // 加锁
                System.out.println("线程 2:获取到锁 B!");
                try {
                    Thread.sleep(1000);
                    System.out.println("线程 2:等待获取 A...");
                    lockA.lock(); // 加锁
                    try {
                        System.out.println("线程 2:获取到锁 A!");
                    } finally {
                        lockA.unlock(); // 释放锁
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    lockB.unlock(); // 释放锁
                }
            }
        });
        t2.start(); // 运行线程
    }

    /**
* 轮询锁
*/
    public static void pollingLock(Lock lockA, Lock lockB) {
        while (true) {
            if (lockA.tryLock()) { // 尝试获取锁
                System.out.println("线程 1:获取到锁 A!");
                try {
                    Thread.sleep(1000);
                    System.out.println("线程 1:等待获取 B...");
                    if (lockB.tryLock()) { // 尝试获取锁
                        try {
                            System.out.println("线程 1:获取到锁 B!");
                        } finally {
                            lockB.unlock(); // 释放锁
                            System.out.println("线程 1:释放锁 B.");
                            break;
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    lockA.unlock(); // 释放锁
                    System.out.println("线程 1:释放锁 A.");
                }
            }
            // 等待一秒再继续执行
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```
以上程序的执行结果如下：<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1676106256874-c1fa94dd-343d-42fd-8287-95041ff56a69.png#averageHue=%23363636&clientId=u387f8697-2009-4&from=paste&id=ud6bf09c2&originHeight=792&originWidth=910&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=uc865fdbd-322c-4e93-a072-1a5405c1c61&title=)从上述结果可以看出，以上代码也没有出现死锁的问题。
<a name="ufGCm"></a>
## 总结
本文介绍了解决死锁的 2 种方案：

- 第 1 种顺序锁：通过改变获取锁的顺序也就打破“环路请求条件”来避免死锁问题的发生；
- 第 2 种轮询锁：通过轮询的方式也就是打破“请求和拥有条件”来解决死锁问题。它的实现思路是，通过自旋的方式来尝试获取锁，在获取锁的途中，如果有任何一个锁获取失败，则释放之前获取的所有锁，等待一段时间之后再次执行之前的流程，这样就避免一个锁一直被（一个线程）占用的尴尬了，从而避免了死锁问题。
