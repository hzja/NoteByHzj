Java 动态代理
<a name="BnsEE"></a>
## 什么是动态代理
首先，动态代理是代理模式的一种实现方式，代理模式除了动态代理还有 静态代理，只不过静态代理能够在编译时期确定类的执行对象，而动态代理只有在运行时才能够确定执行对象是谁。代理可以看作是对最终调用目标的一个封装，**能够通过操作代理对象来调用目标类，这样就可以实现调用者和目标对象的解耦合**。<br />动态代理的应用场景有很多，最常见的就是 **AOP 的实现、RPC 远程调用、Java 注解对象获取、日志框架、全局性异常处理、事务处理等**。<br />动态代理的实现有很多，但是 JDK 动态代理是很重要的一种，下面就 JDK 动态代理来深入理解一波。
<a name="Xc8vM"></a>
## JDK 动态代理
首先先来看一下动态代理的执行过程<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1647825570622-3a3ab32a-a32a-42f1-b9ae-83e19af54252.png#clientId=uca7624eb-2023-4&from=paste&id=ue5ef053b&originHeight=621&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=ua08cf274-c165-4006-b2d7-2caf14af238&title=)<br />在 JDK 动态代理中，实现了 InvocationHandler 的类可以看作是 代理类(因为类也是一种对象，所以上面为了描述关系，把代理类形容成了代理对象)。JDK 动态代理就是围绕实现了 InvocationHandler 的代理类进行的，比如下面就是一个 InvocationHandler 的实现类，同时它也是一个代理类。
```java
public class UserHandler implements InvocationHandler {

    private UserDao userDao;

    public UserHandler(UserDao userDao){
        this.userDao = userDao;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        saveUserStart();
        Object obj = method.invoke(userDao, args);
        saveUserDone();
        return obj;
    }

    public void saveUserStart(){
        System.out.println("---- 开始插入 ----");
    }

    public void saveUserDone(){
        System.out.println("---- 插入完成 ----");
    }
}
```
代理类一个最最最重要的方法就是 invoke 方法，它有三个参数

- `Object proxy`: 动态代理对象，关于这个方法后面会说。
- `Method method`: 表示最终要执行的方法，`method.invoke` 用于执行被代理的方法，也就是真正的目标方法
- `Object[] args`: 这个参数就是向目标方法传递的参数。

这里构造好了代理类，现在就要使用它来实现对目标对象的调用，那么如何操作呢？请看下面代码
```java
public static void dynamicProxy(){
	
	UserDao userDao = new UserDaoImpl();
	InvocationHandler handler = new UserHandler(userDao);
	
	ClassLoader loader = userDao.getClass().getClassLoader();
	Class<?>[] interfaces = userDao.getClass().getInterfaces();
	
	UserDao proxy = (UserDao)Proxy.newProxyInstance(loader, interfaces, handler);
	proxy.saveUser();
}
```
如果要用 JDK 动态代理的话，就需要知道目标对象的**类加载器、目标对象的接口，当然还要知道目标对象是谁**。构造完成后，就可以调用 `Proxy.newProxyInstance`方法，然后把类加载器、目标对象的接口、目标对象绑定上去就完事儿了。<br />这里需要注意一下 Proxy 类，它就是动态代理实现所用到的代理类。<br />Proxy 位于java.lang.reflect 包下，这同时也旁敲侧击的表明动态代理的本质就是反射。<br />下面就围绕 JDK 动态代理，来深入理解一下它的原理，以及搞懂为什么动态代理的本质就是反射。
<a name="ukFYw"></a>
## 动态代理的实现原理
在了解动态代理的实现原理之前，先来了解一下 InvocationHandler 接口
<a name="oGesH"></a>
### InvocationHandler 接口
JavaDoc 告诉我们，InvocationHandler 是一个接口，实现这个接口的类就表示该类是一个代理实现类，也就是代理类。<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1647825570609-af611946-b4e9-4fa0-ac48-25e792089b99.png#clientId=uca7624eb-2023-4&from=paste&id=u90599b87&originHeight=652&originWidth=1054&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=ueba0a007-ee88-4b7c-b9b4-a0923515de9&title=)<br />InvocationHandler 接口中只有一个 invoke 方法。<br />动态代理的优势在于能够很方便的对代理类中方法进行集中处理，而不用修改每个被代理的方法。因为所有被代理的方法（真正执行的方法）都是通过在 InvocationHandler 中的 invoke 方法调用的。所以只需要对 invoke 方法进行集中处理。<br />invoke 方法只有三个参数
```java
public Object invoke(Object proxy, Method method, Object[] args)
        throws Throwable;
```

- proxy：代理对象
- method: 代理对象调用的方法
- args：调用方法中的参数。

动态代理的整个代理过程不像静态代理那样一目了然，清晰易懂，因为在动态代理的过程中，没有看到代理类的真正代理过程，也不明白其具体操作，所以要分析动态代理的实现原理，必须借助源码。<br />那么问题来了，首先第一步应该从哪分析？如果不知道如何分析的话，干脆就使用倒推法，从后往前找，直接先从 `_Proxy.newProxyInstance_`入手，看看是否能略知一二。
<a name="S5vgV"></a>
### `Proxy.newInstance` 方法分析
**Proxy 提供了创建动态代理类和实例的静态方法，它也是由这些方法创建的所有动态代理类的超类**。<br />`Proxy.newProxyInstance` 源码（`java.lang.reflect.Proxy`）
```java
public static Object newProxyInstance(ClassLoader loader,
									  Class<?>[] interfaces,
									  InvocationHandler h)
	throws IllegalArgumentException
	{
	Objects.requireNonNull(h);
	
	final Class<?>[] intfs = interfaces.clone();
	final SecurityManager sm = System.getSecurityManager();
	if (sm != null) {
	checkProxyAccess(Reflection.getCallerClass(), loader, intfs);
	}
	
	Class<?> cl = getProxyClass0(loader, intfs);
	
	try {
	if (sm != null) {
	checkNewProxyPermission(Reflection.getCallerClass(), cl);
	}
	
	final Constructor<?> cons = cl.getConstructor(constructorParams);
	final InvocationHandler ih = h;
	if (!Modifier.isPublic(cl.getModifiers())) {
	AccessController.doPrivileged(new PrivilegedAction<Void>() {
	public Void run() {
	cons.setAccessible(true);
	return null;
	}
	});
	}
	return cons.newInstance(new Object[]{h});
	} catch (Exception e) {
	...
}
```
乍一看起来有点麻烦，其实源码都是这样，看起来非常复杂，但是慢慢分析、厘清条理过后就好，最重要的是分析源码不能着急。<br />上面这个 `Proxy.newProxyInstsance` 其实就做了下面几件事，这里画了一个流程图作为参考。<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1647825570652-24bf5d04-7e3c-4ddb-8fbd-7b2fb6dcf15f.png#clientId=uca7624eb-2023-4&from=paste&id=ubcc3f632&originHeight=610&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=ua0a13ace-8985-4d98-a183-22c51af83a9&title=)<br />从上图中也可以看出，newProxyInstsance 方法最重要的几个环节就是获得代理类、获得构造器，然后构造新实例。<br />对反射有一些了解的同学，应该会知道获得构造器和构造新实例是怎么回事。<br />所以重点就放在了**获得代理类**，这是最关键的一步，对应源码中的 `_Class<?> cl = getProxyClass0(loader, intfs);_` 进入这个方法一探究竟
```java
private static Class<?> getProxyClass0(ClassLoader loader,
									   Class<?>... interfaces) {
	if (interfaces.length > 65535) {
		throw new IllegalArgumentException("interface limit exceeded");
	}
	return proxyClassCache.get(loader, interfaces);
}
```
这个方法比较简单，首先会直接判断接口长度是否大于 65535（刚开始看到这里是有点不明白的，这个判断是要判断什么？interfaces 这不是一个 class 类型吗，从 length 点进去也看不到这个属性，细看一下才明白，这居然是_可变参数_，_Class ..._ 中的 ... 就是可变参数，所以这个判断应该是判断接口数量是否大于 65535。）<br />然后会直接从 proxyClassCache 中根据 loader 和 interfaces 获取代理对象实例。**如果能够根据 loader 和 interfaces 找到代理对象，将会返回缓存中的对象副本；否则，它将通过 ProxyClassFactory 创建代理类**。<br />proxyClassCache.get 就是一系列从缓存中的查询操作，注意这里的 proxyClassCache 其实是一个 _WeakCache_，WeakCahe 也是位于 java.lang.reflect 包下的一个缓存映射 map，它的主要特点是一个弱引用的 map，但是它内部有一个 SubKey ，这个子键却是强引用的。<br />这里不用去追究这个 proxyClassCache 是如何进行缓存的，只需要知道它的缓存时机就可以了：即在类加载的时候进行缓存。<br />如果无法找到代理对象，就会通过 ProxyClassFactory 创建代理，ProxyClassFactory 继承于 BiFunction
```java
private static final class ProxyClassFactory
        implements BiFunction<ClassLoader, Class<?>[], Class<?>>
    {...}
```
ProxyClassFactory 里面有两个属性一个方法。<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1647825570633-cf89d144-3f12-4b09-8456-628dc14fdd2d.png#clientId=uca7624eb-2023-4&from=paste&id=u4a0bf8a1&originHeight=587&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=u1fa317b2-7322-4d9a-9a13-4d5a1504d29&title=)

- proxyClassNamePrefix：这个属性表明使用 ProxyClassFactory 创建出来的代理实例的命名是以 "$Proxy" 为前缀的。
- nextUniqueNumber：这个属性表明 ProxyClassFactory 的后缀是使用 AtomicLong 生成的数字

所以代理实例的命名一般是 _Proxy1_这种。<br />这个 apply 方法是一个**根据接口和类加载器进行代理实例创建的工厂方法**，下面是这段代码的核心。
```java
@Override
public Class<?> apply(ClassLoader loader, Class<?>[] interfaces) {
	
	...
		
	long num = nextUniqueNumber.getAndIncrement();
	String proxyName = proxyPkg + proxyClassNamePrefix + num;
	
	byte[] proxyClassFile = ProxyGenerator.generateProxyClass(
		proxyName, interfaces, accessFlags);
	try {
		return defineClass0(loader, proxyName,
							proxyClassFile, 0, proxyClassFile.length);
	} catch (ClassFormatError e) {
		throw new IllegalArgumentException(e.toString());
	}
}
```
可以看到，代理实例的命名就是上面所描述的那种命名方式，只不过它这里加上了 _proxyPkg_ 包名的路径。然后下面就是生成代理实例的关键代码。<br />`ProxyGenerator.generateProxyClass` 跟进去是只能看到 .class 文件的，class 文件是虚拟机编译之后的结果，所以要看一下 .java 文件源码。.java 源码位于 _OpenJDK_中的 sun.misc 包中的 `ProxyGenerator` 下。<br />此类的 `generateProxyClass()` 静态方法的核心内容就是去调用 `generateClassFile()` 实例方法来生成 Class 文件。方法太长了就不贴了，这里就大致解释以下其作用：

- 第一步：收集所有要生成的代理方法，将其包装成 ProxyMethod 对象并注册到 Map 集合中。
- 第二步：收集所有要为 Class 文件生成的字段信息和方法信息。
- 第三步：完成了上面的工作后，开始组装 Class 文件。

而 `defineClass0` 这个方法点进去是 `native` ，底层是 C/C++ 实现的，于是去看了一下 C/C++ 源码，路径在<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1647825570637-f29e888d-5522-4e3e-8001-edc395f60bcb.png#clientId=uca7624eb-2023-4&from=paste&id=u2d9ce143&originHeight=168&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u7b9ef806-35be-4d8e-8195-ee63e05833e&title=)<br />点开之后的 C/C++ 源码还是挺让人绝望的。<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1647825571096-43416f68-a833-448d-abde-5cf97aaf6a63.png#clientId=uca7624eb-2023-4&from=paste&id=uf9caf011&originHeight=1057&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=u51924515-9119-4e88-8db5-5d9e63b72ba&title=)<br />不过再回头看一下这个 `defineClass0` 方法，它实际上就是根据上面生成的 proxyClassFile 字节数组来生成对应的实例罢了，所以不必再深究 C/C++ 对于代理对象的合成过程了。<br />所以总结一下可以看出，JDK 生成了一个叫 `$Proxy0` 的代理类，这个类文件放在内存中的，在创建代理对象时，就是通过反射获得这个类的构造方法，然后创建的代理实例。<br />所以最开始的 dynamicProxy 方法反编译后的代码就是这样的
```java
public final class $Proxy0 extends java.lang.reflect.Proxy implements com.cxuan.dynamic.UserDao {
  public $Proxy0(java.lang.reflect.InvocationHandler) throws ;
    Code:
       0: aload_0
       1: aload_1
       2: invokespecial #8                  // Method java/lang/reflect/Proxy."<init>":(Ljava/lang/reflect/InvocationHandler;)V
       5: return
```
可以看到代理类继承了 Proxy 类，所以也就决定了 Java 动态代理只能对接口进行代理。<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1647825571204-faa01855-18a6-4034-84d0-b15d17f20722.png#clientId=uca7624eb-2023-4&from=paste&id=u82f5d653&originHeight=401&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=ud35c7c6b-3b52-4786-969b-376cf64d9de&title=)<br />于是，上面这个图应该就可以看懂了。
<a name="hrgkM"></a>
## `invoke` 方法中第一个参数 proxy 的作用
细心的小伙伴们可能都发现了，invoke 方法中第一个 proxy 的作用是啥？代码里面好像 proxy 也没用到，这个参数的意义是啥呢？它运行时的类型是啥啊？为什么不使用 this 代替呢？<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1647825571261-a30b11e3-f2ea-4cc4-bb37-10cc3f65666d.png#clientId=uca7624eb-2023-4&from=paste&id=ub437b054&originHeight=264&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ud7373160-632f-4ef3-b236-37252f8024a&title=)<br />Stackoverflow 给出了一个回答 [https://stackoverflow.com/questions/22930195/understanding-proxy-arguments-of-the-invoke-method-of-java-lang-reflect-invoca](https://stackoverflow.com/questions/22930195/understanding-proxy-arguments-of-the-invoke-method-of-java-lang-reflect-invoca)<br />什么意思呢？<br />就是说这个 proxy ，它是真正的代理对象，invoke 方法可以返回调用代理对象方法的返回结果，也可以返回对象的真实代理对象，也就是 $Proxy0，这也是它运行时的类型。<br />至于为什么不用 this 来代替 proxy，因为实现了 InvocationHandler 的对象中的 this ，指代的还是 InvocationHandler 接口实现类本身，而不是真实的代理对象。
