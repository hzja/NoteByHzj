JavaSpringBoot<br />在开发环境中，都使用过yml配置文件，而且在yml配置文件中，都加入过连接数据库的配置，也就是配置连接池，但是对于不同的数据库，连接数据库的 Jar 包也都是不一样的，而且对应的配置也是不一样的，来说说这个 SpringBoot 项目中的，配置数据库连接的各种参数以及不同的数据库，应该是如何配置的。
<a name="Kw3TE"></a>
## MySQL的配置
先来看配置，然后再看看各项配置是什么意思。
```yaml
spring:
    datasource:
        name: test
        url: jdbc:mysql://localhost:3306/test
        username: root
        password: xxx
        # 使用druid数据源
        type: com.alibaba.druid.pool.DruidDataSource
        driver-class-name: com.mysql.jdbc.Driver
        filters: stat
        maxActive: 20
        initialSize: 1
        maxWait: 60000
        minIdle: 1
        timeBetweenEvictionRunsMillis: 60000
        minEvictableIdleTimeMillis: 300000
        validationQuery: select 'x'
        testWhileIdle: true
        testOnBorrow: false
        testOnReturn: false
        poolPreparedStatements: true
```
上面最简单的 name,url,username,password,type 这些就不多说了，需要说的是剩下的参数都是代表的什么含义。
<a name="IiYlm"></a>
### `filters`
这里配置的是插件，常用的插件有:<br />监控统计: filter:stat<br />日志监控: filter:log4j 或者 slf4j<br />防御SQL注入: filter:wall
<a name="SY48z"></a>
### `maxActive`
连接池中最多支持多少个活动会话
<a name="zB9Uj"></a>
### `initialSize`
启动程序时，在连接池中初始化多少个连接
<a name="xkxxr"></a>
### `maxWait`
程序向连接池中请求连接时，超过`maxWait`的值后，认为本次请求失败，即连接池没有可用连接，单位毫秒，设置-1时表示无限等待
<a name="y9Ga3"></a>
### `minIdle`
回收空闲连接时，将保证至少有minIdle个连接.
<a name="HLv9J"></a>
### `timeBetweenEvictionRunsMillis`
检查空闲连接的频率，单位毫秒，非正整数时表示不进行检查
<a name="kqayA"></a>
### `minEvictableIdleTimeMillis`
池中某个连接的空闲时长达到 N 毫秒后，连接池在下次检查空闲连接时，将回收该连接，要小于防火墙超时设置`net.netfilter.nf_conntrack_tcp_timeout_established`的设置
<a name="Z67kF"></a>
### `validationQuery`
检查池中的连接是否仍可用的 SQL 语句，drui会连接到数据库执行该SQL，如果正常返回，则表示连接可用，否则表示连接不可用
<a name="jvwKw"></a>
### `testWhileIdle`
当程序请求连接，连接池在分配连接时，是否先检查该连接是否有效。(高效)
<a name="ETUtw"></a>
### `testOnBorrow`
程序申请连接时，进行连接有效性检查（低效，影响性能）<br />一般的话，设置均为false
<a name="kCZuO"></a>
### `testOnReturn`
程序返还连接时，进行连接有效性检查（低效，影响性能）<br />一般的话，设置均为false
<a name="hdkFM"></a>
### `poolPreparedStatements`
缓存通过以下两个方法发起的SQL:
```java
public PreparedStatement prepareStatement(String sql)
public PreparedStatement prepareStatement(String sql,int resultSetType, int resultSetConcurrency)
```
推荐设置为true<br />其实有些配置，是非常熟悉的，为什么这么说，因为经常会有那种连接被关闭的错误，而这个错误则是有可能是参数配置不合适导致的。
<a name="EcpG0"></a>
## 配置可能引发的一些问题
其实比较需要注意的就是 `validationQuery`这个参数，`validationQuery`是用来验证数据库连接的查询语句，这个查询语句必须是至少返回一条数据的SELECT语句。每种数据库都有各自的验证语句，这里也收集了几种常见数据库的`validationQuery`。

- hsqldb select 1 from INFORMATION_SCHEMA.SYSTEM_USERS
- Oracle select 1 from dual
- DB2 select 1 from sysibm.sysdummy1
- MySql select 1
- Microsoft SqlServer select1
- postgresql select version()
- ingres select 1
- derby values 1
- H2 select 1

而这个参数，一般是否执行，都是靠着 `testOnBorrow` 还有 `testOnReturn`<br />`testOnBorrow`设置为true后如果要生效，`validationQuery`参数必须设置为非空字符串。<br />同样的 `testOnReturn` 设置为true后如果要生效，`validationQuery`参数必须设置为非空字符串。<br />但是如果设置 `testOnBorrow` 为 false 的时候，也会出现一些些的问题。<br />假如链接池中的链接被数据库关闭了，应用经过链接池`getConnection`时，均可能获取到这些不可用的链接，且这些链接若是不被其余线程回收的话；它们不会被链接池废除，也不会从新被建立，占用了链接池的名额，项目若是是服务端，数据库连接被关闭，客户端调用服务端就会出现大量的timeout，客户端设置了超时时间，会主动断开，服务端就会出现close_wait。<br />这也是为什么有时候在排查日志的时候，会出现一些 close_wait 的错误，虽然知道并不影响业务，但是日志上看着还是难受。<br />那么为什么还要设置成 false 呢？<br />因为 `testOnBorrow` 能够确保每次都能获取到可用的连接，但如果设置成 true ，则每次获取连接的时候都要到数据库验证连接有效性，这在高并发的时候会造成性能下降，可以将`testOnBorrow`设成false，`testWhileIdle`设置成true这样能获得比较好的性能。<br />这样也会执行上面所说的 `validationQuery` 参数中的 SQL 来验证连接的有效性。<br />这样在每次连接失效之后，都会通过`validationQuery` 来进行验证是否失效。
