<a name="L7A7U"></a>
## Demo
首先搞一个 Demo 出来，没有 Demo 的源码解读，就像是吃面的时候没有大蒜，差点意思。<br />先铺垫一个背景吧。<br />假设现在的需求是用户注册成功之后给他发个短信，通知他一下。<br />正常来说，伪代码很简单：
```java
boolean success = userRegister(user);
if(success){
    sendMsg("客官，你注册成功了哦。记得来玩儿~");
}
```
这代码能用，完全没有任何问题。但是，仔细想，发短信通知这个动作按理来说，不应该和用户注册的行为“耦合”在一起，难道短信发送的时候失败了，用户就不算注册成功吗？<br />上面的代码就是一个耦合性很强的代码。<br />怎么解耦呢？<br />应该是在用户注册成功之后，发布一个“有用户注册成功了”的事件：
```java
boolean success = userRegister(user);
if(success){
    publicRegisterSuccessEvent(user);
}
```
然后有地方去监听这个事件，在监听事件的地方触发“短信发送”的动作。<br />这样的好处是后续假设不发短信了，要求发邮件，或者短信、邮件都要发送，诸如此类的需求变化，用户注册流程的代码不需要进行任何变化，仅仅是在事件监听的地方搞事情就完事了。<br />这样就算是完成了两个动作的“解耦”。<br />怎么做呢？<br />可以基于 Spring 提供的 `ApplicationListener` 去做这个时间。<br />Demo 里面用的 Spring 版本是 5.2.10。<br />这次的 Demo 也非常的简单，首先需要一个对象来封装事件相关的信息，比如这里用户注册成功，肯定要关心的是 userName：
```java
@Data
public class RegisterSuccessEvent {

    private String userName;

    public RegisterSuccessEvent(String userName) {
        this.userName = userName;
    }
}
```
这里只是为了做 Demo，对象很简单，实际使用过程中，需要什么字段就放进去就行。<br />然后需要一个事件的监听逻辑：
```java
@Slf4j
@Component
public class RegisterEventListener {

    @EventListener
    public void handleNotifyEvent(RegisterSuccessEvent event) {
        log.info("监听到用户注册成功事件：" +
                 "{}，你注册成功了哦。记得来玩儿~", event.getUserName());
    }

}
```
接着，通过 Http 接口来进行事件发布：
```java
@Resource
private ApplicationContext applicationContext;
@GetMapping("/publishEvent")
public void publishEvent() {
    applicationContext.publishEvent(new RegisterSuccessEvent("歪歪"));
}
```
最后把服务启动起来，调用一次：<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1699685769468-20689fc2-32d0-4029-ae51-7905037475df.png#averageHue=%238a7a40&clientId=u2a21b7b0-fc2a-4&from=paste&id=u333497bc&originHeight=892&originWidth=661&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u4a77cb2d-5066-4d70-9a5f-e5a52e03eee&title=)<br />输出正常，完事儿，这个 Demo 就算是搞定了，就只有十多行代码。
<a name="woFCe"></a>
## Debug
就这几行代码，第一个断点会打在哪里？<br />这没啥好犹豫的，肯定是选择打事件监听的这个地方：<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1699685769437-d0d58501-5741-4339-8c08-0020b7804141.png#averageHue=%232f2c2a&clientId=u2a21b7b0-fc2a-4&from=paste&id=u3078d74e&originHeight=183&originWidth=540&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=uc6129ab0-24cc-4290-9308-0bda64767f8&title=)<br />然后直接就是一个发起调用，拿到调用栈再说：<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1699685769434-afb8c40f-86ff-4bea-ae76-a3c52eb2489a.png#averageHue=%2378815f&clientId=u2a21b7b0-fc2a-4&from=paste&id=uac064b7b&originHeight=618&originWidth=750&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u45588d00-4966-4192-bc9e-d536fd45412&title=)<br />通过观察调用栈发现，全是 Spring 的 event 包下的方法。<br />此时，还是一头雾水的，完全不知道应该怎么去看，所以只有先看第一个涉及到 Spring 源码的地方，也就是这个反射调用的地方：<br />`org.springframework.context.event.ApplicationListenerMethodAdapter#doInvoke`<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1699685769443-df18c42d-d463-43b5-bf3d-917c0e6410dd.png#averageHue=%23504d42&clientId=u2a21b7b0-fc2a-4&from=paste&id=u086628b1&originHeight=733&originWidth=816&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=ucacdd364-9e24-451d-a790-d576453e299&title=)<br />通过观察这三个关键的参数，可以断定此时确实是通过反射在调用 Demo 里面的 `RegisterEventListener` 类的 `handleNotifyEvent` 方法，入参是 `RegisterSuccessEvent` 对象，其 userName 字段的值是“歪歪”：<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1699685769823-7895a640-4308-4681-8bdc-f3aa5212917a.png#averageHue=%23587f60&clientId=u2a21b7b0-fc2a-4&from=paste&id=u77011687&originHeight=606&originWidth=605&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u7c5a0f6a-9556-4a8f-a558-350e8ed2507&title=)<br />此时，第一个问题就来了：Spring 是怎么知道要去触发这个方法的呢？<br />或者换个问法：`handleNotifyEvent` 这个自己写的方法名称怎么就出现在这里了呢？<br />然后顺着这个 method 找过去一看：<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1699685769822-f5331323-bfcc-4bc0-9701-dfda1c2a5819.png#averageHue=%23725f41&clientId=u2a21b7b0-fc2a-4&from=paste&id=u155c47cb&originHeight=725&originWidth=871&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=ue86cdbb6-88cd-4289-b43f-096a349df87&title=)<br />原来是当前类的一个字段，随便还看到了 beanName，也是其一个字段，对应着 Demo 的 `RegisterEventListener`。<br />到这里，第二个问题就随之而来了：既然关键字段都在当前类里面了，那么这个当前类，也就是 `ApplicationListenerMethodAdapter` 是什么时候冒出来的呢？<br />带着这个问题，继续往下查看调用栈，会看到这里的这个 listener 就是要找的这个“当前类”：<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1699685769877-410a65b7-7339-4f33-a509-8941ad06d492.png#averageHue=%237d8c75&clientId=u2a21b7b0-fc2a-4&from=paste&id=uaf501dde&originHeight=618&originWidth=843&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=uabbbdd62-abb2-4134-bf60-15adf96d44a&title=)<br />所以，问题就变成了，这个 listener 是怎么来的？<br />然后就会来到这个地方，把目光停在这个地方：<br />`org.springframework.context.event.SimpleApplicationEventMulticaster#multicastEvent`<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1699685769928-62d1dcec-b67e-4a6f-8978-179e1530a9c5.png#averageHue=%237f8769&clientId=u2a21b7b0-fc2a-4&from=paste&id=u4f7f1110&originHeight=688&originWidth=778&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=ub7f6a30e-7fe1-43e3-8509-75b0bd09f55&title=)<br />为什么会在这个地方停下来呢？<br />因为在这个方法里面，就是整个调用链中 listener 第一次出现的地方。<br />所以，第二个断点的位置，也找到了，就是这个地方：<br />`org.springframework.context.event.SimpleApplicationEventMulticaster#multicastEvent`<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1699685769969-563ccd48-07ea-4e90-afd8-51a78f0fe252.png#averageHue=%23302c2b&clientId=u2a21b7b0-fc2a-4&from=paste&id=u8c22ce9b&originHeight=229&originWidth=759&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u6bcddafa-5cb9-4a20-b7fe-b2f23a4da5a&title=)<br />但是，当然把断点打在这个地方，重启服务准备调试的时候，会发现重启的过程中就会停在断点处，而停下来的时候，去调试会发现根本就不是关心的逻辑。<br />全是 Spring 启动过程中触发的一些框架的监听逻辑。比如应用启动事件，就会在断点处停下：<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1699685770350-c1bd37fc-5c30-414f-a2a0-935c1a520665.png#averageHue=%234e714c&clientId=u2a21b7b0-fc2a-4&from=paste&id=u86bbc268&originHeight=344&originWidth=849&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u6e3f3793-d252-4561-b935-9997d20bdde&title=)<br />怎么办呢？<br />针对这种情况，有两个办法。<br />第一个是服务启动过程中，把断点停用，启动完成之后再次打开断点，然后触发调用。<br />idea 也提供了这样的功能，这个图标就是全局的断点启用和停用的图标：<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1699685770374-ea6a779c-effe-48c1-8be1-7a927e9c5f82.png#averageHue=%23797f6e&clientId=u2a21b7b0-fc2a-4&from=paste&id=ua241e9f4&originHeight=157&originWidth=170&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u6de44f46-f9c4-45bb-b0ad-d7bc433a395&title=)<br />这个方法在本次调试的过程中是行之有效的，但是假设如果以后想要调试的代码，就是要在框架启动过程中调试的代码呢？<br />所以，第二种方案：使用条件断点。<br />通过观察入参，可以看到 event 对象里面有个 payload 字段，里面放的就是 Demo 中的 `RegisterSuccessEvent` 对象：<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1699685770289-22d2d3e5-a3c5-4fa3-82fb-fd8f5fe81cc2.png#averageHue=%234d703e&clientId=u2a21b7b0-fc2a-4&from=paste&id=u994a5f88&originHeight=245&originWidth=783&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u786aa44c-b069-44e8-89d8-aaa920f4e2b&title=)<br />那么，可不可以打上断点，然后让 idea 识别到是上述情况的时候，即有 `RegisterSuccessEvent` 对象的时候，才在断点处停下来呢？<br />当然是可以的，打条件断点就行。<br />在断点处右键，然后弹出框里面有个 Condition 输入框：<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1699685770330-a18080b9-8b15-46b8-8465-e3b87c8b1546.png#averageHue=%233d4245&clientId=u2a21b7b0-fc2a-4&from=paste&id=u3d520145&originHeight=265&originWidth=428&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u1fffe4ef-2cf9-492f-8f79-f63ac36a533&title=)<br />在 idea 的断点这里，它是“条件”的意思，带着个输入框，代表输入条件的意思。<br />在这里的条件是：event 对象里面的 payload 字段放的是 Demo 中的 `RegisterSuccessEvent` 对象时就停下来。<br />所以应该是这样的：<br />`event instanceof PayloadApplicationEvent && (((PayloadApplicationEvent) event).payload instanceof RegisterSuccessEvent)`<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1699685770665-44dce98b-6023-4ba8-9e2c-517c6eb7839d.png#averageHue=%233d4349&clientId=u2a21b7b0-fc2a-4&from=paste&id=uec736074&originHeight=264&originWidth=422&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u5c564b95-9f3e-411e-90ef-5ab043eb4d6&title=)<br />当这样设置完成之后，重启项目，会发现重启过程非常丝滑，并没有在断点处停下来，说明条件断点起作用了。<br />然后，再次发起调用，在断点处停下来了：<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1699685770705-2e2e68e4-06bc-4ea9-98ff-0d5f6ad1a29d.png#averageHue=%23947842&clientId=u2a21b7b0-fc2a-4&from=paste&id=ua08d2728&originHeight=271&originWidth=763&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u88574452-4944-444c-9aac-4ac9dd1aad0&title=)<br />主要关注 134 行的 listener 是怎么来的。<br />当观察 `getApplicationListeners` 方法的时候，会发现这个方法它主要是在对 `retrieverCache` 这个缓存在搞事情。<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1699685770780-3f27e39a-f4cc-4f68-9538-d46e4cc49855.png#averageHue=%232e2c2b&clientId=u2a21b7b0-fc2a-4&from=paste&id=u73e367bc&originHeight=469&originWidth=742&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u3cc3491c-2888-42d6-906c-fd41d0d3e91&title=)<br />这个缓存里面放的就是在项目启动过程中已经触发过的框架自带的 listener 对象：<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1699685771034-ebe0871e-3318-46f1-bf0e-625ef5bd5745.png#averageHue=%233f4955&clientId=u2a21b7b0-fc2a-4&from=paste&id=u4df3aa03&originHeight=260&originWidth=894&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=ufe89cdef-fdf8-4f75-b785-3dff242edea&title=)<br />调用的时候，如果能从缓存中拿到对应的 listener，则直接返回。而 Demo 中的自定义 listener 是第一次触发，所以肯定是没有的。<br />因此关键逻辑就在 `retrieveApplicationListeners` 方法里面：<br />`org.springframework.context.event.AbstractApplicationEventMulticaster#retrieveApplicationListeners`<br />这个方法里面的逻辑较多，不会逐行解析。<br />只说一下这个关键的 for 循环：<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1699685771024-bd1ffecc-2ee0-4abd-8372-31eb53c54e90.png#averageHue=%23312c2a&clientId=u2a21b7b0-fc2a-4&from=paste&id=ub9384ed4&originHeight=453&originWidth=798&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u08312291-6d14-4509-84e4-8d84b3b5894&title=)<br />这个 for 循环在干啥事呢？<br />就是循环当前所有的 listener，过滤出能处理当前这个事件的 listener。<br />可以看到当前一共有 20 个 listener，最后一个 listener 就是自定义的 `registerEventListener`：<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1699685770985-1a4bc82e-e4f6-4b88-b816-b2192c25e0f2.png#averageHue=%236f8972&clientId=u2a21b7b0-fc2a-4&from=paste&id=uc27ba174&originHeight=666&originWidth=894&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=uf9dd0946-841d-4441-a238-2ab5335e6e1&title=)<br />每一个 listener 都经过一次 supportsEvent 方法判断：
```java
supportsEvent(listener, eventType, sourceType)
```
这个方法，就是判断 listener 是否支持给定的事件：<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1699685771380-07c8fb8f-2ed3-4b84-82ac-f6217f1afb61.png#averageHue=%232e2b2a&clientId=u2a21b7b0-fc2a-4&from=paste&id=uf64afff5&originHeight=362&originWidth=756&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u3e79a372-75e6-4a1e-b7e5-d8673559eb9&title=)<br />因为当前的事件是发布的 `RegisterSuccessEvent` 对象。<br />对应到源码中，这里给定的事件，也就是 eventType 字段，对应的就是 `RegisterSuccessEvent` 对象。<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1699685771347-91c04cd8-08c9-46ff-b0aa-0566d20c13cb.png#averageHue=%23678674&clientId=u2a21b7b0-fc2a-4&from=paste&id=ua0331e1f&originHeight=294&originWidth=587&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=uf34bcfab-55bd-40cb-b9dc-ac53e420031&title=)<br />所以当循环到 `registerEventListener` 的时候，在 `supportsEventType` 方法中，用 `eventType` 和 `declaredEventTypes` 做了一个对比，如果比上了，就说明当前的 listener 能处理这个 `eventType`。<br />前面说了 `eventType` 是 `RegisterSuccessEvent` 对象。<br />那么这个 `declaredEventTypes` 是个啥玩意呢？<br />`declaredEventTypes` 字段也在之前就出现过的 `ApplicationListenerMethodAdapter` 类里面。`supportsEventType` 方法也是这个类的方法：<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1699685771345-3b5cd0fc-858e-4770-b0df-f85a16a7bcac.png#averageHue=%237d553e&clientId=u2a21b7b0-fc2a-4&from=paste&id=u96b87c0f&originHeight=656&originWidth=806&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u5259208d-165a-44e4-b3e5-c9b2902b50e&title=)<br />而这个 `declaredEventTypes`，就是 `RegisterSuccessEvent` 对象：<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1699685771385-47b7af7f-637e-40fc-a13e-26c732ef7f49.png#averageHue=%236f8f7e&clientId=u2a21b7b0-fc2a-4&from=paste&id=uea47ffc8&originHeight=270&originWidth=649&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u1d85aad5-3aec-41f0-a103-506e88182db&title=)<br />这不就呼应上了吗？<br />所以，这个 for 循环结束之后，里面一定是有 `registerEventListener`的，因为它能处理当前的 `RegisterSuccessEvent` 这个事件。<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1699685771407-7639d07c-7d41-4f95-8d6c-b349251dc66c.png#averageHue=%236c8973&clientId=u2a21b7b0-fc2a-4&from=paste&id=u24f91762&originHeight=518&originWidth=731&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=uf9518d94-f7a1-4e50-ace1-d5114f909fe&title=)<br />但是发现循环结束之后 list 里面有两个元素，突然冒出来个 `DelegatingApplicationListener` 是什么鬼？<br />这个时候怎么办？<br />别去研究它，它不会影响程序运行，所以可以先做个简单的记录，不要分心，要抓住主要矛盾。<br />经过前面的一顿分析，现在又可以回到这里了。<br />通过 debug 知道这个时候拿到的就是自定义的 listener 了：<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1699685771669-b1950c45-9baa-4e1a-bd73-7f76218b0419.png#averageHue=%2368865b&clientId=u2a21b7b0-fc2a-4&from=paste&id=ud20d0334&originHeight=425&originWidth=1004&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=ud147cf4c-548b-4976-8fb0-17da7fbf622&title=)<br />从这个 listener 里面能拿到类名、方法名，从 event 中能拿到请求参数。<br />后续反射调用的过程，条件齐全，顺理成章的就完成了事件的发布。<br />看到这里，细细回想一下，整个的调试过程，是不是一环扣一环。只要思路不乱，抓住主干，问题不大。
<a name="JP9Ua"></a>
## 进一步思考
到这里，是不是认为已经调试的差不多了？<br />自己已经知道了 Spring 自定义 listener 的大致工作原理了？<br />闭着眼睛想一想也就知道大概是一个什么流程了？<br />回想一下最开始定位到反射这个地方的时候是怎么说的？<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1699685771765-3cd935a4-d15a-40d3-a2ab-c6f617d8ee36.png#averageHue=%232d2c2b&clientId=u2a21b7b0-fc2a-4&from=paste&id=uabdd1287&originHeight=224&originWidth=551&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=ueddae7ea-1cdb-4b78-b02e-135054f107f&title=)<br />是不是给了你这一张图，说 `beanName`、`method`、`declaredEventTypes` 啥的都在 `ApplicationListenerMethodAdapter` 这个类里面？<br />请问：这些属性是什么时候设置到这个类里面的呢？<br />现在看一下 `ApplicationListenerMethodAdapter` 这个类是咋来的。<br />不就是想看看 beanName 是啥时候和这个类扯上关系的嘛，很简单，刚刚才提到的条件断点又可以用起来了：<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1699685771852-390e5b46-97e4-4a66-8dc6-eafb6c999e00.png#averageHue=%2385865b&clientId=u2a21b7b0-fc2a-4&from=paste&id=ub2fc44cc&originHeight=337&originWidth=879&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u8035f715-8200-4b00-aaef-cf1ce41c31d&title=)<br />重启之后，在启动的过程中就会在构造方法中停下，于是又有一个调用栈了：<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1699685772111-5ba57a7e-3dde-4eb0-bcac-49fbb781f4b3.png#averageHue=%23504d42&clientId=u2a21b7b0-fc2a-4&from=paste&id=ufa77ba57&originHeight=802&originWidth=881&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u19321415-9602-4a7c-a83b-96d1ea3b61d&title=)<br />可以看到，在这个构造方法里面，就是在构建要寻找的 `beanName`、`method`、`declaredEventTypes` 这类字段。<br />而之所以会触发这个构造方法，是因为 Spring 容器在启动的过程中调用了下面这个方法：<br />`org.springframework.context.event.EventListenerMethodProcessor#afterSingletonsInstantiated`<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1699685772092-69b03e1e-ce68-4584-b8a9-b43d60293687.png#averageHue=%232d2c2b&clientId=u2a21b7b0-fc2a-4&from=paste&id=u4c9e31eb&originHeight=434&originWidth=782&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u27b441ae-6e38-4456-bead-35880148b4d&title=)<br />在这个方法里面，会去遍历 `beanNames`，然后在 `processBean` 方法里面找到带有 `@EventListener` 注解的 bean：<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1699685772113-d0b83df2-abe5-4b0b-9c1d-0ec27b5ad2b6.png#averageHue=%23322c2b&clientId=u2a21b7b0-fc2a-4&from=paste&id=u1f181170&originHeight=766&originWidth=855&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=ud54399b1-b9cb-4234-acb6-af95b3c76e0&title=)<br />在标号为 ① 地方找到这个 bean 具体是哪些方法标注了 `@EventListener`。<br />在标号为 ② 的地方去触发 `ApplicationListenerMethodAdapter` 类的构造方法，此时就可以把 beanName，代理目标类，代理方法通过参数传递过去。<br />在标号为 ③ 的地方，将这个 listener 加入到 Spring 的上下文中，后续触发的时候直接从这里获取即可。<br />那么 `afterSingletonsInstantiated` 这个方法是什么时候触发的呢？<br />还是看调用栈：<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1699685772215-532d1f2c-fc11-4b16-b7f0-a78a5ebfc9dd.png#averageHue=%23798171&clientId=u2a21b7b0-fc2a-4&from=paste&id=ufa0cb821&originHeight=421&originWidth=642&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u475ed517-047d-4fec-bbde-74b7aad2809&title=)<br />即使再不熟悉 Spring，至少也听说过容器启动过程中有一个 `refresh` 的动作吧？<br />就是这个地方：<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1699685772222-b812ea77-69f7-45f6-92ca-fd19d61ef161.png#averageHue=%23534e42&clientId=u2a21b7b0-fc2a-4&from=paste&id=u10ddc5d9&originHeight=928&originWidth=880&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u03453846-d4e4-402e-a197-1db8a22c2ce&title=)<br />这里，`refreshContext`，就是整个 SpringBoot 框架启动过程的核心方法中的一步。<br />就是在这个方法里面中，在服务启动的过程中，`ApplicationListenerMethodAdapter` 这个类和一个 beanName 为 `registerEventListener` 的类扯上了关系，为后续的事件发布的动作，埋好了伏笔。
<a name="qArpT"></a>
## 细节
前面了解了关于 Spring 的事件发布机制主干代码的流程之后，相信你已经能从“容器启动时”和“请求发起时”这两个阶段进行了一个粗犷的说明了。<br />但是，里面其实还有很多细节需要注意的，比如事件发布是一个串行化的过程。假设某个事件监听逻辑处理时间很长，那么势必会导致其他的事件监听出现等待的情况。<br />比如搞两个事件监听逻辑，在其中一个的处理逻辑中睡眠 3s，模拟业务处理时间。发起调用之后，从日志输出时间上可以看出来，确实是串行化，确实是出现了等待的情况：<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1699685772460-6972f8af-393c-4463-a08f-705a88525aaf.png#averageHue=%232f2d2c&clientId=u2a21b7b0-fc2a-4&from=paste&id=u4471e5de&originHeight=439&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u90194969-d072-4cc1-8257-8de8396cfb4&title=)<br />针对这个问题，前面讲源码关于获取到 listener 之后，其实有这样的一个逻辑：<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1699685772413-11f44516-c14d-4028-b1c0-1b2ae1abb7a4.png#averageHue=%23312c2b&clientId=u2a21b7b0-fc2a-4&from=paste&id=u039b844e&originHeight=300&originWidth=776&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u3f8f5c89-4342-42b8-b359-24567693cad&title=)<br />这不就是线程池异步的逻辑吗？<br />只不过默认情况下是没有开启线程池的。<br />开始之后，日志就变成了这样：<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1699685772506-9a876236-d97b-4180-8640-cde499e888c4.png#averageHue=%232e2d2c&clientId=u2a21b7b0-fc2a-4&from=paste&id=ub3e6cc2e&originHeight=387&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=ubace80b6-df52-4a5c-9750-cd09e45bc13&title=)<br />那么怎么开启呢？<br />主干流程都给你说了个大概了，这些分支细节，就自己去研究吧。<br />再比如，`@EventListener` 注解里面还有这两个参数是没有使用到的：<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1699685772655-66f0ec0d-ff3e-4097-86bc-026c3a88a35f.png#averageHue=%232e2b2a&clientId=u2a21b7b0-fc2a-4&from=paste&id=ubc1c28e7&originHeight=731&originWidth=704&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=uff90146e-64f7-420c-a0d4-c8039024a64&title=)<br />它应该怎么使用并且其到的作用是什么呢？<br />对应的源码是哪个部分呢？<br />这也是属于分支细节的部分，自己去研究吧<br />再再比如，前面讲到 `ApplicationListenerMethodAdapter` 这个类的时候：<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1699685772698-86b328c1-7efd-4527-94e3-925ea8b370c2.png#averageHue=%232f2c2b&clientId=u2a21b7b0-fc2a-4&from=paste&id=udaf79254&originHeight=328&originWidth=996&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u00e1f7d6-8894-4d5e-8c18-bd13fef4c6b&title=)<br />会发现它还有一个子类，点过去一看，它有一个叫做 `ApplicationListenerMethodTransactionalAdapter` 的儿子：<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1699685772732-891c929b-beb2-43aa-9e87-12e008defba0.png#averageHue=%23312c2a&clientId=u2a21b7b0-fc2a-4&from=paste&id=u5877505d&originHeight=151&originWidth=788&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=ud37182f8-017e-4ec3-9acf-e0783a490a0&title=)<br />这个儿子的名字里面带着个 “Transactional”，就知道这是和事务相关的东西了。<br />它里面有个叫做 `TransactionalEventListener` 的字段，它也是一个注解，里面对应着事务的多个不同阶段：<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1699685772850-a3a40fcc-4ae5-4660-86f9-bfa654006df5.png#averageHue=%232e2c2b&clientId=u2a21b7b0-fc2a-4&from=paste&id=u0a100067&originHeight=790&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u96c51132-5c2a-47ca-89ef-af7dabd99c6&title=)<br />想都不用想，肯定是可以针对事务不同阶段进行事件监听。<br />这部分“儿子”的逻辑，是不是也可以去研究研究。<br />再再再比如，前面提到了 Spring 容器在启动的过程中调用了下面这个方法：<br />`org.springframework.context.event.EventListenerMethodProcessor#afterSingletonsInstantiated`<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1699685772905-6ebfad4c-2b49-4608-8546-3a812dec7a47.png#averageHue=%232d2c2b&clientId=u2a21b7b0-fc2a-4&from=paste&id=u417a261e&originHeight=434&originWidth=782&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=ud3695009-fc37-47ab-bbf3-62486a4984a&title=)<br />这个方法属于哪个类？<br />它属于 `EventListenerMethodProcessor` 这个类。<br />那么请问这个类是什么时候出现在 Spring 容器里面的呢？<br />这个类在整个框架里面只有一次调用：<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1699685773011-62c899a0-9a25-46a5-8dce-30e47ce73357.png#averageHue=%23515243&clientId=u2a21b7b0-fc2a-4&from=paste&id=u2a4450f6&originHeight=233&originWidth=1040&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=ue9744d74-e6aa-47e9-8a76-a13934cdd6a&title=)<br />调试起来那不是手拿把掐的事情？<br />也可以去研究研究，看着看着，不就慢慢的从 `@EventLintener` 这个小口子，把源码越撕越大了。
