JavaSpringBoot事务
<a name="w9FSG"></a>
## 大事务引发的问题
在分享解决办法之前，先看看系统中如果出现大事务可能会引发哪些问题<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1650165084141-2d13c1f9-d0fc-4b48-873e-7f70d46a3ef8.png#clientId=u8b75769e-e689-4&from=paste&id=uddd4d71f&originHeight=298&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=uc3802cb0-9214-4eb3-9751-cc2a9d161a2&title=)<br />从上图可以看出如果系统中出现大事务时，问题还不小，所以在实际项目开发中应该尽量避免大事务的情况。如果已有系统中存在大事务问题，该如何解决呢？
<a name="SmE5T"></a>
## 解决办法
<a name="MJ0Ew"></a>
### 少用`@Transactional`注解
大家在实际项目开发中，在业务方法加上`@Transactional`注解开启事务功能，这是非常普遍的做法，它被称为声明式事务。<br />部分代码如下：
```java
@Transactional(rollbackFor=Exception.class)
public void save(User user) {
	 doSameThing...
}
```
第一条是：少用`@Transactional`注解。<br />为什么？

1. `@Transactional`注解是通过spring的aop起作用的，但是如果使用不当，事务功能可能会失效。如果恰巧经验不足，这种问题不太好排查。
2. `@Transactional`注解一般加在某个业务方法上，会导致整个业务方法都在同一个事务中，粒度太粗，不好控制事务范围，是出现大事务问题的最常见的原因。

那该怎么办呢？<br />可以使用编程式事务，在Spring项目中使用`TransactionTemplate`类的对象，手动执行事务。<br />部分代码如下：
```java
@Autowired
private TransactionTemplate transactionTemplate;

...

public void save(final User user) {
	 transactionTemplate.execute((status) => {
		doSameThing...
		return Boolean.TRUE;
	 })
}
```
从上面的代码中可以看出，使用`TransactionTemplate`的编程式事务功能自己灵活控制事务的范围，是避免大事务问题的首选办法。<br />当然，说少使用`@Transactional`注解开启事务，并不是说一定不能用它，如果项目中有些业务逻辑比较简单，而且不经常变动，使用`@Transactional`注解开启事务开启事务也无妨，因为它更简单，开发效率更高，但是千万要小心事务失效的问题。
<a name="sCpPn"></a>
### 将查询(select)方法放到事务外
如果出现大事务，可以将查询(select)方法放到事务外，也是比较常用的做法，因为一般情况下这类方法是不需要事务的。<br />比如出现如下代码：
```java
@Transactional(rollbackFor=Exception.class)
public void save(User user) {
	 queryData1();
	 queryData2();
	 addData1();
	 updateData2();
}
```
可以将queryData1和queryData2两个查询方法放在事务外执行，将真正需要事务执行的代码才放到事务中，比如：addData1和updateData2方法，这样就能有效的减少事务的粒度。<br />如果使用`TransactionTemplate`的编程式事务这里就非常好修改。
```java
@Autowired
private TransactionTemplate transactionTemplate;

...

public void save(final User user) {
	 queryData1();
	 queryData2();
	 transactionTemplate.execute((status) => {
		addData1();
		updateData2();
		return Boolean.TRUE;
	 })
}
```
但是如果实在还是想用`@Transactional`注解，该怎么拆分呢？
```java
public void save(User user) {
	 queryData1();
	 queryData2();
	 doSave();
}

@Transactional(rollbackFor=Exception.class)
public void doSave(User user) {
   addData1();
   updateData2();
}
```
这个例子是非常经典的错误，这种直接方法调用的做法事务不会生效，给正在坑中的朋友提个醒。因为`@Transactional`注解的声明式事务是通过spring aop起作用的，而spring aop需要生成代理对象，直接方法调用使用的还是原始对象，所以事务不会生效。<br />有没有办法解决这个问题呢？
<a name="hydyg"></a>
#### 1、新加一个Service方法
这个方法非常简单，只需要新加一个Service方法，把`@Transactional`注解加到新Service方法上，把需要事务执行的代码移到新方法中。具体代码如下：
```java
@Servcie
publicclass ServiceA {
	@Autowired
	prvate ServiceB serviceB;
	
	public void save(User user) {
		queryData1();
		queryData2();
		serviceB.doSave(user);
	}
}

@Servcie
publicclass ServiceB {
	
	@Transactional(rollbackFor=Exception.class)
	public void doSave(User user) {
		addData1();
		updateData2();
	}
	
}
```
<a name="o7fEj"></a>
#### 2、在该Service类中注入自己
如果不想再新加一个Service类，在该Service类中注入自己也是一种选择。具体代码如下：
```java
@Servcie
publicclass ServiceA {
	@Autowired
	prvate ServiceA serviceA;
	
	public void save(User user) {
		queryData1();
		queryData2();
		serviceA.doSave(user);
	}
	
	@Transactional(rollbackFor=Exception.class)
	public void doSave(User user) {
		addData1();
		updateData2();
	}
}
```
<a name="Pati3"></a>
#### 3、在该Service类中使用`AopContext.currentProxy()`获取代理对象
上面的方法2确实可以解决问题，但是代码看起来并不直观，还可以通过在该Service类中使用`AOPProxy`获取代理对象，实现相同的功能。具体代码如下：
```java
@Servcie
publicclass ServiceA {
	
	public void save(User user) {
		queryData1();
		queryData2();
		((ServiceA)AopContext.currentProxy()).doSave(user);
	}
	
	@Transactional(rollbackFor=Exception.class)
	public void doSave(User user) {
		addData1();
		updateData2();
	}
}
```
<a name="cdyzm"></a>
### 事务中避免远程调用
在接口中调用其他系统的接口是不能避免的，由于网络不稳定，这种远程调的响应时间可能比较长，如果远程调用的代码放在某个事物中，这个事物就可能是大事务。当然，远程调用不仅仅是指调用接口，还有包括：发MQ消息，或者连接redis、mongodb保存数据等。
```java
@Transactional(rollbackFor=Exception.class)
public void save(User user) {
	 callRemoteApi();
	 addData1();
}
```
远程调用的代码可能耗时较长，切记一定要放在事务之外。
```java
@Autowired
private TransactionTemplate transactionTemplate;

...

public void save(final User user) {
	 callRemoteApi();
	 transactionTemplate.execute((status) => {
		addData1();
		return Boolean.TRUE;
	 })
}
```
有些朋友可能会问，远程调用的代码不放在事务中如何保证数据一致性呢？这就需要建立：重试+补偿机制，达到数据最终一致性了。
<a name="UUZxv"></a>
### 事务中避免一次性处理太多数据
如果一个事务中需要处理的数据太多，也会造成大事务问题。比如为了操作方便，可能会一次批量更新1000条数据，这样会导致大量数据锁等待，特别在高并发的系统中问题尤为明显。<br />解决办法是分页处理，1000条数据，分50页，一次只处理20条数据，这样可以大大减少大事务的出现。
<a name="MPhKY"></a>
### 非事务执行
在使用事务之前，都应该思考一下，是不是所有的数据库操作都需要在事务中执行？
```java
@Autowired
private TransactionTemplate transactionTemplate;

...

public void save(final User user) {
	 transactionTemplate.execute((status) => {
		addData();
		addLog();
		updateCount();
		return Boolean.TRUE;
	 })
}
```
上面的例子中，其实addLog增加操作日志方法 和 updateCount更新统计数量方法，是可以不在事务中执行的，因为操作日志和统计数量这种业务允许少量数据不一致的情况。
```java
@Autowired
private TransactionTemplate transactionTemplate;

...

public void save(final User user) {
	 transactionTemplate.execute((status) => {
		addData();           
		return Boolean.TRUE;
	 })
	 addLog();
	 updateCount();
}
```
当然大事务中要鉴别出哪些方法可以非事务执行，其实没那么容易，需要对整个业务梳理一遍，才能找出最合理的答案。
<a name="CNWiX"></a>
### 异步处理
还有一点也非常重要，是不是事务中的所有方法都需要同步执行？都知道，方法同步执行需要等待方法返回，如果一个事务中同步执行的方法太多了，势必会造成等待时间过长，出现大事务问题。<br />看看下面这个列子：
```java
@Autowired
private TransactionTemplate transactionTemplate;

...

public void save(final User user) {
	 transactionTemplate.execute((status) => {
		order();
		delivery();
		return Boolean.TRUE;
	 })
}
```
order方法用于下单，delivery方法用于发货，是不是下单后就一定要马上发货呢？<br />答案是否定的。<br />这里发货功能其实可以走mq异步处理逻辑。
```java
@Autowired
private TransactionTemplate transactionTemplate;

...
	
public void save(final User user) {
transactionTemplate.execute((status) => {
	order();
	return Boolean.TRUE;
})
	sendMq();
}
```
<a name="hlnt4"></a>
## 总结
处理大事务的6种办法：

1. 少用`@Transactional`注解
2. 将查询(`select`)方法放到事务外
3. 事务中避免远程调用
4. 事务中避免一次性处理太多数据
5. 非事务执行
6. 异步处理
