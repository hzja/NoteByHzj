JavaSpringBoot
<a name="muPHA"></a>
## 前言
Spring启动时候整个入口是这么一个方法<br />`AbstractApplicationContext#refresh`<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1694485284595-11a7a6c8-7aa5-4193-a0e4-2103eea351b7.png#averageHue=%232d2d2d&clientId=u996fa81b-d973-4&from=paste&id=ue14a475d&originHeight=861&originWidth=695&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=uf6ac1fe7-7815-40f6-a962-75f30678c12&title=)<br />总共有12个方法，也就是启动时的核心步骤<br />`AbstractApplicationContext`有众多实现，这里选择SpringBoot Web应用默认的实现来讲<br />`AnnotationConfigServletWebServerApplicationContext`<br />![AnnotationConfigServletWebServerApplicationContext类图](https://cdn.nlark.com/yuque/0/2023/png/396745/1694485284487-c7d248c9-521b-48f9-a848-5d5ee987b4c5.png#averageHue=%23342f2e&clientId=u996fa81b-d973-4&from=paste&id=NYx52&originHeight=498&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=u62639571-2c45-465d-873a-451285dbbd7&title=AnnotationConfigServletWebServerApplicationContext%E7%B1%BB%E5%9B%BE "AnnotationConfigServletWebServerApplicationContext类图")<br />对应的SpringBoot版本为 2.2.5.RELEASE<br />高版本`refresh`方法会多一些日志相关的代码，这里为了方便讲解，就使用这个版本<br />所以后面本文提到的所有子类的方法实现、重写都是指`AnnotationConfigServletWebServerApplicationContext`及其父类
<a name="Qp0sX"></a>
## `prepareRefresh`
`prepareRefresh`整个刷新的一个步骤，这个步骤是做启动的一个准备操作<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1694485284538-ff26c9e9-e1ed-4ccd-ac26-855270d27713.png#averageHue=%232d2d2c&clientId=u996fa81b-d973-4&from=paste&id=u7429a8b2&originHeight=974&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u86b1fe7e-ce58-452c-85ef-a85ea6d7414&title=)<br />`ApplicationContext`刚创建出来，什么也没有，所以需要做一些准备<br />首先是做一些状态位的变更，表明开始启动了或者刷新了<br />后面一行<br />`initPropertySources`<br />`initPropertySources`是一个模板方法，本身是一个空实现，是给子类用的<br />这个子类就重写了`initPropertySources`方法<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1694485284464-63dcf7fb-d8cf-42d4-835c-0eb927301215.png#averageHue=%232c2b2b&clientId=u996fa81b-d973-4&from=paste&id=ue2d3d16d&originHeight=282&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u5039bd0b-3a89-4e08-9272-2517f1ce4f3&title=)<br />会将Servlet相关的配置加入到`Environment`中，这样就能从`Environment`中获取到Servlet相关的配置了<br />再后面一行
```java
getEnvironment().validateRequiredProperties()
```
这行代码就是校验一些必要的配置属性，可以通过`ConfigurableEnvironment`来设置哪些属性是必要的，默认是没有必要的<br />所以`prepareRefresh`就是做了一些前置操作，准备好一些属性配置相关的东西，后面的其它环节，比如说生成Bean时可能需要用到这些配置
<a name="WURnN"></a>
## obtainFreshBeanFactory
![](https://cdn.nlark.com/yuque/0/2023/png/396745/1694485284564-31a001cc-7901-43e4-a35f-0be3ef193c30.png#averageHue=%232c2c2b&clientId=u996fa81b-d973-4&from=paste&id=u7218f0e6&originHeight=327&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u6cfbecba-b10f-4d5d-94ad-1747d50bc1e&title=)<br />这一步骤是刷新`BeanFactory`并且获取`BeanFactory`<br />`refreshBeanFactory()` 和 `getBeanFactory()` 都是抽象方法，由子类来实现的<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1694485285149-32559f93-5872-4161-8dea-7befeebd8ebf.png#averageHue=%23312c2b&clientId=u996fa81b-d973-4&from=paste&id=ud1b6b8fb&originHeight=690&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u13f8eb60-17bd-404f-b02e-4e8524b2251&title=)<br />而子类的实现其实很简单，就是给beanFactory设置一个id和返回`beanFactory`<br />`beanFactory`就是下面这个玩意<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1694485285337-14c3b8e1-3eb3-4035-b64e-450af9ab1725.png#averageHue=%23312c2b&clientId=u996fa81b-d973-4&from=paste&id=u60be395d&originHeight=440&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u77215347-1e24-47f2-aaf0-3c92a48465d&title=)<br />并且创建对象的`ApplicationContext`对象的时候就创建了，类型为<br />`DefaultListableBeanFactory`<br />所以从这就可以看出来，虽然说BeanFactory是一个接口，有非常多的实现<br />但是实际情况下，真正使用的就是`DefaultListableBeanFactory`<br />并且`DefaultListableBeanFactory`其实算是`BeanFactory`唯一真正的实现<br />除此之外，还可以得出一个结论，`ApplicationContext`中有一个`BeanFactory`（`DefaultListableBeanFactory`）<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1694485285372-a781057c-d86d-485b-a9e9-0350ee752223.png#averageHue=%23f1e9d8&clientId=u996fa81b-d973-4&from=paste&id=u3502f90d&originHeight=141&originWidth=231&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u823589ef-9be3-4138-9cae-27f7eb66fe3&title=)
<a name="Noz7o"></a>
## `prepareBeanFactory`
上一步骤获取到了`BeanFactory`，但是这个`BeanFactory`仅仅就是刚刚new出来的，什么也没有<br />所以当前步骤就是对`BeanFactory`做一些配置工作
<a name="ZCrKb"></a>
### 前三行代码
![](https://cdn.nlark.com/yuque/0/2023/png/396745/1694485285396-ed5a749a-ec53-45cb-8893-06f3f03774f8.png#averageHue=%232f2e2d&clientId=u996fa81b-d973-4&from=paste&id=ue5e92705&originHeight=176&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=uf7e12898-497f-4907-aac9-ea8e8f51382&title=)<br />先给`BeanFactory`设置了一个`ClassLoader`，因为`BeanFactory`是用来创建Bean，需要加载Bean class对象<br />然后设置了一个`BeanExpressionResolver`，这个是用来解析SpEL表达式的<br />然后添加了一个`PropertyEditorRegistrar`，也就是<br />`ResourceEditorRegistrar`<br />这个的作用就是为`BeanFactory`添加一堆跟资源相关的`PropertyEditor`<br />![ResourceEditorRegistrar核心实现方法](https://cdn.nlark.com/yuque/0/2023/png/396745/1694485285398-5aea2c58-0959-484a-b237-73e82caaf35d.png#averageHue=%232e2c2b&clientId=u996fa81b-d973-4&from=paste&id=u783ea42a&originHeight=546&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=u42a74808-d4a6-47ce-b2d0-f4279ebed2d&title=ResourceEditorRegistrar%E6%A0%B8%E5%BF%83%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95 "ResourceEditorRegistrar核心实现方法")<br />`PropertyEditor`之前说过，就是进行类型转换的，将一个字符串转成对应的类型
<a name="aMp6r"></a>
### 接下来这几行
![](https://cdn.nlark.com/yuque/0/2023/png/396745/1694485285757-fa5341e7-f50b-4f0d-b767-b97c499f3095.png#averageHue=%232d2c2b&clientId=u996fa81b-d973-4&from=paste&id=uda9fdabf&originHeight=314&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u7062dac5-5aca-427d-95ff-7cab34c3933&title=)<br />这里主要是添加了一个`BeanPostProcessor`，也就是<br />`ApplicationContextAwareProcessor`<br />`BeanPostProcessor`都知道会在Bean的生命周期阶段进行回调，是Bean的生命周期一个核心的环节<br />`ApplicationContextAwareProcessor`这个是用来处理Bean生命周期中的`Aware`回调有关<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1694485285873-32ce8c87-1b4a-4757-af32-6355959c1782.png#averageHue=%232e2d2b&clientId=u996fa81b-d973-4&from=paste&id=u35251ca4&originHeight=258&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u2163f0ad-405e-49bd-b41b-3693def6d20&title=)<br />当Bean实现这些接口的时候，在创建的时候Spring会回调这些接口，传入对应的对象<br />而后面的这行代码
```java
beanFactory.ignoreDependencyInterface(EnvironmentAware.class);
```
意思是说，如果Bean想注入一个`EnvironmentAware`对象
```java
@Resource
private EnvironmentAware environmentAware;
```
这是不允许的<br />因为很简单，注入一个`EnvironmentAware`对象，没有实际的意义<br />后面的其它几行代码也都是这个意思
<a name="ze8Jq"></a>
### 再接下来这几行
![](https://cdn.nlark.com/yuque/0/2023/png/396745/1694485286119-628568c8-5073-45ea-b307-25604db203cc.png#averageHue=%232f2e2e&clientId=u996fa81b-d973-4&from=paste&id=u04046b28&originHeight=226&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u2dcb0c67-f630-4333-ab59-9d96880ffad&title=)<br />这跟上面的`ignoreDependencyInterface`作用相反<br />他是来设置依赖注入时Bean的类型所对应的对象<br />比如说这行代码
```java
beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);
```
这行代码的意思就是当需要注入一个Bean类型为`BeanFactory.class`类型的时候
```java
@Resource
private BeanFactory beanFactory;
```
那么实际注入的就是方法第二个参数`beanFactory`，也就是上面获取的`DefaultListableBeanFactory`对象<br />同理，注入`ResourceLoader`、`ApplicationEventPublisher`、`ApplicationContext`时，其实注入的对象都是this，也就是当前的`ApplicationContext`对象
<a name="bsTn8"></a>
### 再再接下来这几行
![](https://cdn.nlark.com/yuque/0/2023/png/396745/1694485286058-d74bd657-17fa-4aa7-bd3d-57413a3c48f7.png#averageHue=%232c2c2c&clientId=u996fa81b-d973-4&from=paste&id=ue4b3c150&originHeight=553&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=ufcb6e366-6df2-45f1-b648-cad23e504f1&title=)<br />最开始又添加了一个`BeanPostProcessor`<br />`ApplicationListenerDetector`<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1694485286097-aa344561-3a6f-4f12-9161-ff2bb2bc0886.png#averageHue=%232e2c2b&clientId=u996fa81b-d973-4&from=paste&id=u5ecf5a44&originHeight=572&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u1f851011-75dd-414c-8a5b-3949704a4ba&title=)<br />这个`BeanPostProcessor`是跟`ApplicationListener`有关<br />他是将单例的`ApplicationListener`给添加到`ApplicationContext`中<br />再后面就是往`BeanFactory`里面添加一些跟配置属性相关的单例对象，如果有哪里用到，就可以从`BeanFactory`中获取到了<br />`prepareBeanFactory`就完了<br />正如方法名字的含义一样，就是对`BeanFactory`做一些配置相关的东西<br />比如添加一些`BeanPostProcessor`，注册一些`PropertyEditor`<br />为Bean的生成做准备操作<br />最后画张图来总结一下这个方法的作用<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1694485286409-cf584c6f-d398-4e86-8116-a8996b0715d4.png#averageHue=%23f4f3f0&clientId=u996fa81b-d973-4&from=paste&id=u5a619cca&originHeight=231&originWidth=401&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u6df38c65-2dd2-40d0-8ef1-7672b30b562&title=)<br />此时`BeanFactory`状态就是这样的<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1694485286414-a268c879-b4f0-49af-ae40-88e7c3851446.png#averageHue=%23eee9da&clientId=u996fa81b-d973-4&from=paste&id=u67f6b183&originHeight=191&originWidth=271&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u9a0a9abb-7f45-4c96-944b-77109d02230&title=)
<a name="PH8J1"></a>
## `postProcessBeanFactory`
这个方法是一个模板方法<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1694485286667-d2578ac7-6da8-4054-b06d-7310b3de6842.png#averageHue=%232c2c2b&clientId=u996fa81b-d973-4&from=paste&id=u79843526&originHeight=231&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u445be144-23cc-4132-8fbb-d401ae4c28f&title=)<br />本身是空实现，是交给子类来扩展，子类可以根据不同的特性再对`BeanFactory`进行一些准备工作<br />比如用的这个Web实现就重写了这个方法，对`BeanFactory`设置一些Web相关的配置<br />![AnnotationConfigServletWebServerApplicationContext#postProcessBeanFactory](https://cdn.nlark.com/yuque/0/2023/png/396745/1694485286695-cab8186f-f3c3-483e-bd80-48b2e0930f1b.png#averageHue=%232d2c2b&clientId=u996fa81b-d973-4&from=paste&id=uce5fbbfe&originHeight=339&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=u7b9e4293-6dbd-42b3-b70a-e2122882ac2&title=AnnotationConfigServletWebServerApplicationContext%23postProcessBeanFactory "AnnotationConfigServletWebServerApplicationContext#postProcessBeanFactory")<br />首先调用父类`ServletWebServerApplicationContext`的`postProcessBeanFactory`<br />![ServletWebServerApplicationContext#postProcessBeanFactory](https://cdn.nlark.com/yuque/0/2023/png/396745/1694485286708-a5bf46f3-4238-4652-aee6-8bcc3c6a82a8.png#averageHue=%232c2c2b&clientId=u996fa81b-d973-4&from=paste&id=u78d4b537&originHeight=277&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=u83136ea5-2d0c-4c08-b8a3-aab296b7fb2&title=ServletWebServerApplicationContext%23postProcessBeanFactory "ServletWebServerApplicationContext#postProcessBeanFactory")<br />前两行代码跟之前说的一样，也是添加`Aware`接口的回调对应的`BeanPostProcessor`，只不过这个`Aware`是跟Servlet相关的东西<br />接下来调用`registerWebApplicationScopes`方法，最终会调到下面这个方法<br />`WebApplicationContextUtils#registerWebApplicationScopes`<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1694485286786-b7b69b17-08e0-450e-9226-13dd1bb17a28.png#averageHue=%232d2c2b&clientId=u996fa81b-d973-4&from=paste&id=ub5fbf5cf&originHeight=576&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u9ec221cc-b389-4da3-ad7a-bd56f67a1e4&title=)<br />这个方法干了两件事<br />第一件事就是注册一下Bean在Web环境下的作用域request、session，八股文中的东西<br />第二个就是注册一些依赖注入时Bean类型和对应的对象，这在日常开发中还是有用的<br />比如可以直接注入一个`ServletRequest`
```java
@Resource
private ServletRequest servletRequest;
```
所以，父类的实现主要还是对`BeanFactory`进行一些配置，只不过配置的主要是跟Web环境相关的东西<br />现在来看看`AnnotationConfigServletWebServerApplicationContext`自身的实现<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1694485371648-85b883f6-2ead-4e6f-b531-2d4169d9e665.png#averageHue=%23322d2b&clientId=u996fa81b-d973-4&from=paste&id=u67c2dbf5&originHeight=350&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u6ee16ef1-eea6-46b1-951d-00bb86eb01f&title=)<br />核心代码就是这两行
```java
this.scanner.scan(this.basePackages);
this.reader.register(ClassUtils.toClassArray(this.annotatedClasses));
```
`scanner`和`reader`就是下面这两个玩意<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1694485371607-cb8321f2-d3e6-45b1-9f78-166d95a91cb9.png#averageHue=%23312c2b&clientId=u996fa81b-d973-4&from=paste&id=u4eeba0cb&originHeight=384&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=ue27ac346-1843-4701-a507-a3f9b9923e2&title=)<br />也就是说，如果这些配置都不是空的话，那么此时就会扫描对应的包的下Bean，生成对应的`BeanDenifition`，再注册到`DefaultListableBeanFactory`<br />至于为什么会存到`DefaultListableBeanFactory`中，可以看看之前的文章<br />此时`BeanFactory`大概是这么一个状态<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1694485371612-b886c92a-cc27-4a20-b6c1-6444b0468174.png#averageHue=%236a6255&clientId=u996fa81b-d973-4&from=paste&id=ufbb57c1b&originHeight=221&originWidth=821&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u25f2a028-ecdf-442e-b2ce-e2b4f101b01&title=)<br />除此之外，还有一个贼重要的事<br />`AnnotationConfigServletWebServerApplicationContext`这个`ApplicationContext`创建时会去创建`AnnotatedBeanDefinitionReader`<br />而`AnnotatedBeanDefinitionReader`的构造方法最终会调用这么一行代码
```java
AnnotationConfigUtils#registerAnnotationConfigProcessors(BeanDefinitionRegistry registry)
```
![](https://cdn.nlark.com/yuque/0/2023/png/396745/1694485371643-a63c7309-f915-46fc-b32b-22d4fd04940e.png#averageHue=%232f2c2b&clientId=u996fa81b-d973-4&from=paste&id=u4c0172ab&originHeight=577&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=ude97e31d-c9a1-4c7f-94a8-345f23da4b0&title=)<br />这个方法非常重要，他会去注册一些`BeanDefinition`到`BeanFactory`中，这里称为**Spring内部的Bean**<br />这里说几个常见和重要的

- `ConfigurationClassPostProcessor`：这个是用来处理配置类的，非常重要，记住这个类，后面有大用
- `AutowiredAnnotationBeanPostProcessor`：处理`@Autowired`、`@Value`注解
- `CommonAnnotationBeanPostProcessor`：处理`@Resource`、`@PostConstruct`等注解

所以除了扫描出来的一些Bean对应的`BeanDefinition`，还有一些Spring内部的Bean会注册到`BeanFactory`中<br />此时`BeanFactory`的状态就如下图所示<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1694485371636-f22ace54-a778-498d-b9ae-ecc9ff3970f5.png#averageHue=%23f5f1ec&clientId=u996fa81b-d973-4&from=paste&id=u53eeca2e&originHeight=221&originWidth=821&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u276db852-2c99-448f-8273-c8d151c890c&title=)<br />不过，在SpringBoot默认情况下，不会指定包和配置类，也就不会扫描文件，生成`BeanDefinition`<br />但是内部创建的`BeanDefinition`依然存在，并且在`ApplicationContext`创建的时候就注册到`BeanFactory`中了<br />所以总结来说，`postProcessBeanFactory`这个方法是交给子类对`BeanFactory`做一些准备操作，并且可能会扫描Bean
<a name="y263d"></a>
## `invokeBeanFactoryPostProcessors`
从这个方法的名字可以看出，是调用`BeanFactoryPostProcessor`，这个步骤非常重要，而且过程有点绕
<a name="vc6P4"></a>
### 前置知识：`BeanFactoryPostProcessor`及其子接口
`BeanFactoryPostProcessor`是一个接口，有一个方法，方法参数就是`BeanFactory`<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1694485372206-239d9824-0cc4-4cc4-95c9-5557812e4a83.png#averageHue=%232c2c2b&clientId=u996fa81b-d973-4&from=paste&id=u7107a492&originHeight=308&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u10d130f5-ddf9-453f-998d-f2e3b902e1f&title=)<br />通过这个方法就可以拿到`BeanFactory`，然后对`BeanFactory`做一些自己的调整<br />比如说，想关闭循环依赖，就可以实现这个接口，然后进行调整<br />他还有一个子接口`BeanDefinitionRegistryPostProcessor`<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1694485372214-fae9bb4c-e8c6-4ec9-8374-47a30a8f28f9.png#averageHue=%232c2c2b&clientId=u996fa81b-d973-4&from=paste&id=u4c973d7d&originHeight=311&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u268e6662-b624-442d-b6ad-fc9123a4b78&title=)<br />这个接口是对`BeanDefinitionRegistry`进行调整，`BeanDefinitionRegistry`就是存`BeanDefinition`的地方，真实的实现就是`DefaultListableBeanFactory`<br />所以`BeanDefinitionRegistryPostProcessor`的作用就是往`BeanDefinitionRegistry`（`DefaultListableBeanFactory`）中添加`BeanDefinition`的
<a name="w2Bji"></a>
### 再看`invokeBeanFactoryPostProcessors`
有了这两个前置知识之后，来看看`invokeBeanFactoryPostProcessors`方法的实现<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1694485372509-0a4d63ee-e505-4206-9b4c-ee5e9b1ea5c1.png#averageHue=%23332d2c&clientId=u996fa81b-d973-4&from=paste&id=ua208c8d4&originHeight=264&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u73cb5ec5-74e1-4232-9202-4d8af20d118&title=)<br />这个方法最终会调用下面方法来真正的处理
```java
PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors;
```
![](https://cdn.nlark.com/yuque/0/2023/png/396745/1694485372849-7431b0eb-fe70-40ec-99b3-0a819453d067.png#averageHue=%232c2b2b&clientId=u996fa81b-d973-4&from=paste&id=u049078a2&originHeight=556&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u73ead748-7bf5-4812-9a14-5af5afca990&title=)<br />这个方法比较长，大致分为两件事

- 调用所有的`BeanDefinitionRegistryPostProcessor`，解析配置类，注册`BeanDefinition`到`DefaultListableBeanFactory`中
- 从`BeanFactory`中获取所有的`BeanFactoryPostProcessor`进行调用，完成对`BeanFactory`一些其它的扩展
<a name="FgNew"></a>
#### 调用`BeanDefinitionRegistryPostProcessor`
**首先第一步**，先从`BeanFactory`中获取到所有的`BeanDefinitionRegistryPostProcessor`对象，调用它的`postProcessBeanDefinitionRegistry`方法<br />注册Spring内部的Bean时特地强调的一个类`ConfigurationClassPostProcessor`。<br />他就实现了`BeanDefinitionRegistryPostProcessor`接口<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1694485373042-6fea9ecb-7221-4849-a7f1-a3ff2975f5bb.png#averageHue=%23302b2a&clientId=u996fa81b-d973-4&from=paste&id=u9e459754&originHeight=426&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u0e872892-2a6b-4222-a34e-64c0fcd6658&title=)<br />所以此时获取到的就是`ConfigurationClassPostProcessor`<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1694485372979-257f0e01-f658-4006-974f-1445aa44bdff.png#averageHue=%23635554&clientId=u996fa81b-d973-4&from=paste&id=u669e1619&originHeight=181&originWidth=182&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u1e482f7c-89ee-4d5b-9527-c5f65b19d27&title=)<br />获取`ConfigurationClassPostProcessor`的时候会走Bean的生命周期，也就是会回调前面添加的`BeansPostProcessor`，但是也没几个<br />之后会调用他的`postProcessBeanDefinitionRegistry`方法，来处理此时BeanFactory中的配置类<br />配置类从哪来，前面一直没提到过<br />但是看一下`ApplicationContext`是如何使用的就知道了<br />比如说，下面这个demo<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1694485373160-271d008a-92e9-4c42-bf6a-824def765079.png#averageHue=%23302b2a&clientId=u996fa81b-d973-4&from=paste&id=u681b0ba8&originHeight=334&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u902d5215-e366-429f-917f-641a12a3f23&title=)<br />在创建一个`ApplicationContext`之后，在注册一个Bean之后再refresh<br />此时这个注册的Bean就是配置类。<br />如果不注册，那是真没有配置类，此时也就没什么意义了。<br />所以，`ApplicationContext`一定会有一个配置类，不然没有意义。<br />在SpringBoot条件下，SpringBoot在启动时就会将启动引导类当做配置类给扔到BeanFactory中。<br />所以`ConfigurationClassPostProcessor`最开始处理的时候，就是处理启动引导类<br />可以在`ConfigurationClassPostProcessor`方法实现上打个断点验证一下<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1694485373171-76b5d2a7-11e5-4e93-9b16-1a5c05e9e1b4.png#averageHue=%232e2b2a&clientId=u996fa81b-d973-4&from=paste&id=uabfebbee&originHeight=526&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=ufb026870-e96a-48a1-878c-1e16a11587b&title=)<br />在处理之前可以看见，除了几个Spring内部的`BeanDefinition`之外，还有一个myApplication，就是启动引导类<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1694485373380-396b5058-7906-4061-9e8b-40adf985d5df.png#averageHue=%233a4043&clientId=u996fa81b-d973-4&from=paste&id=u336de5db&originHeight=478&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u9cefe713-b272-455e-9914-9955f68409d&title=)<br />处理的时候它会解析启动引导类的注解，进行自动装配，扫描你写的代码的操作，之后生成`BeanDefinition`<br />当处理完成之后再看看，`DefaultListableBeanFactory`有了非常多的`BeanDefinition`了<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1694485373491-f27d26dc-5230-40bb-9ba7-9b05c096a665.png#averageHue=%233b3f43&clientId=u996fa81b-d973-4&from=paste&id=u42ee5fa0&originHeight=802&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u19cc6e43-1b83-4043-8ebd-04c2fee45e9&title=)<br />所以到第一步就完成了，此时`BeanFactory`就加载了很多Bean<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1694485373576-f33f7ee9-bbd6-43d9-a606-5dd0e835a5a1.png#averageHue=%235b5347&clientId=u996fa81b-d973-4&from=paste&id=u6d8cb388&originHeight=296&originWidth=611&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u5b11a436-1aa8-43fb-9384-d159f3d65a8&title=)<br />**接下来**，由于又新注册了很多`BeanDefinition`，而这些里面就有可能有`BeanDefinitionRegistryPostProcessor`接口的实现<br />所以之后会重复从BeanFactory中获取`BeanDefinitionRegistryPostProcessor`，调用`postProcessBeanDefinitionRegistry`<br />一直会循环下去，直到所有的`BeanDefinitionRegistryPostProcessor`都被调用为止<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1694485373629-f380fb94-8697-4c2c-83cd-ac5dcd2cbad7.png#averageHue=%232d2c2c&clientId=u996fa81b-d973-4&from=paste&id=u9b28d24c&originHeight=423&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u2ea4acc0-67b7-4d51-8a95-161e4c54fd1&title=)<br />由于`BeanDefinitionRegistryPostProcessor`继承`BeanFactoryPostProcessor`<br />所以之后也会调用`BeanDefinitionRegistryPostProcessor`的`postProcessBeanFactory`方法
<a name="kJEwz"></a>
#### 调用`BeanFactoryPostProcessor`
当调完所有的`BeanDefinitionRegistryPostProcessor`实现方法<br />之后就会从`BeanFactory`获取所有的`BeanFactoryPostProcessor`（除了`BeanDefinitionRegistryPostProcessor`实现之外），调用`postProcessBeanFactory`方法<br />此时就可以通过`BeanFactoryPostProcessor`再次对`BeanFactory`进制扩展<br />总的来说，这一步骤的核心作用就是完成对`BeanFactory`自定义扩展，但是由于`BeanFactoryPostProcessor`都是Bean，所以要第一步先加载Bean，之后才能通过`BeanFactoryPostProcessor`来扩展<br />一张图来总结上面主要干的事<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1694485373738-8501e481-e7fc-46c9-be0d-fd9682e151a7.png#averageHue=%23363432&clientId=u996fa81b-d973-4&from=paste&id=uc91fb5ec&originHeight=241&originWidth=541&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=uc122ed98-58a0-41e8-a264-564d78b439b&title=)<br />这里简化了一些前面提到东西
<a name="u0m67"></a>
## `registerBeanPostProcessors`
上面一个步骤已经完成了Bean的扫描和对`BeanFactory`的扩展<br />这一节通过方法名就可以看出，是跟`BeanPostProcessor`相关<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1694485373895-5f424872-cc01-4bad-95b5-4bf7ccfa8e8c.png#averageHue=%232d2c2b&clientId=u996fa81b-d973-4&from=paste&id=ucc4cc3dc&originHeight=193&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=uc4794b18-f252-4554-9999-27f4c2ead8c&title=)<br />不过在这个方法执行之前，先来看看此时`BeanFactory`中已经有了哪些`BeanPostProcessor`<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1694485374178-71350099-c626-4d15-93ca-a96bdedd94a7.png#averageHue=%234d604a&clientId=u996fa81b-d973-4&from=paste&id=u6fb0c877&originHeight=499&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u7aee7dfa-36c8-4796-9190-0c61467ae34&title=)<br />此时只有4个，前3个前面都提到过，但是像熟知的处理`@Autowired`、`@Resource`注解的`BeanPostProcessor`都不在里面<br />所以这里就有一个非常重要的小细节<br />**在当前这个步骤执行之前如果从BeanFactory中获取Bean的话，虽然会走Bean生命周期的整个过程，但是**`**@Autowired**`**、**`**@Resource**`**注解都不会生效，因为此时**`**BeanFactory**`**中还没有处理这些注解的**`**BeanPostProcessor**`**（**`**CommonAnnotationBeanPostProcessor**`**等）**<br />什么意思呢，举个例子<br />比如上面一节，在当前步骤执行之前会从`BeanFactory`中获取`BeanFactoryPostProcessor`<br />假设现在实现了`BeanFactoryPostProcessor`，想注入一个`ApplicationContext`对象<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1694485374417-a0ae96bf-d31f-4f97-b1d1-450f56dcaa4a.png#averageHue=%232e2c2b&clientId=u996fa81b-d973-4&from=paste&id=u0b50834f&originHeight=327&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u787408e3-6fee-4da1-b9b1-81f35a04776&title=)<br />此时是注入不成功的，`@Resource`注解不会生效，就是这个意思。<br />这时只能通过`ApplicationContextAware`方式获取，因为有对应的`BeanPostProcessor`（`ApplicationContextAwareProcessor`）<br />接下来再来看看`registerBeanPostProcessors`实现<br />最终也是调用下面的方法
```java
PostProcessorRegistrationDelegate#registerBeanPostProcessors
```
![](https://cdn.nlark.com/yuque/0/2023/png/396745/1694485374481-bd7bafd1-f32c-42d0-9d88-59d0a80b4e7c.png#averageHue=%232d2d2c&clientId=u996fa81b-d973-4&from=paste&id=ue4c9cfe6&originHeight=650&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u327649f3-5a78-4ddd-b1d5-d826f166cb5&title=)<br />这个过程就没上面那个步骤复杂了<br />其实就是从`BeanFactory`中获取到所有的`BeanPostProcessor`，然后添加到`BeanFactory`中<br />不过值得注意的是，`BeanPostProcessor`创建会有优先级，优先级高的会先被创建和添加到`BeanFactory`中<br />到这一步其实`BeanFactory`就算是准备完成了，基本上跟创建Bean相关的前置操作**几乎**都完成了<br />最后再来张图总结一下这个方法干的事<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1694485374442-190ee5b4-d8e7-43d2-8969-2e4952787355.png#averageHue=%23f2f1ef&clientId=u996fa81b-d973-4&from=paste&id=u3561820c&originHeight=241&originWidth=511&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=ub3d076f5-33f6-45e3-83af-312a3121f4c&title=)
<a name="rrLIe"></a>
## `initMessageSource`
这个方法是处理国际化相关的操作<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1694485374558-fb21790a-05eb-4d79-989b-d456477313a4.png#averageHue=%232f2c2b&clientId=u996fa81b-d973-4&from=paste&id=u2ae5025a&originHeight=730&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=ubf0e601c-c56e-415a-accd-500e4b73ee5&title=)<br />这个操作比较简单，就是从`BeanFactory`中看看有没有Bean名称为`messageSource`的Bean<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1694485374712-97c11dc8-44b4-46c8-8807-c98347a8f738.png#averageHue=%232d2c2c&clientId=u996fa81b-d973-4&from=paste&id=u40e6e99c&originHeight=219&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u41cd9853-195c-482e-862b-c3adbdb2d2f&title=)<br />有的话就使用这个`MessageSource`，没有的话就用默认的<br />不过SpringBoot项目下会自动装配一个`MessageSource`，所以此时容器中是有的
<a name="RG1iS"></a>
## `initApplicationEventMulticaster`
![](https://cdn.nlark.com/yuque/0/2023/png/396745/1694485374892-de72f8e7-72ee-46df-b5f9-699e472a47a4.png#averageHue=%232b2b2b&clientId=u996fa81b-d973-4&from=paste&id=u85f15e55&originHeight=537&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u39002a25-decf-4f4d-b5b6-2e49337c845&title=)<br />这个方法跟上面的差不多，也是从`BeanFactory`找有没有`ApplicationEventMulticaster`<br />有就用容器中的，没有就自己创建一个<br />`ApplicationEventMulticaster`是真正用来发布事件的，`ApplicationEventPublisher`最终也是调用他来发布事件<br />`ApplicationEventMulticaster`内部会缓存所有的监听器<br />当通过`ApplicationEventMulticaster`发布事件的时候，会去找到所有的监听器，然后调用
<a name="kK4rl"></a>
## `onRefresh`
`onRefresh`也是一个模板方法，本身也是空实现<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1694485374959-f7f7ef43-2b99-4e83-98c9-137c557be665.png#averageHue=%232c2c2b&clientId=u996fa81b-d973-4&from=paste&id=ud2f82944&originHeight=347&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u2252bcdf-67b8-4fc3-90d0-de1f31a8589&title=)<br />子类重写这个方法，会去创建一个Web服务器<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1694485375061-220abbc9-832a-4362-991b-ce6963fca49d.png#averageHue=%232c2b2b&clientId=u996fa81b-d973-4&from=paste&id=ufbd234c9&originHeight=360&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u12f9f1e4-1e67-48b5-90d2-5044169423a&title=)
<a name="yBFFq"></a>
## `registerListeners`
![](https://cdn.nlark.com/yuque/0/2023/png/396745/1694485375069-e19324a8-0bd6-45b8-b077-c4bc18885199.png#averageHue=%232c2c2c&clientId=u996fa81b-d973-4&from=paste&id=u95e32b51&originHeight=519&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=ue081c46c-e81a-4528-ac83-88c4ab9eaa6&title=)<br />这个方法其实也比较简单，就是将监听器给添加到`ApplicationEventMulticaster`中
<a name="POyTX"></a>
## `finishBeanFactoryInitialization`
![](https://cdn.nlark.com/yuque/0/2023/png/396745/1694485375231-ed984aad-70e0-43cd-bba1-5b04a3d46f52.png#averageHue=%232d2d2d&clientId=u996fa81b-d973-4&from=paste&id=u71c08b36&originHeight=794&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u53aaac59-5882-4ea1-9497-ca707f941e3&title=)<br />这个方法首先又是老套路，就是判断容器中有没有`ConversionService`<br />`ConversionService`也是用来做类型转换的，跟前面提到的`PropertyEditor`作用差不多<br />如果有，就把`ConversionService`设置到`BeanFactory`中<br />到这一步，`BeanFactory`才算真的准备完成。。。<br />之后其实干的事就不太重要了<br />但是最后一行比较重要
```java
beanFactory.preInstantiateSingletons();
```
从方法的命名就可以看出，实例化所有的单例对象<br />因为对于`BeanFactory`的一些配置在前面都完成了，所以这里就可以来实例化所有的单例对象了<br />这个方法会做两件事<br />第一件事就是实例化所有的非懒加载的单例Bean<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1694485375413-42e09913-a0d7-4d37-b822-82991622618d.png#averageHue=%232d2b2b&clientId=u996fa81b-d973-4&from=paste&id=udca81d92&originHeight=807&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=ud264404f-e0f5-4340-bba5-eebe8008d34&title=)<br />实际上就是通过`getBean`方法来的，因为获取Bean，不存在的时候就会创，会走Bean的生命周期<br />第二件事就是一旦单例Bean实现了`SmartInitializingSingleton`接口，就会调用`SmartInitializingSingleton`的`afterSingletonsInstantiated`方法<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1694485375510-c3ab5523-f2e0-4751-a67d-6d5d069b7939.png#averageHue=%232f2b2b&clientId=u996fa81b-d973-4&from=paste&id=ue4d49350&originHeight=461&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=uadd544b9-6772-4acc-b126-cd512aebdaa&title=)<br />这个其实也算是Bean生命周期的一部分。
<a name="H0h9z"></a>
## `finishRefresh`
这个方法是整个Spring容器刷新的最后一个方法<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1694485375576-d924e610-a1aa-418c-9814-5491580b1963.png#averageHue=%232d2d2d&clientId=u996fa81b-d973-4&from=paste&id=uce7590c9&originHeight=773&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u24b9fe37-f557-4089-adb1-9c936e305d5&title=)<br />这个方法就是收尾的操作<br />清理一下缓存操作<br />之后就是初始化`LifecycleProcessor`<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1694485375580-421c1408-1f31-4007-b740-554e4be9d2bf.png#averageHue=%232c2b2b&clientId=u996fa81b-d973-4&from=paste&id=u9268f6b5&originHeight=684&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u04323033-1e5d-47ff-8906-9771f38ba08&title=)<br />都是一样的套路，优先用`BeanFactory`中的<br />后面就会调用`LifecycleProcessor#onRefresh`方法<br />这个方法的作用就是，如果Bean实现了`SmartLifecycle`的接口，会调`start`的方法<br />随后就发布一个`ContextRefreshedEvent`事件，表明容器已经刷新完成了<br />在Web环境下，这个`finishRefresh`方法被重写了<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1694485375902-7d1ad75f-3092-43bb-b621-89f271c17359.png#averageHue=%232c2c2b&clientId=u996fa81b-d973-4&from=paste&id=u1b4c5062&originHeight=281&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u40022430-20f1-4d14-a8df-7543e739151&title=)<br />主要是多干了一件事，那就是启动Web服务器<br />并且会发布了一个`ServletWebServerInitializedEvent`事件<br />这个事件在SpringBoot中用的不多<br />但是在SpringCloud中却非常重要<br />在SpringCloud环境底下会有一个类监听这个事件<br />一旦监听到这个事件，SpringCloud就会将当前的服务的信息自动注册到注册中心上<br />这就是服务自动注册的原理
<a name="EXyFj"></a>
## 总结
这里再来简单回顾一下Spring启动大致的几个过程<br />最开始的准备操作，这部分就是准备一些配置属性相关的<br />之后连续好几个方法都是准备`BeanFactory`的，把上面那张图拿过来<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1694485376194-11b85217-cf55-4b06-8931-b4b9aa2e30b5.png#averageHue=%23f2f1ef&clientId=u996fa81b-d973-4&from=paste&id=u0cb6383e&originHeight=241&originWidth=511&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u65410bcb-0f26-466e-bbda-b9608ab7403&title=)<br />整个准备`BeanFactory`过程大致如下：

- 先配置`BeanFactory`
- 通过`ConfigurationClassPostProcessor`加载Bean到`BeanFactory`中
- 从上一步加载的Bean中获取`BeanFactoryPostProcessor`，完成对`BeanFactory`做自定义处理
- 从上一步加载的Bean中获取`BeanPostProcessor`，添加到BeanFactory中

当这些步骤完成之后，`BeanFactory`跟Bean创建相关的配置几乎算是配置完成了<br />之后其实就是一些`ApplicationContext`内部的一些组价的初始化，比如`MessageSource`、`ApplicationEventMulticaster`等等<br />优先从`BeanFactory`中获取，没有再用默认的<br />到这`ApplicationContext`也算配置完成了，之后就可以实例化单例非懒加载的Bean了<br />再后面就是一些扫尾的操作，发布一个`ContextRefreshedEvent`事件，表明容器已经刷新完成了<br />这时Spring就就算是真正启动完成了。
