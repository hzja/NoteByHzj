JavaSpring<br />在学习 Spring 框架中，大家可能会遇到这种问题，为什么Spring IOC能降低耦合度？
<a name="EwUFl"></a>
## 1、什么是耦合度
耦合度是指系统中不同部分之间的依赖程度或联系紧密程度。在软件开发中，耦合度是指模块或组件之间的相互依赖程度。耦合度越高，模块之间的依赖关系越紧密，修改一个模块可能会对其他模块产生影响，系统的可维护性和可扩展性会降低。<br />反之，耦合度越低，模块之间的依赖关系越松散，修改一个模块不会对其他模块产生影响，系统的可维护性和可扩展性会提高。
<a name="SNmjO"></a>
## 2、解析
<a name="YvLFK"></a>
### 2.1、传统方式用new创建对象
举个例子来分析：<br />最开始小明想要活下去，所以他要吃东西；
```java
Food food = new Food();
food.eat();
```
小明现在吃饱了，想要玩耍；
```java
Play play = new Play();
play.with();
```
小明玩耍之后想要交朋友；
```java
Friend friend = new Friend();
friend.get();
```
思考时间到，接着往下看。<br />从代码上看好像没多大问题，就改了两行代码。但是假设对数据量进行一个扩大，不只是小明一个人，现在有1000个人都要在玩耍之后再交朋友，就需要改2000行代码，有10000个地方都这样写，就需要改20000行代码。
<a name="s1lkO"></a>
### 2.2、接口编程
经过上面的操作，小明想好到了一个好点子，定义好一些方法，大家都按照这个规则来，不就好了。<br />给小明的各种行为定义一个接口：
```java
public interface activity{
    // 定义一个行为接口，有一个 act方法
    void act();
}
```
小明想要吃东西就实现这个接口：
```java
public class Food implements activity{
    @Override
    public void act() {
        System.out.println("吃东西");        
    }
}
```
小明想要玩耍就实现这个接口：
```java
public class Play implements activity{
    @Override
    public void act() {
        System.out.println("去玩耍");        
    }
}
```
小明想要交朋友就实现这个接口：
```java
public class Friend implements activity{
    @Override
    public void act() {
        System.out.println("交朋友");        
    }
}
```
通过小明的好点子，带入上面的思考，现在有1000个人都要玩耍之后在交朋友，就需要改1000行代码，有10000个地方都这样写，就需要改10000行代码。与传统方式用new创建对象这个方法相比，现在只需要修改 new 那块就可以了，节省了许多代码量。
<a name="svpSe"></a>
### 2.3、工厂方法
利用接口确实好一些了，但是问题还是没有解决。为了提高内聚性，负责特定的事情，所以使用一个类作为工厂类，既能吃东西也可以玩耍和交朋友等等。
```java
class ActivityFactory{
    ActivityFactory(){}
    public static Activity getInstance(String type){
        Animal result = null;
        if("food".equals(type)){
            result = new Food();
        }
        if("play".equals(type)){
            result = new Play();
        }
        if("friend".equals(type)){
            result = new Friend();
        }
        return result;
    }
}
Activity activity = ActivityFactory.getInstance("food");
activity.act();
```
这种方法把创建对象的过程交给了一个工厂类，只需要告诉他需要什么(参数)，他就会返回正确的对象，解决了内聚性的问题。大家想一想这种方法还有什么不足自处？大家想的没错，还是需要自己声明，例如小明吃饭后要玩耍，还是需要去将参数从food替换为play。<br />用此方法的好处：<br />**1、降低耦合度**：工厂类可以将对象的创建和使用分离，降低了类之间的耦合度，使得系统更加灵活。<br />**2、提高代码复用性**：通过工厂类创建对象，可以避免在多个地方重复创建相同的对象，提高了代码的复用性。<br />**3、简化代码**：工厂类可以封装对象的创建过程，使得客户端不需要了解对象的创建细节，从而简化了代码。<br />**4、易于维护**：如果需要修改对象的创建方式，只需要修改工厂类即可，而不需要修改客户端代码，从而降低了维护成本。<br />**5、可以实现多态**：工厂类可以返回不同类型的对象，从而实现多态，提高了系统的灵活性和扩展性。
<a name="mc7im"></a>
### 2.4、反射
后来小明想到一个更绝妙的主意，在写程序的时候不告诉工厂类需要什么，等到运行的时候再告诉工厂类需要什么，再利用反射技术生产出来。
```java
Activity activity = ActivityFactory.getInstance(读取配置文件);
activity.act();
//小明想要的：交朋友
food.act();
```
大功告成，这样要什么，都写在一个配置文件中，利用反射技术就可以创建好，这样就不用在生产了，下次换进行其他活动的时候直接去配置文件中修改就好了，代码中不用修改。
<a name="iwunf"></a>
### 2.5、Spring IOC
Spring IOC 就是利用工厂模式+反射实现自动生产对象，管理对象生命周期的功能。降低了代码的耦合。
<a name="xJsn2"></a>
## 3、总结
依赖注入的意思是你需要的东西不是由你创建的，而是第三方，或者说容器提供给你的。这样的设计符合正交性，即所谓的松耦合。它是调用者仅通过声明某个组件就可以获得组件的控制权，而对该组件的依赖关系管理、查找、加载由外部完成。<br />它是你不用关心对象的生命周期，什么时候被创建，什么时候销毁，只需直接使用即可，对象的生命周期由提供依赖注入的框架来管理。依赖注入的好处包括：

- **降低耦合度**：通过依赖注入，对象之间的依赖关系被解耦出来，从而降低了对象之间的耦合度，使得应用程序更加灵活、可扩展和易于维护。
- **提高代码复用性**：通过依赖注入，可以避免在多个地方重复创建相同的对象，提高了代码的复用性。
- **简化代码**：通过依赖注入，可以使得应用程序代码更加简洁、清晰，从而降低了代码的复杂度。
- **易于测试**：通过依赖注入，可以方便地进行单元测试和集成测试，从而提高了测试的效率和质量。
- **支持AOP**：通过依赖注入，可以支持AOP编程，从而实现横切关注点的统一处理。
