JavaSpring<br />Spring中有3个核心的概念：**控制反转(Ioc)、依赖注入(DI)、面向切面编程(AOP)**，Spring中其他的技术都是依靠3个核心的技术建立起来的，所以学习Spring需要先对这3个概念有个深入的理解。<br />先介绍其中的两个：控制反转和依赖注入。
<a name="RYsdZ"></a>
### 引出Spring
有2个类，A和B，如下：
```java
public class A{
    public void m1(){}
}

public class B{
    public void m1();
}
```
上面2个类都有同样的m1方法。<br />现在调用B的m1方法完成一些事情，而B中的m1方法需要调用A中的m1方法才可以完成这个事情，所以B的代码变成了下面这样：
```java
public class B{

    private A a; // @1

    public B(){
        this.a = new A(); //@2
    }

    public void m1(){
        this.a.m1(); //@3
    }

}
```
分析一下上面代码：<br />@1：B类中声明了一个A类型的属性a<br />@2：new了一个A对象，赋给了a属性<br />@3：B类中的m1方法中去调用a.m1()完成业务操作<br />**先说一下什么是依赖关系？**<br />当a对象完成某些操作需要调用b对象中的方法来实现时，说明a依赖于对象b，a和b是依赖关系。<br />上面代码中B的m1需要调用A的m1方法，说明了B依赖于A<br />**上面代码存在一些问题问题**<br />**B类中a对象的创建被写死在B的构造方法中了，如果想在创建不同的B对象的时候，使用不同的a对象，此时是无能为力的；代码也不利于测试，由于B中a的创建被写死在构造方法中了，想测试一下B中不同a对象的效果，此时只能去修改B中的构造方法。**<br />上面代码需要优化，B中a对象的创建不能写死，可以让外部传入进去，调整一下变成了下面这样：
```java
public class B{

    private A a;

    public B(A a){
        this.a = a;
    }

    public void m1(){
        this.a.m1(); 
    }
}
```
上面代码可以在创建B对象的时候，将外部创建好的a对象传入进去，此时a的控制权交给了使用者，创建B对象如下：
```java
A a = new A();
B b = new B(a);
b.m1();
```
上面代码再扩展一下，如果B类中还需要依赖很多类似于A的对象，比如需要依赖于C、D、E、F或者更多对象，首先是需要调整B的构造方法，修改老的构造方法不是很好，可以在B中新增一些构造方法。<br />但是使用B的时候就变成了下面这样：
```java
A a = new A();
C c = new C();
D d = new D();
E e = new E();
F f = new F();
...
B b = new B(a,c,d,e,f,...);
b.m1();
```
使用者创建B对象之前，需要先将B依赖的对象都给创建好，然后B依赖的这些对象传递给B对象，如果有很多地方都需要用到B类型的对象，都采用这种new的写法，代码量比较大，也不方便维护，如果B中新增了依赖，又需采用new的方式先创建好被依赖的对象，然后将被依赖的对象填充给B对象。<br />上面创建对象之前，需要先将被依赖对象通过new的方式创建好，然后将其传递给B，这些工作都是B的使用者自己去做的，所有对象的创建都是由使用者自己去控制的，弊端上面也说了，代码量也比较大，代码耦合度比较高（依赖有调整，改动也比较大），也不利于扩展。<br />那么有没有更好的方式来解决这些问题呢？<br />上面B对象以及B依赖的对象都是使用者自己主动去控制其创建的，能不能找一个第三方来把这个事情给做了，比如给第三方一个清单，清单中告诉第三方需要用到B对象以及B需要依赖的对象，然后由这个第三方去负责创建和组装B对象，使用者需要使用B对象的时候，只需要向第三方发起一个查找，如果第三方那边有B对象，直接将其内部组装好的B对象返回就可以了，整个系统中所有需要用到的对象都可以列个清单，让第三方帮忙创造，用的时候只需要向第三方索取就可以了，当B中依赖的对象有新增或者删除的时候，只需要去调整一下清单就可以了，这个事情Spring已经实现了。
<a name="fMVXz"></a>
### Spring容器
Spring容器的概念，容器这个名字起的相当好，容器可以放很多东西，程序启动的时候会创建Spring容器，会给Spring容器一个清单，清单中列出了需要创建的对象以及对象依赖关系，Spring容器会创建和组装好清单中的对象，然后将这些对象存放在Spring容器中，当程序中需要使用的时候，可以到容器中查找获取，然后直接使用。
<a name="paai3"></a>
### IOC：控制反转
使用者之前使用B对象的时候都需要自己去创建和组装，而现在这些创建和组装都交给Spring容器去给完成了，使用者只需要去Spring容器中查找需要使用的对象就可以了；这个过程中B对象的创建和组装过程被反转了，之前是使用者自己主动去控制的，现在交给Spring容器去创建和组装了，对象的构建过程被反转了，所以叫做控制反转；IOC是是面相对象编程中的一种设计原则，主要是为了降低系统代码的耦合度，让系统利于维护和扩展。
<a name="fZBnK"></a>
### DI：依赖注入
依赖注入是Spring容器中创建对象时给其设置依赖对象的方式，比如给Spring一个清单，清单中列出了需要创建B对象以及其他的一些对象（可能包含了B类型中需要依赖对象），此时Spring在创建B对象的时候，会看B对象需要依赖于哪些对象，然后去查找一下清单中有没有包含这些被依赖的对象，如果有就去将其创建好，然后将其传递给B对象；可能B需要依赖于很多对象，B创建之前完全不需要知道其他对象是否存在或者其他对象在哪里以及被他们是如何创建，而Spring容器会将B依赖对象主动创建好并将其注入到B中去，比如Spring容器创建B的时候，发现B需要依赖于A，那么Spring容器在清单中找到A的定义并将其创建好之后，注入到B对象中。
<a name="ZiUno"></a>
### 总结

1. IOC控制反转，是一种设计理念，将对象创建和组装的主动控制权利交给了Spring容器去做，控制的动作被反转了，降低了系统的耦合度，利于系统维护和扩展，**主要就是指需要使用的对象的组装控制权被反转了，之前是自己要做的，现在交给Spring容器做了**。
2. DI依赖注入，表示Spring容器中创建对象时给其设置依赖对象的方式，通过某些注入方式可以让系统更灵活，比如自动注入等可以让系统变的很灵活，这个后面的文章会细说。
3. Spring容器：主要负责容器中对象的创建、组装、对象查找、对象生命周期的管理等等操作。
