Java Spring<br />在使用Spring框架的日常开发中，bean之间的循环依赖太频繁了，spring已经解决循环依赖问题，对开发者来说是无感知的，下面具体分析一下spring是如何解决bean之间循环依赖，为什么要使用到三级缓存，而不是二级缓存？
<a name="XSEkS"></a>
## bean生命周期
首先需要了解一下bean在Spring中的生命周期，bean在Spring的加载流程，才能够更加清晰知道Spring是如何解决循环依赖的。<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1646124193267-618ddc06-06c6-4982-8db8-a8710adcd1fd.png#clientId=ud9e6d5c8-abf5-4&from=paste&id=u3888329e&originHeight=634&originWidth=1071&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8fe81cae-6bda-4267-b9a3-d1c79f95468&title=)<br />在Spring的`BeanFactory`工厂列举了很多接口，代表着bean的生命周期，主要记住的是圈红线圈出来的接口，再结合Spring的源码来看这些接口主要是在哪里调用的<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1646124193316-bb5c1cea-5987-44f2-b3d9-366cde280815.png#clientId=ud9e6d5c8-abf5-4&from=paste&id=uc73639c5&originHeight=537&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ub3b80b97-98ab-4cbe-ac0f-335609a337d&title=)<br />`AbstractAutowireCapableBeanFactory`类的`doCreateBean`方法是创建bean的开始，可以看到首先需要实例化这个bean，也就是在堆中开辟一块内存空间给这个对象，`createBeanInstance`方法里面逻辑大概就是采用反射生成实例对象，进行到这里表示对象还并未进行属性的填充，也就是`@Autowired`注解的属性还未得到注入<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1646124194244-10617540-9774-4e4c-bff0-b892b3224cfb.png#clientId=ud9e6d5c8-abf5-4&from=paste&id=u58d246d6&originHeight=407&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2e807997-03d2-4d40-a894-47024374448&title=)<br />可以看到第二步就是填充bean的成员属性，`populateBean`方法里面的逻辑大致就是对使用到了注入属性的注解就会进行注入，如果在注入的过程发现注入的对象还没生成，则会跑去生产要注入的对象，第三步就是调用`initializeBean`方法初始化bean，也就是调用上述所提到的接口<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1646124193297-22ef3794-fcaa-4b81-ad39-6a170b6e05d3.png#clientId=ud9e6d5c8-abf5-4&from=paste&id=uc06e0864&originHeight=441&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ud9ab47d1-d1a8-4411-b9e4-1421e771e21&title=)<br />可以看到`initializeBean`方法中，首先调用的是使用的`Aware`接口的方法，具体看一下`invokeAwareMethods`方法中会调用`Aware`接口的那些方法<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1646124194257-6feb0a3f-7803-434d-a780-3d4ea8b7ece0.png#clientId=ud9e6d5c8-abf5-4&from=paste&id=ud0c6cdc9&originHeight=251&originWidth=1035&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ub9f069db-e71d-4b27-ba5e-e3f912d1428&title=)<br />可以知道如果实现了`BeanNameAware`，`BeanClassLoaderAware`，`BeanFactoryAware`三个`Aware`接口的话，会依次调用`setBeanName()`，`setBeanClassLoader()`，`setBeanFactory()`方法，再看`applyBeanPostProcessorsBeforeInitialization`源码<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1646124194159-57d650cd-675c-4a57-8abb-d7d19d34289e.png#clientId=ud9e6d5c8-abf5-4&from=paste&id=u5332d689&originHeight=231&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u398477d4-9945-477f-b229-e644889d006&title=)<br />发现会如果有类实现了`BeanPostProcessor`接口，就会执行`postProcessBeforeInitialization`方法，这里需要注意的是：如果多个类实现`BeanPostProcessor`接口，那么多个实现类都会执行`postProcessBeforeInitialization`方法，可以看到是for循环依次执行的，还有一个注意的点就是如果加载A类到Spring容器中，A类也重写了`BeanPostProcessor`接口的`postProcessBeforeInitialization`方法，这时要注意A类的`postProcessBeforeInitialization`方法并不会得到执行，因为A类还未加载完成，还未完全放到Spring的`singletonObjects`一级缓存中。<br />再看一个注意的点<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1646124194139-24fa43ce-27db-4cff-895e-61bb8f7cb0b6.png#clientId=ud9e6d5c8-abf5-4&from=paste&id=ube2a5e99&originHeight=578&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1814272f-627b-4316-ba13-9495051e9bc&title=)<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1646124194269-d07dec70-4f3a-4888-92a4-477e499114b9.png#clientId=ud9e6d5c8-abf5-4&from=paste&id=udd270f2b&originHeight=453&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ubc8aaa09-5ad7-4a14-8807-03bc87c2ed4&title=)<br />可以看到`ApplicationContextAwareProcessor`也实现了`BeanPostProcessor`接口，重写了`postProcessBeforeInitialization`方法，方法里面并调用了`invokeAwareInterfaces`方法，而`invokeAwareInterfaces`方法也写着如果实现了众多的`Aware`接口，则会依次执行相应的方法，值得注意的是`ApplicationContextAware`接口的`setApplicationContext`方法，再看一下`invokeInitMethods`源码<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1646124194716-663867e4-6e80-469d-abd8-9bb093b646c5.png#clientId=ud9e6d5c8-abf5-4&from=paste&id=u163aee75&originHeight=517&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u94ee7332-4e0a-46b1-bed3-e31bba44555&title=)<br />发现如果实现了`InitializingBean`接口，重写了`afterPropertiesSet`方法，则会调用`afterPropertiesSet`方法，最后还会调用是否指定了init-method，可以通过标签，或者`@Bean`注解的`initMethod`指定，最后再看一张`applyBeanPostProcessorsAfterInitialization`源码图<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1646124194890-a9e6e1ff-677e-41a1-864d-b901284ba469.png#clientId=ud9e6d5c8-abf5-4&from=paste&id=u68c4d219&originHeight=219&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ubd66db23-5dd3-47c0-93c1-4bf3cf8a466&title=)<br />发现跟之前的`postProcessBeforeInitialization`方法类似，也是循环遍历实现了`BeanPostProcessor`的接口实现类，执行`postProcessAfterInitialization`方法。整个bean的生命执行流程就如上面截图所示，哪个接口的方法在哪里被调用，方法的执行流程。<br />最后，对bean的生命流程进行一个流程图的总结<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1646124194909-e798063c-0381-4f9f-a3d1-a9caf86ab46c.png#clientId=ud9e6d5c8-abf5-4&from=paste&id=u30417b2e&originHeight=1091&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u31f71b77-04a8-4e34-9be3-e314cd17396&title=)
<a name="G7FAK"></a>
## 三级缓存解决循环依赖
上面对bean的生命周期做了一个整体的流程分析，对Spring如何去解决循环依赖的很有帮助。前面分析到填充属性时，如果发现属性还未在Spring中生成，则会跑去生成属性对象实例。<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1646124195148-2260bda3-7ffd-4e26-aa4f-1547241d10ba.png#clientId=ud9e6d5c8-abf5-4&from=paste&id=ub1a279b0&originHeight=407&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u41b714ef-efb3-4495-b7c7-a3bb7df30ce&title=)<br />可以看到填充属性的时候，Spring会提前将已经实例化的bean通过ObjectFactory半成品暴露出去，为什么称为半成品是因为这时候的bean对象实例化，但是未进行属性填充，是一个不完整的bean实例对象<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1646124195240-9eaeb70b-f0db-4dfd-aa17-4c68531eee1c.png#clientId=ud9e6d5c8-abf5-4&from=paste&id=u1ec01c15&originHeight=333&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u502137f9-0fc1-44e8-ad44-1b76f0de9b7&title=)<br />Spring利用`singletonObjects`，`earlySingletonObjects`，`singletonFactories`三级缓存去解决的，所说的缓存其实也就是三个Map<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1646124195522-22a207dc-3875-4bf3-9356-fd6627c2d6c5.png#clientId=ud9e6d5c8-abf5-4&from=paste&id=u9e50fd1c&originHeight=379&originWidth=1042&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u388b431c-bf0d-4bd9-bfa2-980773e2ad3&title=)<br />可以看到三级缓存各自保存的对象，这里重点关注二级缓存`earlySingletonObjects`和三级缓存`singletonFactory`，一级缓存可以进行忽略。前面讲过先实例化的bean会通过`ObjectFactory`半成品提前暴露在三级缓存中<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1646124195418-d7f31d89-4ac8-425c-87de-6b89274aadd1.png#clientId=ud9e6d5c8-abf5-4&from=paste&id=u6277f166&originHeight=240&originWidth=991&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ueb8c79da-9ebc-4229-8331-1dfad99f4d6&title=)<br />`singletonFactory`是传入的一个匿名内部类，调用`ObjectFactory.getObject()`最终会调用`getEarlyBeanReference`方法。再来看看循环依赖中是怎么拿其它半成品的实例对象的。<br />假设现在有这样的场景AService依赖BService，BService依赖AService

1. AService首先实例化，实例化通过`ObjectFactory`半成品暴露在三级缓存中
2. 填充属性BService，发现BService还未进行过加载，就会先去加载BService
3. 再加载BService的过程中，实例化，也通过`ObjectFactory`半成品暴露在三级缓存
4. 填充属性AService的时候，这时候能够从三级缓存中拿到半成品的`ObjectFactory`

![](https://cdn.nlark.com/yuque/0/2022/png/396745/1646124195852-0a970f04-4439-4d0e-b9fb-af5cb6d2e1b3.png#clientId=ud9e6d5c8-abf5-4&from=paste&id=u61ef43a6&originHeight=429&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ud2e4eec2-e509-45a5-9520-9fc3c506810&title=)<br />拿到`ObjectFactory`对象后，调用`ObjectFactory.getObject()`方法最终会调用`getEarlyBeanReference()`方法，`getEarlyBeanReference`这个方法主要逻辑大概描述下如果bean被AOP切面代理则返回的是`beanProxy`对象，如果未被代理则返回的是原bean实例。<br />这时会发现能够拿到bean实例(属性未填充)，然后从三级缓存移除，放到二级缓存`earlySingletonObjects`中，而此时B注入的是一个半成品的实例A对象，不过随着B初始化完成后，A会继续进行后续的初始化操作，最终B会注入的是一个完整的A实例，因为在内存中它们是同一个对象。<br />下面是重点，可以发现这个二级缓存好像显得有点多余，好像可以去掉，只需要一级和三级缓存也可以做到解决循环依赖的问题？？？<br />只要两个缓存确实可以做到解决循环依赖的问题，但是有一个前提这个bean没被AOP进行切面代理，如果这个bean被AOP进行了切面代理，那么只使用两个缓存是无法解决问题，下面来看一下bean被AOP进行了切面代理的场景<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1646124195878-ed75ebb9-cb78-41e4-bf5e-8f07dd944d76.png#clientId=ud9e6d5c8-abf5-4&from=paste&id=u6c263a05&originHeight=432&originWidth=1005&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u7bfbdeff-8460-4180-b613-688b6dd31a5&title=)<br />可以发现AService的testAopProxy被AOP代理了，看看传入的匿名内部类的`getEarlyBeanReference`返回的是什么对象。<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1646124195926-43fe38ed-80c7-468d-9002-b5c4656ae6db.png#clientId=ud9e6d5c8-abf5-4&from=paste&id=udd07abf7&originHeight=370&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u059984e0-54ab-43ec-9b80-a5b2136b22b&title=)<br />发现`singletonFactory.getObject()`返回的是一个AService的代理对象，还是被CGLIB代理的。再看一张再执行一遍`singletonFactory.getObject()`返回的是否是同一个AService的代理对象<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1646124195988-daf6be41-d8b6-4044-920a-46779a7f473a.png#clientId=ud9e6d5c8-abf5-4&from=paste&id=u456a3310&originHeight=403&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u5ec140a6-750d-46e9-b517-5bfc1308c0d&title=)<br />可以发现再执行一遍`singleFactory.getObject()`方法又是一个新的代理对象，这就会有问题了，因为AService是单例的，每次执行`singleFactory.getObject()`方法又会产生新的代理对象。<br />假设这里只有一级和三级缓存的话，每次从三级缓存中拿到`singleFactory`对象，执行`getObject()`方法又会产生新的代理对象，这是不行的，因为AService是单例的，所有这里要借助二级缓存来解决这个问题，将执行了`singleFactory.getObject()`产生的对象放到二级缓存中去，后面去二级缓存中拿，没必要再执行一遍`singletonFactory.getObject()`方法再产生一个新的代理对象，保证始终只有一个代理对象。还有一个注意的点<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1646124196063-6465bb70-63a1-4c1d-aac5-736af58c1447.png#clientId=ud9e6d5c8-abf5-4&from=paste&id=u46f95c02&originHeight=326&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uab1fc6f0-4a69-4f5b-a3b0-70a5c7d3598&title=)<br />既然`singleFactory.getObject()`返回的是代理对象，那么注入的也应该是代理对象，可以看到注入的确实是经过CGLIB代理的AService对象。所以如果没有AOP的话确实可以两级缓存就可以解决循环依赖的问题，如果加上AOP，两级缓存是无法解决的，不可能每次执行`singleFactory.getObject()`方法都给产生一个新的代理对象，所以还要借助另外一个缓存来保存产生的代理对象
<a name="Y7hiZ"></a>
## 总结
前面先讲到bean的加载流程，了解了bean加载流程对Spring如何解决循环依赖的问题很有帮助，后面再分析到Spring为什么需要利用到三级缓存解决循环依赖问题，而不是二级缓存。网上可以试试AOP的情形，实践一下就能明白二级缓存为什么解决不了AOP代理的场景了
