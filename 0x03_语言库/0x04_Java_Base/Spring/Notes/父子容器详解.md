<a name="CWdkf"></a>
## 先来看一个案例
系统中有2个模块：module1和module2，两个模块是独立开发的，module2会使用到module1中的一些类，module1会将自己打包为jar提供给module2使用，来看一下这2个模块的代码。
<a name="Cglsa"></a>
### 模块1
放在module1包中，有3个类
<a name="BK7xr"></a>
#### Service1
```java
package com.javacode2018.lesson002.demo17.module1;

import org.springframework.stereotype.Component;

@Component
public class Service1 {
    public String m1() {
        return "我是module1中的Servce1中的m1方法";
    }
}
```
<a name="BT8qS"></a>
#### Service2
```java
package com.javacode2018.lesson002.demo17.module1;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class Service2 {

    @Autowired
    private com.javacode2018.lesson002.demo17.module1.Service1 service1; //@1

    public String m1() { //@2
        return this.service1.m1();
    }

}
```
上面2个类，都标注了`@Compontent`注解，会被Spring注册到容器中。<br />@1：Service2中需要用到Service1，标注了`@Autowired`注解，会通过Spring容器注入进来<br />@2：Service2中有个m1方法，内部会调用service的m1方法。
<a name="K4E9a"></a>
#### 来个Spring配置类：Module1Config
```java
package com.javacode2018.lesson002.demo17.module1;

import org.springframework.context.annotation.ComponentScan;

@ComponentScan
public class Module1Config {
}
```
上面使用了`@CompontentScan`注解，会自动扫描当前类所在的包中的所有类，将标注有`@Compontent`注解的类注册到Spring容器，即Service1和Service2会被注册到Spring容器。
<a name="Gv77F"></a>
### 再来看模块2
放在module2包中，也是有3个类，和模块1中的有点类似。
<a name="HmcqN"></a>
#### Service1
模块2中也定义了一个Service1，内部提供了一个m2方法，如下：
```java
package com.javacode2018.lesson002.demo17.module2;

import org.springframework.stereotype.Component;

@Component
public class Service1 {
    public String m2() {
        return "我是module2中的Servce1中的m2方法";
    }
}
```
<a name="wFymr"></a>
#### Service3
```java
package com.javacode2018.lesson002.demo17.module2;

import com.javacode2018.lesson002.demo17.module1.Service2;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class Service3 {
    //使用模块2中的Service1
    @Autowired
    private com.javacode2018.lesson002.demo17.module2.Service1 service1; //@1
    //使用模块1中的Service2
    @Autowired
    private com.javacode2018.lesson002.demo17.module1.Service2 service2; //@2

    public String m1() {
        return this.service2.m1();
    }

    public String m2() {
        return this.service1.m2();
    }

}
```
@1：使用module2中的Service1<br />@2：使用module1中的Service2
<a name="RqP1n"></a>
#### 先来思考一个问题
**上面的这些类使用Spring来操作会不会有问题？会有什么问题？**<br />这个问题还是比较简单的，大部分人都可以看出来，会报错，因为两个模块中都有Service1，被注册到Spring容器的时候，bean名称会冲突，导致注册失败。
<a name="J1eHK"></a>
#### 来个测试类，看一下效果
```java
package com.javacode2018.lesson002.demo17;

import com.javacode2018.lesson001.demo21.Config;
import com.javacode2018.lesson002.demo17.module1.Module1Config;
import com.javacode2018.lesson002.demo17.module2.Module2Config;
import org.junit.Test;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class ParentFactoryTest {

    @Test
    public void test1() {
        //定义容器
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
        //注册bean
        context.register(Module1Config.class, Module2Config.class); //@1
        //启动容器
        context.refresh();
    }
}
```
@1：将Module1Config、Module2Config注册到容器，Spring内部会自动解析这两个类上面的注解，即：`@CompontentScan`注解，然后会进行包扫描，将标注了`@Compontent`的类注册到Spring容器。
<a name="pr1uM"></a>
#### 运行test1输出
下面是部分输出：
```
Caused by: org.springframework.context.annotation.ConflictingBeanDefinitionException: Annotation-specified bean name 'service1' for bean class [com.javacode2018.lesson002.demo17.module2.Service1] conflicts with existing, non-compatible bean definition of same name and class [com.javacode2018.lesson002.demo17.module1.Service1]
```
service1这个bean的名称冲突了。
<a name="jw2KC"></a>
#### 那么如何解决？
对module1中的Service1进行修改？这个估计是行不通的，module1是别人以jar的方式提供的，源码是无法修改的。<br />而module2是自己的开发的，里面的东西可以随意调整，那么可以去修改一下module2中的Service1，可以修改一下类名，或者修改一下这个bean的名称，此时是可以解决问题的。<br />不过大家有没有想过一个问题：如果模块中有很多类都出现了这种问题，此时一个个去重构，还是比较痛苦的，并且代码重构之后，还涉及到重新测试的问题，工作量也是蛮大的，这些都是风险。<br />而Spring中的父子容器就可以很好的解决上面这种问题。
<a name="s6lVu"></a>
## 什么是父子容器
创建Spring容器的时候，可以给当前容器指定一个父容器。
<a name="l7t2L"></a>
### `BeanFactory`的方式
```java
//创建父容器parentFactory
DefaultListableBeanFactory parentFactory = new DefaultListableBeanFactory();
//创建一个子容器childFactory
DefaultListableBeanFactory childFactory = new DefaultListableBeanFactory();
//调用setParentBeanFactory指定父容器
childFactory.setParentBeanFactory(parentFactory);
```
<a name="hKuRZ"></a>
### `ApplicationContext`的方式
```java
//创建父容器
AnnotationConfigApplicationContext parentContext = new AnnotationConfigApplicationContext();
//启动父容器
parentContext.refresh();

//创建子容器
AnnotationConfigApplicationContext childContext = new AnnotationConfigApplicationContext();
//给子容器设置父容器
childContext.setParent(parentContext);
//启动子容器
childContext.refresh();
```
上面代码还是比较简单的，大家都可以看懂。<br />需要了解父子容器的特点，这些是比较关键的，如下。
<a name="VMNJz"></a>
### 父子容器特点

1. **父容器和子容器是相互隔离的，他们内部可以存在名称相同的bean**
2. **子容器可以访问父容器中的bean，而父容器不能访问子容器中的bean**
3. **调用子容器的getBean方法获取bean的时候，会沿着当前容器开始向上面的容器进行查找，直到找到对应的bean为止**
4. **子容器中可以通过任何注入方式注入父容器中的bean，而父容器中是无法注入子容器中的bean，原因是第2点**
<a name="FftcS"></a>
## 使用父子容器解决开头的问题
<a name="dDId1"></a>
### 关键代码
```java
@Test
public void test2() {
    //创建父容器
    AnnotationConfigApplicationContext parentContext = new AnnotationConfigApplicationContext();
    //向父容器中注册Module1Config配置类
    parentContext.register(Module1Config.class);
    //启动父容器
    parentContext.refresh();

    //创建子容器
    AnnotationConfigApplicationContext childContext = new AnnotationConfigApplicationContext();
    //向子容器中注册Module2Config配置类
    childContext.register(Module2Config.class);
    //给子容器设置父容器
    childContext.setParent(parentContext);
    //启动子容器
    childContext.refresh();

    //从子容器中获取Service3
    Service3 service3 = childContext.getBean(Service3.class);
    System.out.println(service3.m1());
    System.out.println(service3.m2());
}
```
<a name="p3WPx"></a>
### 运行输出
```
我是module1中的Servce1中的m1方法
我是module2中的Servce1中的m2方法
```
这次正常了。
<a name="jS4Pj"></a>
## 父子容器使用注意点
使用容器的过程中，经常会使用到的一些方法，这些方法通常会在下面的两个接口中
```
org.springframework.beans.factory.BeanFactory
org.springframework.beans.factory.ListableBeanFactory
```
这两个接口中有很多方法，这里就不列出来了，大家可以去看一下源码，这里要说的是使用父子容器的时候，有些需要注意的地方。<br />`BeanFactory`接口，是Spring容器的顶层接口，这个接口中的方法是支持容器嵌套结构查找的，比如常用的`getBean`方法，就是这个接口中定义的，调用getBean方法的时候，会从沿着当前容器向上查找，直到找到满足条件的bean为止。<br />而`ListableBeanFactory`这个接口中的方法是不支持容器嵌套结构查找的，比如下面这个方法
```java
String[] getBeanNamesForType(@Nullable Class<?> type)
```
获取指定类型的所有bean名称，调用这个方法的时候只会返回当前容器中符合条件的bean，而不会去递归查找其父容器中的bean。<br />来看一下案例代码，感受一下：
```java
@Test
public void test3() {
    //创建父容器parentFactory
    DefaultListableBeanFactory parentFactory = new DefaultListableBeanFactory();
    //向父容器parentFactory注册一个bean[userName->"Java"]
    parentFactory.registerBeanDefinition("userName",
                                         BeanDefinitionBuilder.
                                         genericBeanDefinition(String.class).
                                         addConstructorArgValue("Java").
                                         getBeanDefinition());

    //创建一个子容器childFactory
    DefaultListableBeanFactory childFactory = new DefaultListableBeanFactory();
    //调用setParentBeanFactory指定父容器
    childFactory.setParentBeanFactory(parentFactory);
    //向子容器parentFactory注册一个bean[address->"上海"]
    childFactory.registerBeanDefinition("address",
                                        BeanDefinitionBuilder.
                                        genericBeanDefinition(String.class).
                                        addConstructorArgValue("上海").
                                        getBeanDefinition());

    System.out.println("获取bean【userName】：" + childFactory.getBean("userName"));//@1

    System.out.println(Arrays.asList(childFactory.getBeanNamesForType(String.class))); //@2
}
```
上面定义了2个容器<br />父容器：parentFactory，内部定义了一个String类型的bean：userName->Java<br />子容器：childFactory，内部也定义了一个String类型的bean：address->上海<br />@1：调用子容器的getBean方法，获取名称为userName的bean，userName这个bean是在父容器中定义的，而getBean方法是`BeanFactory`接口中定义的，支持容器层次查找，所以getBean是可以找到userName这个bean的<br />@2：调用子容器的`getBeanNamesForType`方法，获取所有String类型的bean名称，而getBeanNamesForType方法是`ListableBeanFactory`接口中定义的，这个接口中方法不支持层次查找，只会在当前容器中查找，所以这个方法只会返回子容器的address<br />来运行一下看看效果：
```
获取bean【userName】：Java
[address]
```
结果和分析的一致。<br />**那么问题来了：有没有方式解决**`**ListableBeanFactory**`**接口不支持层次查找的问题？**<br />Spring中有个工具类就是解决这个问题的，如下：
```
org.springframework.beans.factory.BeanFactoryUtils
```
这个类中提供了很多静态方法，有很多支持层次查找的方法，源码你们可以去细看一下，名称中包含有Ancestors的都是支持层次查找的。<br />在test2方法中加入下面的代码：
```java
//层次查找所有符合类型的bean名称
String[] beanNamesForTypeIncludingAncestors = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(childFactory, String.class);
System.out.println(Arrays.asList(beanNamesForTypeIncludingAncestors));

Map<String, String> beansOfTypeIncludingAncestors = BeanFactoryUtils.beansOfTypeIncludingAncestors(childFactory, String.class);
System.out.println(Arrays.asList(beansOfTypeIncludingAncestors));
```
运行输出
```
[address, userName]
[{address=上海, userName=Java}]
```
查找过程是按照层次查找所有满足条件的bean。
<a name="IZeYv"></a>
## 回头看一下SpringMVC父子容器的问题
<a name="GdiwJ"></a>
### 问题1：SpringMVC中只使用一个容器是否可以？
只使用一个容器是可以正常运行的。
<a name="m5IDy"></a>
### 问题2：那么SpringMVC中为什么需要用到父子容器？
通常使用SpringMVC的时候，采用3层结构，Controller层，Service层，dao层；父容器中会包含dao层和Service层，而子容器中包含的只有Controller层；这2个容器组成了父子容器的关系，Controller层通常会注入Service层的bean。<br />采用父子容器可以避免有些人在Service层去注入Controller层的bean，导致整个依赖层次是比较混乱的。<br />父容器和子容器的需求也是不一样的，比如父容器中需要有事务的支持，会注入一些支持事务的扩展组件，而子容器中Controller完全用不到这些，对这些并不关心，子容器中需要注入一下SpringMVC相关的bean，而这些bean父容器中同样是不会用到的，也是不关心一些东西，将这些相互不关心的东西隔开，可以有效的避免一些不必要的错误，而父子容器加载的速度也会快一些。
<a name="vdQ3E"></a>
## 总结

1. 本文需掌握父子容器的用法，了解父子容器的特点：子容器可以访问父容器中bean，父容器无法访问子容器中的bean
2. `BeanFactory`接口支持层次查找
3. `ListableBeanFactory`接口不支持层次查找
4. `BeanFactoryUtils`工具类中提供了一些非常实用的方法，比如支持bean层次查找的方法等等
