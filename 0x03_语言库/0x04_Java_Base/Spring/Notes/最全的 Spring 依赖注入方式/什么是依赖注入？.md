Java<br />编写 Web 后端代码的时候，会用到这样的代码：
```java
class A {
    private IB _b;

    public A(IB b){
        _b = b;
    }

    public void MethodA(){
        _b.MethodB();
    }
}
```
如果存在这样的困惑：<br />在 Class A 中没有任何地方 new Class B 的实例，但是运行的时候，MethodA 中的变量 _b 已经是 Class B 的一个实例了，为什么会这样？<br />带着疑问，**了解一下依赖注入的来龙去脉**。<br />文章从依赖注入的历史出发，分为三个部分：

1. **依赖倒置原则**
2. **控制反转**
3. **依赖注入**

![依赖注入发展历史](https://cdn.nlark.com/yuque/0/2023/jpeg/396745/1676197599266-bca50d0d-ccfb-4af5-a3ce-7706d5f25fc8.jpeg#averageHue=%23f5f5f5&clientId=u2dc41029-bba9-4&from=paste&id=u978830ca&originHeight=608&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=u418ceaba-b7aa-4e88-a771-a594e79e290&title=%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2 "依赖注入发展历史")
<a name="H4mhC"></a>
## 1、依赖倒置原则
依赖倒置原则（DIP Dependency Inversion Principle）<br />在没有依赖注入的情况下，如果 Class A 调用了 Class B 的方法，这就意味着 Class A 依赖于 Class B。换句话说，在编译时 Class A 将取决于 Class B。<br />![直接依赖的编译情况](https://cdn.nlark.com/yuque/0/2023/jpeg/396745/1676197599273-b17ad63b-c83a-40c3-b4b0-b41e29689771.jpeg#averageHue=%23fcfafa&clientId=u2dc41029-bba9-4&from=paste&id=u70cc5690&originHeight=608&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=u2a248140-c0d8-4805-ab4f-9f47cbeb9ca&title=%E7%9B%B4%E6%8E%A5%E4%BE%9D%E8%B5%96%E7%9A%84%E7%BC%96%E8%AF%91%E6%83%85%E5%86%B5 "直接依赖的编译情况")<br />代码可以这么编写：
```java
class A {
    private B b；

    public A(){
        b = new B();
    }

    public void MethodA(){
        b.MethodB();
    }
}
```
在 90 年代的时候，代码差不多都是这么写的。这样的代码有什么问题吗？<br />为了准确地回答这个问题，回到 1995 年。“Bob 大叔”（Robert C. Martin）当年提出了——**依赖倒置原则**。<br />这个原则有以下两个定义：

1. **高层模块不应该依赖于低层模块，二者都应该依赖于抽象。**
2. **抽象不应该依赖于细节，细节应该依赖于抽象。**

上面的代码很明显不符合这个原则。那么**怎样才算能符合这个原则？**
<a name="vV05L"></a>
### 依赖倒置原则示例
来看看 “Bob 大叔” 在他的著作《敏捷软件开发，原则、模式与实践 C# 版》中的一个示例，来深入理解这个原则的具体含义。<br />假设有一个控制电水壶（Kettle）温度调节器的软件，该软件可以从一个 I/O 通道中读取当前的温度，并通过向另一个 I/O 通道发送指令来操作电水壶打开或者关闭。<br />调节器软件将电水壶的温度控制在一个范围（最低温度 和 最高温度之间）。当温度低于最低温度（minTemp）时，就发送指令打开（Turn On）电水壶。当温度高于最高温度（maxTemp）时，就发送指令关闭（Turn Off）电水壶。<br />根据上述需求，代码可以这样写：
```cpp
//读取温度的 I/O 通道
const byte TERMOMETER = 0x86; 
//操作电水壶开关的 I/O 通道
const byte KETTLE = 0x87; 
// 开电水壶的指令
const byte TURNON = 1; 
//关电水壶的指令
const byte TURNOFF = 0; 

//温度调节器函数
void Regulate(double minTemp, double maxTemp)
{
    for(;;)
    {
        //当温度高于最低温度时，就等待 1 秒中，继续循环。
        while(in(TERMOMETER) > minTemp)
            wait(1);
        //否则就发送指令打开电水壶。
        out(KETTLE,TURNON);

        //当温度低于最高温度时，就等待 1 秒中，继续循环。
        while(in(TERMOMETER) < maxTemp)
            wait(1);
        //否则就发送指令关闭电水壶。
        out(KETTLE,TURNOFF);
    }
}
```
整个函数的高层意图非常清晰，但是实现的代码中包括了许多底层的细节，in 和 out 函数都是系统底层函数。<br />如果其他类型的加热器（Heater）也有同样的调节温度需求，这段代码会因为包括了电水壶的**底层细节无法被重用**。<br />如何修改这段代码让它可以重用？这时候就可以使用依赖倒置原则。<br />![使用依赖倒置的调节器函数](https://cdn.nlark.com/yuque/0/2023/jpeg/396745/1676197599262-b6b1a2a2-ce2d-4105-beee-c5a91a55e3c2.jpeg#averageHue=%23fcf6f6&clientId=u2dc41029-bba9-4&from=paste&id=u892ec753&originHeight=608&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=u7e73b41e-4473-45c4-899f-2fac81efc3e&title=%E4%BD%BF%E7%94%A8%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E7%9A%84%E8%B0%83%E8%8A%82%E5%99%A8%E5%87%BD%E6%95%B0 "使用依赖倒置的调节器函数")<br />在图中，可以看到 Regulate 调节器函数接受了两个接口参数：IThermometer 接口可以读取（Read）温度；IHeater 接口可以打开（TurnOn）或者关闭（TurnOff）加热器。<br />接口的定义和 Regulate 调节器函数都属于高层模块，函数只需要知道着这两个接口，跟具体加热器的实现细节无关。<br />所有的加热器只需实现这两个接口就可以，这些接口的实现属于底层模块。<br />这就是依赖关系倒置，高层的 Regulate 调节器函数，不再依赖任何加热器的底层细节，函数本身有了很好的可用性。<br />最终 Regulate 调节器函数可以写成下面这样：
```java
void Regulate(IThermometer t, IHeater h,
        double minTemp, double maxTemp)
{
    for(;;)
    {
        while(t.Read() > minTemp)
            wait(1);
        h.TurnOn();

        while(t.Read() > maxTemp)
            wait(1);
        h.TurnOff();
    }
}
```
<a name="IDlFW"></a>
### 使用依赖倒置原则优化代码
依赖倒置原则，不仅解释了为什么之前代码的写法不好，而且提出了解决方案。<br />再次回到之前的例子中：<br />代码 1 **直接依赖**：
```java
class A {
    private B b；

    public A(){
        b = new B();
    }

    public void MethodA(){
        b.MethodB();
    }
}

class B {
    public void MethodB(){
        //code of method.
    }
}
```
之前已经提到，在这段代码中 Class A 依赖于 Class B。如果 Class A 是高层模块，如何让 Class A 不依赖于 Class B？<br />根据依赖倒置原则，可以让 Class A 依赖于 Class B 的抽象 IB。<br />代码 2 **依赖倒置**：
```java
class A {
    public void MethodA(IB b){
        b.MethodB();
    }
}

interface IB {
    void MethodB();
}

class B : IB {
    public void MethodB(){
        //code of method.
    }
}
```
![依赖倒置的编译情况](https://cdn.nlark.com/yuque/0/2023/jpeg/396745/1676197599278-9288a3d1-014e-45f3-a04f-05ce8996b2af.jpeg#averageHue=%23fcfafa&clientId=u2dc41029-bba9-4&from=paste&id=u3aaebe48&originHeight=608&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=u804ad017-0b7a-4211-bfd6-5335275003e&title=%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E7%9A%84%E7%BC%96%E8%AF%91%E6%83%85%E5%86%B5 "依赖倒置的编译情况")<br />此时，Class A 和 Class B 的**依赖关系反转**了。<br />Class A 和接口 IB 属于高层模块，Class B 作为接口 IB 的实现属于底层模块。<br />但是想要调用 Class A 中的 MethodA，应用程序仍然需要先 new 一个 Class B 的实例。
```java
class Test {
    static void Main(){
        A a = new A();
        B b = new B();

        a.MethodA(b);
    }
}
```
这样的调用关系，在编译时 Class A 依赖于抽象 IB；在运行时，实例 a 仍然直接调用了实例 b，所以应用程序需要事先准备好 Class B 的实例 b。<br />这跟依赖注入有什么关系？带着这个疑问，先进入下一个概念——控制反转 (IoC Inversion of Control)。
<a name="JO3Jv"></a>
## 2、控制反转
控制反转 (IoC Inversion of Control)
<a name="oPfmZ"></a>
### 直接依赖和依赖倒置运行时的情况
回过头来，再看看之前的两段代码。<br />代码 1 **直接依赖**：
```java
class A {
    private B b；

    public A(){
        b = new B();
    }

    public void MethodA(){
        b.MethodB();
    }
}

class B {
    public void MethodB(){
        //code of method.
    }
}
```
第一段代码使用了直接依赖的方式，Class A 依赖于 Class B。**编译时依赖关系顺着运行时执行的方向流动，二者方向是一致的。**<br />![直接依赖编译和运行时的情况](https://cdn.nlark.com/yuque/0/2023/jpeg/396745/1676197599287-ec4ff4e2-fd8b-4481-9f90-97133115dc3d.jpeg#averageHue=%23fbf7f7&clientId=u2dc41029-bba9-4&from=paste&id=ufc586f73&originHeight=608&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=ued7ee064-7435-421d-ad35-be8227f56d2&title=%E7%9B%B4%E6%8E%A5%E4%BE%9D%E8%B5%96%E7%BC%96%E8%AF%91%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E6%83%85%E5%86%B5 "直接依赖编译和运行时的情况")<br />代码 2 **依赖倒置**：
```java
class A {
    public void MethodA(IB b){
        b.MethodB();
    }
}

interface IB {
    void MethodB();
}

class B : IB {
    public void MethodB(){
        //code of method.
    }
}
```
第二段代码使用了依赖倒置原则，使得**代码在编译阶段的依赖关系发生了反转**。Class A 在编译时可以调用 Class B 的抽象 IB 上的方法。而在运行时，Class A 的实例仍然直接调用 Class B 的实例。<br />![依赖倒置编译和运行时的情况](https://cdn.nlark.com/yuque/0/2023/jpeg/396745/1676197599677-e84bfdd6-db06-4a8a-882e-fd58f4762950.jpeg#averageHue=%23faf6f6&clientId=u2dc41029-bba9-4&from=paste&id=uad30c42c&originHeight=608&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=u99e781b7-9df8-438d-be17-f40dc051646&title=%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E7%BC%96%E8%AF%91%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E6%83%85%E5%86%B5 "依赖倒置编译和运行时的情况")<br />**在代码的运行阶段，这两段代码的执行流程是一致的。**<br />因为，**在传统的面向对象程序中，执行的代码（主函数）需要先实例化对象、再调用方法，这样代码才能继续执行。**<br />![直接依赖 VS 依赖倒置](https://cdn.nlark.com/yuque/0/2023/jpeg/396745/1676197599681-f7da72ca-eae1-4a8a-ad8f-727d6576afb9.jpeg#averageHue=%23faf6f6&clientId=u2dc41029-bba9-4&from=paste&id=u0ebef555&originHeight=608&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=u85bc7a0b-3732-4848-9089-2c8b68c7599&title=%E7%9B%B4%E6%8E%A5%E4%BE%9D%E8%B5%96%20VS%20%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE "直接依赖 VS 依赖倒置")
<a name="vfvK8"></a>
### 控制反转介绍
回过头来，看看文章最开始使用的代码示例。<br />代码 3 **控制反转**：
```java
class A {
    private IB _b;

    public A(IB b){
        _b = b;
    }

    public void MethodA(){
        _b.MethodB();
    }
}

interface IB {
    void MethodB();
}

class B : IB {
    public void MethodB(){
        //code of method.
    }
}
```
代码 3 控制反转和代码 2 依赖倒置的结构很类似，所以，很明显代码 3 **控制反转也是符合依赖倒置原则的**。<br />![依赖倒置 VS 控制反转](https://cdn.nlark.com/yuque/0/2023/jpeg/396745/1676197599693-96ad0f40-eceb-46c8-9c16-d9659f4da960.jpeg#averageHue=%23888c7f&clientId=u2dc41029-bba9-4&from=paste&id=u87496edd&originHeight=608&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=u5efa0d87-0fb9-46ef-a82d-81d1ac01e87&title=%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%20VS%20%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC "依赖倒置 VS 控制反转")<br />但这两段代码的使用还是不一样，在使用代码 3 控制反转的项目中，开发人员不需要编写任何实例化 Class B 的代码。<br />为什么会这样？这时就必须引入控制反转 （IoC Inversion of Control）概念了。
<a name="W8q6z"></a>
### 控制反转的概念
**控制反转的主要思想是：有一个独立的框架，它可以获得接口 IB 合适的实现类 Class B，并主动创建这个类的实例，再赋值给 Class A 类的一个字段 _b。** <br />如下图所示：<br />![控制反转的运行时的情况](https://cdn.nlark.com/yuque/0/2023/jpeg/396745/1676197599682-a0b90e42-a40a-4be5-ab0a-b8718febcfe9.jpeg#averageHue=%23fbf7f3&clientId=u2dc41029-bba9-4&from=paste&id=uc2919898&originHeight=608&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=u47f804f8-5bc4-4f30-a91b-3041c627ddc&title=%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%E7%9A%84%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E6%83%85%E5%86%B5 "控制反转的运行时的情况")<br />此时，**程序执行的控制流程（先实例化对象、再调用方法），就从应用程序本身转移到了 IoC 框架中**。也就是说，程序的主要控制者发生了反转，从应用程序变成了 IoC 框架。<br />从上面的介绍可以看出，框架的一个重要特征是：**用户为框架定义的方法，经常会从框架本身，而不是从用户的应用程序代码中调用。**<br />**这种控制权的倒置有时被称为好莱坞原则："不要调用我们，我们会调用你（Don't call me; I'll call you.）"。**<br />在协调和安排应用活动的顺序方面，框架往往扮演着主程序的角色。这种控制的倒置使得框架有能力作为可扩展的骨架。
<a name="SNtNO"></a>
### 控制反转的示例
带着上面的理论，再来看看 代码 3 控制反转中的代码片段：<br />代码中，为框架定义的方法——构造函数 public A(IB b) ，会被框架调用而不是应用程序本身调用。<br />这就是为什么在项目中看不到任何调用这个构造函数的原因。<br />控制反转框架在运行时调用了 Class A 的构造函数，发现参数需要 IB 接口，就找到了接口 IB 合适的实现类 Class B，然后创建了Class B 的实例，最后赋值给构造函数的参数。在这里，**程序执行的控制流程完全发生了转变，从应用程序转移到了控制反转框架中。**<br />控制反转的发展也经历了很长时间的迭代：<br />从 1983 年，Richard E. Sweet 提出好莱坞原则开始；到 1998 年，随着 Java Apache 服务器框架的提出，Stefano Mazzocchi 将控制反转作为框架的主要驱动设计原则之一，普及了这个概念；最后，在 2003 年，Spring、PicoContainer 等框架纷纷实现了控制反转。最终才有了文章最开始展示的那种类型的代码。
<a name="fvnlk"></a>
## 3、依赖注入
依赖注入（DI Dependency Injection）<br />说了半天，还没有提及文章标题中的名词——依赖注入。<br />2004 年，Martin Fowler 在他的文章《控制反转容器&依赖注入模式》首次提出了依赖注入这个名词。<br />文章中指出，**控制反转这个词太宽泛，并不能很好地解释这个框架的具体实现。作者和 IoC 爱好者们商讨出了一个新的名称：依赖注入（DI Dependency Injection）。**<br />这个名词很形象地解释了控制反转在运行时发生了什么。比如之前的代码 3 中，在运行时，构造函数 public A(IB b) 需要接口 IB 的一个实例，此时框架就像是给函数打针一样，注入了 Class B 的实例。<br />下面这幅漫画生动地展现了用户的使用感受。<br />![依赖注入漫画](https://cdn.nlark.com/yuque/0/2023/jpeg/396745/1676197599701-72ea6cd0-de75-4b1a-b81b-7894c3306933.jpeg#averageHue=%23dfdfde&clientId=u2dc41029-bba9-4&from=paste&id=u75778ec0&originHeight=208&originWidth=624&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=u8e745efe-b91d-4fac-bed0-093a03865e9&title=%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%BC%AB%E7%94%BB "依赖注入漫画")<br />**打个比方，包饺子的时候不需要确定具体是什么馅，只管包就行了，在吃饺子的时候，说想吃韭菜鸡蛋馅的饺子，这时候就有人用针管给饺子注入韭菜鸡蛋馅。**
<a name="kUdcJ"></a>
## 4、历史演变过程
从上面的描述中可以看到，依赖倒置原则是一个软件设计原则，而使用了控制反转的代码都符合这一原则。<br />**控制反转框架，将程序执行的控制流程从应用程序转移到了框架中。最终使用的感觉就是，开发者在代码中所依赖的对象，会在运行的时候直接注入到相应的方法中去，所以就有了一个新名词——依赖注入。**<br />整个技术的演变历程如下：<br />![依赖注入发展历史](https://cdn.nlark.com/yuque/0/2023/jpeg/396745/1676197600075-8c49cc6f-5112-4154-934d-3ee631cfd834.jpeg#averageHue=%23f5f5f5&clientId=u2dc41029-bba9-4&from=paste&id=u6a8f6d38&originHeight=608&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=uae0585f2-ffaf-49d9-bc3f-11a562d02a2&title=%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2 "依赖注入发展历史")
