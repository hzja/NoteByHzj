JavaSpring
<a name="i2bwJ"></a>
## 单例模式
单例模式是指一个类在一个进程中只有一个实例对象（但也不一定，比如Spring中的Bean的单例是指在一个容器中是单例的）<br />单例模式创建分为饿汉式和懒汉式，总共大概有8种写法。但是在开源项目中使用最多的主要有两种写法：
<a name="I9bHX"></a>
### 1、静态常量
静态常量方式属于饿汉式，以静态变量的方式声明对象。这种单例模式在Spring中使用的比较多，举个例子，在Spring中对于Bean的名称生成有个类`AnnotationBeanNameGenerator`就是单例的。<br />![AnnotationBeanNameGenerator](https://cdn.nlark.com/yuque/0/2022/png/396745/1668691536885-77cee9cf-e787-449b-b594-739a41b2bcd9.png#averageHue=%232f2c2a&clientId=ua26e412b-61b7-4&from=paste&id=u21ab52e2&originHeight=440&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=u3671f3e6-6797-481b-bbd5-8b1793182b4&title=AnnotationBeanNameGenerator "AnnotationBeanNameGenerator")
<a name="vaygd"></a>
### 2、双重检查机制
除了上面一种，还有一种双重检查机制在开源项目中也使用的比较多，而且在面试中也比较喜欢问。双重检查机制方式属于懒汉式，代码如下：
```java
public class Singleton {

    private volatile static Singleton INSTANCE;

    private Singleton() {
    }

    public static Singleton getInstance() {
        if (INSTANCE == null) {
            synchronized (Singleton.class) {
                if (INSTANCE == null) {
                    INSTANCE = new Singleton();
                }
            }
        }
        return INSTANCE;
    }

}
```
之所以这种方式叫双重检查机制，主要是在创建对象的时候进行了两次`INSTANCE == null`的判断。
<a name="nQBML"></a>
#### 疑问讲解
这里解释一下双重检查机制的三个疑问：

- 外层判断null的作用
- 内层判断null的作用
- 变量使用`volatile`关键字修饰的作用

**外层判断null的作用**：其实就是为了减少进入同步代码块的次数，提高效率。你想一下，其实去了外层的判断其实是可以的，但是每次获取对象都需要进入同步代码块，实在是没有必要。<br />**内层判断null的作用**：防止多次创建对象。假设AB同时走到同步代码块，A先抢到锁，进入代码，创建了对象，释放锁，此时B进入代码块，如果没有判断null，那么就会直接再次创建对象，那么就不是单例的了，所以需要进行判断null，防止重复创建单例对象。<br />`**volatile**`**关键字的作用**：防止重排序。因为创建对象的过程不是原子，大概会分为三个步骤

- 第一步：分配内存空间给`Singleton`这个对象
- 第二步：初始化对象
- 第三步：将`INSTANCE`变量指向`Singleton`这个对象内存地址

假设没有使用`volatile`关键字发生了重排序，第二步和第三步执行过程被调换了，也就是先将`INSTANCE`变量指向Singleton这个对象内存地址，再初始化对象。这样在发生并发的情况下，另一个线程经过第一个if非空判断时，发现已经为不为空，就直接返回了这个对象，但是此时这个对象还未初始化，内部的属性可能都是空值，一旦被使用的话，就很有可能出现空指针这些问题。
<a name="YtNG2"></a>
#### 双重检查机制在dubbo中的应用
在dubbo的spi机制中获取对象的时候有这样一段代码：<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1668691536933-9a2b3727-c297-44a5-9f93-3756222bef6f.png#averageHue=%232e2b2b&clientId=ua26e412b-61b7-4&from=paste&id=ua3efdfbf&originHeight=959&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8d28433f-7ca8-4088-9bd0-cab25407b24&title=)<br />虽然这段代码跟上面的单例的写法有点不同，但是不难看出其实是使用了双重检查机制来创建对象，保证对象单例。
<a name="Z6esh"></a>
## 建造者模式
将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。<br />上面的意思看起来很绕，其实在实际开发中，其实建造者模式使用的还是比较多的，比如有时在创建一个pojo对象时，就可以使用建造者模式来创建：
```java
PersonDTO personDTO = PersonDTO.builder()
    .name("java")
    .age(18)
    .sex(1)
    .phone("188****9527")
    .build();
```
上面这段代码就是通过建造者模式构建了一个PersonDTO对象，所以建造者模式又被称为`Budiler`模式。<br />这种模式在创建对象的时候看起来比较优雅，当构造参数比较多的时候，适合使用建造者模式。<br />接下来就来看看建造者模式在开源项目中是如何运用的
<a name="YxFPd"></a>
### 1、在Spring中的运用
都知道，Spring在创建Bean之前，会将每个Bean的声明封装成对应的一个`BeanDefinition`，而`BeanDefinition`会封装很多属性，所以Spring为了更加优雅地创建`BeanDefinition`，就提供了`BeanDefinitionBuilder`这个建造者类。<br />![BeanDefinitionBuilder](https://cdn.nlark.com/yuque/0/2022/png/396745/1668691536952-3599ad2b-861e-4770-8b64-b6689cb31815.png#averageHue=%232d2c2b&clientId=ua26e412b-61b7-4&from=paste&id=ua01ec66c&originHeight=477&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=u8a0f5765-99db-4873-b172-66c75a89960&title=BeanDefinitionBuilder "BeanDefinitionBuilder")
<a name="XfmJV"></a>
### 2、在Guava中的运用
在项目中，如果需要使用本地缓存，会使用本地缓存的实现的框架来创建一个，比如在使用Guava来创建本地缓存时，就会这么写
```java
Cache<String, String> cache = CacheBuilder.newBuilder()
    .expireAfterAccess(1, TimeUnit.MINUTES)
    .maximumSize(200)
    .build();
```
这其实也就是建造者模式。<br />建造者模式不仅在开源项目中有所使用，在JDK源码中也有使用到，比如`StringBuilder`类。<br />最后上面说的建造者模式其实算是在Java中一种简化的方式，如果想了解一下传统的建造者模式，可以看一下这篇文章<br />[https://m.runoob.com/design-pattern/builder-pattern.html?ivk_sa=1024320u](https://m.runoob.com/design-pattern/builder-pattern.html?ivk_sa=1024320u)
<a name="uYiYZ"></a>
## 工厂模式
工厂模式在开源项目中也使用的非常多，具体的实现大概可以细分为三种：

- 简单工厂模式
- 工厂方法模式
- 抽象工厂模式
<a name="jkqmY"></a>
### 简单工厂模式
简单工厂模式，就跟名字一样，的确很简单。比如说，现在有个动物接口Animal，具体的实现有猫Cat、狗Dog等等，而每个具体的动物对象创建过程很复杂，有各种各样地步骤，此时就可以使用简单工厂来封装对象的创建过程，调用者不需要关心对象是如何具体创建的。
```java
public class SimpleAnimalFactory {

    public Animal createAnimal(String animalType) {
        if ("cat".equals(animalType)) {
            Cat cat = new Cat();
            //一系列复杂操作
            return cat;
        } else if ("dog".equals(animalType)) {
            Dog dog = new Dog();
            //一系列复杂操作
            return dog;
        } else {
            throw new RuntimeException("animalType=" + animalType + "无法创建对应对象");
        }
    }

}
```
当需要使用这些对象，调用者就可以直接通过简单工厂创建就行。
```java
SimpleAnimalFactory animalFactory = new SimpleAnimalFactory();
Animal cat = animalFactory.createAnimal("cat");
```
需要注意的是，一般来说如果每个动物对象的创建只需要简单地`new`一下就行了，那么其实就无需使用工厂模式，工厂模式适合对象创建过程复杂的场景。
<a name="CGTrG"></a>
### 工厂方法模式
上面说的简单工厂模式看起来没啥问题，但是还是违反了七大设计原则的OCP原则，也就是开闭原则。所谓的开闭原则就是对修改关闭，对扩展开放。<br />什么叫对修改关闭？就是尽可能不修改的意思。就拿上面的例子来说，如果现在新增了一种动物兔子，那么createAnimal方法就得修改，增加一种类型的判断，那么就此时就出现了修改代码的行为，也就违反了对修改关闭的原则。<br />所以解决简单工厂模式违反开闭原则的问题，就可以使用工厂方法模式来解决。
```java
/**
 * 工厂接口
 */
public interface AnimalFactory {
    Animal createAnimal();
}

/**
 * 小猫实现
 */
public class CatFactory implements AnimalFactory {
    @Override
    public Animal createAnimal() {
        Cat cat = new Cat();
        //一系列复杂操作
        return cat;
    }
}

/**
 * 小狗实现
 */
public class DogFactory implements AnimalFactory {
    @Override
    public Animal createAnimal() {
        Dog dog = new Dog();
        //一系列复杂操作
        return dog;
    }
}
```
这种方式就是工厂方法模式。他将动物工厂提取成一个接口`AnimalFactory`，具体每个动物都各自实现这个接口，每种动物都有各自的创建工厂，如果调用者需要创建动物，就可以通过各自的工厂来实现。
```java
AnimalFactory animalFactory = new CatFactory();
Animal cat = animalFactory.createAnimal();
```
此时假设需要新增一个动物兔子，那么只需要实现`AnimalFactory`接口就行，对于原来的猫和狗的实现，其实代码是不需要修改的，遵守了对修改关闭的原则，同时由于是对扩展开放，实现接口就是扩展的意思，那么也就符合扩展开放的原则。
<a name="rtmyo"></a>
### 抽象工厂模式
工厂方法模式其实是创建一个产品的工厂，比如上面的例子中，`AnimalFactory`其实只创建动物这一个产品。而抽象工厂模式特点就是创建一系列产品，比如说，不同的动物吃的东西是不一样的，那么就可以加入食物这个产品，通过抽象工厂模式来实现。
```java
public interface AnimalFactory {

    Animal createAnimal();

    Food createFood();

}
```
在动物工厂中，新增了创建食物的接口，小狗小猫的工厂去实现这个接口，创建狗粮和猫粮，这里就不去写了。
<a name="CIwK5"></a>
#### 1、工厂模式在Mybatis的运用
在Mybatis中，当需要调用`Mapper`接口执行sql的时候，需要先获取到`SqlSession`，通过`SqlSession`再获取到`Mapper`接口的动态代理对象，而`SqlSession`的构造过程比较复杂，所以就提供了`SqlSessionFactory`工厂类来封装`SqlSession`的创建过程。<br />![SqlSessionFactory及默认实现DefaultSqlSessionFactory](https://cdn.nlark.com/yuque/0/2022/png/396745/1668691536935-1ebce21e-ceed-4599-a68e-9ad74e66f2a9.png#averageHue=%23302d2c&clientId=ua26e412b-61b7-4&from=paste&id=ue2349e22&originHeight=746&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=ua7df8d64-06e0-49f6-974d-fbe938be44f&title=SqlSessionFactory%E5%8F%8A%E9%BB%98%E8%AE%A4%E5%AE%9E%E7%8E%B0DefaultSqlSessionFactory "SqlSessionFactory及默认实现DefaultSqlSessionFactory")<br />对于使用者来说，只需要通过`SqlSessionFactory`来获取到`SqlSession`，而无需关心`SqlSession`是如何创建的。
<a name="cJaSc"></a>
#### 2、工厂模式在Spring中的运用
Spring中的Bean是通过`BeanFactory`创建的。<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1668691536855-342139f7-9b56-484e-8190-9c36d058e9e7.png#averageHue=%2330302f&clientId=ua26e412b-61b7-4&from=paste&id=ub8dc6475&originHeight=409&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u5354c918-ffc5-4739-a10d-dca9c944081&title=)<br />BeanFactory就是Bean生成的工厂。一个Spring Bean在生成过程中会经历复杂的一个生命周期，而这些生命周期对于使用者来说是无需关心的，所以就可以将Bean创建过程的逻辑给封装起来，提取出一个Bean的工厂。
<a name="PpGib"></a>
## 策略模式
策略模式也比较常见，就比如说在Spring源码中就有很多地方都使用到了策略模式。<br />在讲策略模式是什么之前先来举个例子，假设现在有一个需求，需要将消息推送到不同的平台。<br />最简单的做法其实就是使用if else来做判断就行了。
```java
public void notifyMessage(User user, String content, int notifyType) {
    if (notifyType == 0) {
        //调用短信通知的api发送短信
    } else if (notifyType == 1) {
        //调用app通知的api发送消息
    }
}
```
根据不同的平台类型进行判断，调用对应的api发送消息。<br />虽然这样能实现功能，但是跟上面的提到的简单工厂的问题是一样的，同样违反了开闭原则。当需要增加一种平台类型，比如邮件通知，那么就得修改notifyMessage的方法，再次进行else if的判断，然后调用发送邮件的邮件发送消息。<br />此时就可以使用策略模式来优化了。<br />首先设计一个策略接口：
```java
public interface MessageNotifier {

    /**
     * 是否支持改类型的通知的方式
     *
     * @param notifyType 0:短信 1:app
     * @return
     */
    boolean support(int notifyType);

    /**
     * 通知
     *
     * @param user
     * @param content
     */
    void notify(User user, String content);

}
```
短信通知实现：
```java
@Component
public class SMSMessageNotifier implements MessageNotifier {
    @Override
    public boolean support(int notifyType) {
        return notifyType == 0;
    }

    @Override
    public void notify(User user, String content) {
        //调用短信通知的api发送短信
    }
}
```
app通知实现：
```java
public class AppMessageNotifier implements MessageNotifier {
    @Override
    public boolean support(int notifyType) {
        return notifyType == 1;
    }

    @Override
    public void notify(User user, String content) {
       //调用通知app通知的api
    }
}
```
最后`notifyMessage`的实现只需要要循环调用所有的`MessageNotifier`的`support`方法，一旦`support`方法返回`true`，说明当前`MessageNotifier`支持该类的消息发送，最后再调用`notify`发送消息就可以了。
```java
@Resource
private List<MessageNotifier> messageNotifiers;

public void notifyMessage(User user, String content, int notifyType) {
    for (MessageNotifier messageNotifier : messageNotifiers) {
        if (messageNotifier.support(notifyType)) {
            messageNotifier.notify(user, content);
        }
    }
}
```
那么如果现在需要支持通过邮件通知，只需要实现`MessageNotifier`接口，注入到Spring容器就行，其余的代码根本不需要有任何变动。<br />到这其实可以更好的理解策略模式了。就拿上面举的例子来说，短信通知，app通知等其实都是发送消息一种策略，而策略模式就是需要将这些策略进行封装，抽取共性，使这些策略之间相互替换。
<a name="py2MF"></a>
### 策略模式在SpringMVC中的运用
<a name="GJqh3"></a>
#### 1、对接口方法参数的处理
比如说，经常在写接口的时候，会使用到了`@PathVariable`、`@RequestParam`、`@RequestBody`等注解，一旦使用了注解，SpringMVC会处理注解，从请求中获取到参数，然后再调用接口传递过来，而这个过程，就使用到了策略模式。<br />对于这类参数的解析，SpringMVC提供了一个策略接口`HandlerMethodArgumentResolver`<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1668691537225-e94d64c7-c7c5-437e-8924-40aeb983e231.png#averageHue=%232c2b2b&clientId=ua26e412b-61b7-4&from=paste&id=gEn1j&originHeight=603&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ue0e5e90a-ba70-4980-b2be-bd80c1e31af&title=)<br />HandlerMethodArgumentResolver<br />这个接口的定义就跟上面定义的差不多，不同的参数处理只需要实现这个解决就行，比如上面提到的几个注解，都有对应的实现。<br />比如处理`@RequestParam`注解的`RequestParamMethodArgumentResolver`的实现。<br />![RequestParamMethodArgumentResolver](https://cdn.nlark.com/yuque/0/2022/png/396745/1668691537514-ea8553e0-7ebf-4e1f-a027-00631feee85d.png#averageHue=%232c2b2b&clientId=ua26e412b-61b7-4&from=paste&id=u2b2ac627&originHeight=453&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=uc3942dc4-466f-4750-9d4c-622f4612573&title=RequestParamMethodArgumentResolver "RequestParamMethodArgumentResolver")<br />当然还有其它很多的实现，如果想知道各种注解处理的过程，只需要找到对应的实现类就行了。
<a name="g6sp3"></a>
#### 2、对接口返回值的处理
同样，SpringMVC对于返回值的处理也是基于策略模式来实现的。<br />![HandlerMethodReturnValueHandler](https://cdn.nlark.com/yuque/0/2022/png/396745/1668691537567-52183acf-6287-4b00-8475-b5111422c898.png#averageHue=%232c2b2b&clientId=ua26e412b-61b7-4&from=paste&id=u3e120a7f&originHeight=563&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=ub954edd9-dd76-44ea-a970-6dda8d357b7&title=HandlerMethodReturnValueHandler "HandlerMethodReturnValueHandler")<br />`HandlerMethodReturnValueHandler`接口定义跟上面都是同一种套路。<br />比如说，常见的对于`@ResponseBody`注解处理的实现`RequestResponseBodyMethodProcessor`。<br />![ResponseBody注解处理的实现RequestResponseBodyMethodProcessor](https://cdn.nlark.com/yuque/0/2022/png/396745/1668691537508-b4cb60e1-7856-4c90-81d3-920c92fbba69.png#averageHue=%232c2b2b&clientId=ua26e412b-61b7-4&from=paste&id=u4a52e553&originHeight=213&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=ue5cea556-5744-46cc-812d-9eb3d1d58b6&title=ResponseBody%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0RequestResponseBodyMethodProcessor "ResponseBody注解处理的实现RequestResponseBodyMethodProcessor")<br />同样，`HandlerMethodReturnValueHandler`的实现也有很多，这里就不再举例了。<br />策略模式在Spring的运用远不止这两处，对于配置文件的加载`PropertySourceLoader`也是策略模式的运用。
<a name="tOHbP"></a>
## 模板方法模式
模板方法模式是指，在父类中定义一个操作中的框架，而操作步骤的具体实现交由子类做。其核心思想就是，对于功能实现的顺序步骤是一定的，但是具体每一步如何实现交由子类决定。<br />比如说，对于旅游来说，一般有以下几个步骤：

- 做攻略，选择目的地
- 收拾行李
- 乘坐交通工具去目的地
- 玩耍、拍照
- 乘坐交通工具去返回

但是对于去哪，收拾什么东西都，乘坐什么交通工具，都是由具体某个旅行来决定。<br />那么对于旅游这个过程使用模板方法模式翻译成代码如下：
```java
public abstract class Travel {

    public void travel() {
        //做攻略
        makePlan();

        //收拾行李
        packUp();

        //去目的地
        toDestination();

        //玩耍、拍照
        play();

        //乘坐交通工具去返回
        backHome();
    }

    protected abstract void makePlan();

    protected abstract void packUp();

    protected abstract void toDestination();

    protected abstract void play();

    protected abstract void backHome();

}
```
对于某次旅行来说，只需要重写每个步骤该做的事就行，比如说这次可以选择去杭州西湖，下次可以去长城，但是对于旅行过程来说是不变了，对于调用者来说，只需要调用暴露的`travel`方法就行。<br />可能这说的还是比较抽象，再举两个模板方法模式在源码中实现的例子。
<a name="e5OW8"></a>
### 模板方法模式在源码中的使用
<a name="j12AF"></a>
#### 1、模板方法模式在`HashMap`中的使用
`HashMap`都很熟悉，可以通过`put`方法存元素，并且在元素添加成功之后，会调用一下`afterNodeInsertion`方法。<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1668691537530-0d0c58d9-4050-44e4-a079-ebfdf434859f.png#averageHue=%232d2b2b&clientId=ua26e412b-61b7-4&from=paste&id=ue646dc18&originHeight=801&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1b20b491-5044-4cc8-a487-d6d802c828b&title=)<br />而`afterNodeInsertion`其实是在HashMap中是空实现，什么事都没干。<br />![afterNodeInsertion](https://cdn.nlark.com/yuque/0/2022/png/396745/1668691537643-50dd24fa-9853-435a-a604-a12913079e90.png#averageHue=%233a312d&clientId=ua26e412b-61b7-4&from=paste&id=u3d34646c&originHeight=276&originWidth=932&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=u1ecf5a4f-c932-4975-8cdb-0c8c452791f&title=afterNodeInsertion "afterNodeInsertion")<br />这其实就是模板方法模式。HashMap定义了一个流程，那就是当元素成功添加之后会调用`afterNodeInsertion`，子类如果需要在元素添加之后做什么事，那么重写`afterNodeInsertion`就行。<br />正巧，JDK中的`LinkedHashMap`重写了这个方法。<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1668691538004-61169a28-0ce0-4a94-813e-f32f0c7f484e.png#averageHue=%23312d2c&clientId=ua26e412b-61b7-4&from=paste&id=u016a4680&originHeight=514&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u31a5edbe-860f-4177-8f52-c2bbd73a5c6&title=)<br />而这段代码主要干的一件事就是可能会移除最老的元素，至于到底会不会移除，得看if是否成立。<br />添加元素移除最老的元素，基于这种特性其实可以实现LRU算法，比如Mybatis的LruCache就是基于`LinkedHashMap`实现的，有兴趣的可以扒扒源码，这里就不再展开讲了。
<a name="kdVMq"></a>
#### 2、模板方法模式在Spring中的运用
都知道，在Spring中，`ApplicationContext`在使用之前需要调用一下`refresh`方法，而`refresh`方法就定义了整个容器刷新的执行流程代码。<br />![refresh方法部分截图](https://cdn.nlark.com/yuque/0/2022/png/396745/1668691537862-a96d18bf-05f8-4ca3-b764-520f6aabdd56.png#averageHue=%232d2d2d&clientId=ua26e412b-61b7-4&from=paste&id=u97660330&originHeight=974&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=u11f2df47-3cfb-4d6d-95a1-3ce4fecd499&title=refresh%E6%96%B9%E6%B3%95%E9%83%A8%E5%88%86%E6%88%AA%E5%9B%BE "refresh方法部分截图")<br />在整个刷新过程有一个`onRefresh`方法<br />![onRefresh方法](https://cdn.nlark.com/yuque/0/2022/png/396745/1668691537945-ebb3a116-a2ff-47ce-a574-ab70466434f3.png#averageHue=%232c2b2b&clientId=ua26e412b-61b7-4&from=paste&id=uc6fa1360&originHeight=348&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=uda0d22de-dc2d-431f-ae6d-9fd1f08a311&title=onRefresh%E6%96%B9%E6%B3%95 "onRefresh方法")<br />而`onRefresh`方法默认是没有做任何事，并且在注释上有清楚两个单词Template method，翻译过来就是模板方法的意思，所以`onRefresh`就是一个模板方法，并且方法内部的注释也表明了，这个方法是为了子类提供的。<br />在Web环境下，子类会重写这个方法，然后创建一个Web服务器。<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1668691538106-3e9fb6b6-7f1b-4b6e-88d0-55fdf85d107a.png#averageHue=%232d2b2b&clientId=ua26e412b-61b7-4&from=paste&id=u684f41e7&originHeight=347&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1a171d42-c538-43c0-8025-a12af913004&title=)
<a name="I0Myt"></a>
#### 3、模板方法模式在Mybatis中的使用
在Mybatis中，是使用`Executor`执行Sql的。<br />![Executor](https://cdn.nlark.com/yuque/0/2022/png/396745/1668691538315-6cf8e94f-3d85-4486-a76c-b99a62f409f8.png#averageHue=%232c2c2b&clientId=ua26e412b-61b7-4&from=paste&id=u1c28b1cf&originHeight=619&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=u5f41cdae-2562-491c-aac3-b8aa002a308&title=Executor "Executor")<br />而Mybatis一级缓存就在`Executor`的抽象实现中`BaseExecutor`实现的。如图所示，红圈就是一级缓存<br />![BaseExecutor](https://cdn.nlark.com/yuque/0/2022/png/396745/1668691538232-c5d1a52d-56cd-4278-b532-bc15d41e828b.png#averageHue=%232f2c2b&clientId=ua26e412b-61b7-4&from=paste&id=u9cb7bd51&originHeight=582&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=u85491165-b02f-44a6-934d-4b7b6edf29c&title=BaseExecutor "BaseExecutor")<br />比如在查询的时候，如果一级缓存有，那么就处理缓存的数据，没有的话就调用`queryFromDatabase`从数据库查<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1668691538325-97577ecd-0d11-46cf-8f46-9c0fae1dcb17.png#averageHue=%232d2b2b&clientId=ua26e412b-61b7-4&from=paste&id=u9dc23c99&originHeight=788&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u7c4f8066-6021-44a5-865c-9e89aae966c&title=)<br />`queryFromDatabase`会调用`doQuery`方法从数据库查数据，然后放入一级缓存中。<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1668691538520-957794e4-3b6f-404f-86c0-0ee689f07030.png#averageHue=%232f2b2b&clientId=ua26e412b-61b7-4&from=paste&id=u1237a1b7&originHeight=335&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u3d8066cc-6e49-45fc-89aa-71044ea957f&title=)<br />而`doQuery`是个抽象方法<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1668691538618-5285b002-b202-4cd0-999b-b76f74520fc8.png#averageHue=%232f2d2b&clientId=ua26e412b-61b7-4&from=paste&id=ucd442d07&originHeight=328&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u5a99907a-157d-4fb5-b8f4-c1a95c4448f&title=)<br />所以doQuery其实就是一个模板方法，需要子类真正实现从数据库中查询数据，所以这里就使用了模板方法模式。
<a name="gzzi0"></a>
## 责任链模式
在责任链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，由该链上的某一个对象或者某几个对象决定处理此请求，每个对象在整个处理过程中值扮演一个小小的角色。<br />举个例子，现在有个请假的审批流程，根据请假的人的级别审批到的领导不同，比如有有组长、主管、HR、分管经理等等。<br />先需要定义一个处理抽象类，抽象类有个下一个处理对象的引用，提供了抽象处理方法，还有一个对下一个处理对象的调用方法。
```java
public abstract class ApprovalHandler {

    /**
     * 责任链中的下一个处理对象
     */
    protected ApprovalHandler next;

    /**
     * 设置下一个处理对象
     *
     * @param approvalHandler
     */
    public void nextHandler(ApprovalHandler approvalHandler) {
        this.next = approvalHandler;
    }

    /**
     * 处理
     *
     * @param approvalContext
     */
    public abstract void approval(ApprovalContext approvalContext);

    /**
     * 调用下一个处理对象
     *
     * @param approvalContext
     */
    protected void invokeNext(ApprovalContext approvalContext) {
        if (next != null) {
            next.approval(approvalContext);
        }
    }

}
```
几种审批人的实现
```java
//组长审批实现
public class GroupLeaderApprovalHandler extends ApprovalHandler {
    @Override
    public void approval(ApprovalContext approvalContext) {
        System.out.println("组长审批");
        //调用下一个处理对象进行处理
        invokeNext(approvalContext);
    }
}

//主管审批实现
public class DirectorApprovalHandler extends ApprovalHandler {
    @Override
    public void approval(ApprovalContext approvalContext) {
        System.out.println("主管审批");
        //调用下一个处理对象进行处理
        invokeNext(approvalContext);
    }
}

//hr审批实现
public class HrApprovalHandler extends ApprovalHandler {
    @Override
    public void approval(ApprovalContext approvalContext) {
        System.out.println("hr审批");
        //调用下一个处理对象进行处理
        invokeNext(approvalContext);
    }
}
```
有了这几个实现之后，接下来就需要对对象进行组装，组成一个链条，比如在Spring中就可以这么玩。
```java
@Component
public class ApprovalHandlerChain {

    @Autowired
    private GroupLeaderApprovalHandler groupLeaderApprovalHandler;
    @Autowired
    private DirectorApprovalHandler directorApprovalHandler;
    @Autowired
    private HrApprovalHandler hrApprovalHandler;

    public ApprovalHandler getChain() {
        //组长处理完下一个处理对象是主管
        groupLeaderApprovalHandler.nextHandler(directorApprovalHandler);
        //主管处理完下一个处理对象是hr
        directorApprovalHandler.nextHandler(hrApprovalHandler);
        
        //返回组长，这样就从组长开始审批，一条链就完成了
        return groupLeaderApprovalHandler;
    }

}
```
之后对于调用方而言，只需要获取到链条，开始处理就行。<br />一旦后面出现需要增加或者减少审批人，只需要调整链条中的节点就行，对于调用者来说是无感知的。
<a name="F5oIw"></a>
### 责任链模式在开源项目中的使用
<a name="IWWNY"></a>
#### 1、在SpringMVC中的使用
在SpringMVC中，可以通过使用`HandlerInterceptor`对每个请求进行拦截。<br />![HandlerInterceptor](https://cdn.nlark.com/yuque/0/2022/png/396745/1668691538701-591b1b71-6120-4c16-bad4-3781ae1904e6.png#averageHue=%232f2e2e&clientId=ua26e412b-61b7-4&from=paste&id=u976ca7b7&originHeight=507&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=ua0c220ef-585c-4a70-abbb-c5df6d9b440&title=HandlerInterceptor "HandlerInterceptor")<br />而`HandlerInterceptor`其实就使用到了责任链模式，但是这种责任链模式的写法跟上面举的例子写法不太一样。<br />对于`HandlerInterceptor`的调用是在`HandlerExecutionChain`中完成的。<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1668691538729-6a71df6d-e529-467e-a0a4-1981cec50921.png#averageHue=%232c2b2b&clientId=ua26e412b-61b7-4&from=paste&id=u74502d06&originHeight=481&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u381b0361-65b4-4e71-882a-58224638771&title=)<br />比如说，对于请求处理前的拦截，就在是这样调用的。<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1668691538792-951a013e-61dc-484b-832f-ccc6b8102e1e.png#averageHue=%232c2b2b&clientId=ua26e412b-61b7-4&from=paste&id=u3694d5de&originHeight=424&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8e79e0b6-39a6-495e-9eb7-86cea4b9ce0&title=)<br />其实就是循环遍历每个`HandlerInterceptor`，调用`preHandle`方法。
<a name="UIOXc"></a>
#### 2、在Sentinel中的使用
Sentinel是阿里开源的一个流量治理组件，而Sentinel核心逻辑的执行其实就是一条责任链。<br />在Sentinel中，有个核心抽象类`AbstractLinkedProcessorSlot`<br />![AbstractLinkedProcessorSlot](https://cdn.nlark.com/yuque/0/2022/png/396745/1668691538827-78569121-61ab-44ff-b67c-869aa23274c2.png#averageHue=%232d2c2b&clientId=ua26e412b-61b7-4&from=paste&id=u8e889621&originHeight=458&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=u3c88e466-5b6a-4eb3-a523-78bb7d12a37&title=AbstractLinkedProcessorSlot "AbstractLinkedProcessorSlot")<br />这个组件内部也维护了下一个节点对象，这个类扮演的角色跟例子中的`ApprovalHandler`类是一样的，写法也比较相似。这个组件有很多实现<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1668691539073-e5907866-c144-4836-91c7-e29eafd398d5.png#averageHue=%23515c56&clientId=ua26e412b-61b7-4&from=paste&id=u89eba435&originHeight=461&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u79b7f1c3-c399-47c1-9237-dc7725c5798&title=)<br />比如有比较核心的几个实现

- `DegradeSlot`：熔断降级的实现
- `FlowSlot`：流量控制的实现
- `StatisticSlot`：统计的实现，比如统计请求成功的次数、异常次数，为限流提供数据来源
- `SystemSlot`：根据系统规则来进行流量控制

整个链条的组装的实现是由`DefaultSlotChainBuilder`实现的<br />![DefaultSlotChainBuilder](https://cdn.nlark.com/yuque/0/2022/png/396745/1668691539159-474b00f2-0d4b-4b75-ace2-3e1342ed184e.png#averageHue=%232c2b2b&clientId=ua26e412b-61b7-4&from=paste&id=u587ced07&originHeight=488&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=ud4c9a298-414d-4f6e-a875-f884a8613d3&title=DefaultSlotChainBuilder "DefaultSlotChainBuilder")<br />并且内部是使用了SPI机制来加载每个处理节点<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1668691539159-7b24063c-59a1-41ec-9392-6b66c754848e.png#averageHue=%23393b3d&clientId=ua26e412b-61b7-4&from=paste&id=u42fd2c68&originHeight=438&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u4e09f2de-4048-4fba-8abd-b8663809eb5&title=)<br />所以，如果想自定一些处理逻辑，就可以基于SPI机制来扩展。<br />除了上面的例子，比如Gateway网关、Dubbo、MyBatis等等框架中都有责任链模式的身影，所以责任链模式使用的还是比较多的。
<a name="tXseh"></a>
## 代理模式
代理模式也是开源项目中很常见的使用的一种设计模式，这种模式可以在不改变原有代码的情况下增加功能。<br />举个例子，比如现在有个`PersonService`接口和它的实现类`PersonServiceImpl`
```java
//接口
public interface PersonService {

    void savePerson(PersonDTO person);

}

//实现
public class PersonServiceImpl implements PersonService{
    @Override
    public void savePerson(PersonDTO person) {
        //保存人员信息
    }
}
```
这个类刚开始运行的好好的，但是突然之前不知道咋回事了，有报错，需要追寻入参，所以此时就可以这么写。
```java
public class PersonServiceImpl implements PersonService {
    @Override
    public void savePerson(PersonDTO person) {
        log.info("savePerson接口入参:{}", JSON.toJSONString(person));
        //保存人员信息
    }
}
```
这么写，就修改了代码，万一以后不需要打印日志了呢，岂不是又要修改代码，不符和之前说的开闭原则，那么怎么写呢？可以这么玩。
```java
public class PersonServiceProxy implements PersonService {

    private final PersonService personService = new PersonServiceImpl();

    @Override
    public void savePerson(PersonDTO person) {
        log.info("savePerson接口入参:{}", JSON.toJSONString(person));
        personService.savePerson(person);
    }
}
```
可以实现一个代理类`PersonServiceProxy`，对`PersonServiceImpl`进行代理，这个代理类干的事就是打印日志，最后调用`PersonServiceImpl`进行人员信息的保存，这就是代理模式。<br />当需要打印日志就使用`PersonServiceProxy`，不需要打印日志就使用PersonServiceImpl，这样就行了，不需要改原有代码的实现。<br />讲到了代理模式，就不得不提一下Spring AOP，Spring AOP其实跟静态代理很像，最终其实也是调用目标对象的方法，只不过是动态生成的，这里就不展开讲解了。
<a name="YnmDK"></a>
### 代理模式在Mybtais中的使用
前面在说模板方法模式的时候，举了一个`BaseExecutor`使用到了模板方法模式的例子，并且在`BaseExecutor`这里面还完成了一级缓存的操作。<br />其实不光是一级缓存是通过`Executor`实现的，二级缓存其实也是，只不过不在`BaseExecutor`里面实现，而是在`CachingExecutor`中实现的。<br />![CachingExecutor](https://cdn.nlark.com/yuque/0/2022/png/396745/1668691539267-b8ff6703-6088-45ef-9c6c-86f3580179ce.png#averageHue=%232f2d2b&clientId=ua26e412b-61b7-4&from=paste&id=u588b12fb&originHeight=661&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=u9763571d-6671-4c1f-a5db-b0689d057b3&title=CachingExecutor "CachingExecutor")<br />`CachingExecutor`中内部有一个`Executor`类型的属性`delegate`，`delegate`单词的意思就是代理的意思，所以`CachingExecutor`显然就是一个代理类，这里就使用到了代理模式。<br />`CachingExecutor`的实现原理其实很简单，先从二级缓存查，查不到就通过被代理的对象查找数据，而被代理的Executor在Mybatis中默认使用的是`SimpleExecutor`实现，`SimpleExecutor`继承自`BaseExecutor`。<br />这里思考一下二级缓存为什么不像一级缓存一样直接写到`BaseExecutor`中？<br />这里猜测一下是为了减少耦合。<br />Mybatis的一级缓存默认是开启的，一级缓存写在`BaseExecutor`中的话，那么只要是继承了`BaseExecutor`，就拥有了一级缓存的能力。<br />但二级缓存默认是不开启的，如果写在`BaseExecutor`中，讲道理也是可以的，但不符和单一职责的原则，类的功能过多，同时会耦合很多判断代码，比如开启二级缓存走什么逻辑，不开启二级缓存走什么逻辑。而使用代理模式很好的解决了这一问题，只需要在创建的`Executor`的时候判断是否开启二级缓存，开启的话就用`CachingExecutor`代理一下，不开启的话老老实实返回未被代理的对象就行，默认是`SimpleExecutor`。<br />如图所示，是构建`Executor`对象的源码，一旦开启了二级缓存，就会将前面创建的`Executor`进行代理，构建一个`CachingExecutor`返回。<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1668691539672-64643a4e-b145-4abc-9711-627847cc85df.png#averageHue=%232e2c2b&clientId=ua26e412b-61b7-4&from=paste&id=u873c50d4&originHeight=589&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u4de290ee-0d63-4c65-babb-c1d6466b491&title=)
<a name="tFFio"></a>
## 适配器模式
适配器模式使得原本由于接口不兼容而不能一起工作的哪些类可以一起工作，将一个类的接口转换成客户希望的另一个接口。<br />举个生活中的例子，比如手机充电器接口类型有USB TypeC接口和Micro USB接口等。现在需要给一个Micro USB接口的手机充电，但是现在只有USB TypeC接口的充电器，这怎么办呢？<br />其实一般可以弄个一个USB TypeC转Micro USB接口的转接头，这样就可以给Micro USB接口手机充电了，代码如下<br />USBTypeC接口充电
```java
public class USBTypeC {

    public void chargeTypeC() {
        System.out.println("开启充电了");
    }

}
```
MicroUSB接口
```java
public interface MicroUSB {

    void charge();

}
```
适配实现，最后是调用USBTypeC接口来充电
```java
public class MicroUSBAdapter implements MicroUSB {

    private final USBTypeC usbTypeC = new USBTypeC();

    @Override
    public void charge() {
        //使用usb来充电
        usbTypeC.chargeTypeC();
    }

}
```
方然除了上面这种写法，还有一种继承的写法。
```java
public class MicroUSBAdapter extends USBTypeC implements MicroUSB {

    @Override
    public void charge() {
        //使用usb来充电
        this.chargeTypeC();
    }

}
```
这两种写法主要是继承和组合（聚合）的区别。<br />这样就可以通过适配器（转接头）就可以实现USBTypeC给MicroUSB接口充电。
<a name="fTJJ1"></a>
### 适配器模式在日志中的使用
在日常开发中，日志是必不可少的，可以帮助我们快速快速定位问题，但是日志框架比较多，比如Slf4j、Log4j等等，一般同一系统都使用一种日志框架。<br />但是像Mybatis这种框架来说，它本身在运行的过程中也需要产生日志，但是Mybatis框架在设计的时候，无法知道项目中具体使用的是什么日志框架，所以只能适配各种日志框架，项目中使用什么框架，Mybatis就使用什么框架。<br />为此Mybatis提供一个Log接口<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1668691539703-e562905a-5a4c-4120-a699-a06919d98b89.png#averageHue=%232d2c2b&clientId=ua26e412b-61b7-4&from=paste&id=uf81a9730&originHeight=836&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u95fbe81c-370e-4a28-9455-0db5760ed1f&title=)<br />而不同的日志框架，只需要适配这个接口就可以了<br />![Slf4jLoggerImpl](https://cdn.nlark.com/yuque/0/2022/png/396745/1668691539695-b8871974-a0b4-4e96-90cb-a774cafae059.png#averageHue=%232f2d2b&clientId=ua26e412b-61b7-4&from=paste&id=u19612269&originHeight=790&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=u504d426b-5f01-4d71-bc75-b220b8ac026&title=Slf4jLoggerImpl "Slf4jLoggerImpl")<br />就拿Slf4j的实现来看，内部依赖了一个Slf4j框架中的Logger对象，最后所有日志的打印都是通过Slf4j框架中的Logger对象来实现的。<br />此外，Mybatis还提供了如下的一些实现<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1668691539697-2b9eb943-2e83-4099-b512-b563645b6cf9.png#averageHue=%23545047&clientId=ua26e412b-61b7-4&from=paste&id=ucc1254d7&originHeight=429&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ub2de99ab-3445-4919-ae6a-fc498623804&title=)<br />这样，Mybatis在需要打印日志的时候，只需要从Mybatis自己的`LogFactory`中获取到Log对象就行，至于最终获取到的是什么Log实现，由最终项目中使用日志框架来决定。<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1668691540059-75c8f5e0-7132-40e0-bfd6-f1d4d3a1a6a4.png#averageHue=%232b2b2b&clientId=ua26e412b-61b7-4&from=paste&id=ub04f7f24&originHeight=692&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ud19d044e-43da-4f71-a917-99a58ea5170&title=)
<a name="HwRgJ"></a>
## 观察者模式
当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知依赖它的对象。<br />这是什么意思呢，举个例子来说，假设发生了火灾，可能需要打119、救人，那么就可以基于观察者模式来实现，打119、救人的操作只需要观察火灾的发生，一旦发生，就触发相应的逻辑。<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1668691539989-9be26cca-99f6-469f-afee-50990126400e.png#averageHue=%23f6f5f0&clientId=ua26e412b-61b7-4&from=paste&id=u961240bc&originHeight=450&originWidth=808&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua28e39d6-d5d3-445c-8b3a-ebd0cb476d3&title=)<br />观察者的核心优点就是观察者和被观察者是解耦合的。就拿上面的例子来说，火灾事件（被观察者）根本不关系有几个监听器（观察者），当以后需要有变动，只需要扩展监听器就行，对于事件的发布者和其它监听器是无需做任何改变的。<br />观察者模式实现起来比较复杂，这里举一下Spring事件的例子来说明一下。
<a name="MdjPH"></a>
### 观察者模式在Spring事件中的运用
Spring事件，就是Spring基于观察者模式实现的一套API。<br />Spring事件的实现比较简单，其实就是当Bean在生成完成之后，会将所有的`ApplicationListener`接口实现（监听器）添加到`ApplicationEventMulticaster`中。<br />`ApplicationEventMulticaster`可以理解为一个调度中心的作用，可以将事件通知给监听器，触发监听器的执行。<br />![ApplicationEventMulticaster可以理解为一个总线](https://cdn.nlark.com/yuque/0/2022/png/396745/1668691540187-13a87962-0f91-4547-b3d4-fae163474793.png#averageHue=%232f2c2b&clientId=ua26e412b-61b7-4&from=paste&id=u1636a72d&originHeight=456&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=ua28cbc18-b68d-4f0b-b74d-f8f4cc6c31f&title=ApplicationEventMulticaster%E5%8F%AF%E4%BB%A5%E7%90%86%E8%A7%A3%E4%B8%BA%E4%B8%80%E4%B8%AA%E6%80%BB%E7%BA%BF "ApplicationEventMulticaster可以理解为一个总线")<br />`retrieverCache`中存储了事件类型和对应监听器的缓存。当发布事件的时候，会通过事件的类型找到对应的监听器，然后循环调用监听器。<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1668691540054-81892887-80dd-47f9-935b-e141aed52156.png#averageHue=%232f2c2b&clientId=ua26e412b-61b7-4&from=paste&id=u2948ad39&originHeight=363&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ubd45feac-7a7f-49e4-aba4-234645bf673&title=)<br />所以，Spring的观察者模式实现的其实也不复杂。
<a name="pbwSU"></a>
## 总结
这里通过对设计模式的讲解加源码举例的方式介绍了9种在代码设计中常用的设计模式：

- 单例模式
- 建造者模式
- 工厂模式
- 策略模式
- 模板方法模式
- 责任链模式
- 代理模式
- 适配器模式
- 观察者模式

其实这些设计模式不仅在源码中常见在平时工作中也是可以经常使用到的。<br />设计模式其实还是一种思想，或者是套路性的东西，至于设计模式具体怎么用、如何用、代码如何写还得依靠具体的场景来进行灵活的判断。
