JavaSpringMybatis<br />如果对Spring框架足够熟悉，整合MyBatis其实很容易理解，当然这里假定大家已经熟悉了MyBatis框架。<br />在正常的应用开发过程中，使用MyBatis一般分为如下几个步骤：

1. 在配置类上增加MapperScan注解，例如：`@MapperScan(basePackages = {"com.test.dao"},annotationClass = Mapper.class);`
2. 在basePackages指定的目录下创建待MyBatis读取的接口文件，例如：
```java
@Mapper
public interface TestMapper {
	......
}
```

3. 在Service或者其他地方使用该Mapper来操作数据库。

使用起来是很简单的，但是大家有没有想过，为什么做了这么一个简单的配置，这个Mapper就能操作数据库了？按理说这个Mapper是个接口，应该是不能被创建才对啊！如果你有这个疑问，证明你是个爱思考的好童鞋。<br />咱们直接进入主题。Spring要与MyBatis整合，简单来说只要解决如下两个问题：
<a name="QbZkd"></a>
## Spring如何知道哪些类应该被管理？
要让Spring去管理Bean的生命周期，首先需要对应的类被Spring扫描到，并且生成`DeanDefinition`，然后基于`BeanDefinition`生成Bean。下面对Spring生成`BeanDefinition`的方式做个小总结：

- 包含`Component`、`Configuration`、`ComponentScan`、`Import`、`ImportResource`注解的类；
- `Import`注解中指定的类、被`Bean`注解标注的方法所在的类；
- 实现了`ImportBeanDefinitionRegistrar`接口，并且在`registerBeanDefinitions`方法中调用`registry`直接注册的类；
- 实现了`ImportSelector`接口，并且在`selectImports`方法中返回的字符串对应的类；
- 直接调用`register`方法；
- 另外Spring还提供了一个扩展，可以让开发者自己指定需要被管理的类对应的类型：通过往`includeFilters`中添加注解类类型。

分析源码，第一步得找到它的入口，Spring整合MyBatis的入口，毫无疑问是`MapperScan`这个注解，在`MapperScan`注解上包含`Import(MapperScannerRegistrar.class)`注解，Spring整合MyBatis正是用了`Import`和`ImportBeanDefinitionRegistrar`的方式。先通过一张流程图来了解下整体流程，然后再慢慢品。<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1668430412496-6de1c350-2350-4e0f-9b3f-27af8ed1dae9.png#averageHue=%23ededed&clientId=uaa0cf9eb-d29b-4&from=paste&id=ub1e42f32&originHeight=303&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8e875e60-aed2-4282-a8fc-acaf7cef520&title=)<br />来看`MapperScannerRegistrar`这个类的继承关系图：<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1668430412475-5ef4ebbd-e020-43a7-8a17-4901f1c772e0.png#averageHue=%232d2d2d&clientId=uaa0cf9eb-d29b-4&from=paste&id=u789a3e5c&originHeight=632&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=udd083ce8-6730-4b0e-87e1-30c1b578f57&title=)<br />`MapperScannerRegistrar`是`ImportBeanDefinitionRegistrar`的实现类，Spring会去调用这个类的`registerBeanDefinitions`方法添加`beanDefinition`，这个方法中具体做了些什么呢：

- 获取`MapperScan`注解的配置信息，比如`basePackages`、`annotationClass`，`basePackages`表示需要扫描的路径，`annotationClass`则是指定了增加了这种注解类的类需要被Spring进行管理，比如增加了Mapper注解的类需要被Spring管理。
- 生成`MapperScannerConfigurer`这个类型的`beanDefinition`，并且把`MapperScan`注解的配置信息添加到该`beanDefinition`的属性集合中。

后续Spring就会基于这个`MapperScannerConfigurer`做一系列文章，看下它的继承关系：<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1668430412411-bcec343e-287f-4dff-9089-8cd1e6d60641.png#averageHue=%232d2d2d&clientId=uaa0cf9eb-d29b-4&from=paste&id=u055a0f85&originHeight=349&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ubfe26bd2-044b-4c68-adee-fca208954f8&title=)<br />它是`BeanDefinitionRegistryPostProcessor`的实现类，是一个`BeanFactory`后置处理器，Spring会调用该类的`postProcessBeanDefinitionRegistry`方法来添加`beanDefinition`的操作，`MapperScannerConfigurer`这个类中具体实现如下：<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1668430412389-e5407213-7702-45b2-af64-0af383cdbd54.png#averageHue=%232e2d2c&clientId=uaa0cf9eb-d29b-4&from=paste&id=u2697a8b2&originHeight=519&originWidth=966&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u610b15d6-5df5-440f-9a9a-341cfe82805&title=)<br />它定义了`ClassPathMapperScanner`这个扫描器，然后使用这个扫描器来扫描类，扫描哪些类呢？扫描有`Mapper`注解的类，看它的关系知道，它是`ClassPathBeanDefinitionScanner`的子类，而spring则是使用`ClassPathBeanDefinitionScanner`来进行扫描的。<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1668430412715-54b24d6b-6a88-4134-967f-40e52f780acd.png#averageHue=%232f2f2e&clientId=uaa0cf9eb-d29b-4&from=paste&id=u3f0b6fbf&originHeight=760&originWidth=952&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u92d6c508-4750-4044-89aa-4d3d4712edd&title=)<br />为什么`ClassPathMapperScanner`能够扫描到带有`Mapper`注解的类呢？看上面代码，就是通过调用`registerFilters`方法来添加`includeFilter`（实际类型是：`TypeFilter`），这个就是Spring提供的扩展点，让开发者自己来指定需要被扫描的类，这里使用的是`MappScan`注解中`annotationClass`属性配置的注解类型，这里配置了Mapper，所以调用scan方法开启扫描后，Spring就会将包含Mapper注解的类扫描为`BeanDefinition`。注意这里的扫描能力还是调用Spring的扫描器来实现的，`ClassPathMapperScanner`并没有修改，只是当扫描完成后，`ClassPathMapperScanner`会对扫描出的`BeanDefinition`进行重新处理，主要是把原来的BeanClass修改成了`MapperFactoryBean.class`：<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1668430412812-99cd89b4-88f5-4dbe-b042-caeefa022042.png#averageHue=%23322c2b&clientId=uaa0cf9eb-d29b-4&from=paste&id=u7a6898f5&originHeight=383&originWidth=969&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1055127b-7a88-4fb3-ac0c-3fb35bd3165&title=)<br />而这个`MapperFactoryBean`是`FactoryBean`的实现类，`FactoryBean`这种Bean有什么特点？这个可是面试的高发点。<br />**做个小小的总结：**Spring扫描到有Mapper注解的类，生成`BeanDefinition`，并且将这一类`BeanDefinition`的`BeanClass`的值修改为`MapperFactoryBean`，也就是说它的类型不再是自己编写的`Mapper`接口了，而是一个`FactoryBean`，这样Spring就能做妖了。
<a name="Pnvki"></a>
## Mapper注解的类是接口，那如何实例化呢？
到这一步，其实大家也大概清楚了，Spring在实例化`Mapper`实例时，实际上首先会实例化`MapperFactoryBean`，然后再调用它的`getObject`方法。都知道在Java里面接口是肯定不能被实例化的，那这个被实例化的对象只能是一个代理对象，所以有理由猜想这个`getObject`方法应该是用来创建代理对象的。要创建代理对象，得从以下两个方面着手：
<a name="rMyHH"></a>
### 准备工作
这里Spring准备的是接口类型和创建代理对象的代理工厂。具体如何准备的呢？来看上述`MapperFactoryBean`类型的整体继承关系：<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1668430412893-478a5dee-59c6-4a6b-ba60-952696afc3f3.png#averageHue=%232e2e2e&clientId=uaa0cf9eb-d29b-4&from=paste&id=u42124239&originHeight=640&originWidth=894&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u09c9ffb5-7871-4d5f-a62d-a4229d03afe&title=)<br />它实现了`InitializingBean`，于是可以知道，在`MapperFactoryBean`初始化完成后，Spring会调用它的`afterPropertiesSet`方法，从而会执行到`checkDaoConfig`方法：<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1668430413046-6990e6a1-ca17-432b-a871-6ff721521e0b.png#averageHue=%232e2c2b&clientId=uaa0cf9eb-d29b-4&from=paste&id=ua8044389&originHeight=380&originWidth=759&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u4084a829-f13e-4ff5-a0b4-ac2c0470124&title=)<br />在该方法中调用`configuration`的`addMapper`方法，这个方法里面到底做了啥？<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1668430413226-8a55b347-1d75-4e85-9c7e-02fd7e173394.png#averageHue=%232e2d2c&clientId=uaa0cf9eb-d29b-4&from=paste&id=u486e9729&originHeight=579&originWidth=792&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ubf3dfd1b-9449-4185-bcb5-a5fc4264d11&title=)<br />看出门道了吗？其实就是使用`Mapper`的接口类型作为key，`MapperProxyFactory`做为value，然后添加到`mapperRegistry`对象的Map集合中，注意这个type同时也是`MapperProxyFactory`对象的构造参数哦。
<a name="bIWRV"></a>
### 实例化
上述动作已经准备好了，接下来就应该是创建了。Spring在创建完成`MapperFactoryBean`对象后，最终会调用它的`getObject`方法来获得真实的对象：<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1668430413135-013d49fe-a7f2-42bf-8be5-f5e5269dd958.png#averageHue=%23575240&clientId=uaa0cf9eb-d29b-4&from=paste&id=u9ded4167&originHeight=282&originWidth=589&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u4b484021-b58d-4191-b6f6-65512345083&title=)<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1668430413402-67d030a2-b053-4f25-8fd5-513e26828c26.png#averageHue=%23302f2d&clientId=uaa0cf9eb-d29b-4&from=paste&id=ue618174a&originHeight=87&originWidth=511&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u0e167364-242b-42e8-84d2-11e2a08357c&title=)<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1668430413523-39a632c4-4f39-4322-acb2-a462e6cb65d3.png#averageHue=%232f2c2b&clientId=uaa0cf9eb-d29b-4&from=paste&id=u683cf05d&originHeight=255&originWidth=827&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u5288f604-eeba-465c-b6dd-dacc1c34d79&title=)<br />`getObject`方法中，会调用`getMapper`方法，该方法中从`knowMappers`这个Map集合中拿到`MapperProxyFactory`对象，这个对象不就是在准备阶段添加的嘛！它就是用来创建代理对象的工厂。<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1668430413569-f116231a-d7d9-406a-8596-4a0275c5863b.png#averageHue=%23302c2b&clientId=uaa0cf9eb-d29b-4&from=paste&id=ua95846e2&originHeight=192&originWidth=949&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u204fc2d1-688e-4afa-bba5-8a6914fb43d&title=)<br />从上面代码中也不难看出，确实是为开发者自己的接口创建了代理对象，而代理类的处理类则是`MapperProxy`对象，也就是说对所有接口对象的调用，都会进入`MapperProxy`的`Invoke`方法，至此Spring成功对接MyBatis。
