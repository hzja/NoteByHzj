JavaSpringCloud<br />一起来看看SpringCloud配置中心的核心原理。在刚开始使用SpringCloud配置中心的时候是否有很多的疑惑：

- SpringCloud是什么时候去拉取配置中心的？
- 配置中心客户端的配置信息为什么要写在bootstrap文件中？
- 对象中注入的属性是如何动态刷新的？
- 一些开源的配置中心是如何整合SpringCloud的？
- ...

通过探讨上述问题来探秘SpringCloud配置中心核心的底层原理。
<a name="Gifib"></a>
## 从SpringBoot的启动过程说起
在SpringBoot启动的时候会经历一系列步骤，核心就是`SpringApplication`的`run`方法的逻辑<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1697776712714-fb6d84b0-47ff-4393-bbfd-9b8a6c8176c5.png#averageHue=%232b2b2b&clientId=ue073c610-3458-4&from=paste&id=ue5463312&originHeight=899&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u1bbb41de-9a8d-4a7a-9b9f-77e9c77079d&title=)<br />整个过程大致可以划分为三个阶段：<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1697776712705-66f7977c-b4bf-4be3-aaf3-7182f7730a84.png#averageHue=%23f0e7dd&clientId=ue073c610-3458-4&from=paste&id=u3a081037&originHeight=261&originWidth=121&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u6c1ecbf3-8281-4946-a884-253b9d9f2f9&title=)<br />`**ApplicationContext**`**刷新前阶段**，这个阶段主要也干三件事

- **准备**`**Environment**`（关键），也就是准备SpringBoot的整个外部化配置的对象
- 创建一个`ApplicationContext`
- 为`ApplicationContext`做一些准备工作

![](https://cdn.nlark.com/yuque/0/2023/png/396745/1697776712731-92f17bd9-c117-427d-8389-b0b2d93aa524.png#averageHue=%23362c2a&clientId=ue073c610-3458-4&from=paste&id=udaf05f7c&originHeight=363&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u670ee4fc-2b79-47db-8dce-2b51c940d86&title=)<br />`**ApplicationContext**`**刷新阶段**，这个阶段其实就是调用`ApplicationContext#refresh`方法来刷新容器<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1697776712684-73174a2e-443a-4dee-b869-4bbfb2f3f56c.png#averageHue=%232c2b2a&clientId=ue073c610-3458-4&from=paste&id=ua6d75f41&originHeight=401&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=udf84f8d6-d56e-4c29-9ea3-453a5d485a8&title=)**`**ApplicationContext**`**刷新后阶段**，这个阶段其实就是收尾的阶段，这个过程其实没有什么非常核心的事<br />在说完上面这三个阶段之后，思考一个问题<br />在上面的三个阶段，哪个阶段最有可能从配置中心拉取配置？<br />其实稍微思考一下，肯定是想到的就是刷新前阶段，**准备**`**Environment**`<br />为什么是这个阶段？<br />很好理解，因为这个阶段是准备`Environment`，也就是准备外部化配置<br />只需要在这个阶段加载配置中心的配置，放到`Environment`中，后面在整个`ApplicationContext`刷新阶段创建Bean的时候，就可以使用到配置中心的配置了<br />其实不光是配置中心的配置，比如配置文件的配置，也是在这里阶段读取的<br />至于如何实现的，接着往下看
<a name="m8qyv"></a>
## 准备`Environment`的核心操作
上一节得出一个结论<br />准备`Environment`，也就是`prepareEnvironment`方法的实现，是拉取配置的核心<br />![prepareEnvironment方法](https://cdn.nlark.com/yuque/0/2023/png/396745/1697776713111-251e0ed0-687d-40c6-8e43-5f5593708010.png#averageHue=%232c2b2b&clientId=ue073c610-3458-4&from=paste&id=udc42c30e&originHeight=427&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=udb0ca9de-d15e-4ba4-becd-a2d3c0de575&title=prepareEnvironment%E6%96%B9%E6%B3%95 "prepareEnvironment方法")<br />不过在说这个方法之前，先来讲一下一些前置操作
<a name="PfgMo"></a>
### 前置操作
在`SpringApplication`创建的时候，会去加载spring.factories中的一些对象，其中就包括：

- `org.springframework.context.ApplicationListener`键对应的`ApplicationListener`的实现

![](https://cdn.nlark.com/yuque/0/2023/png/396745/1697776713346-e44b7f1e-52a2-4e37-ac8e-5fb31892e262.png#averageHue=%23312c2b&clientId=ue073c610-3458-4&from=paste&id=u34b0604c&originHeight=316&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u63e6cabb-43d6-4246-acbd-88b22fd20ff&title=)

- `org.springframework.boot.SpringApplicationRunListener`键对应的`SpringApplicationRunListener`的实现类

![](https://cdn.nlark.com/yuque/0/2023/png/396745/1697776713598-40aa969a-4b9e-476b-a66b-fa185ff78424.png#averageHue=%23342d2b&clientId=ue073c610-3458-4&from=paste&id=ue7a744a3&originHeight=155&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=uf8ab59f6-38d6-4f33-8eb5-1411e4c8d11&title=)<br />`SpringApplicationRunListener`仅仅只有一个实现`EventPublishingRunListener`<br />![EventPublishingRunListener](https://cdn.nlark.com/yuque/0/2023/png/396745/1697776713710-a555346e-83ec-40d7-a1eb-67484d5b0587.png#averageHue=%23302c2b&clientId=ue073c610-3458-4&from=paste&id=u70674f51&originHeight=509&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=u0cc9ad94-6abf-42f7-8d07-806615cb18f&title=EventPublishingRunListener "EventPublishingRunListener")<br />构造的时候会创建一个`SimpleApplicationEventMulticaster`，再将加载的`ApplicationListener`添加进去<br />按照传统，画张图来理一下这部分前置操作<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1697776713909-ee74a0d6-0892-4500-95ed-0ea335987899.png#averageHue=%23302c25&clientId=ue073c610-3458-4&from=paste&id=u328a068c&originHeight=244&originWidth=491&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=ub2903cfa-1a70-4634-a097-c3679b56cbe&title=)
<a name="vBuV3"></a>
### `prepareEnvironment`的核心逻辑
接着来讲一下`prepareEnvironment`方法<br />![prepareEnvironment方法](https://cdn.nlark.com/yuque/0/2023/png/396745/1697776715220-e3bd1e28-8c47-4674-aaed-e343e153db08.png#averageHue=%23302c2b&clientId=ue073c610-3458-4&from=paste&id=ub63c7731&originHeight=419&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=u8bd350a8-ea2a-40c4-9759-c68f5471dcf&title=prepareEnvironment%E6%96%B9%E6%B3%95 "prepareEnvironment方法")<br />这个方法会首先创建一个`Environment`对象<br />之后会执行这么一行方法，传入刚刚创建的`Environment`对象
```java
listeners.environmentPrepared(environment);
```
这个方法最终会走到这个方法
```java
EventPublishingRunListener#environmentPrepared
```
![](https://cdn.nlark.com/yuque/0/2023/png/396745/1697776714190-3ef5e18a-c1c3-47dd-873a-bf8cccdaf274.png#averageHue=%23302c2b&clientId=ue073c610-3458-4&from=paste&id=u0976c891&originHeight=158&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=ubc3aa0a4-c0ec-4547-8135-ba40bae1c25&title=)<br />这个方法最终会发布一个`ApplicationEnvironmentPreparedEvent`事件<br />而对这个事件有两个特别重要的监听器：

- `ConfigFileApplicationListener`
- `BootstrapApplicationListener`

这些监听器都是通过前置操作从spring.factories配置文件中加载的<br />`ConfigFileApplicationListener`，用来处理配置文件的，他会解析配置文件的配置，放到`Environment`中<br />`BootstrapApplicationListener`这个跟本文探讨的主题相关了，它是用来专门来跟配置中心交互的<br />到这就找到了SpringCloud配置中心配置拉取的整个入口逻辑<br />不过在分析`BootstrapApplicationListener`是如何从配置中心拉取配置的之前，先来张图总结一下这部分`prepareEnvironment`的操作<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1697776714285-24fd2114-f64d-488f-8f50-2679721b8c1f.png#averageHue=%2326221e&clientId=ue073c610-3458-4&from=paste&id=uc89fd11d&originHeight=421&originWidth=750&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u3a3d94c6-ac1c-4666-b44a-5fcfe2aa520&title=)
<a name="M27ao"></a>
## SpringCloud是如何巧妙地拉取配置的？
在`BootstrapApplicationListener`中，他首先也会创建一个`SpringApplication`去执行<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1697776714465-25a7bf94-c0b2-483f-8579-4b496f2441fa.png#averageHue=%232f2c2b&clientId=ue073c610-3458-4&from=paste&id=u1e2027c7&originHeight=1108&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=ufd7d94b2-8b1b-444a-a8a5-3cca7bf67dc&title=)<br />其实本质上就是创建一个Spring容器，也就是`ApplicationContext`<br />这个容器非常重要，这个容器是专门用来跟配置中心交互的<br />这个容器在创建的时候会给它两个比较重要的配置<br />第一个就是设置这个容器所用的配置文件的名称<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1697776714544-60942325-68f8-4110-8909-a12950b19bc0.png#averageHue=%23804a38&clientId=ue073c610-3458-4&from=paste&id=ua8b12a0d&originHeight=468&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=ucdd2acbc-12b5-4ab9-a4e3-1fee845d108&title=)<br />默认就是bootstrap<br />这就解释了为什么配置中心的配置信息需要写在bootstrap配置文件中<br />第二个就是会加入一个配置类`BootstrapImportSelectorConfiguration`<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1697776714538-5d09ae13-39da-479c-a700-c636f12d0236.png#averageHue=%23332d2c&clientId=ue073c610-3458-4&from=paste&id=ubc2c651e&originHeight=377&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=ufdf73432-6491-4436-8ec2-bcf54abb7aa&title=)<br />这个配置类又会通过`@Import`注解导入另一个配置类`BootstrapImportSelector`<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1697776714854-408d1be7-4358-430d-9bc1-9ce5f4471513.png#averageHue=%232e2c2b&clientId=ue073c610-3458-4&from=paste&id=u6978eeb7&originHeight=804&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=uffea460f-0596-4b8f-a9e3-65012b8af48&title=)<br />`BootstrapImportSelector`实现了（间接）`ImportSelector`接口<br />那么这个容器在启动的时候，就会调用`BootstrapImportSelector`的`selectImports`方法的实现获取到一些配置类<br />而`BootstrapImportSelector`的`selectImports`实现从截图中也就可以看出<br />他会加载所有的spring.factories中的键为`org.springframework.cloud.bootstrap.BootstrapConfiguration`的配置类<br />其实这里`@BootstrapConfiguration`的作用其实跟`@EnableAutoConfiguration`的作用是差不多的，都是用来导入配置类的<br />所以，总的来说，这个用来跟配置中心交互的Spring容器最最主要就是干两件事：

- 加载bootstrap配置文件
- 加载所有的spring.factories中的键为`org.springframework.cloud.bootstrap.BootstrapConfiguration`对应的配置类

![](https://cdn.nlark.com/yuque/0/2023/png/396745/1697776715020-7d466e07-6365-4922-b978-f3950d74d906.png#averageHue=%23252120&clientId=ue073c610-3458-4&from=paste&id=uc08bbf87&originHeight=161&originWidth=431&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u4d4db7fe-69de-40f4-8dac-3ef0148eee2&title=)<br />而在spring-cloud-context包下，`@BootstrapConfiguration`会导入一个很重要的配置类<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1697776715656-2aea37a4-2823-444b-9c70-db238c30e881.png#averageHue=%234f5244&clientId=ue073c610-3458-4&from=paste&id=u4efda09f&originHeight=376&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u30192875-5eda-4f32-9223-8608ee2979e&title=)<br />`PropertySourceBootstrapConfiguration`<br />![PropertySourceBootstrapConfiguration](https://cdn.nlark.com/yuque/0/2023/png/396745/1697776716083-ab2e4cbb-3a64-4454-913b-c563fbd329b7.png#averageHue=%232e2c2b&clientId=ue073c610-3458-4&from=paste&id=u497a1ebc&originHeight=582&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=u5a121308-b596-4fbe-a32f-a3707f1deae&title=PropertySourceBootstrapConfiguration "PropertySourceBootstrapConfiguration")<br />这个配置类中会注入这么一个集合对象<br />`PropertySourceLocator`<br />![PropertySourceLocator](https://cdn.nlark.com/yuque/0/2023/png/396745/1697776716154-0af76636-afa9-4591-86fe-05d2dbd3c979.png#averageHue=%232c2b2b&clientId=ue073c610-3458-4&from=paste&id=u5f48e7d9&originHeight=469&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=udb925680-2cd2-48b5-968e-5ee838907d7&title=PropertySourceLocator "PropertySourceLocator")<br />这个接口非常非常重要，先来看看注释
> Strategy for locating (possibly remote) property sources for the Environment. Implementations should not fail unless they intend to prevent the application from starting.

译：
> 以一种策略的方式为`Environment`定位（可能是远程）属性配置（`PropertySource`）。实现不应该失败，除非打算阻止应用程序启动。

从这个翻译后的意思就是说，这个接口是用来定位，也就是说获取属性配置的<br />并且**可能是远程**告诉我们一个很重要的信息，那就是获取的配置信息不仅仅可以存在本地，而且还可以存在远程。<br />远程？作者这里就差直接告诉你可以从配置中心获取了。。<br />所以这个接口的作用就是用配置中心获取配置的！<br />那么自然而然不同的配置中心要想整合到SpringCloud就得实现这个接口<br />当注入完`PropertySourceLocator`集合之后，在某个阶段会调用所有的`PropertySourceLocator`，获取配置中心中的配置<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1697776716621-9c521412-85b0-4cad-9fe1-736abc0fad40.png#averageHue=%232f2b2b&clientId=ue073c610-3458-4&from=paste&id=ued641548&originHeight=796&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u773ab687-ff80-4d74-9b58-934e73a19d1&title=)<br />之后在把这些配置放到`Environment`中<br />这样在`ApplicationContext`的刷新阶段就可以使用到配置中心的那些配置了
<a name="qjIDK"></a>
### 小总结
到这就弄明白了在项目启动中加载配置中心的配置了<br />其实就是项目在启动时会额外创建一个跟配置中心相关的Spring容器<br />这个容器会去加载bootstrap配置文件和所有的spring.factories中的键为`org.springframework.cloud.bootstrap.BootstrapConfiguration`对应的配置类<br />之后会去调用这个容器中所有的`PropertySourceLocator`对象，从配置中心获取配置<br />再放到`Environment`中就完成了启动时从配置中心获取配置的方式<br />最后，来张图概括一下前面整体的步骤<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1697776716677-efaed226-0cae-4894-af3f-c3f762e81c03.png#averageHue=%23282420&clientId=ue073c610-3458-4&from=paste&id=u722b8de6&originHeight=701&originWidth=790&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u6164a4ff-3b36-49ef-b7a3-112b057c325&title=)
<a name="YRgOy"></a>
## 如何动态刷新Bean的属性？
都知道，要想实现配置属性的动态刷新，需要在类上加上一个注解`@RefreshScope`<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1697776717025-09b9d1ba-46b9-4f34-b487-35e738b63bfe.png#averageHue=%232e2d2b&clientId=ue073c610-3458-4&from=paste&id=u36d4177b&originHeight=516&originWidth=792&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u870c7e47-40d7-47b1-9c59-02d93d01f14&title=)<br />重点来了<br />加了`@RefreshScope`注解的Bean，就拿上图中的UserService举例<br />Spring在生成的时候会生成两个UserService的Bean：

- 第一个是UserService的代理动态代理的Bean，后面称为**第一个Bean**
- 第二个就是UserService这个Bean，后面称为**第二个Bean**

当在其它类中需要注入一个UserService时，真正注入的是**第一个Bean**，也就是动态代理的Bean<br />当使用这个注入的动态代理的Bean的时候，他会去找**第二个Bean**，也就是真正的UserService这个Bean，然后调用对应的方法<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1697776717307-d9180abd-0e2b-4e72-ab94-710860bd3189.png#averageHue=%23110f0f&clientId=ue073c610-3458-4&from=paste&id=udd685917&originHeight=241&originWidth=461&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=ud7c7d606-e969-4ff4-b19b-4440aba1c1b&title=)<br />比如调用注入的UserService代理对象的`getUsername`方法，最终就会调用到**第二个**`**Bean**getUsername`方法<br />获取到的username属性值自然也就是**第二个Bean**中的username值<br />那么为什么要生成两个Bean？<br />接着往下瞅<br />在SpringCloud中有这么一项规定<br />当配置中心客户端一旦感知到服务端的某个配置有变化的时候，需要发布一个RefreshEvent事件来告诉SpringCloud配置有变动<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1697776717286-f69047c9-cce5-4613-b494-5224e5dc43ee.png#averageHue=%232e2a22&clientId=ue073c610-3458-4&from=paste&id=ud61fc165&originHeight=241&originWidth=247&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u3c60e09b-e4b3-43d2-af56-48d98252335&title=)<br />在SpringCloud中`RefreshEventListener`类会去监听这个事件<br />![RefreshEventListener](https://cdn.nlark.com/yuque/0/2023/png/396745/1697776717622-1ed1cd02-e7ae-475b-9ecb-d05235dbff43.png#averageHue=%232f2d2b&clientId=ue073c610-3458-4&from=paste&id=ub4cadeb3&originHeight=686&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=u2c45ac45-7668-4795-8e3d-65cecbb2952&title=RefreshEventListener "RefreshEventListener")<br />一旦监听到这个事件，SpringCloud会再次从配置中心拉取配置<br />这个拉取配置的核心逻辑跟启动时拉取配置的核心逻辑是一样的<br />也是通过 `BootstrapApplicationListener` 来实现的<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1697776718570-2a3185e2-21c2-4e14-aaba-172d32ca7486.png#averageHue=%232f2d2c&clientId=ue073c610-3458-4&from=paste&id=ud8902078&originHeight=604&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=ubead7ff5-2e19-4bba-a8d4-e695018bcbd&title=)<br />这部分代码逻辑在`ContextRefresher`类中，顺着`RefreshEventListener`就能看到，再把上面拉取配置的图拿过来<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1697776718520-014d36bd-73eb-49df-9bc3-4dfbfa318923.png#averageHue=%2324201d&clientId=ue073c610-3458-4&from=paste&id=u6d3de942&originHeight=341&originWidth=790&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=ud8f5b15b-1772-4671-8b99-49ef3c8172f&title=)<br />有了最新的配置之后，就会进行一步骚操作来移花接木”刷新“注入到对象的属性<br />这个操作就是销毁所有的前面提到的**第二个Bean**，但是**第一个Bean**，也就是代理对象保持不变<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1697776718543-bab1b594-b6e4-467e-a47a-821e212b76a2.png#averageHue=%230f0d0d&clientId=ue073c610-3458-4&from=paste&id=uc47d8808&originHeight=241&originWidth=481&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u90d9019b-153c-4c19-a616-998e1a5db34&title=)<br />当程序运行调用代理对象的方法的时候，发现**第二个Bean**没有了，此时他就会去**重新创建第二个Bean**，也就是**重新创建一个UserService对象**<br />由于此时已经拉到最新的配置了，也就是这个被**重新创建的UserService对象**注入的就是**最新的属性**了<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1697776718564-8c5c2641-09f1-438a-8a47-d212bf3e4eba.png#averageHue=%2311100f&clientId=ue073c610-3458-4&from=paste&id=u967b9403&originHeight=241&originWidth=631&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u7f48f7b6-9b0b-4054-b028-4c823298812&title=)<br />之后再调用的这个新创建的**第二个Bean**，拿到的自然就是最新的配置<br />所以，给你的感觉是对象的属性发生了变化，实际上是真正被调用的对象重新创建了<br />所以这招移花接木还是有点意思的！
<a name="jHNEy"></a>
### 小总结
其实到这就弄明白了Bean的属性动态刷新的原理<br />其实就是当配置中心客户端发现服务端的配置有变化，需要发送一个RefreshEvent事件来告诉SpringCloud配置有变动<br />SpringCloud会去监听这个事件，按照项目启动的方式重新拉取配置中心最新的属性配置<br />当拉取完属性配置之后，就会销毁所有的**第二个Bean**，也就是真正被使用的Bean<br />之后当**第一个Bean**（动态代理的Bean）需要使用这个**第二个Bean**时，就会重新创建这个**第二个Bean**<br />此时由于已经有最新的配置了，那么创建的这个**第二个Bean**就会被注入最新的属性，这样就实现了属性的”刷新“<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1697776718786-f670e688-2751-4acc-9555-2febf2d353c7.png#averageHue=%231c1a17&clientId=ue073c610-3458-4&from=paste&id=ub7b6458b&originHeight=301&originWidth=1036&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u7e40afa5-a3a5-4e1f-867c-f60f450cb0d&title=)
<a name="GX9CX"></a>
### 补充：`@RefreshScope`的秘密
上面大致说了`@RefreshScope`动态刷新的原理<br />这里补充一下`@RefreshScope`代码层面的实现原理<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1697776718994-eb0b67b0-f511-4b84-9d63-a44528747424.png#averageHue=%232e2c2b&clientId=ue073c610-3458-4&from=paste&id=u6bbfe1a3&originHeight=517&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=ue46f41a9-2f33-4e15-a022-ee90170bb6e&title=)<br />这个注解是个衍生注解，真正起作用的就是`@Scope`注解<br />`@Scope`注解并不陌生，他其实是定义Bean的作用域<br />比如多例（原型），就可以加上`@Scope("prototype")`注解<br />还有一些八股文常背的作用域，比如session作用域等等<br />而`@RefreshScope`也可以看做是一种Bean的作用域，名字叫做refresh<br />这些**除了单例和多例之外**的作用域的底层实现逻辑都是一样的<br />这些带有作用域的Bean相比于普通的单例Bean主要有以下几点不同：

- 会注册两个Bean，这个前面已经提到过
- 保存的地方不同，比如单例Bean最终会存在三级缓存中的第一级缓存中，而不同作用域的Bean是存在不同的地方的

先说会注册两个Bean，还是以前面提到的UserService举个例子，这两个Bean分别是

- 第一个Bean的Bean名称为userService，Bean class为`ScopedProxyFactoryBean.class`，这个scope为默认，也就是单例
- 第二个Bean的Bean名称为`scopedTarget.userService`，Bean class为UserService.class，scope为refresh（如果是session作用域就是session）

第一个Bean的class为`ScopedProxyFactoryBean`，是个FactoryBean的实现<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1697776719605-aee308f0-24b9-4ca6-b149-41a38104e6a7.png#averageHue=%232d2c2b&clientId=ue073c610-3458-4&from=paste&id=u393fb7bf&originHeight=648&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u64ea507d-f5ca-475e-b34f-0455fe5dd35&title=)<br />这个最终会生成一个代理对象，上面的例子就是为UserService生成一个代理对象，并且由于是单例的，所以最终这个对象会被放到一级缓存中，使用时注入的也就是这个对象<br />第二个Bean的class是UserService，所以生成的就是真正的UserService对象，但是由于scope为refresh，所以不会存在第一级缓存中<br />这部分注册两个Bean的代码是在`ScopedProxyUtils#createScopedProxy`方法中，有兴趣的可以扒扒<br />再来讲一讲保存的地方不同<br />不同的作用域都需要实现一个Scope接口来存放对应的Bean<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1697776719882-85d1248d-8cd0-4085-80e7-ef33c8a3cb34.png#averageHue=%23313130&clientId=ue073c610-3458-4&from=paste&id=u42cf407a&originHeight=388&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=uab8ae513-cec6-413f-b386-2abc4feae59&title=)<br />比如refresh、session作用域都有对应的实现<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1697776721106-c7934b17-4f63-4b1a-b1d9-7ea18be5d336.png#averageHue=%2390958d&clientId=ue073c610-3458-4&from=paste&id=ua1fc880d&originHeight=458&originWidth=548&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u2430db19-341d-4a5f-ad59-70504237ecd&title=)<br />也就是通过`Scope`就可以管理不同作用域的Bean<br />所以，对于refresh这个作用域来说，他的所有的Bean都在`RefreshScope`中<br />后面说的销毁，只需要移除`RefreshScope`中的Bean就可以了<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1697776721341-9016802f-7616-4343-9f31-2d940464f526.png#averageHue=%23312e2c&clientId=ue073c610-3458-4&from=paste&id=u71d94ab3&originHeight=586&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u6415eb94-e632-41a1-a84c-042390c41e3&title=)<br />代码也在`ContextRefresher`类中
<a name="iNmZb"></a>
## 开源配置中心是如何整合SpringCloud的？
首先再来梳理一下拉取配置和刷新配置的核心关键点<br />拉取配置关键点就是项目启动的时候（也包括重新拉取配置），会去创建一个容器<br />这个容器只读取bootstrap配置文件和spring.factories中的键为`org.springframework.cloud.bootstrap.BootstrapConfiguration`对应的配置类<br />之后会获取这个容器中的`PropertySourceLocator`，从而获取配置中心的配置<br />刷新配置关键点就是一旦配置中心配置变动，就需要发送RefreshEvent事件，之后一系列刷新操作都是由SpringCloud的来完成的<br />所以，配置中心整合到SpringCloud其实就很简单，就两点<br />第一点就是需要实现`PropertySourceLocator`，并且配置中心一些相关的Bean需要通过`org.springframework.cloud.bootstrap.BootstrapConfiguration`来装配到这个容器中<br />第二点，当配置发生变更需要发送`RefreshEvent`事件，这部分配置中心一些相关的Bean配置肯定是需要通过自动装配来完成<br />有了这两点来看看Nacos作为配置中心是如何整合到SpringCloud的<br />直接看Nacos的spring.factories文件<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1697776721309-f0bc633f-9828-40fd-8aca-75c6c81ceaf5.png#averageHue=%23585445&clientId=ue073c610-3458-4&from=paste&id=u08b2f447&originHeight=308&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u75e24999-7783-4e38-8b15-569527befe6&title=)<br />`NacosConfigBootstrapConfiguration`是用来实现第一点的<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1697776721684-5606e67a-cace-4e50-bb05-3891cd182058.png#averageHue=%232f2d2b&clientId=ue073c610-3458-4&from=paste&id=u02effa88&originHeight=664&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u2deaf1a9-2319-4aad-9ec3-49d85925d14&title=)<br />除了Nacos自己的一些Bean，他还声明了一个`NacosPropertySourceLocator`这个Bean<br />![NacosPropertySourceLocator](https://cdn.nlark.com/yuque/0/2023/png/396745/1697776721781-6b3be25b-b2cd-4c83-8656-31fb33b50ee0.png#averageHue=%232d2c2b&clientId=ue073c610-3458-4&from=paste&id=u7068486d&originHeight=613&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=udcbd6f78-3e8a-4760-a442-9ad662bc1f5&title=NacosPropertySourceLocator "NacosPropertySourceLocator")<br />这个Bean就实现了`PropertySourceLocator`接口<br />第二点的实现就是通过`NacosConfigAutoConfiguration`配置类来实现的<br />这里面有这么一个Bean<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1697776721970-a9e8bc1a-32da-4b17-9b9f-cab4290ea229.png#averageHue=%23302d2c&clientId=ue073c610-3458-4&from=paste&id=u757f7d31&originHeight=633&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u295d3dac-2480-4008-8b41-068bd198654&title=)<br />这个Bean就实现了配置变化发送事件的操作<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1697776722293-79766df3-a731-4526-9af4-1f2197098e51.png#averageHue=%232e2c2b&clientId=ue073c610-3458-4&from=paste&id=u69a0316f&originHeight=596&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=ua8ffb93c-b839-4592-8023-cb112cf76bd&title=)<br />除了Nacos，比如说Consul作为配置中心的时候也是这么一套实现逻辑<br />但是值的注意的是，像Apollo配置中心，他并没有适配SpringCloud这套规范<br />当然，如果有兴趣，可以自己实现Apollo适配SpringCloud这套规范
