微服务 测试<br />![](https://cdn.nlark.com/yuque/0/2021/jpeg/396745/1631286871990-529a66dd-b505-4392-bd00-677f8f6f55ca.jpeg)<br />由于微服务有内部的依赖，也有外部的依赖，有些依赖可能还不在团队的控制之下，这样带来的测试条件就更加困难。针对这种复杂性，可以采用分而治之的策略，先针对每个微服务进行隔离测试，在对每个微服务测试时要进行分层测试。测试过程中采用Mock技术来隔离依赖简化测试。再确保每个微服务通过测试以后再测试每个微服务端到端的集成测试。
<a name="qZ3m9"></a>
## 微服务测试分类和技术
根据分而治之的策略，为了测试整个微服务系统，先要实现对每个微服务进行测试，为了对每个微服务进行测试，先要理解每个微服务的结构，每个微服务的结构如下：<br />![](https://cdn.nlark.com/yuque/0/2021/jpeg/396745/1631288162294-7f411389-b6fc-4be7-b09e-b3f9b1dbd65e.jpeg)
<a name="I3lsK"></a>
### 单元测试
![](https://cdn.nlark.com/yuque/0/2021/jpeg/396745/1631288530356-704b78e7-1b9e-4330-8af4-9f0cb2ed4460.jpeg)
<a name="MDpHM"></a>
### 单元测试常用工具
<a name="Cg0sS"></a>
#### Junit5
[https://junit.org/junit5/](https://junit.org/junit5/)
<a name="tv50D"></a>
#### Mockito
[https://site.mockito.org/](https://site.mockito.org/)
<a name="hDblx"></a>
### 集成测试（Integration Test）
单元测试即使有充分的覆盖度，但是他不能保证每个层次之间协作逻辑的执行，不能保证整个系统的正确性。所以仍然需要其他的测试手段。<br />![](https://cdn.nlark.com/yuque/0/2021/jpeg/396745/1631535013854-8986a30d-90f4-470b-8846-a65da1c58d23.jpeg)
<a name="s3a7C"></a>
### 组件测试（Component Test）~内部Mock
![](https://cdn.nlark.com/yuque/0/2021/jpeg/396745/1631535016089-590c3c04-2409-4a3e-9675-c808caca81bd.jpeg)
<a name="KWn9X"></a>
#### WireMock
[http://wiremock.org/](http://wiremock.org/)
<a name="rUZ1p"></a>
#### MockBean（Spring提供）
[https://www.baeldung.com/java-spring-mockito-mock-mockbean](https://www.baeldung.com/java-spring-mockito-mock-mockbean)<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1631289429836-e8ce9e17-3f10-4f1e-a1b5-e348124043ce.png#clientId=u85cf25cb-da61-4&from=paste&height=599&id=uaf1689eb&originHeight=1796&originWidth=3798&originalType=binary&ratio=1&size=751653&status=done&style=shadow&taskId=ufbd34584-bcf5-4d7e-bae5-703be4f0e8f&width=1266)
<a name="ey7OM"></a>
### 组件测试（Component Test）~外部Mock
![](https://cdn.nlark.com/yuque/0/2021/jpeg/396745/1631535020007-c61e4014-4300-4d36-be00-71eeda4b99f7.jpeg)
<a name="bgkLN"></a>
#### Hoverfly
[https://hoverfly.io/](https://hoverfly.io/)
<a name="QCawd"></a>
#### Mbtest
[http://www.mbtest.org/](http://www.mbtest.org/)<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1631289891469-0677fac0-f55e-439c-bb47-e8c6ad13763d.png#clientId=u85cf25cb-da61-4&from=paste&height=601&id=u68177d02&originHeight=1803&originWidth=3840&originalType=binary&ratio=1&size=922207&status=done&style=none&taskId=u87209246-61cd-4eb7-b766-58887e2845e&width=1280)
<a name="sCIDF"></a>
## 契约驱动测试
<a name="A6JRJ"></a>
### 契约测试（Contract Test）
![](https://cdn.nlark.com/yuque/0/2021/jpeg/396745/1631462344572-5ce01e89-7d36-4389-99a9-b67267d1a950.jpeg)
<a name="Li5IC"></a>
#### PACT
[https://docs.pact.io/](https://docs.pact.io/)<br />![summary.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1631462358421-e64c314a-a2e5-433a-b730-b76ed1ee3387.png#clientId=u76d8c948-758b-4&from=ui&id=u290ee2b6&originHeight=1342&originWidth=1799&originalType=binary&ratio=1&size=404885&status=done&style=stroke&taskId=u7832b215-b4c1-4db9-aa28-9bf5f2fb89a)
<a name="H4Jy3"></a>
#### Spring Cloud Contract
[https://spring.io/projects/spring-cloud-contract](https://spring.io/projects/spring-cloud-contract)
<a name="Lmzwd"></a>
### 契约驱动测试
![](https://cdn.nlark.com/yuque/0/2021/jpeg/396745/1631496624517-30745b33-f7a8-47f4-8f58-80bbcbbe314b.jpeg)<br />采用描述性契约以后，即可作为服务提供方Mock Provider的输入，来驱动消费者端的契约测试。又可以作为服务消费方Mock Consumer的输入，来驱动生产端的契约测试。所以这种方式比较灵活，覆盖面比较完善。<br />契约测试需要跨团队协调配合，开发和维护工作量比较大，系统化采用的话成本比较高。
<a name="P65BV"></a>
## 端到端测试（End-to-End Test）
![](https://cdn.nlark.com/yuque/0/2021/jpeg/396745/1631533141367-9c8216ef-7a1e-432b-b7c9-6361c728d35d.jpeg)<br />端到端测试将整个系统看作一个黑盒子，通过测试接口，对系统整体进行功能测试以及非功能测试。
<a name="fWdr9"></a>
### Selenium WebDriver（UI 测试常用）
[https://www.selenium.dev/](https://www.selenium.dev/)<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1631533026091-436f7226-a3a1-4ead-bf69-72ea7e41c308.png#clientId=ue3013844-29b4-4&from=paste&height=601&id=uf083dca8&originHeight=1803&originWidth=3798&originalType=binary&ratio=1&size=544388&status=done&style=stroke&taskId=uc3b9ddae-8193-483c-a220-7add3a070ee&width=1266)
<a name="p8huZ"></a>
### Rest-assured（Java API测试常用）
[https://rest-assured.io/](https://rest-assured.io/)<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1631533168518-bde80f20-00ec-47d4-b7f4-4e6a453cb66f.png#clientId=ue3013844-29b4-4&from=paste&height=601&id=u34aeaded&originHeight=1803&originWidth=3798&originalType=binary&ratio=1&size=3648837&status=done&style=none&taskId=ua5f7ea02-b2bd-46f5-9a21-7c6daa536ee&width=1266)
<a name="CmglH"></a>
### 端到端测试实践

1. 80/20，聚焦核心业务服务
2. 用户使用场景驱动
3. 适当Mock不稳定测试点
4. 规范测试环境和环境自动化
5. 测试数据管理
6. 灰度测试+生产监控
<a name="ikWwU"></a>
## 测试方式总结
| 分类 | 功能 |
| --- | --- |
| 单元测试 | 确保类、模块功能正确 |
| 集成测试 | 确保组件间接口、交互和链路正确 |
| 组件测试 | 确保微服务作为独立整体、接口功能正确 |
| 契约测试 | 确保服务提供方和消费方都遵循契约规范 |
| 端到端测试 | 确保整个应用满足用户需求 |
| 探索测试 | 手工探索学习系统功能，改进自动化测试 |

一致性>具体定义
<a name="UTvpH"></a>
## 测试金字塔
![](https://cdn.nlark.com/yuque/0/2021/jpeg/396745/1631533972526-d6816ce3-7c08-41db-aaa2-3239e5c4949c.jpeg)<br />测试金字塔建议多做单元测试。
<a name="MBiog"></a>
## 测试补充
<a name="hTzCV"></a>
### Mock VS Spy
对接口进行Mock测试是比较方便的。Spy主要针对的是类的场景（比如来自第三方提供的一些类）。
<a name="WADl0"></a>
### BDD行为驱动测试（了解）
行为测试主要是面向用户的。
<a name="zOLtT"></a>
### 性能测试
<a name="qaLwR"></a>
#### JMeter（有UI操作界面）
<a name="aP3tC"></a>
#### Gatling（偏脚本编程、可集成CI/CD）
[https://gatling.io/open-source/](https://gatling.io/open-source/)<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1631538438021-216e28a0-ee13-4dcf-90ab-165da0dfc9ba.png#clientId=u1497b7dd-53ea-4&from=paste&height=447&id=ued3fab07&originHeight=1342&originWidth=3798&originalType=binary&ratio=1&size=1663319&status=done&style=none&taskId=ufabe3755-b617-49fa-9922-e091da9d13d&width=1266)
