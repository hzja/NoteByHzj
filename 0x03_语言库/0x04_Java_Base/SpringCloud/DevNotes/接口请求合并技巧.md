<a name="InIxj"></a>
## 一、什么是请求合并
在WEB项目中，一般会使用HTTP协议来处理请求<br />那么与服务器交互方式将会是这样的，一次请求，一次处理<br />![](https://cdn.nlark.com/yuque/0/2023/jpeg/396745/1695869481674-fced8118-d529-47f6-a56f-b6beb240457e.jpeg)<br />调用批量接口相比调用非批量接口有更大的性能优势（因为减少了IO交互操作），在高并发情况下，如果有非常频繁的接口请求发生的话，则可以考虑请求合并了，将多个请求进行一定的等待延迟，当请求累计达到一定量级的时候，进行批量请求处理
<a name="LI5CH"></a>
## 二、请求合并的优缺点
所谓请求合并，就是讲多次请求合并为一次批量请求<br />![](https://cdn.nlark.com/yuque/0/2023/jpeg/396745/1695869484791-ea460455-9d8e-4e1c-86bb-1f0225aa73f9.jpeg)<br />**优点：**将多次请求处理进行一定时间或请求数量的等待，使之合并成为一次请求，减少IO交互<br />**缺点：**由于请求需要等待指定时间或指定请求数量，所以合并的接口存在延时，故对请求合并的接口有所限制，该接口不能对响应及时性有要求，支持一定时间的延迟
<a name="ABZym"></a>
## 三、请求合并技术实现
采用定时线程池`ScheduledExecutorService`，与内存队列`LinkedBlockingDeque`进行实现请求合并<br />原理是将用户的请求进行缓存起来，缓存的请求数量达到指定数量或达到定时线程池执行时，将已有多个单请求处理合并为多处理，调用批量接口进行操作<br />依赖

- 只需要JDK，无需任何第三方依赖

批量请求合并工具类定义如下：<br />核心原理就是 将请求放入队列，放入时检测内存队列数量是否超过设置阈值，以及时间阈值到期触发定时线程池执行
```java
import lombok.extern.log4j.Log4j2;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.concurrent.*;

/**
 * @desc 请求合并工具类
 **/
@Log4j2
public class BatchCollapser<T, R> {
    private static final Map<Class, BatchCollapser> BATCH_INSTANCE =new ConcurrentHashMap<>();
    private static final ScheduledExecutorService SCHEDULE_EXECUTOR = Executors.newScheduledThreadPool(1);

    private final LinkedBlockingDeque<T> batchContainer = new LinkedBlockingDeque<>();
    private final BatchHandler<List<T>, R> handler;
    private final int countThreshold;

    /**
     * constructor
     *
     * @param handler        处理器
     * @param countThreshold 数量阈值，达到此阈值后触发处理器
     * @param timeThreshold  时间阈值，达到此时间后触发处理器
     */
    private BatchCollapser(BatchHandler<List<T>, R> handler, int countThreshold, long timeThreshold) {
        this.handler = handler;
        this.countThreshold = countThreshold;
        SCHEDULE_EXECUTOR.scheduleAtFixedRate(() -> {
            try {
                this.popUpAndHandler(BatchHandlerType.BATCH_HANDLER_TYPE_TIME);
            } catch (Exception e) {
                log.error("pop-up container exception", e);
            }
        }, timeThreshold, timeThreshold, TimeUnit.SECONDS);
    }

    /**
     * 添加请求元素入队
     * @param event
     */
    public void addRequestParam(T event) {
        batchContainer.add(event);
        if (batchContainer.size() >= countThreshold) {
            popUpAndHandler(BatchHandlerType.BATCH_HANDLER_TYPE_DATA);
        }
    }

    /**
     * 从队列获取请求,并进行批量处理
     * @param handlerType
     */
    private void popUpAndHandler(BatchHandlerType handlerType) {
        List<T> tryHandlerList = Collections.synchronizedList(new ArrayList<>(countThreshold));
        batchContainer.drainTo(tryHandlerList, countThreshold);
        if (tryHandlerList.size() < 1) {
            return;
        }

        try {
            R handle = handler.handle(tryHandlerList, handlerType);
            log.info("批处理工具执行result:{}", handle);
        } catch (Exception e) {
            log.error("batch execute error, transferList:{}", tryHandlerList, e);
        }
    }

    /**
     * 获取合并器实例
     *
     * @param batchHandler   处理执行器
     * @param countThreshold 阈值数量(队列数量)
     * @param timeThreshold  阈值时间 单位秒（目前设置是触发后获取阈值数量请求，可根据需要修改）
     * @param <E>
     * @param <R>
     * @return
     */
    public static <E, R> BatchCollapser<E, R> getInstance(BatchHandler<List<E>, R> batchHandler, int countThreshold, long timeThreshold) {
        Class jobClass = batchHandler.getClass();
        if (BATCH_INSTANCE.get(jobClass) == null) {
            synchronized (BatchCollapser.class) {
                BATCH_INSTANCE.putIfAbsent(jobClass, new BatchCollapser<>(batchHandler, countThreshold, timeThreshold));
            }
        }
        return BATCH_INSTANCE.get(jobClass);
    }

    /**
     * 请求处理接口
     *
     * @param <T>
     * @param <R>
     */
    public interface BatchHandler<T, R> {
        /**
         * 处理用户具体请求
         *
         * @param input
         * @param handlerType
         * @return
         */
        R handle(T input, BatchHandlerType handlerType);
    }

    /**
     * 合并执行类型枚举
     */
    public enum BatchHandlerType {
        /**
         * 数量类型
         */
        BATCH_HANDLER_TYPE_DATA,

        /**
         * 时间类型
         */
        BATCH_HANDLER_TYPE_TIME,
    }
}
```
使用方式如下：
```java
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;

import javax.annotation.PostConstruct;
import java.util.List;

/**
 * @desc
 **/
@Service
public class ProductService implements BatchCollapser.BatchHandler<List<Integer>, Integer> {
    private BatchCollapser<Integer, Integer> batchCollapser;

    @PostConstruct
    private void postConstructorInit() {
        // 当请求数量达到20个，或每过5s合并执行一次请求
        batchCollapser = BatchCollapser.getInstance(ProductService.this, 20, 5);
    }

    @Override
    public Integer handle(List<Integer> input, BatchCollapser.BatchHandlerType handlerType) {
        System.out.println("处理类型:" + handlerType + ",接受到批量请求参数:" + input);
        return input.stream().mapToInt(x -> x).sum();
    }


    /**
     * 假设这里是300ms一次请求
     */
    @Scheduled(fixedDelay = 300)
    public void aaa() {
        Integer requestParam = (int) (Math.random() * 100) + 1;
        batchCollapser.addRequestParam(requestParam);
        System.out.println("当前请求参数:" + requestParam);

    }
}
```
```java
@Data
public class Product {
    private Integer id;
    private String notes;
}
```
![](https://cdn.nlark.com/yuque/0/2023/png/396745/1695868065183-64e9bb10-24bd-4817-b8cc-5525839c55e2.png#averageHue=%232e2d2d&clientId=uab954a3d-d947-4&from=paste&id=u4323e698&originHeight=499&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=ue0d2b938-8ae6-4e14-bd40-5675193c384&title=)<br />当然以上工具类仅仅只是DEMO，各位大佬可自行完善，权衡请求合并利弊，降低服务器在高并发请求时的压力。
