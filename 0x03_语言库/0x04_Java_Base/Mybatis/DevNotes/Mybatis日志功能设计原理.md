Mybatis 日志<br />在使用Mybatis时，如果出现sql问题，一般会把Mybatis配置文件中的`logging.level`参数改成`debug`，这样就能在日志中看到某个`mapper`最终执行sql、入参和影响数据行数。拿到sql和入参，手动拼接成完整的sql，然后将该sql在数据库中执行一下，就基本能定位到问题原因。Mybatis的日志功能使用起来还是非常方便的，有没有想过它是如何设计的呢？
<a name="zOhqv"></a>
## 从logging目录开始
先看一下Mybatis的logging目录，该目录的功能决定了Mybatis使用什么日志工具打印日志。<br />logging目录结构如下：<br />![2021-09-17-07-23-41-417152.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1631834935684-1279adcb-89ea-4be8-83cc-c070a0a6f27c.png#clientId=u76ff439f-72cb-4&from=ui&id=ue38a9a12&originHeight=458&originWidth=428&originalType=binary&ratio=1&size=32900&status=done&style=none&taskId=ufb7c605a-9ede-419a-a862-2a2160fa6f0)<br />它里面除了jdbc目录，还包含了7个子目录，每一个子目录代表一种日志打印工具，目前支持6种日志打印工具和1种非日志打印工具。用一张图来总结一下<br />![2021-09-17-07-23-42-119152.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1631834935701-21eddde4-423c-4289-9867-f1187c292010.png#clientId=u76ff439f-72cb-4&from=ui&id=X2lDk&originHeight=667&originWidth=1080&originalType=binary&ratio=1&size=76577&status=done&style=shadow&taskId=u48272f9a-233b-4b40-b8ae-d8ef3a08977)<br />除了上面的8种日志工具之外，它还抽象出一个Log接口，所有的日志打印工具必须实现该接口，后面可以面向接口编程。定义了`LogException`异常，该异常是日志功能的专属异常，如果有看过Mybatis其他源码的话，不难发现，其他功能也定义专属异常，比如：`DataSourceException`等，这是Mybatis的惯用手法，主要是为了将异常细粒度的划分，以便更快定位问题。此外，它还定义了`LogFactory`日志工厂，以便于屏蔽日志工具实例的创建细节，让用户使用起来更简单。
<a name="mC1RS"></a>
### 如何设计这个功能？
按照上面目录结构的介绍其实已经有一些思路：

1. 定义一个`Log`接口，以便于统一抽象日志功能，这8种日志功能都实现Log接口，并且重写日志打印方法。
2. 定义一个`LogFactory`日志工厂，它会根据项目中引入的某个日志打印工具jar包，创建一个具体的日志打印工具实例。

看起来，不错。但是，再仔细想想，`LogFactory`中如何判断项目中引入了某个日志打印工具jar包才创建相应的实例呢？第一个想到的可能是用if...else判断不就行了，再想想感觉用`if...else`不好，7种条件判断太多了，并非优雅的编程。这时候，会想一些避免太长`if...else`判断的方法，Mybatis用了一个新的办法。
<a name="uhWI2"></a>
### Mybatis是如何设计这个功能的？

1. 从`Log`接口开始

![2021-09-17-07-23-43-196158.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1631834952205-d13a073d-ecc5-40bc-82b9-ce694ecd28bc.png#clientId=u76ff439f-72cb-4&from=ui&id=u5613c517&originHeight=614&originWidth=540&originalType=binary&ratio=1&size=52006&status=done&style=none&taskId=ub6daab65-470b-4b36-96ce-3d2d181ffe7)<br />它里面抽象了日志打印的5种方法和2种判断方法。

1. 再分析`LogFactory`的代码

![](https://cdn.nlark.com/yuque/0/2021/webp/396745/1631834601744-863076ae-507f-4f6e-bde8-218cd6e22751.webp#clientId=u76ff439f-72cb-4&from=paste&id=ufacad3ad&originHeight=1174&originWidth=860&originalType=url&ratio=1&status=done&style=none&taskId=u88bb669d-6ca2-47dc-8e2a-9d3b5c00194)<br />它里面定义了一个静态的构造器`logConstructor`，没有用`if...else`判断，在static代码块中调用了6个`tryImplementation`方法，该方法会启动一个执行任务去调用了`useXXXLogging`方法，创建日志打印工具实例。<br />![](https://cdn.nlark.com/yuque/0/2021/webp/396745/1631834601776-89a259c7-13e8-470a-8555-cad1b7cd7d5a.webp#clientId=u76ff439f-72cb-4&from=paste&id=u1454e81b&originHeight=340&originWidth=852&originalType=url&ratio=1&status=done&style=none&taskId=u15e95d81-d794-4789-9b1a-e010857dd07)<br />当然`tryImplementation`方法在执行前会判断构造器`logConstructor`为空才允许执行任务中的run方法。下一步看看`useXXXLogging`方法：<br />![2021-09-17-07-23-45-767210.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1631834975894-1dde733d-db20-469f-ae1d-75d0e0e8cb15.png#clientId=u76ff439f-72cb-4&from=ui&id=u8c525149&originHeight=770&originWidth=1080&originalType=binary&ratio=1&size=244163&status=done&style=none&taskId=u305e0380-9893-4959-befc-44defaa9006)<br />看到这里，可能会有这样的疑问，从上图可以看出Mybatis定义了8种`useXXXLogging`方法，但是在前面的`static`静态代码块中却只调用了6种，这是为什么？<br />对比后发现：`useCustomLogging `和 `useStdOutLogging`前面是没调用的。`useStdOutLogging`它里面使用了`StdOutImpl`类<br />![2021-09-17-07-23-46-736918.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1631834991933-09cddeaf-de09-49cc-9790-7ed502c27faa.png#clientId=u76ff439f-72cb-4&from=ui&id=u9ff3e849&originHeight=1094&originWidth=826&originalType=binary&ratio=1&size=129493&status=done&style=none&taskId=u492abe5d-c189-405b-8883-f6f10ee9263)<br />该类其实就是通过`JDK`自带的`System`类的方法打印日志的，无需引入额外的jar包，所以不参与`static`代码块中的判断。<br />而`useCustomLogging`方法需要传入一个实现了`Log`接口的类，如果Mybatis默认提供的6种日志打印工具不满足要求，以便于用户自己扩展。<br />而这个方法是在`Configuration`类中调用的，如果用户有自定义`logImpl`参数的话。<br />![2021-09-17-07-23-48-362919.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1631834991874-7bd048eb-ee4a-483b-872f-9c93d278064e.png#clientId=u76ff439f-72cb-4&from=ui&id=i8g0X&originHeight=77&originWidth=401&originalType=binary&ratio=1&size=3105&status=done&style=shadow&taskId=u5ca2edd4-2a74-43c2-bd6d-b9d02ec0924)<br />![2021-09-17-07-23-48-961918.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1631834991893-494e487d-b5fa-43ab-9534-d881bfae48dd.png#clientId=u76ff439f-72cb-4&from=ui&id=PLWHK&originHeight=256&originWidth=880&originalType=binary&ratio=1&size=35504&status=done&style=none&taskId=u1ff0d645-982d-422f-97af-2f00c68f52d)<br />具体是在`XMLConfigBuilder`类的`settingsElement`方法中调用<br />![2021-09-17-07-23-49-547922.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1631835017261-20306d95-9453-4b1a-8a83-d08550edf4a9.png#clientId=u76ff439f-72cb-4&from=ui&id=ud8dcebc3&originHeight=73&originWidth=1080&originalType=binary&ratio=1&size=39989&status=done&style=none&taskId=u9168a381-917b-449b-90db-713338cba13)<br />再回到前面`LogFactory`的`setImplementation`方法<br />![2021-09-17-07-23-50-322916.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1631835017317-19dbb515-95f2-4890-a539-2067cba99b34.png#clientId=u76ff439f-72cb-4&from=ui&id=V5NLq&originHeight=404&originWidth=1080&originalType=binary&ratio=1&size=141701&status=done&style=none&taskId=uf41b53b6-93f9-47f3-8845-3354380d69a)<br />它会先找到实现了`Log`接口的类的构造器，返回将该构造器赋值给全局的`logConstructor`。<br />这样一来，就可以通过`getLog`方法获取到`Log`实例。<br />![2021-09-17-07-23-51-091915.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1631835017334-c72fe408-05e8-433c-a815-8f4663c0594e.png#clientId=u76ff439f-72cb-4&from=ui&id=Q9r7u&originHeight=335&originWidth=1080&originalType=binary&ratio=1&size=77957&status=done&style=none&taskId=u5689376b-b59a-4b1c-93c7-0eab0dc5a81)<br />然后在业务代码中通过下面这种方式获取`Log`对象，调用它的方法打印日志了。<br />![2021-09-17-07-23-51-563917.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1631835042768-7ec607ed-bb66-4b4e-8be0-de84896d98c1.png#clientId=u76ff439f-72cb-4&from=ui&id=u8e895ce2&originHeight=82&originWidth=1060&originalType=binary&ratio=1&size=13905&status=done&style=none&taskId=u49a2fb47-196c-4556-96bb-fc490461e1c)<br />梳理一下LogFactory的流程：

- 在static代码块中根据逐个引入日志打印工具jar包中的日志类，先判断如果全局变量logConstructor为空，则加载并获取相应的构造器，如果可以获取到则赋值给全局变量logConstructor。
- 如果全局变量logConstructor不为空，则不继续获取构造器。
- 根据getLog方法获取Log实例
- 通过Log实例的具体日志方法打印日志

在这里还分享一个知识点，如果某个工具类里面都是静态方法，那么要把该工具类的构造方法定义成`private`的，防止被疑问调用，`LogFactory`就是这么做的。<br />![2021-09-17-07-23-52-054919.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1631835042775-8fbdeb66-0ce4-4dce-90ef-9e175025e007.png#clientId=u76ff439f-72cb-4&from=ui&id=Ge5hY&originHeight=156&originWidth=428&originalType=binary&ratio=1&size=11370&status=done&style=none&taskId=ub45f7443-3b83-485b-bdd5-b901e76e8c5)

1. 适配器模式

日志模块除了使用工厂模式之外，还是有了适配器模式。<br />适配器模式会将所需要适配的类转换成调用者能够使用的目标接口<br />涉及以下几个角色：

- 目标接口（ Target ）
- 需要适配的类（ Adaptee ）
- 适配器（ Adapter)

![2021-09-17-07-23-52-668916.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1631835042784-0aeb87ad-9f86-40b1-bd91-8d64e0d2f45c.png#clientId=u76ff439f-72cb-4&from=ui&id=wlYiD&originHeight=312&originWidth=454&originalType=binary&ratio=1&size=11193&status=done&style=shadow&taskId=u8aa2ccf8-5fde-488b-ab80-ec5c36a7fe2)<br />Mybatis是怎么用适配器模式的?<br />![2021-09-17-07-23-53-351916.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1631835088342-c0d7cfbf-d438-49ec-b4d5-83450aed1c44.png#clientId=u76ff439f-72cb-4&from=ui&id=ua49e0b10&originHeight=890&originWidth=684&originalType=binary&ratio=1&size=92129&status=done&style=none&taskId=ued176ea4-1ca4-4797-8fbd-d1fb5ec0e16)<br />上图中标红的类对应的是`Adapter`角色，`Log`是`Target`角色。<br />![2021-09-17-07-23-54-006919.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1631835088350-ece426c3-fb93-4ad3-afdf-3f986f763a76.png#clientId=u76ff439f-72cb-4&from=ui&id=GD7Ri&originHeight=206&originWidth=1080&originalType=binary&ratio=1&size=53109&status=done&style=none&taskId=ud01bd411-f310-4c02-9b3a-b2d3b121f41)<br />而`LogFactory`就是`Adaptee`，它里面的`getLog`方法里面包含是需要适配的对象。
<a name="l1eij"></a>
## sql执行日志打印原理
从上面已经能够确定使用哪种日志打印工具，但在sql执行的过程中是如何打印日志的呢？这就需要进一步分析`logging`目录下的`jdbc`目录了。<br />![2021-09-17-07-23-55-584921.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1631835088356-5b7f6d9a-c7a7-40fe-ad7a-a1c6f36d21f0.png#clientId=u76ff439f-72cb-4&from=ui&id=VhhdA&originHeight=234&originWidth=464&originalType=binary&ratio=1&size=28240&status=done&style=none&taskId=uba124dfe-0301-4724-8049-a38ff191cbf)<br />看看这几个类的关系图：<br />![2021-09-17-07-23-56-266926.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1631835108503-036ca73a-439f-4e6e-8e00-831f70b5f3d8.png#clientId=u76ff439f-72cb-4&from=ui&id=ud38e8fb0&originHeight=223&originWidth=1080&originalType=binary&ratio=1&size=40531&status=done&style=none&taskId=u20b1158d-d236-4044-9318-38a492bbf69)<br />`ConnectionLogger`、`PreparedStatementLogger`、`ResultSetLogger`和`StatementLogger`都继承了`BaseJdbcLogger`类，并且实现了`InvocationHandler`接口。从类名非常直观的看出，这4种类对应的数据库jdbc功能。

| 类名 | 对应功能 |
| --- | --- |
| ConnectionLogger | Connection |
| PreparedStatementLogger | PreparedStatement |
| ResultSetLogger | ResultSet |
| StatementLogger | Statement |

它们实现了`InvocationHandler`接口意味着它用到了动态代理，真正起作用的是`invoke`方法，以`ConnectionLogger`为例：<br />![2021-09-17-07-23-57-766976.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1631835108674-58e0bb4d-6089-42dd-aca3-03fa6357b470.png#clientId=u76ff439f-72cb-4&from=ui&id=wx4f2&originHeight=853&originWidth=1080&originalType=binary&ratio=1&size=322565&status=done&style=none&taskId=u7b6e21cc-bc29-491a-b3c7-7c1260a52a8)<br />如果调用了`prepareStatement`方法，则会打印debug日志。<br />![2021-09-17-07-23-58-573918.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1631835108615-c5c09c22-ac6a-4039-8cb8-e20765accc5a.png#clientId=u76ff439f-72cb-4&from=ui&id=zV4jM&originHeight=569&originWidth=1080&originalType=binary&ratio=1&size=212736&status=done&style=none&taskId=ud2ef953d-31b0-4e29-93d4-60b7ca11a78)<br />上图中传入的`original`参数里面包含了`\n\t`等分隔符，需要将分隔符替换成空格，拼接成一行sql。<br />最终会在日志中打印sql、入参和影响行数：<br />![2021-09-17-07-23-59-463941.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1631835129190-ce6d7bec-920b-4e88-a078-774eb2bf61b4.png#clientId=u76ff439f-72cb-4&from=ui&id=uff616160&originHeight=59&originWidth=1080&originalType=binary&ratio=1&size=45408&status=done&style=none&taskId=uc8592492-ea55-4519-8c42-2fdb3e7f91f)<br />上图中的sql语句是在`ConnectionLogger`类中打印的<br />那么入参和影响行数呢？<br />入参在`PreparedStatementLogger`类中打印的<br />![2021-09-17-07-24-00-279921.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1631835129283-16476db5-f662-493b-9242-d92b853511dd.png#clientId=u76ff439f-72cb-4&from=ui&id=bjnGm&originHeight=496&originWidth=1080&originalType=binary&ratio=1&size=168098&status=done&style=none&taskId=u5703225b-3cdc-4cff-93a6-4b06b87ce73)<br />影响行数在`ResultSetLogger`类中打印的<br />![2021-09-17-07-24-01-102961.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1631835129298-a2bff13c-195c-4748-9f90-fe96ec149064.png#clientId=u76ff439f-72cb-4&from=ui&id=B7MRW&originHeight=838&originWidth=1080&originalType=binary&ratio=1&size=214726&status=done&style=none&taskId=u2ab11d69-592a-4ca2-9152-c407f91d672)<br />大家需要注意的一个地方是：sql、入参和影响行数只打印了debug级别的日志，其他级别并没打印。所以需要在Mybatis配置文件中的`logging.level`参数配置成`debug`，才能打印日志。
<a name="DIC1Y"></a>
## 彩蛋
在`LogFactory`的代码中定义了很多匿名的任务执行器<br />![2021-09-17-07-24-01-743920.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1631835145978-cf9a0f36-3970-436e-8519-dc9a846deecb.png#clientId=u76ff439f-72cb-4&from=ui&id=ue2d4f20a&originHeight=704&originWidth=594&originalType=binary&ratio=1&size=70662&status=done&style=none&taskId=u7388a787-1d5e-4889-9a62-95e57370c44)<br />但是在实际调用时，却没有在线程中执行，而是直接调用的，这是为什么？<br />![2021-09-17-07-24-02-271928.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1631835145980-2ba0083b-de83-493b-8dc4-043b464e342e.png#clientId=u76ff439f-72cb-4&from=ui&id=tll6O&originHeight=350&originWidth=884&originalType=binary&ratio=1&size=32680&status=done&style=none&taskId=u11edcfe6-f04a-458a-b5d1-ca3335b71c8)<br />答案是为了保证顺序执行，如果所有的日志工具jar包都有，加载优先级是：slf4j 》commonsLog 》log4j2 》log4j 》jdkLog 》NoLog
