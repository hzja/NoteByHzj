Java Mybatis<br />1、Mapper接口和映射文件是如何进行绑定的 <br />2、MyBatis中SQL语句的执行流程 <br />3、自定义MyBatis中的参数设置处理器`typeHandler`<br />4、自定义MyBatis中结果集处理器`typeHandler`<br />PS：本文基于MyBatis3.5.5版本源码
<a name="vmFNe"></a>
## 概要
在MyBatis中，利用编程式进行数据查询，主要就是下面几行代码：
```java
SqlSession session = sqlSessionFactory.openSession();
UserMapper userMapper = session.getMapper(UserMapper.class);
List<LwUser> userList = userMapper.listUserByUserName("Fcant");
```
第一行是获取一个`SqlSession`对象在上一篇文章分析过了，想要详细了解的可以点击这里，第二行就是获取`UserMapper`接口，第三行一行代码就实现了整个查询语句的流程，接下来就来仔细分析一下第二和第三步。
<a name="zO47A"></a>
## 获取Mapper接口(`getMapper`)
第二步是通过`SqlSession`对象是获取一个Mapper接口，这个流程还是相对简单的，下面就是调用`session.getMapper`方法之后的运行时序图：<br />![2022-09-29-09-42-33.178929200.png](https://cdn.nlark.com/yuque/0/2022/png/396745/1664416937127-1d635145-c256-40e2-9191-9a6a627a7789.png#clientId=ufbeb28e4-ea8a-4&errorMessage=unknown%20error&from=ui&id=uef7e3615&originHeight=390&originWidth=760&originalType=binary&ratio=1&rotation=0&showTitle=false&size=891105&status=error&style=none&taskId=u633c17ad-363b-440c-9926-f62f8343e24&title=)<br />1、在调用`getMapper`之后，会去`Configuration`对象中获取Mapper对象，因为在项目启动的时候就会把Mapper接口加载并解析存储到`Configuration`对象<br />![2022-09-29-09-42-33.447497500.png](https://cdn.nlark.com/yuque/0/2022/png/396745/1664416936877-0cfca75e-7fee-4057-93f0-692644bc6ae6.png#clientId=ufbeb28e4-ea8a-4&errorMessage=unknown%20error&from=ui&id=BLHcS&originHeight=240&originWidth=768&originalType=binary&ratio=1&rotation=0&showTitle=false&size=554173&status=error&style=none&taskId=u4d6fc74a-9d55-4224-9f48-f9717fad3a3&title=)<br />2、通过`Configuration`对象中的`MapperRegistry`对象属性，继续调用`getMapper`方法<br />![2022-09-29-09-42-33.680514800.png](https://cdn.nlark.com/yuque/0/2022/png/396745/1664416936281-4546f781-ab14-4f2d-8ca2-086a344ad94b.png#clientId=ufbeb28e4-ea8a-4&errorMessage=unknown%20error&from=ui&id=wxpov&originHeight=197&originWidth=757&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23498&status=error&style=none&taskId=u8c30366c-c827-468c-b9f1-fb4fa11b706&title=)<br />3、根据type类型，从`MapperRegistry`对象中的`knownMappers`获取到当前类型对应的代理工厂类，然后通过代理工厂类生成对应`Mapper`的代理类<br />![2022-09-29-09-42-33.782718500.png](https://cdn.nlark.com/yuque/0/2022/png/396745/1664416980855-fa03a171-427a-479f-b600-366e41f3e475.png#clientId=ufbeb28e4-ea8a-4&errorMessage=unknown%20error&from=ui&id=u0f0e9bf3&originHeight=564&originWidth=898&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1522514&status=error&style=none&taskId=u55a22469-c6cd-4641-8dbc-9727c55c830&title=)<br />4、最终获取到接口对应的代理类`MapperProxy`对象<br />![2022-09-29-09-42-34.116014600.png](https://cdn.nlark.com/yuque/0/2022/png/396745/1664416979550-9b5559ad-b2ec-4c70-bb89-5c75d188fe09.png#clientId=ufbeb28e4-ea8a-4&errorMessage=unknown%20error&from=ui&id=ADdYH&originHeight=132&originWidth=736&originalType=binary&ratio=1&rotation=0&showTitle=false&size=17597&status=error&style=none&taskId=u7dfbe84e-b029-4906-8241-9971a1ef1f3&title=)<br />而`MapperProxy`可以看到实现了`InvocationHandler`，使用的就是JDK动态代理。<br />![2022-09-29-09-42-34.200823000.png](https://cdn.nlark.com/yuque/0/2022/png/396745/1664416980761-5fb74750-f104-41fe-9cc1-ad368b0ae82c.png#clientId=ufbeb28e4-ea8a-4&errorMessage=unknown%20error&from=ui&id=kpgrr&originHeight=476&originWidth=940&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1345036&status=error&style=none&taskId=u3d7fedbc-5b27-426f-abf6-1a4631efc37&title=)<br />至此获取Mapper流程结束了，那么就有一个问题了`MapperRegistry`对象内的HashMap属性`knownMappers`中的数据是什么时候存进去的呢？
<a name="nXr7f"></a>
## Mapper接口和映射文件是何时关联的
Mapper接口及其映射文件是在加载mybatis-config配置文件的时候存储进去的，下面就是时序图：<br />![2022-09-29-09-42-34.399374600.png](https://cdn.nlark.com/yuque/0/2022/png/396745/1664417024048-a3a93bd3-5b44-4ddb-bf8f-1c9da1442ce4.png#clientId=ufbeb28e4-ea8a-4&errorMessage=unknown%20error&from=ui&id=ud916b482&originHeight=480&originWidth=1080&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1558267&status=error&style=none&taskId=u283b2bbc-bd5d-4840-9bb7-5ade0d1d887&title=)<br />1、首先会手动调用`SqlSessionFactoryBuilder`方法中的`build()`方法：<br />![2022-09-29-09-42-34.660026800.png](https://cdn.nlark.com/yuque/0/2022/png/396745/1664417023675-6b7ea746-7364-412d-81c3-5c725e43a972.png#clientId=ufbeb28e4-ea8a-4&errorMessage=unknown%20error&from=ui&id=o9oGN&originHeight=403&originWidth=932&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1129089&status=error&style=none&taskId=uc9d1d19a-7e17-4c89-b69f-c53acba3de8&title=)<br />2、然后会构造一个`XMLConfigBuilder`对象，并调用其`parse`方法：<br />![2022-09-29-09-42-34.849767900.png](https://cdn.nlark.com/yuque/0/2022/png/396745/1664417023190-d2500a0b-34ad-43b1-affd-f5f2d17219b0.png#clientId=ufbeb28e4-ea8a-4&errorMessage=unknown%20error&from=ui&id=pGck1&originHeight=254&originWidth=867&originalType=binary&ratio=1&rotation=0&showTitle=false&size=662052&status=error&style=none&taskId=ubb51af21-2f77-44d4-8195-86a09044b5b&title=)<br />3、然后会继续调用自己的`parseConfiguration`来解析配置文件，这里面就会分别去解析全局配置文件的顶级节点，其他的先不看，直接看最后解析`mappers`节点<br />![2022-09-29-09-42-35.046650700.png](https://cdn.nlark.com/yuque/0/2022/png/396745/1664417079879-dec68917-b642-4918-bf8c-83e81523c5d9.png#clientId=ufbeb28e4-ea8a-4&errorMessage=unknown%20error&from=ui&id=ue18195da&originHeight=550&originWidth=832&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1375643&status=error&style=none&taskId=u145ddc47-c5de-4f13-80c7-209ec492c22&title=)<br />4、继续调用自己的mapperElement来解析mappers文件（这个方法比较长，为了方便截图完整，所以把字体缩小了1号），可以看到，这里面分了四种方式来解析mappers节点的配置，对应了4种mapper配置方式，而其中红框内的两种方式是直接配置的xml映射文件，蓝框内的两种方式是解析直接配置Mapper接口的方式，从这里也可以说明，不论配置哪种方式，最终MyBatis都会将xml映射文件和`Mapper`接口进行关联。<br />![2022-09-29-09-42-35.363904300.png](https://cdn.nlark.com/yuque/0/2022/png/396745/1664417080350-66d25ed4-f24d-41f2-905f-45ae8c353a87.png#clientId=ufbeb28e4-ea8a-4&errorMessage=unknown%20error&from=ui&id=fh4y1&originHeight=585&originWidth=1067&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1876275&status=error&style=none&taskId=u3875a00d-d38a-4d63-8c77-5e93ab66244&title=)<br />5、先看第2种和第3中（直接配置xml映射文件的解析方式），会构建一个`XMLMapperBuilder`对象并调用其`parse`方法。<br />![2022-09-29-09-42-35.662238200.png](https://cdn.nlark.com/yuque/0/2022/png/396745/1664417080309-89d007f5-6dcb-4b4e-ac52-8eaf0efc0f62.png#clientId=ufbeb28e4-ea8a-4&errorMessage=unknown%20error&from=ui&id=ZG7bz&originHeight=550&originWidth=1080&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1785508&status=error&style=none&taskId=u706336c6-563b-4dcd-8d2a-c19ff979feb&title=)<br />但是这里有一个问题，如果有多重继承或者多重依赖时在这里是可能会无法被完全解析的，比如说三个映射文件互相依赖，那么if里面(假设是最坏情况)只能加载1个，失败2个，然后走到下面if之外的代码又只能加载1个，还有1个会失败(如下代码中，只会处理1次，再次失败并不会继续加入`incompleteResultMaps`)：<br />当然，这个还是会被解析的，后面执行查询的时候会再次通过不断遍历去全部解析完毕，不过有一点需要注意的是，互相引用这种是会导致解析失败报错的，所以在开发过程中应该避免循环依赖的产生。<br />6、解析完映射文件之后，调用自身方法`bindMapperForNamespace`，开始绑定Mapper接口和映射文件：<br />![2022-09-29-09-42-36.197867900.png](https://cdn.nlark.com/yuque/0/2022/png/396745/1664417153593-51f8994c-a775-4959-ad72-69e3b9b93e64.png#clientId=ufbeb28e4-ea8a-4&errorMessage=unknown%20error&from=ui&id=ud7e5de23&originHeight=453&originWidth=1080&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1470625&status=error&style=none&taskId=u072bf1ff-4ccf-4698-8be9-657b06baeb0&title=)<br />7、调用`Configuration`对象的`addMapper`<br />![2022-09-29-09-42-36.532657400.png](https://cdn.nlark.com/yuque/0/2022/png/396745/1664417152000-02576d8e-c427-41bc-a45b-e45060ce11aa.png#clientId=ufbeb28e4-ea8a-4&errorMessage=unknown%20error&from=ui&id=cIkIL&originHeight=185&originWidth=571&originalType=binary&ratio=1&rotation=0&showTitle=false&size=18635&status=error&style=none&taskId=u4864c09b-9173-412e-8452-9b49e73a8ec&title=)<br />8、调用`Configuration`对象的属性`MapperRegistry`内的`addMapper`方法，这个方法就是正式将Mapper接口添加到`knownMappers`，所以上面`getMapper`可以直接获取：<br />![2022-09-29-09-42-36.682373700.png](https://cdn.nlark.com/yuque/0/2022/png/396745/1664417153487-a8ac708a-76a3-471b-a0ec-510cec6d31c3.png#clientId=ufbeb28e4-ea8a-4&errorMessage=unknown%20error&from=ui&id=ErOt2&originHeight=418&originWidth=1022&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1284157&status=error&style=none&taskId=u220bc8f3-e3d2-4b0a-89f9-6a036b6e75b&title=)<br />到这里就完成了Mapper接口和xml映射文件的绑定 <br />9、注意上面红框里面的代码，又调用了一次`parse`方法，这个`parse`方法主要是解析注解，比如下面的语句：
```java
@Select("select * from lw_user")
List<LwUser> listAllUser();
```
所以这个方法里面会去解析`@Select`等注解，需要注意的是，parse方法里面会同时再解析一次xml映射文件，因为上面提到了`mappers`节点有4种配置方式，其中两种配置的是`Mapper`接口，而配置Mapper接口会直接先调用`addMapper`接口，并没有解析映射文件，所以进入注解解析方法parse之中会需要再尝试解析一次XML映射文件。![2022-09-29-09-42-36.966920200.png](https://cdn.nlark.com/yuque/0/2022/png/396745/1664417265082-d545a4d5-4a07-4a02-a181-6eb3da6676df.png#clientId=ufbeb28e4-ea8a-4&errorMessage=unknown%20error&from=ui&id=u7ecd064b&originHeight=520&originWidth=1080&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1688119&status=error&style=none&taskId=ufae15ea2-4e3d-441c-a14b-d96f82c940e&title=)<br />解析完成之后，还会对`Mapper`接口中的方法进行解析，并将每个方法的全限定类名作为key存入存入`Configuration`中的`mappedStatements`属性。<br />需要指出的是，这里存储的时候，同一个value会存储2次，一个全限定名作为key，另一个就是只用方法名(sql语句的id)来作为key：<br />![2022-09-29-09-42-37.322496600.png](https://cdn.nlark.com/yuque/0/2022/png/396745/1664417264898-b92ec8c4-eb83-4f08-9851-bbd72fc1dce7.png#clientId=ufbeb28e4-ea8a-4&errorMessage=unknown%20error&from=ui&id=jaJBs&originHeight=466&originWidth=1034&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1448414&status=error&style=none&taskId=u4281442a-49a2-48a3-b4ac-a98af3fb047&title=)<br />所以最终`mappedStatements`会是下面的情况：<br />![2022-09-29-09-42-37.516056400.png](https://cdn.nlark.com/yuque/0/2022/png/396745/1664417263058-2d152ced-23f5-48d3-be23-e339cf4d3ce1.png#clientId=ufbeb28e4-ea8a-4&errorMessage=unknown%20error&from=ui&id=VvaUi&originHeight=186&originWidth=844&originalType=binary&ratio=1&rotation=0&showTitle=false&size=30639&status=error&style=none&taskId=u960751f7-f3a4-452c-9c2b-a7c054aaf26&title=)<br />事实上如果通过接口的方式来编程的话，最后来`getStatement`的时候，都是根据全限定名来取的，所以即使有重名也没有影响，而之所以要这么做的原因其实还是为了兼容早期版本的用法，那就是不通过接口，而是直接通过方法名的方式来进行查询：
```java
session.selectList("com.lonelyWolf.mybatis.mapper.UserMapper.listAllUser");
```
这里如果shortName没有重复的话，是可以直接通过简写来查询的：
```java
session.selectList("listAllUser");
```

但是通过简写来查询一旦shortName重复了就会抛出以下异常：<br />![2022-09-29-09-42-37.695847000.png](https://cdn.nlark.com/yuque/0/2022/png/396745/1664417322343-90472812-23f0-4421-94fe-c4627cc339e5.png#clientId=ufbeb28e4-ea8a-4&errorMessage=unknown%20error&from=ui&id=ueba393c3&originHeight=175&originWidth=1080&originalType=binary&ratio=1&rotation=0&showTitle=false&size=568172&status=error&style=none&taskId=u99b1ceb4-02db-41ff-94a2-e136bfaf6db&title=)<br />这里的异常其实就是`StrickMap`的`get`方法抛出来的：<br />![2022-09-29-09-42-37.924862200.png](https://cdn.nlark.com/yuque/0/2022/png/396745/1664417322837-6991adb7-5a20-4709-9241-4681158c2c80.png#clientId=ufbeb28e4-ea8a-4&errorMessage=unknown%20error&from=ui&id=fYPCL&originHeight=344&originWidth=1019&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1053732&status=error&style=none&taskId=u11b64e56-e3a3-43d0-83d8-c9aaa178b98&title=)
<a name="ivSvm"></a>
## sql执行流程分析
上面讲到了，获取到的Mapper接口实际上被包装成为了代理对象，所以执行查询语句肯定是执行的代理对象方法，接下来就以Mapper接口的代理对象MapperProxy来分析一下查询流程。<br />整个sql执行流程可以分为两大步骤：<br />一、寻找sql <br />二、执行sql语句
<a name="ygswh"></a>
## 寻找sql
首先还是来看一下寻找sql语句的时序图：<br />![2022-09-29-09-42-38.149918700.png](https://cdn.nlark.com/yuque/0/2022/png/396745/1664417352723-dcccafc1-e69d-4368-84c4-06148ee283b0.png#clientId=ufbeb28e4-ea8a-4&errorMessage=unknown%20error&from=ui&id=ue61a7ce0&originHeight=459&originWidth=581&originalType=binary&ratio=1&rotation=0&showTitle=false&size=801869&status=error&style=none&taskId=u630c947b-2a07-4770-ac6f-2e4b91feff7&title=)<br />1、了解代理模式的应该都知道，调用被代理对象的方法之后实际上执行的就是代理对象的invoke方法<br />![2022-09-29-09-42-38.235365300.png](https://cdn.nlark.com/yuque/0/2022/png/396745/1664417353118-f30db9db-578e-449c-a8cc-201c0f972c46.png#clientId=ufbeb28e4-ea8a-4&errorMessage=unknown%20error&from=ui&id=JempX&originHeight=385&originWidth=883&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1021977&status=error&style=none&taskId=u1a0a1a53-7ecc-479b-bcdd-059349d9c17&title=)<br />2、因为这里并没有调用Object类中的方法，所以肯定走的else。else中会继续调用`MapperProxy`内部类`MapperMethodInvoker`中的方法`cachedInvoker`，这里面会有一个判断，判断一下是不是`default`方法，因为Jdk1.8中接口中可以新增`default`方法，而`default`方法是并不是一个抽象方法，所以也需要特殊处理（刚开始会从缓存里面取)）。<br />![2022-09-29-09-42-38.448820700.png](https://cdn.nlark.com/yuque/0/2022/png/396745/1664417354204-84fb6935-a1db-4aae-8ce8-a20a5730c29f.png#clientId=ufbeb28e4-ea8a-4&errorMessage=unknown%20error&from=ui&id=s6IZs&originHeight=586&originWidth=1066&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1877719&status=error&style=none&taskId=u3b1e38c1-cb99-475d-9a4f-f861552d5ad&title=)<br />3、接下来，是构造一个`MapperMethod`对象，这个对象封装了Mapper接口中对应的方法信息以及对应的sql语句信息：<br />![2022-09-29-09-42-38.835975500.png](https://cdn.nlark.com/yuque/0/2022/png/396745/1664417607651-d6d87c52-2f66-47ec-9cde-048c24def2d3.png#clientId=ufbeb28e4-ea8a-4&errorMessage=unknown%20error&from=ui&id=ub0f5b019&originHeight=449&originWidth=848&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1144632&status=error&style=none&taskId=u3dcfdb4a-3006-42e8-b6fc-a49932096cf&title=)<br />这里面就会把要执行的sql语句，请求参数，方法返回值全部解析封装成`MapperMethod`对象，然后后面就可以开始准备执行sql语句了
<a name="Vp6vL"></a>
## 执行sql语句
还是先来看一下执行Sql语句的时序图：<br />![2022-09-29-09-42-41.695683800.png](https://cdn.nlark.com/yuque/0/2022/png/396745/1664417608149-696a73bc-96fd-4e47-8da9-228b9eb9b39e.png#clientId=ufbeb28e4-ea8a-4&errorMessage=unknown%20error&from=ui&id=u13eb266e&originHeight=504&originWidth=856&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1296951&status=error&style=none&taskId=u8ebc4d29-c72b-4809-bb17-82687e3cab5&title=)<br />1、继续上面的流程进入`execute`方法：<br />![2022-09-29-09-42-41.913546200.png](https://cdn.nlark.com/yuque/0/2022/png/396745/1664417607906-6143091c-129e-4990-9d01-20da7928cbb1.png#clientId=ufbeb28e4-ea8a-4&errorMessage=unknown%20error&from=ui&id=aaAy4&originHeight=413&originWidth=937&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1163307&status=error&style=none&taskId=u182d968d-8ec2-4ce8-802e-59f809297fe&title=)<br />2、这里面会根据语句类型以及返回值类型来决定如何执行，本人这里返回的是一个集合，故而进入`executeForMany`方法：<br />![2022-09-29-09-42-42.440798500.png](https://cdn.nlark.com/yuque/0/2022/png/396745/1664417650757-d22370f7-b2f3-4de4-8d3a-70d5b32e7c78.png#clientId=ufbeb28e4-ea8a-4&errorMessage=unknown%20error&from=ui&id=u485fbe59&originHeight=423&originWidth=791&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1005905&status=error&style=none&taskId=uc07755f4-bc16-48ff-b5a6-e4c3713b1cf&title=)<br />3、这里面首先会将前面存好的参数进行一次转换，然后绕了这么一圈，回到了起点`SqlSession`对象，继续调用`selectList`方法：<br />![2022-09-29-09-42-42.811007100.png](https://cdn.nlark.com/yuque/0/2022/png/396745/1664417650754-b2b39e9d-87a8-429a-86b4-e29cd3df548f.png#clientId=ufbeb28e4-ea8a-4&errorMessage=unknown%20error&from=ui&id=vYKpY&originHeight=376&originWidth=912&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1030856&status=error&style=none&taskId=u829b30da-8bcd-471b-8835-3f6fd350341&title=)<br />3、接下来又讲流程委派给了`Execute`去执行`query`方法，最终又会去调用`queryFromDatabase`方法：<br />![2022-09-29-09-42-43.144270600.png](https://cdn.nlark.com/yuque/0/2022/png/396745/1664417650885-3e678bd0-aeed-422b-9eb5-44cc2a775120.png#clientId=ufbeb28e4-ea8a-4&errorMessage=unknown%20error&from=ui&id=c1aL2&originHeight=377&originWidth=976&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1106090&status=error&style=none&taskId=uab909f3a-c9ca-4ccf-816e-eff7fa8e5d7&title=)<br />4、到这里之后，终于要进入正题了，一般带了这种do开头的方法就是真正做事的，Spring中很多地方也是采用的这种命名方式：<br />![2022-09-29-09-42-43.402216400.png](https://cdn.nlark.com/yuque/0/2022/png/396745/1664417689018-2ab037fc-8d8f-4a09-b449-eafcfc890121.png#clientId=ufbeb28e4-ea8a-4&errorMessage=unknown%20error&from=ui&id=u4025028d&originHeight=364&originWidth=985&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1077800&status=error&style=none&taskId=uf5546d84-1525-4ffa-82b9-f3fd18b3b10&title=)<br />注意，前面sql语句还是占位符的方式，并没有将参数设置进去，所以这里在`return`上面一行调用`prepareStatement`方法创建`Statement`对象的时候会去设置参数，替换占位符。参数如何设置先跳过，等把流程执行完了在单独分析参数映射和结果集映射。<br />5、继续进入`PreparedStatementHandler`对象的`query`方法，可以看到，这一步就是调用了jdbc操作对象`PreparedStatement`中的`execute`方法，最后一步就是转换结果集然后返回。<br />![2022-09-29-09-42-43.675843600.png](https://cdn.nlark.com/yuque/0/2022/png/396745/1664417687824-d68207ac-a088-4504-8e63-bf28b0a676c8.png#clientId=ufbeb28e4-ea8a-4&errorMessage=unknown%20error&from=ui&id=CBhBh&originHeight=154&originWidth=913&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23455&status=error&style=none&taskId=ubc598e9b-db86-4aef-b971-672782478bf&title=)<br />到这里，整个SQL语句执行流程分析就结束了，中途有一些参数的存储以及转换并没有深入进去，因为参数的转换并不是核心，只要清楚整个数据的流转流程，自己也可以有自己的实现方式，只要存起来最后能重新解析读出来就行。
<a name="Ewaf6"></a>
## 参数映射
现在来看一下上面在执行查询之前参数是如何进行设置的，先进入`prepareStatement`方法：<br />![2022-09-29-09-42-43.792865800.png](https://cdn.nlark.com/yuque/0/2022/png/396745/1664417688761-e9285a76-2265-4811-9628-86d0525122b3.png#clientId=ufbeb28e4-ea8a-4&errorMessage=unknown%20error&from=ui&id=ok9AQ&originHeight=256&originWidth=929&originalType=binary&ratio=1&rotation=0&showTitle=false&size=714966&status=error&style=none&taskId=u354bccc1-88c9-44f2-8b50-8a480b165bc&title=)<br />可以发现，最终是调用了`StatementHandler`中的`parameterize`进行参数设置，接下来这里为了节省篇幅，不会一步步点进去，直接进入设置参数的方法：<br />![2022-09-29-09-42-43.976180900.png](https://cdn.nlark.com/yuque/0/2022/png/396745/1664417750465-9305af03-f287-44ac-8899-c956ceca0484.png#clientId=ufbeb28e4-ea8a-4&errorMessage=unknown%20error&from=ui&id=uf15584b1&originHeight=537&originWidth=982&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1585179&status=error&style=none&taskId=ubc46fbbb-af8c-4e7c-a50b-dbe53b31111&title=)<br />上面的`BaseTypeHandler`是一个抽象类，`setNonNullParameter`并没有实现，都是交给子类去实现，而每一个子类就是对应了数据库的一种类型。下图中就是默认的一个子类`StringTypeHandler`，里面没什么其他逻辑，就是设置参数。<br />![2022-09-29-09-42-44.413861000.png](https://cdn.nlark.com/yuque/0/2022/png/396745/1664417750309-262bc733-85db-4799-aa3a-374e381f89e3.png#clientId=ufbeb28e4-ea8a-4&errorMessage=unknown%20error&from=ui&id=u39623bb1&originHeight=426&originWidth=1080&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1382976&status=error&style=none&taskId=u735d96c7-8f3c-47ee-8f43-6c76f743691&title=)<br />可以看到String里面调用了jdbc中的`setString`方法，而如果是int也会调用`setInt`方法。看到这些子类如果大家之前阅读过前面讲的MyBatis参数配置，应该就很明显可以知道，这些子类就是系统默认提供的一些`typeHandler`。而这些默认的`typeHandler`会默认被注册并和Java对象进行绑定：<br />![2022-09-29-09-42-44.762902900.png](https://cdn.nlark.com/yuque/0/2022/png/396745/1664417952677-aef9f444-1bd6-45e4-9b0d-87e4d652aa17.png#clientId=ufbeb28e4-ea8a-4&errorMessage=unknown%20error&from=ui&id=u3d2ce627&originHeight=451&originWidth=864&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1171406&status=error&style=none&taskId=u61029060-a6a0-4b52-b695-083704875d9&title=)<br />正是因为MyBatis中默认提供了常用数据类型的映射，所以写Sql的时候才可以省略参数映射关系，可以直接采用下面的方式，系统可以根据参数的类型，自动选择合适的`typeHander`进行映射：
```sql
select user_id,user_name from lw_user where user_name=#{userName}
```
上面这条语句实际上和下面这条是等价的：
```sql
select user_id,user_name from lw_user where user_name=#{userName,jdbcType=VARCHAR}
```
或者说可以直接指定`typeHandler`：
```sql
select user_id,user_name from lw_user where user_name=#{userName,jdbcType=VARCHAR,typeHandler=org.apache.ibatis.type.IntegerTypeHandler}
```
这里因为配置了`typeHandler`，所以会优先以配置的`typeHandler`为主不会再去读取默认的映射，如果类型不匹配就会直接报错了：<br />![2022-09-29-09-42-45.064868000.png](https://cdn.nlark.com/yuque/0/2022/png/396745/1664417951788-dee4d511-b8cb-4814-928b-3eeec38dd174.png#clientId=ufbeb28e4-ea8a-4&errorMessage=unknown%20error&from=ui&id=OxAHX&originHeight=159&originWidth=1080&originalType=binary&ratio=1&rotation=0&showTitle=false&size=116692&status=error&style=none&taskId=u378905bc-858e-4c49-ab18-0e490f80b57&title=)<br />看到这里很多人应该就知道了，如果自己自定义一个`typeHandler`，然后就可以配置成自己的自定义类。所以接下来看看如何自定义一个`typeHandler`<br />自定义`typeHandler` 自定义`typeHandler`需要实现`BaseTypeHandler`接口，`BaseTypeHandler`有4个方法，包括结果集映射，为了节省篇幅，代码没有写上来：
```java
public class MyTypeHandler extends BaseTypeHandler<String> {
    @Override
    public void setNonNullParameter(PreparedStatement preparedStatement, int index, String param, JdbcType jdbcType) throws SQLException {
        System.out.println("自定义typeHandler生效了");
        preparedStatement.setString(index,param);
    }
}
```
然后改写一下上面的查询语句：
```sql
select user_id,user_name from lw_user where user_name=#{userName,jdbcType=VARCHAR,typeHandler=com.lonelyWolf.mybatis.typeHandler.MyTypeHandler}
```
然后执行，可以看到，自定义的typeHandler生效了：<br />![2022-09-29-09-42-45.674898700.png](https://cdn.nlark.com/yuque/0/2022/png/396745/1664417951757-f61fc038-f364-4207-a23a-0f8116e155e7.png#clientId=ufbeb28e4-ea8a-4&errorMessage=unknown%20error&from=ui&id=HEeR9&originHeight=188&originWidth=824&originalType=binary&ratio=1&rotation=0&showTitle=false&size=24534&status=error&style=none&taskId=udc3ed6d5-ad8b-4506-806b-b487e66c7d9&title=)
<a name="TMuP4"></a>
## 结果集映射
接下来看看结果集的映射，回到上面执行sql流程的最后一个方法：
```java
resultSetHandler.handleResultSets(ps)
```
结果集映射里面的逻辑相对来说还是挺复杂的，因为要考虑到非常多的情况，这里就不会去深究每一个细节，直接进入到正式解析结果集的代码，下面的5个代码片段就是一个简单的但是完整的解析流程：<br />![2022-09-29-09-42-46.046431100.png](https://cdn.nlark.com/yuque/0/2022/png/396745/1664418100416-e8176dbc-3c09-4bea-933e-5b50204bf09a.png#clientId=ufbeb28e4-ea8a-4&errorMessage=unknown%20error&from=ui&id=u1fbc39e8&originHeight=288&originWidth=973&originalType=binary&ratio=1&rotation=0&showTitle=false&size=842393&status=error&style=none&taskId=u110b6524-2b34-4c64-91de-23264780964&title=)![2022-09-29-09-42-46.175082900.png](https://cdn.nlark.com/yuque/0/2022/png/396745/1664418101414-ee3f478d-a561-4e6e-9052-b90d5aead148.png#clientId=ufbeb28e4-ea8a-4&errorMessage=unknown%20error&from=ui&id=u0ab5194b&originHeight=396&originWidth=1003&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1193969&status=error&style=none&taskId=ua02a56fd-b901-4ed2-b18f-37ab4d959db&title=)![2022-09-29-09-42-46.493946100.png](https://cdn.nlark.com/yuque/0/2022/png/396745/1664418101954-e8a232c2-1929-4073-9cf3-bd2075440f47.png#clientId=ufbeb28e4-ea8a-4&errorMessage=unknown%20error&from=ui&id=u0d462fd3&originHeight=468&originWidth=994&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1398383&status=error&style=none&taskId=ua3a767c4-d390-4284-b092-17d0ed62943&title=)![2022-09-29-09-42-46.827864800.png](https://cdn.nlark.com/yuque/0/2022/png/396745/1664418102408-ec7f0feb-f692-4601-8e5d-9a6319ed64ac.png#clientId=ufbeb28e4-ea8a-4&errorMessage=unknown%20error&from=ui&id=u0b260b90&originHeight=591&originWidth=976&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1733915&status=error&style=none&taskId=u674691b9-fa94-43f5-97cb-f43fee1667c&title=)![2022-09-29-09-42-47.185572700.png](https://cdn.nlark.com/yuque/0/2022/png/396745/1664418101664-95e0e4bf-a270-4bb7-af92-98570ec0c09c.png#clientId=ufbeb28e4-ea8a-4&errorMessage=unknown%20error&from=ui&id=u1fa2093b&originHeight=426&originWidth=962&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1231931&status=error&style=none&taskId=ua9caad90-25b6-4429-809d-a7f0997052b&title=)<br />从上面的代码片段也可以看到，实际上解析结果集还是很复杂的，就如复杂查询一样，一个查询可以不断嵌套其他查询，还有延迟加载等等一些复杂的特性的处理，所以逻辑分支是有很多，但是不管怎么处理，最后的核心还是上面的一套流程，最终还是会调用`typeHandler`来获取查询到的结果。<br />这个就是上面映射参数的`typeHandler`，因为`typeHandler`里面不只是一个设置参数方法，还有获取结果集方法(上面设置参数的时候省略了)。
<a name="curwN"></a>
## 自定义`typeHandler`结果集
所以说还是用上面那个`MyTypeHandler `例子来重写一下取值方法(省略了设置参数方法)：
```java
public class MyTypeHandler extends BaseTypeHandler<String> {
    /**
 * 设置参数
 */
    @Override
    public void setNonNullParameter(PreparedStatement preparedStatement, int index, String param, JdbcType jdbcType) throws SQLException {
        System.out.println("设置参数->自定义typeHandler生效了");
        preparedStatement.setString(index,param);
    }
    /**
 * 根据列名获取结果
 */
    @Override
    public String getNullableResult(ResultSet resultSet, String columnName) throws SQLException {
        System.out.println("根据columnName获取结果->自定义typeHandler生效了");
        return resultSet.getString(columnName);
    }

    /**
 * 根据列的下标来获取结果
 */
    @Override
    public String getNullableResult(ResultSet resultSet, int columnIndex) throws SQLException {
        System.out.println("根据columnIndex获取结果->自定义typeHandler生效了");
        return resultSet.getString(columnIndex);
    }

    /**
 * 处理存储过程的结果集
 */
    @Override
    public String getNullableResult(CallableStatement callableStatement, int columnIndex) throws SQLException {
        return callableStatement.getString(columnIndex);
    }
}
```
改写Mapper映射文件配置：
```xml
<resultMap id="MyUserResultMap" type="lwUser">
    <result column="user_id" property="userId" jdbcType="VARCHAR" typeHandler="com.lonelyWolf.mybatis.typeHandler.MyTypeHandler" />
    <result column="user_name" property="userName" jdbcType="VARCHAR" />
</resultMap>
```
执行之后输出如下：<br />![2022-09-29-09-42-47.491591700.png](https://cdn.nlark.com/yuque/0/2022/png/396745/1664418199170-f501074d-bfbc-4285-a29c-3d8665bc65cc.png#clientId=ufbeb28e4-ea8a-4&errorMessage=unknown%20error&from=ui&id=u2edbe870&originHeight=257&originWidth=808&originalType=binary&ratio=1&rotation=0&showTitle=false&size=624316&status=error&style=none&taskId=ud8676b3b-2840-42b5-8bf0-ab152281fcb&title=)<br />因为属性上面只配置了一个属性，所以只输出了一次。
<a name="wACem"></a>
## 工作流程图
上面介绍了代码的流转，可能绕来绕去有点晕，所以来画一个主要的对象之间流程图来更加清晰的展示一下MyBatis主要工作流程：<br />![2022-09-29-09-42-47.599648700.png](https://cdn.nlark.com/yuque/0/2022/png/396745/1664418126137-2f023aeb-ebe0-4d11-b89e-f056e77bda45.png#clientId=ufbeb28e4-ea8a-4&errorMessage=unknown%20error&from=ui&id=XC6Df&originHeight=501&originWidth=678&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1021262&status=error&style=none&taskId=u299bf3f1-acf0-40fe-a6ab-b48f6c30ae3&title=)<br />从上面的工作流程图上可以看到，SqlSession下面还有4大对象，这4大对象也很重要，后面学习拦截器的时候就是针对这4大对象进行的拦截。
<a name="gxRNU"></a>
## 总结
本文主要分析了MyBatis的SQL执行流程。在分析流程的过程中，也举例论证了如何自定义`typeHandler`来实现自定义的参数映射和结果集映射，不过MyBatis中提供的默认映射其实可以满足大部分的需求，如果对某些属性需要特殊处理，那么就可以采用自定义的`typeHandle`来实现，相信如果本文如果读懂了，以下几点大家应该至少会有一个清晰的认识：<br />1、Mapper接口和映射文件是如何进行绑定的 <br />2、MyBatis中SQL语句的执行流程 <br />3、自定义MyBatis中的参数设置处理器`typeHandler `<br />4、自定义MyBatis中结果集处理器`typeHandler`<br />当然，其中很多细节并没有提到，而看源码也并不需要追求每一行代码都能看懂，就比如一个稍微复杂一点的业务系统，即使是项目开发者如果某一个模块不是本人负责的，恐怕也很难搞清楚每一行代码的含义。所以对于MyBatis及其他框架的源码中也是一样，首先应该从大局入手，掌握整体流程和设计思想，然后如果对某些实现细节感兴趣，再深入进行了解。
