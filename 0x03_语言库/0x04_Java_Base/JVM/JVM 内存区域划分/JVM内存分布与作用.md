JVM<br />先放一张内存区域的图，方便后面介绍的时候可以对照着看。<br />「须知」当前JDK版本为JDK8。<br />![](https://cdn.nlark.com/yuque/0/2021/png/396745/1622956039381-17d2eb3b-fca0-4b8a-a7bd-a63938a96952.png#clientId=ubfacbd30-d658-4&from=paste&id=u5bc40528&originHeight=392&originWidth=668&originalType=url&ratio=3&status=done&style=shadow&taskId=uad85311f-f1b7-4576-93b1-57a279fa29b)<br />Java内存区域图
<a name="BRa0r"></a>
## 程序计数器
首先它是线程私有的，它也称为代码的行号指示器，字节码解释器就是通过改变程序计数器的位置来确定下一行要执行的代码，它不存在OOM。<br />如果线程正在执行一个Java方法，那么它记录的是正在执行虚拟机字节码指令的地址，如果是一个本地方法那么它的值为空。
<a name="ubqVn"></a>
## Java虚拟机栈
它也是线程私有的，它的声明周期和线程一致。每个线程创建时都会创建一个虚拟机栈，内部保存了一个个的栈帧，每个栈帧就对应着一次方法的调用。既然知道了虚拟机栈里面存放的是一个个的栈帧，那么也不难猜出虚拟机栈里面都存储了什么东西。<br />Java虚拟机栈是存在OOM的，当线程所请求的栈的深度大于虚拟机栈的深度或者虚拟机栈可以动态扩容，当栈扩展时无法申请到足够的内存时，就会抛出OOM。

- 「虚拟机栈内部结构」：

![](https://cdn.nlark.com/yuque/0/2021/png/396745/1622956039395-a82597c2-1b18-4f07-a54d-aa248ae67644.png#clientId=ubfacbd30-d658-4&from=paste&id=ud5e447af&originHeight=454&originWidth=455&originalType=url&ratio=3&status=done&style=shadow&taskId=u1cedca5a-3e32-4d1f-9ff8-7658d1b2e57)<br />虚拟机栈内部结构

- 「局部变量表」：主要存储方法的参数，所有的基本类型数据和对象地址，以及返回地址类型（return address）。它以变量槽为最小的存储单位，Java虚拟机并没有规定一个变量槽占用多少内存空间，但是规定了一个变量槽可以存放一个32位以内的数据类型。如果存储的数据类型超过32位，比如long、double，那么就使用两个变量槽进行存储。
- 「操作数栈」：操作数栈是一个先进后出的操作数栈，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的，它主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。如果被调用的方法有返回值，那么返回值将会被压入当前栈帧的操作数栈中。操作数栈并非采用索引的方式进行数据访问，而是通过入栈（push）和出栈（pop）操作来完成数据的访问。
- 「动态链接」：大白话就是，栈帧中保存了一个方法的引用，当执行方法的时候，可以拿着这个引用到运行时常量池中找到这个方法。动态链接的作用就是将这些方法的符号引用转换为调用方法的直接引用。
- 「方法返回地址」：就是在方法执行结束之后，要返回下一条要执行代码位置的值，也就是程序计数器的值。那么除了方法正常执行结束退出外，还有另外一种情况就是异常导致的方法退出，那么这种情况下是不会返回任何值的。对于抛出的异常，栈帧中不会做任何记录，但是会记录在一个异常表中。
<a name="L6lqy"></a>
## 本地方法栈
Java虚拟机栈为虚拟机执行Java方法服务，本地方法栈则为虚拟机使用到的本地方法服务。像JVM就有好多C语言写的方法，这个就需要本地方法栈来执行。
<a name="qJExy"></a>
## Java堆
Java堆是虚拟机中最大的一块内存空间，它被所有的线程共享，在虚拟机启动时创建。它唯一的目的就是存放对象实例。<br />如果面试被问到，所有的对象实例都是在堆中分配内存吗？这个时候一定要回答，不是。<br />随着即时编译技术的发展进步，尤其是逃逸分析技术的日渐强大，栈上分配、变量替换等优化手段，让实例在“只在堆”中分配不再成为绝对。<br />Java堆是垃圾收集的主要区域，Java堆中也经常出现新生代、老年代、永久代等等，这里需要注意，这些并不是Java堆物理上的内存布局，它是作为垃圾收集器而划分一种内存布局。
<a name="Lc8iH"></a>
## 方法区
方法区也是线程共享的区域，它主要用于存储被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。<br />方法区它是可以被垃圾收集器进行回收的，主要针对类型的卸载和常量池的回收。<br />方法区也可以产生OOM，当方法区无法满足新的内存分配需求时，将抛出OutOfMemoryError异常。
<a name="iadd2"></a>
## 运行时常量池
运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等信息外，还有一项信息是常量池表，它用来存储编译期生成的各种字面量和符号引用。
