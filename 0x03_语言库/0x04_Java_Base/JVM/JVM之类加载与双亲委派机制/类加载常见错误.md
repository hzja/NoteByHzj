Java 类加载
<a name="qC3gL"></a>
## 类加载
类加载的基础知识<br />![2021-05-13-11-19-32-964954.jpeg](https://cdn.nlark.com/yuque/0/2021/jpeg/396745/1620876024695-a9d349e5-ec41-440c-9f44-ef74d524779b.jpeg#clientId=u16d9ec0a-f309-4&from=ui&id=u4e81afac&originHeight=667&originWidth=606&originalType=binary&size=27535&status=done&style=shadow&taskId=uf40db8ef-f530-4510-b323-fbadd3fd1a1)<br />以上是大家比较熟悉的类加载器模型，主要包含 3 种类加载器：

- BootstrapClassloader 根加载器，也就是系统类加载器，加载核心库，如 rt.jar。
- ExtensionClassloader 扩展类加载器，主要加载/ext/下面的 jar 包
- AppClassloader 负责加载 classpath 下的类，开发时候代码大部分由其加载。

此外比较需要知道的几点：

- 一个类是由 jvm 加载是通过类加载器+全限定类名确定唯一性的。
- 双亲委派，众所周知，子加载器会尽量委托给父加载器进行加载，父加载器找不到再自己加载
- 线程上下文类加载，为了满足 spi 等需求突破双亲委派机制，当高层类加载器想加载底层类时通过 `Thread.contextClassLoader` 来获取当前线程的类加载器(往往是底层类加载器)去加载类。
<a name="J02qp"></a>
## ClassNotFoundException
ClassNotFoundException 表示类找不到异常，是一种 Exception，通常发生在载入阶段，当开发者主动调用 `Class.forName()`、`ClassLoader.loadClass()`或 `ClassLoader.findSystemClass()`动态加载指定类时候，类加载器就会去 classpath 下寻找类，如果找不到就会抛出此错误。<br />还有另外一种情况是当一个类已经被某个类加载器加载到内存中，另外一个类加载器试图去加载时也会发生错误。<br />ClassNotFoundException 是一个 exception 类，同时发生在主动执行动态加载时，所以应该去 catch 它，防止发生一些运行时错误。
<a name="qTm0F"></a>
## NoClassDefFoundError
NoClassDefFoundError 是一种和 ClassNotFoundException 很像的错误，只不过它是更严重的 error 类型。它发生在链接阶段，表示 jvm 在编译阶段可以找到相应的类，但在执行过程中却找不到相应的类。<br />一种原因是由于在编译后运行前类被更改或者删除了。另外一种则是 classpath 本身被修改过了，这可以通过`System.getProperty("java.classpath")`来找到程序实际运行的 classpath，或者通过`-classpath` 命令来指定正确的 classpath。<br />那如果是在 ide 中开发，很多时候出现的情况是可以通过 ide 编译通过，但在实际运行的 WEB-INF/lib 下却是没有的。所以排查的时候需要去实际的 war 包下面确定是否有类。
<a name="SLchG"></a>
## NoSuchMethodError
还会遇到 NoSuchMethodError 错误，它表示找不到方法，但找不到方法归根结底是找到了不正确的类。<br />通常情况下是因为 jar 包冲突问题，即加载了不匹配版本的类导致的。例如应用中有 A、B 两个二方包，A 依赖 C-v1 包，而 B 依赖 C-v2 包，如果 maven 仲裁最后使用的是 C-v1 包，那么当 B 加载到 C-v2 中有而 C-v1 中没有的方法时就会报 NoSuchMethodError。<br />这种情况首先得知道 jvm 到底加载的是什么版本，这可以使用`-verbose:class`来确定。
<a name="zaB3I"></a>
## LinkageError
LinkageError 相比较之前几种错误不那么常见，只有多个类加载器同时作用交互时才会出现。另外，<br />jvm 中一个类由全限定类名与类加载器确定类实例，那么不同类加载器加载的同一个类是属于不同类实例的，然后在内存中如果两者发生交互，就会出现 LinkageError 异常。<br />一般情况下，jvm 加载类都会遵循之前所述的双亲委派原则，不太可能出现一个类有不同类加载器加载的情况。但在诸如 tomcat 之类的 javaEE 环境中，常常出这种状况，这是由于 tomcat 上的 web 应用类加载机制稍有不同，每个资源模块（比如一个 war 包）都优先使用自身的资源，突破了双亲委派模型：<br />![2021-05-13-11-19-33-104580.jpeg](https://cdn.nlark.com/yuque/0/2021/jpeg/396745/1620876069990-f908255b-6163-4ee0-8af2-51e952d4e48e.jpeg#clientId=u16d9ec0a-f309-4&from=ui&id=ufbced4e6&originHeight=654&originWidth=606&originalType=binary&size=27364&status=done&style=shadow&taskId=u31054e6a-c248-4389-93b1-a74c24a6f90)<br />当 appClassLoader 加载类时候，会首先在自己的本地资源库中查找类，其次才会走双亲委派模型。那么如果一个类 A 由 AppClassLoaderx 加载，但其超类在 AppClassLoader 中没有，只有委托 CommonClassLoader 才能找到，当类 A 与其超类进行交互时就会报错了。<br />还有一种比较常见的情况是进行自定义类加载器开发时遇到。比如开发类隔离容器时，期望将某些中间件都由与应用不同的独立类加载器加载，但这时候如果中间件依赖 spring context，而应用本身也依赖 spring context，那么 作为 spring bean 交互时候就会妥妥报 LinkageError 了。<br />解决这个问题的办法包括 2 种，即控制不同类加载器加载的类不进行交互，或者都交于一个共同的父加载器进行加载。
<a name="h6xW7"></a>
## Some Tips
总结一下以上几种错误。ClassNotFoundException 以及 NoClassDefFoundError 都是由于加载不到类导致的，而 NoSuchMethodError 是因为加载了不正确的类，LinkageError 则是由于同一个类被多个类加载器加载所导致的。<br />以上这些问题都可以使用arthas进行排查。例如使用 sc 命令来查看 JVM 已加载的类信息，包括从哪个 jar 包读取，由哪个类加载器加载。使用 jad 命令来查看 jvm 中反编译的代码，可以定位到底到底有没有所需 method。以及使用 classloader 命令，来查看当前所有 classloader 的信息，包括加载的 urls，是否能加载到指定的类或者 resources 等。
