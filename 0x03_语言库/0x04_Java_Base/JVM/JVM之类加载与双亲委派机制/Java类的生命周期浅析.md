Java
<a name="IPkJ0"></a>
## 知识前提
在了解类的生命周期之前，有必要先了解一下jvm的内存结构。如下所示：<br />![2021-08-03-09-06-24-819787.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1627952883167-830e47d4-6fed-4e38-98c3-26244c11a691.png#clientId=u408469fc-e860-4&from=ui&id=ua051934e&originHeight=872&originWidth=1076&originalType=binary&ratio=1&size=2820313&status=done&style=shadow&taskId=u2eda3476-0cdf-4adb-9c84-5664a89d13f)<br />在了解完jvm的内存结构之后，就知道了例如堆区，栈区，常量池和方法区等概念。<br />也了解到了，编写的代码，是先需要通过编译的，转化成.class文件，才能够被jvm所加载运行的。那简单来说，java类被jvm进行加载到卸载的过程，就是java类的一生，称之为java类的生命的周期。
<a name="EL1FV"></a>
## 类的生命周期
一个类完整的生命周期，会经历五个阶段，分别为：加载、连接、初始化、使用、和卸载。其中的连接又分为验证、准备和解析三个步骤。如下图所示：<br />也可能会存在加载或连接之后就直接别使用的情况，这里后续讨论<br />![2021-08-03-09-06-25-095819.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1627952891482-88d652d5-a495-43ad-bb5f-3cd48bd344a9.png#clientId=u408469fc-e860-4&from=ui&id=u7cea3332&originHeight=493&originWidth=1080&originalType=binary&ratio=1&size=1600477&status=done&style=shadow&taskId=u53f8a040-b7f5-4093-9c4a-2c642c5d208)<br />也可以说：Java类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using) 和 卸载(Unloading)七个阶段
<a name="qYTY7"></a>
### 加载（Loading）
简单一句话概括，类的加载阶段就是：找到需要加载的类并把类的信息加载到jvm的方法区中，然后在堆区中实例化一个java.lang.Class对象，作为方法区中这个类的信息的入口。结合jvm的内存结构会比较好理解。<br />这里要区别一下接触到的类加载。类加载其实包括加载、连接、初始化三个阶段。类加载强调一个jvm能够直接使用所需的类，所以类必须完成初始化。<br />不同的虚拟机对类的加载时机有不同的实现方式，具体要看虚拟机的实现方式。这里不做展开。<br />类的加载方式比较灵活，总结下来有如下几种：

1. 据类的全路径名找到相应的class文件，然后从class文件中读取文件内容；（常用）
2. 从jar文件中读取。另外，还有下面几种方式也比较常用：（常用）
3. 从网络中获取：比如10年前十分流行的Applet。
4. 根据一定的规则实时生成，比如设计模式中的动态代理模式，就是根据相应的类自动生成它的代理类。
5. 从非class文件中获取，其实这与直接从class文件中获取的方式本质
<a name="dw8To"></a>
### 连接（Linking）

1. 验证：进行类的合法性校验。会对比如字节码格式、变量与方法的合法性、数据类型的有效性、继承与实现的规范性等等进行检查，确保别加载的类能够正常的被jvm所正常运行。
2. 准备：为类的静态变量分配内存，并设为jvm默认的初值；对于非静态的变量，则不会为它们分配内存。简单说就是分内存、赋初值。注意：设置初始值为jvm默认初值，而不是程序设定。规则如下
   - 基本类型（int、long、short、char、byte、boolean、float、double）的默认值为0
   - 引用类型的默认值为null
   - 常量的默认值为程序中设定的值，比如在程序中定义`final static int a = 100`，则准备阶段中a的初值就是100。
3. 解析：这一阶段的任务就是把常量池中的符号引用转换为直接引用。
<a name="jv679"></a>
### 初始化(Initialization)
类初始化阶段是类加载过程的最后一步。而也是到了该阶段，才真正开始执行类中定义的java程序代码(字节码)，之前的动作都由虚拟机主导。<br />jvm对类的加载时机没有明确规范，但对类的初始化时机有：只有当类被直接引用的时候，才会触发类的初始化。类被直接引用的情况有以下几种：

1. 通过以下几种方式：
   - `new`关键字创建对象
   - 读取或设置类的静态变量
   - 调用类的静态方法
2. 通过反射方式执行1里面的三种方式；
3. 初始化子类的时候，会触发父类的初始化；
4. 作为程序入口直接运行时（调用main方法）；
5. 接口实现类初始化的时候，会触发直接或间接实现的所有接口的初始化。

关于类的初始化，记住两句话<br />1、类的初始化，会自上而下运行静态代码块或静态赋值语句，非静态与非赋值的静态语句均不执行。<br />2、如果存在父类，则父类先进行初始化，是一个典型的递归模型。<br />区别于对象的初始化，类的初始化所做的一起都是基于类变量或类语句的，也就是说执行的都是共性的抽象信息。类就是对象实例的抽象。
<a name="FHs9g"></a>
### 使用（Using）
类的使用分为直接引用和间接引用。<br />直接引用与间接引用等判别条件，是看对该类的引用是否会引起类的初始化<br />直接引用已经在类的初始化中的有过阐述，不再赘述。而类的间接引用，主要有下面几种情况：

1. 当引用了一个类的静态变量，而该静态变量继承自父类的话，不引起初始化
2. 定义一个类的数组，不会引起该类的初始化；
3. 当引用一个类的的常量时，不会引起该类的初始化
<a name="Tupga"></a>
### 卸载（(Unloading）
当类使用完了之后，类就要进入卸载阶段了。那何为衡量类使用完的标准呢？

1. 该类所有的实例都已经被回收，也就是java堆中不存在该类的任何实例。
2. 加载该类的ClassLoader已经被回收。
3. 该类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。

如果以上三个条件全部满足，jvm就会在方法区垃圾回收的时候对类进行卸载，类的卸载过程其实就是在方法区中清空类信息，java类的整个生命周期就结束了。
