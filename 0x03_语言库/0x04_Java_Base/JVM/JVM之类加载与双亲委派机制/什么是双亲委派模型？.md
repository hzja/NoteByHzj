Java<br />双亲委派模型是 Java 类加载器的一种工作模式，通过这种工作模式，Java 虚拟机将类文件加载到内存中，这样就保证了 Java 程序能够正常的运行起来。那么双亲委派模型究竟说的是啥呢？接下来一起来看。
<a name="bPioI"></a>
## 1、类加载器
双亲委派模型针对的是 Java 虚拟机中三个类加载器的，这三个类加载器分别是：

1. 启动类加载器（Bootstrap ClassLoader）
2. 扩展类加载器（Extension ClassLoader）
3. 应用程序类加载器（Application ClassLoader）

如下图所示：<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1675432278057-3fef21a8-c700-4ae4-811f-db77fd2aaf3e.png#averageHue=%23f4f0ef&clientId=u3b164da8-058b-4&from=paste&id=u24930661&originHeight=639&originWidth=457&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u08d3f1a0-0ff7-4f44-a401-c260d26df1c&title=)<br />这 3 个类加载器的作用如下。
<a name="mRixV"></a>
### 1.1 启动类加载器
启动类加载器（Bootstrap ClassLoader）是由 C++ 实现的，它是用来加载 <JAVA_HOME>\jre\lib\rt.jar 和 resources.jar 等 jar 包的，如下图所示：![](https://cdn.nlark.com/yuque/0/2023/png/396745/1675432278038-3eaf5099-730d-46ec-be86-a9e8736014ef.png#averageHue=%23f8f8f7&clientId=u3b164da8-058b-4&from=paste&id=ud1e67c08&originHeight=709&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=udd7efaab-5050-41dc-bd71-2dda2b40612&title=)接下来写个代码测试一下 rt 类加载器的打印：
```java
public class ClassLoaderExample {
    public static void main(String[] args) {
        // rt 类下的 ClassLoader 打印
        System.out.println("rt classloader：" + String.class.getClassLoader());
    }
}
```
以上程序的执行结果如下图所示：![](https://cdn.nlark.com/yuque/0/2023/png/396745/1675432278040-d90ca9c8-af8e-4828-ac2d-5092f6ff7921.png#averageHue=%23f6f6f5&clientId=u3b164da8-058b-4&from=paste&id=u1ca712db&originHeight=237&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua9709ffb-d15c-4b2e-9371-deebcfb6f9b&title=)问题来了，为什么打印的不是“Bootstrap ClassLoader”而是 null 呢？这是因为启动类加载器（Bootstrap ClassLoader）是由 C++ 实现的，而这个 C++ 实现的类加载器在 Java 中是没有与之对应的类的，所以拿到的结果是 null。
<a name="tmi6N"></a>
### 1.2 扩展类加载器
扩展类加载器是用来加载 <JAVA_HOME>\jre\lib\ext 目录下 jar 包的，如下图所示：![](https://cdn.nlark.com/yuque/0/2023/png/396745/1675432278049-d695ecaa-897d-4c8f-b076-a213f9bc7a45.png#averageHue=%23fbfbfa&clientId=u3b164da8-058b-4&from=paste&id=u3532e37f&originHeight=709&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ud14af0d6-f72f-4356-b1d1-61f4e2f14cd&title=)接下来使用代码来演示一下 ext 类加载器，示例代码如下：
```java
public class ClassLoaderExample {
    public static void main(String[] args) {
        // ext 类下 classloader 打印
        System.out.println("ext classloader：" +
                sun.net.spi.nameservice.dns.DNSNameService.class.getClassLoader());
    }
}
```
以上程序的执行结果如下图所示：![](https://cdn.nlark.com/yuque/0/2023/png/396745/1675432278047-32f4473d-c054-4f60-b0ee-c2813b208c84.png#averageHue=%23efeeed&clientId=u3b164da8-058b-4&from=paste&id=uab7c76e0&originHeight=359&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uae25a5b1-b4ba-40e6-8eae-b2a63a81abb&title=)
<a name="j7M0P"></a>
### 1.3 应用程序类加载器
应用程序类加载器是用来加载 classpath 也就是用户的所有类的，接下来写代码测试一下应用程序类加载器的打印，实现代码如下：
```java
public class ClassLoaderExample {
    public static void main(String[] args) {
        System.out.println("application classloader：" +
                ClassLoaderExample.class.getClassLoader());
    }
}
```
以上程序的执行结果如下图所示：![](https://cdn.nlark.com/yuque/0/2023/png/396745/1675432278454-047b4b96-bac5-4e74-b8b3-772f2bda17fc.png#averageHue=%23f0efee&clientId=u3b164da8-058b-4&from=paste&id=u91704ce6&originHeight=329&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u3232ae6a-cbe5-4364-b0a5-0bea76b594c&title=)
<a name="Nrze9"></a>
## 2、双亲委派模型
双亲委派模型的执行流程是这样的：<br />1、当加载一个类时，会先从应用程序类加载器的缓存里查找相应的类，如果能找到就返回对象，如果找不到就执行下面流程；<br />2、在扩展加载器缓存中查找相应的类，如果能找到就返回对象，如果找不到就继续下面流程；<br />3、在启动类加载器中查询相应的类，如果找到就返回对象，如果找不到就继续下面流程；<br />4、在扩展加载器中查找并加载类，如果能找到就返回对象，并将对象加入到缓存中，如果找不到就继续下面流程；<br />5、在应用程序类加载器中查找并加载类，如果能找到就返回对象，并将对象加入到缓存中，如果找不到就返回 ClassNotFound 异常。加载流程如下图所示：![](https://cdn.nlark.com/yuque/0/2023/png/396745/1675432278475-74c3fee1-fedc-4d6c-8ca1-fd6460e15faf.png#averageHue=%23f5f3f2&clientId=u3b164da8-058b-4&from=paste&id=ue07b0cd6&originHeight=647&originWidth=759&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uabb6a500-bef2-487b-a11c-31a26da6aed&title=)一般“双亲”指的是“父亲”和“母亲”，而在这里“双亲”指的是类加载类先向上找，再向下找的流程就叫做双亲委派模型。
<a name="iQ7Gh"></a>
## 3、优缺点分析
<a name="waV7w"></a>
### 3.1 优点
双亲委派模型的优点有两个：1、安全。2、避免重复加载。
<a name="h303S"></a>
#### 3.1.1 安全
在安全方面的表现时，当使用双亲委派模型时，用户就不能伪造一些不安全的系统类了，比如 jre 里面已经提供了 String 类在启动类加载时加载，那么用户自定义再自定义一个不安全的 String 类时，按照双亲委派模型就不会再加载用户定义的那个不安全的 String 类了，这样就可以避免非安全问题的发生了。
<a name="rwvlQ"></a>
#### 3.1.2 避免重复加载
使用双亲委派模型也可以避免一个类被重复加载，当一个类被加载之后，因为使用的双亲委派模型，这样不会出现多个类加载器都将同一个类重复加载的情况了。
<a name="CSRYM"></a>
### 3.2 缺点
双亲委派模型的典型问题是加载 SPI 实现类的场景，比如 JNDI（Java Naming and Directory Interface，Java 命名与目录接口）服务，它的代码由启动类加载器去加载(在 JDK 1.3 时放进 rt.jar)，但 JNDI 的目的就是对资源进行集中管理和查找，它需要调用独立厂商实现部部署在应用程序的 classpath 下的 JNDI 接口提供者（SPI, Service Provider Interface）的代码，但启动类加载器不可能“认识”之些代码，这就双亲委派模型的问题，JDBC 也是同样的问题。
<a name="OGDMC"></a>
## 总结
双亲委派模型是和 Java 中多个类加载器（启动类加载器、扩展加载器、应用程序类加载器）的运行规则，通过这个（双亲委派模型）规则可以避免类的非安全问题和类被重复加载的问题，但它也遇到了一些问题，比如 JNDI 和 JDBC 不能通过这个规则进行加载，它需要通过打破双亲委派的模型的方式来加载。
