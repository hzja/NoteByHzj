Java
<a name="L9PdB"></a>
## 什么是自动垃圾回收？
自动垃圾回收是一种在堆内存中找出哪些对象在被使用，还有哪些对象没被使用，并且将后者删掉的机制。<br />所谓使用中的对象（已引用对象），指的是程序中有指针指向的对象；而未使用中的对象（未引用对象），则没有被任何指针给指向，因此占用的内存也可以被回收掉。<br />在用 C 之类的编程语言时，程序员需要自己手动分配和释放内存。而 Java 不一样，它有垃圾回收器，释放内存由回收器负责。本文接下来将介绍垃圾回收机制的基本过程。
<a name="qsaFb"></a>
### 第一步：标记
垃圾回收的第一步是标记。垃圾回收器此时会找出哪些内存在使用中，还有哪些不是。![](https://cdn.nlark.com/yuque/0/2022/jpeg/396745/1647485531632-9ea68a32-a559-4c5f-92a2-5b567bfea44d.jpeg#clientId=ue6d18f0b-0419-4&from=paste&id=u19185e05&originHeight=660&originWidth=1077&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=uec0c9a8f-eb5e-4318-a548-4798a30f8e1&title=)<br />上图中，蓝色表示已引用对象，橙色表示未引用对象。垃圾回收器要检查完所有的对象，才能知道哪些有被引用，哪些没。如果系统里所有的对象都要检查，那这一步可能会相当耗时间。
<a name="Tg6wK"></a>
### 第二步：清除
这一步会删掉标记出的未引用对象。![](https://cdn.nlark.com/yuque/0/2022/jpeg/396745/1647485531638-8768c135-9ba3-483d-a4a2-85f3525f9a58.jpeg#clientId=ue6d18f0b-0419-4&from=paste&id=u74cd809f&originHeight=625&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=u1d8cd81a-57bf-44b2-93b6-14064ab11ac&title=)<br />内存分配器会保留指向可用内存的引用，以供分配新对象。
<a name="skGxM"></a>
### 压缩
为了提升性能，删除了未引用对象后，还可以将剩下的已引用对象放在一起（压缩），这样就能更简单快捷地分配新对象了。![](https://cdn.nlark.com/yuque/0/2022/jpeg/396745/1647485531618-ee887516-027a-4185-b63b-c801d598b65b.jpeg#clientId=ue6d18f0b-0419-4&from=paste&id=u9528498f&originHeight=637&originWidth=1073&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=ue0c8943c-b640-4439-904e-716d94c7193&title=)
<a name="VkoOw"></a>
## 为什么需要分代垃圾收集？
之前说过，逐一标记和压缩 Java 虚拟机里的所有对象非常低效：分配的对象越多，垃圾回收需时就越久。不过，根据统计，大部分的对象，其实用没多久就不用了。<br />来看个例子。（下图中，竖轴代表已分配的字节，而横轴代表程序运行时间）<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1647485531658-00f354ef-f080-4604-9b81-7513ed9a119d.png#clientId=ue6d18f0b-0419-4&from=paste&id=u0aded37f&originHeight=411&originWidth=647&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=u1f611f2f-d29f-4f41-90a3-b37799b8f14&title=)<br />上图可见，存活（没被释放）的对象随运行时间越来越少。而图中左侧的那些峰值，也表明了大部分对象其实都挺短命的。
<a name="L74W4"></a>
### JVM 分代
根据之前的规律，就可以用来提升 JVM 的效率了。方法是，把堆分成几个部分（就是所谓的分代），分别是新生代、老年代，以及永生代。![](https://cdn.nlark.com/yuque/0/2022/jpeg/396745/1647485531652-685f993b-7557-4ecb-8e00-d620fde81306.jpeg#clientId=ue6d18f0b-0419-4&from=paste&id=u379f48f1&originHeight=596&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=u8e9c7a74-cf0e-45c1-a92b-1666616c93e&title=)<br />新对象会被分配在新生代内存。一旦新生代内存满了，就会开始对死掉的对象，进行所谓的小型垃圾回收过程。一片新生代内存里，死掉的越多，回收过程就越快；至于那些还活着的对象，此时就会老化，并最终老到进入老年代内存。<br />Stop the World 事件 —— 小型垃圾回收属于一种叫 "Stop the World" 的事件。在这种事件发生时，所有的程序线程都要暂停，直到事件完成（比如这里就是完成了所有回收工作）为止。<br />老年代用来保存长时间存活的对象。通常，设置一个阈值，当达到该年龄时，年轻代对象会被移动到老年代。最终老年代也会被回收。这个事件成为 Major GC。<br />Major GC 也会触发STW（Stop the World）。通常，Major GC会慢很多，因为它涉及到所有存活对象。所以，对于响应性的应用程序，应该尽量避免Major GC。还要注意，Major GC的STW的时长受年老代垃圾回收器类型的影响。<br />永久代包含JVM用于描述应用程序中类和方法的元数据。永久代是由JVM在运行时根据应用程序使用的类来填充的。此外，Java SE类库和方法也存储在这里。<br />如果JVM发现某些类不再需要，并且其他类可能需要空间，则这些类可能会被回收。
<a name="gLoGm"></a>
## 世代垃圾收集过程
现在已经理解了为什么堆被分成不同的代，现在是时候看看这些空间是如何相互作用的。后面的图片将介绍JVM中的对象分配和老化过程。<br />首先，将任何新对象分配给 eden 空间。两个 survivor 空间都是空的。<br />![](https://cdn.nlark.com/yuque/0/2022/jpeg/396745/1647485532098-362512a7-0d4a-4640-b327-3073ef0530e3.jpeg#clientId=ue6d18f0b-0419-4&from=paste&id=ua1692110&originHeight=616&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=u42e48e8f-266c-4f97-862b-67cde6b3459&title=)<br />当 eden 空间填满时，会触发轻微的垃圾收集。<br />![](https://cdn.nlark.com/yuque/0/2022/jpeg/396745/1647485532123-baad9e51-e9d7-49ae-8749-8d3a648cab6f.jpeg#clientId=ue6d18f0b-0419-4&from=paste&id=u230b17c4&originHeight=612&originWidth=1023&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=u495aacf4-ed59-4345-8d50-58712e9e7e1&title=)<br />引用的对象被移动到第一个 survivor 空间。清除 eden 空间时，将删除未引用的对象。<br />![](https://cdn.nlark.com/yuque/0/2022/jpeg/396745/1647485532137-ab364f9d-8ed9-4b15-9892-ba1bd58c2d73.jpeg#clientId=ue6d18f0b-0419-4&from=paste&id=u173b05c7&originHeight=610&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=uad9effe3-f14e-4dca-a229-29b2c6646b7&title=)<br />在下一次Minor GC中，Eden区也会做同样的操作。删除未被引用的对象，并将被引用的对象移动到Survivor区。然而，这里，他们被移动到了第二个Survivor区（S1）。<br />此外，第一个Survivor区（S0）中，在上一次Minor GC幸存的对象，会增加年龄，并被移动到S1中。待所有幸存对象都被移动到S1后，S0和Eden区都会被清空。注意，Survivor区中有了不同年龄的对象。<br />![](https://cdn.nlark.com/yuque/0/2022/jpeg/396745/1647485532150-e67ac56a-fe01-481c-8e2f-b7c0e86b4035.jpeg#clientId=ue6d18f0b-0419-4&from=paste&id=u6677e46b&originHeight=630&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=u6c4fae41-4ac5-4fa1-8b85-d3ce6511f34&title=)<br />在下一次Minor GC中，会重复同样的操作。不过，这一次Survivor区会交换。被引用的对象移动到S0,。幸存的对象增加年龄。Eden区和S1被清空。<br />![](https://cdn.nlark.com/yuque/0/2022/jpeg/396745/1647485532371-300ffde8-4b06-4c7d-af91-cc23be3ea0c7.jpeg#clientId=ue6d18f0b-0419-4&from=paste&id=u2e19e111&originHeight=654&originWidth=1044&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=ub321c40f-ffd1-4d18-87bd-4ad71c75c74&title=)<br /> 此幻灯片演示了 promotion。在较小的GC之后，当老化的物体达到一定的年龄阈值（在该示例中为8）时，它们从年轻一代晋升到老一代。<br />![](https://cdn.nlark.com/yuque/0/2022/jpeg/396745/1647485532616-dae810aa-d07e-49c3-b9f6-4b766aa6db1e.jpeg#clientId=ue6d18f0b-0419-4&from=paste&id=u29e5df7c&originHeight=693&originWidth=1052&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=ue684598b-222d-4280-9c12-cf90d3003ba&title=)<br />随着较小的GC持续发生，物体将继续被推广到老一代空间。<br />![](https://cdn.nlark.com/yuque/0/2022/jpeg/396745/1647485532745-10900c70-57fb-47e6-ae26-7c9bae1af56c.jpeg#clientId=ue6d18f0b-0419-4&from=paste&id=udb193657&originHeight=738&originWidth=845&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=u7f9dd38d-9de0-47fb-af36-b1cb865fa13&title=)<br />所以这几乎涵盖了年轻一代的整个过程。最终，将主要对老一代进行GC，清理并最终压缩该空间。<br />![](https://cdn.nlark.com/yuque/0/2022/jpeg/396745/1647485532752-102a3c5d-69fe-41cb-be32-d88ac474e13a.jpeg#clientId=ue6d18f0b-0419-4&from=paste&id=uf43758cf&originHeight=765&originWidth=974&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=ud6342652-2a06-46c7-9356-3d7da399b0f&title=)
