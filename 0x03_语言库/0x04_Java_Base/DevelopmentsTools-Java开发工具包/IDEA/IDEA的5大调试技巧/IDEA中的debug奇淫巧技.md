开发过程中，遇到运行结果和预期的不一致的时候，最有效的方法就是debug了。当然随着开发经验的增加，不通过debug直接看代码有时也能定位问题，但是十分依赖经验和运气，本地debug还是最直接和彻底的解决方式。开发的IDE从eclipse转到idea也好几年了，工作中积累了一些debug常用的方法，做个总结，后续有新的姿势了继续来补充。
<a name="RP7Xg"></a>
## debug
idea中，debug非常简单，找到你要断点的地方，鼠标左键点击就会出现一个红色小球，这就打上断点了，用debug方式启动程序后，触发你要debug的方法，就会帮你停在这一行。<br />![普通断点](https://cdn.nlark.com/yuque/0/2023/jpeg/396745/1694137190484-04e23a8a-bef4-4fca-bd6f-8dde87b8313e.jpeg#averageHue=%23383f3c&clientId=u75dd9ea1-0a26-4&from=paste&id=u74cf55dc&originHeight=518&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=u47dde598-f918-4998-8285-f11530c4cfc&title=%E6%99%AE%E9%80%9A%E6%96%AD%E7%82%B9 "普通断点")<br />debug的时候，有各种变量和表达式，有些可能在代码里面并不直接出现，但是对你debug挺重要，这里可以用这个表达式计算器来帮你验证各种表达式的值，不需要自己人工计算。点这个计算器的小图标，然后输入你的表达式，idea就会帮你计算出当前表达式的值。<br />![表达式计算器](https://cdn.nlark.com/yuque/0/2023/jpeg/396745/1694137190457-36b7bb86-34a1-4714-a687-7bab09a83ebd.jpeg#averageHue=%233c4146&clientId=u75dd9ea1-0a26-4&from=paste&id=u682fb77d&originHeight=488&originWidth=1000&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=u2a1d070f-61bc-41da-abac-3850fdc9a55&title=%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%A1%E7%AE%97%E5%99%A8 "表达式计算器")
<a name="WVYiE"></a>
## 条件断点
条件断点是debug中最常用的一个技巧，针对像for循环、递归等同一行代码在同一次触发中会反复进入的情况，如果没有条件断点，循环多少次就要在这个地方停多少次，十分麻烦，循环次数多了几乎在这个地方就无法断点。比例循环10000次，当前运行异常可以断定在6378次出了问题，如果不改代码，在循环中的某一行根本无法去打断点，打了之后就要手动放行6378次才能到，这时候只能通过修改代码，增加第6378次的判断，然后打再新增的代码上才能进去debug。有了条件之后，可以在断点上设置一个boolean表达式的条件，表达式为true的时候，才会在断点处停住。例如上面图片中的例子，i是0~4的循环，可以设置一个条件“i == 3”，这样只有在i == 3的时候，断点才会停住。设置条件断点的方法是，在断点上右键，弹出设置条件的面板，然后在条件中填入你的表达式，效果如下图<br />![条件断点](https://cdn.nlark.com/yuque/0/2023/jpeg/396745/1694137190509-f565a2fd-d2e4-4099-be55-9d22f32ca778.jpeg#averageHue=%23353b35&clientId=u75dd9ea1-0a26-4&from=paste&id=u29a64d8d&originHeight=481&originWidth=1000&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=u138984ba-f157-44a8-a21d-4de1d155fa0&title=%E6%9D%A1%E4%BB%B6%E6%96%AD%E7%82%B9 "条件断点")<br />![条件断点](https://cdn.nlark.com/yuque/0/2023/jpeg/396745/1694137190512-8d0bf519-0d81-4861-8029-caa688b36b3e.jpeg#averageHue=%2339413d&clientId=u75dd9ea1-0a26-4&from=paste&id=u064669eb&originHeight=485&originWidth=1000&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=ue9870eb0-0e21-4340-818e-ad2d5d4a535&title=%E6%9D%A1%E4%BB%B6%E6%96%AD%E7%82%B9 "条件断点")<br />可以注意到，设置了条件断点后，断点icon的右下角会有一个小问号；运行起来后，并不是每次运行到这行代码都会停住，只有在满足i==3的时候，才会停住，这样就可以直接运行到出问题的那个循环。
<a name="BnZeY"></a>
## 单次断点
有些情况下，希望这个断点只生效1次就可以了，那就可以设置一下单次断点。设置的方法是先打开“Breakpoints”（左边侧栏2个红点的图标），找到你的断点，然后勾选上“Remove once hit”就好。<br />![单次断点](https://cdn.nlark.com/yuque/0/2023/jpeg/396745/1694137190505-3074bf32-931e-4c37-bc22-01f7ba07de9e.jpeg#averageHue=%233d4247&clientId=u75dd9ea1-0a26-4&from=paste&id=u0f9eb8eb&originHeight=521&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=u6c4048f5-63be-4fca-8ad2-0365a1ba65f&title=%E5%8D%95%E6%AC%A1%E6%96%AD%E7%82%B9 "单次断点")
<a name="aXBgV"></a>
## 异常断点
这个也是开发中比较常用的一种断点方式。想象是否遇到过这样的场景：运行后报了空指针异常或者其他什么异常，但是当前堆栈信息不够判断是哪一行报的，比较传统的做法是，在方法开始的地方打一个断点，然后一步步跟着往下走，然后看看运行到哪一步会造成异常，如果方法比较长的话，这种方式比较费时。异常断点的意思是，并不直接在某一行设置断点，而是在某一种异常上设置断点，方法运行后，idea会帮你停在造成异常的这一行，这样的话，debug起来效率就高多了。设置异常断点的方法是，先打开“Breakpoints”，点击左上角的“+”，选择到“Java Exception Breakpoints”，然后所搜你想断点的异常，如果是自定义异常，可以选择到“Project”。<br />![异常断点](https://cdn.nlark.com/yuque/0/2023/jpeg/396745/1694137190908-12d162a6-791f-4067-808f-7ae0e4b3aba0.jpeg#averageHue=%233d4246&clientId=u75dd9ea1-0a26-4&from=paste&id=u4185c0c8&originHeight=518&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=u87d49314-7e8f-4ae7-ae53-831c158e9ae&title=%E5%BC%82%E5%B8%B8%E6%96%AD%E7%82%B9 "异常断点")<br />![异常断点](https://cdn.nlark.com/yuque/0/2023/jpeg/396745/1694137191001-7a75fa03-4d70-454a-baa0-431159a6cab0.jpeg#averageHue=%233d4247&clientId=u75dd9ea1-0a26-4&from=paste&id=ud16bebef&originHeight=480&originWidth=1000&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=uf460bb83-1214-4279-a959-f5abb227470&title=%E5%BC%82%E5%B8%B8%E6%96%AD%E7%82%B9 "异常断点")<br />设置完成后，并不会在某一行出现断点的标志，因为运行之前idea也不知道哪一行会抛出这个异常，人造了一个空指针异常来验证，如下图所示<br />![异常断点](https://cdn.nlark.com/yuque/0/2023/jpeg/396745/1694137191003-f92418b8-7b09-4766-98d1-1285f57ddf97.jpeg#averageHue=%233a413f&clientId=u75dd9ea1-0a26-4&from=paste&id=ucb18b1ed&originHeight=478&originWidth=1000&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=u0cdde919-ac1d-46d3-9d5f-68e5c32bf4b&title=%E5%BC%82%E5%B8%B8%E6%96%AD%E7%82%B9 "异常断点")<br />用debug启动后，idea停在了“`s.length()`”这里，这里s是空，所以会抛出空指针异常，这们就能通过异常断点的方式，直接让idea定位到了抛出异常的行。
<a name="C56Xn"></a>
## 强制返回
想象是否遇到过这样的场景：一个方法debug到底10行，已经知道问题了，这时候可能不想执行后面的代码了，因为后面的代码可能有写数据库、有远程调用、有发送消息，如果走了后面的代码后续要再恢复起来会比较麻烦，这时候最常见的操作是直接stop，但是很遗憾，直接stop后，后面的代码还是会被执行到，如下图所示，“这句在for循环之后执行”这句话在debug结束后还是会被打印出来。<br />![](https://cdn.nlark.com/yuque/0/2023/jpeg/396745/1694137190984-a008d2ed-b799-4d8e-9300-d24225bf1647.jpeg#averageHue=%23343a35&clientId=u75dd9ea1-0a26-4&from=paste&id=uf1ac0a9e&originHeight=477&originWidth=1000&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=ue289fb10-332c-432e-bce5-36fc9c2b48b&title=)<br />![](https://cdn.nlark.com/yuque/0/2023/jpeg/396745/1694137191002-8a68a34e-1f99-47e3-9bde-6e2cdd35a1eb.jpeg#averageHue=%23353a35&clientId=u75dd9ea1-0a26-4&from=paste&id=u3237f668&originHeight=478&originWidth=1000&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u9a2b7c99-5549-439b-8123-9fcb4803f46&title=)<br />那有没有办法让后续的代码不被执行呢？这里就可以使用强制返回。在Debug时找到Frames模块，里面找到当前正在debug的方法，右键，选择“Force Return”，这样就可以强制返回了，后面的代码不会被执行到。<br />![强制返回](https://cdn.nlark.com/yuque/0/2023/jpeg/396745/1694137191418-afc72244-a550-4fc0-9b8b-58d1d087e7a3.jpeg#averageHue=%233c4143&clientId=u75dd9ea1-0a26-4&from=paste&id=ua62869dc&originHeight=477&originWidth=1000&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=ucad015ce-c371-44d3-9c34-351a8e51660&title=%E5%BC%BA%E5%88%B6%E8%BF%94%E5%9B%9E "强制返回")<br />如下图效果，就没有打印出“这句在for循环之后执行”，证明后面的代码缺失没有被执行<br />![强制返回](https://cdn.nlark.com/yuque/0/2023/jpeg/396745/1694137191511-dc864aa6-7823-44d9-a01b-08371c0e0a92.jpeg#averageHue=%23333833&clientId=u75dd9ea1-0a26-4&from=paste&id=u835a06e7&originHeight=482&originWidth=1000&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=u7c406a35-2c26-4786-a290-c68d74d7444&title=%E5%BC%BA%E5%88%B6%E8%BF%94%E5%9B%9E "强制返回")<br />PS：有些同学的idea可能默认没有打开frames模块，可以在右边这个小魔方这里选择打开<br />![打开frames模块](https://cdn.nlark.com/yuque/0/2023/jpeg/396745/1694137191477-d74c4328-bfa9-4ab2-869e-6b1eb0d10c41.jpeg#averageHue=%23353b36&clientId=u75dd9ea1-0a26-4&from=paste&id=u677fe84b&originHeight=485&originWidth=1000&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=u83cdaaba-1446-4c9a-a858-e1c9fbac08a&title=%E6%89%93%E5%BC%80frames%E6%A8%A1%E5%9D%97 "打开frames模块")
<a name="IuoQW"></a>
## 抛出异常
有些时候，在调用方法的地方加了try catch，或者用AOP的方式增加了统一的异常捕获，但是某一次在catch模块中处理结果和预期不一致，但是自己有的测试数据都不会发生异常，那就很难debug到catch模块的代码了。这时候可以在方法执行的过程中强制抛出某种异常，这样就可以保证debug到异常捕获的代码。设置的方法跟强制返回类似，选择抛出异常并且在表达式中创建想要抛出的异常即可：<br />![](https://cdn.nlark.com/yuque/0/2023/jpeg/396745/1694137191504-bf2c10bf-a9c0-4cc4-ac0f-9ff0f37fc071.jpeg#averageHue=%233b4146&clientId=u75dd9ea1-0a26-4&from=paste&id=u0be84c6e&originHeight=482&originWidth=1000&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u7811f9e9-2990-4161-b02b-71161e45862&title=)<br />![](https://cdn.nlark.com/yuque/0/2023/jpeg/396745/1694137191540-7feccd3a-af8e-4c2f-bed6-d1c9edcccced.jpeg#averageHue=%233b4145&clientId=u75dd9ea1-0a26-4&from=paste&id=u9a8cc92b&originHeight=485&originWidth=1000&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=ua705c788-03b5-439d-94ca-bf73056a47e&title=)<br />如上图所示，在method1种强制抛出了空指针异常，在main方法的catch中就捕捉到了这个异常，这样就可以继续debug捕捉到异常后的处理逻辑，如下图所示<br />![](https://cdn.nlark.com/yuque/0/2023/jpeg/396745/1694137191834-a7bc330d-f25b-467b-8e18-334073012f44.jpeg#averageHue=%233c4246&clientId=u75dd9ea1-0a26-4&from=paste&id=u0d0f44d9&originHeight=484&originWidth=1000&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u019d1543-8241-4358-960d-0d7bb7ab176&title=)
<a name="DEPEx"></a>
## Drop Frame
在debug过程中，有时候在一步步往下走的时候，F8按快了多走了一步，导致关键的一行没有被停止到，这时候只能重来一次，如果遇到不太容易触发的分支，重来一次的代价是比较大的，有没有办法回溯呢？当然并没有完整的上一步的功能，但是使用drop frame，可以让某个子方法重新走一遍，一定程度上起到了上一步的作用。例如当前在method1种，走到了第2行，但是第1行是关键行，可以drop掉method1这个方法的frame，这样就会回到调用method1的地方，可以再进入一遍。<br />第一次，过了method1的第1行，当前在第2行，选择method1这里的Drop Frame<br />![](https://cdn.nlark.com/yuque/0/2023/jpeg/396745/1694137191859-1fd8ebf8-1b0e-4d8b-b5ae-c30e43949fdc.jpeg#averageHue=%233b4144&clientId=u75dd9ea1-0a26-4&from=paste&id=u09a4a33a&originHeight=482&originWidth=1000&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=ue159f3d3-02a9-41ff-a421-85e3271c9f5&title=)<br />这时候回退到调用menthod1的地方<br />![](https://cdn.nlark.com/yuque/0/2023/jpeg/396745/1694137191916-7a634308-732b-497f-82bf-43e7209af2ea.jpeg#averageHue=%233c4145&clientId=u75dd9ea1-0a26-4&from=paste&id=u04a276a9&originHeight=513&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u3c856489-cd58-4fd5-a614-b9ff17b6d60&title=)<br />可以按F7重新进入method1内部<br />![](https://cdn.nlark.com/yuque/0/2023/jpeg/396745/1694137191903-a8db46d2-5b5c-4d87-9bfb-52ab4eb218ad.jpeg#averageHue=%233c4144&clientId=u75dd9ea1-0a26-4&from=paste&id=u4ff3eca3&originHeight=482&originWidth=1000&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u84556049-e9d9-45f8-b5b6-aa05a0403ab&title=)<br />执行结果后，可以看到method1的第1行的sout确实被执行了2次<br />![](https://cdn.nlark.com/yuque/0/2023/jpeg/396745/1694137192033-1cad3a83-777e-41a2-988d-b1348dc1f151.jpeg#averageHue=%23343935&clientId=u75dd9ea1-0a26-4&from=paste&id=u1558e697&originHeight=482&originWidth=1000&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u60dc52a3-94d0-47aa-959e-595dc2d8fc5&title=)
