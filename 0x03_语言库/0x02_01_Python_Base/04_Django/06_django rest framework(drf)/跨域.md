# 跨域

同源策略会阻止一个域的javascript脚本和另外一个域的内容进行交互。所谓同源（即指在同一个域）就是两个页面具有相同的协议（protocol），主机（host）和端口号（port）



# 目的

同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。

在发送Ajax请求时，如果当前浏览器的URL是a.com，页面中向b.com发送ajax请求，请求可以正常发送，但数据回到浏览器时，浏览器就会阻止



# 限制范围

> 1.  Cookie、LocalStorage 和 IndexDB 无法读取。
> 2.  DOM 无法获得。
> 3.  AJAX 请求不能发送。

**解决思路：**jsonp绕过浏览器的同源策略，通过websocket/cors，正反代理来告诉服务端发起请求的源，由服务端来判断是否同意该请求，发送ajax请求跨域无法获取数据，html中的src不会



# 非AJAX跨域

1. **一级域名相同，二级域名不同的情况下，可以设置document.domain相同，就可以共享cookie**

~~~ python 
Set-Cookie: key=value; domain=.example.com; path=/
~~~

2. **以iframe和window.open方法打开的窗口为例，有三种方法可以跨域**

1. a. url后#片段识别符携带传递参数 通过hashchange方法进行通知

2. b. window.name 不论同源只要在同一个窗口设置了这个属性就可以传参，容量大，但是需要额外监听

3. c. window.postMessage 是H5引入的新的API，window.postMessage(data，target地址)

通过上面的方法也可以读写其他窗口的localStorage



# AJAX跨域

同源政策规定，AJAX请求只能发给同源的网址，否则就报错。除了架设服务器代理（浏览器请求同源服务器，再由后者请求外部服务），有三种方法规避这个限制。

## 方法一 JSONP（仅仅用于get请求）

1. **实现原理**

　　从上面的分析我们已经知道，web页面上请求跨站资源请求是不会受到同源策略限制的，所有我们会想，我们可不可以在服务器上想办法把web端需要的数据装进一个js文件里面，然后让web端直接访问这个js文件，从而获取需要的数据呢？恰巧我们知道有一种叫做json的数据格式，且js原生支持，所以web端就可以通过像访问js脚本一样的方式，来调用跨域服务器上动态生成的js文件。

　　**基本原理：**由于 script 标签不受浏览器同源策略的影响，在html标签中类似script、<img>、<iframe>具有src属性的都不会受跨域的影响，网页通过添加一个script元素，向服务器请求JSON数据，服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。

2. **jsonp实例**

当通过 script 元素调用数据时，响应内容必须用javascript函数名和圆括号包裹起来。而不是发送这样一段JSON数据，这就是JSONP中P的意义所在

~~~ json
$.ajax({
    url:'js/data.js',
    type:'get',
    dataType:'jsonp',
    jsonpCallback:'fnBack'
})
.done(function(data){
    alert(data.name);
})
.fail(function() {
    alert('服务器超时，请重试！');
});

// data.js里面的数据： fnBack({"name":"tom","age":18});
~~~



## 方法二 CORS（跨域资源共享）

 CORS（跨域资源共享）：**本质是设置响应头，**相比JSONP只能发GET请求，CORS允许任何类型的请求。



**实现原理**

1. CORS 通过 HTTP 请求中附带 Origin 的 Header 来表明自己来源域。例如 Origin 的 Header 就是 www.a.com
2. 服务器端接收到这个请求之后，会判断是否允许该来源域的请求。如果允许，服务器在返回的响应中会附带上 Access-Control-Allow-Origin 这个 Header，内容为 www.a.com 来表示允许该次跨域访问。
3. 浏览器根据是否返回了对应的 Header 来决定该跨域请求是否成功。如果是非简单请求，浏览器会先发送一个 OPTIONS 预请求来获取服务器的 CORS 配置，如果服务器不支持接下来的操作，浏览器也会拦截接下来的请求

**劣势**：增加服务器的负担，且访问速度慢



**实例**

1.安装django-cors-headers模块

~~~ python 
pip install django-cors-headers
~~~



2.修改 setting.py

~~~ python 
INSTALLED_APPS = [
    ...
    'corsheaders'
]

MIDDLEWARE = [
    ...
    # 一定要写在CSRF之前，为了方便处理，一般写在最前面
    'corsheaders.middleware.CorsMiddleware'
]
# 跨域增加忽略
CORS_ALLOW_CREDENTIALS = True
CORS_ORIGIN_ALLOW_ALL = True
CORS_ORIGIN_WHITELIST = (
    '*'
)
CORS_ALLOW_METHODS = (
    'DELETE',
    'GET',
    'OPTIONS',
    'PATCH',
    'POST',
    'PUT',
    'VIEW',
)

CORS_ALLOW_HEADERS = (
    'XMLHttpRequest',
    'X_FILENAME',
    'accept-encoding',
    'authorization',
    'content-type',
    'dnt',
    'origin',
    'user-agent',
    'x-csrftoken',
    'x-requested-with',
    'Pragma',
    # token是我自定义的，如果你有也需要在这里写上
    'token',
)
~~~

**注意点:**

- 来源必须标明:ip，端口，协议，而且ip，协议，端口一一对应才能获取
- 当中的127.0.0.1与localhost代表的不是同一个

- - 比如说你选了http://127.0.0.1:1000 你发起请求时http://localhost:1000 数据就没法获得



**或者在b.com中设置一个响应头就可以解决问题。**

~~~ python 
from django.shortcuts import render,HttpResponse

def book(request):
    result = HttpResponse('bbbbbbb')
    result['Access-Control-Allow-Origin'] = "*"
    return result
~~~



## 方法三 Nginx代理跨域

**注意：**真正项目上线之后，使用cors解决跨域时，在nginx上设置响应头即可，因为单独使用django-cors-header无法实现Django静态文件的cors通信

~~~ nginx
upstream devops_api {
    server 127.0.0.1:8081;
}

server {
    listen       81;
    server_name  localhost;
    charset UTF-8;
    access_log /var/log/nginx/django_api_access.log;
    error_log /var/log/nginx/django_api_error.log;
    client_max_body_size 75M;

    location / {
        # 指定允许跨域的方法，*代表所有
        add_header Access-Control-Allow-Methods GET, POST, OPTIONS;
        # 预检命令的缓存，如果不缓存每次会发送两次请求
        add_header Access-Control-Max-Age 3600;
        # 带cookie请求需要加上这个字段，并设置为true
        add_header Access-Control-Allow-Credentials true;
        # 表示允许这个域跨域调用（客户端发送请求的域名和端口） 
        # $http_origin动态获取请求客户端请求的域   不用*的原因是带cookie的请求不支持*号
        add_header Access-Control-Allow-Origin $http_origin;
        # 表示请求头的字段 动态获取
        add_header Access-Control-Allow-Headers 
        $http_access_control_request_headers;
        # OPTIONS预检命令，预检命令通过时才发送请求
        # 检查请求的类型是不是预检命令
        if ($request_method = OPTIONS){
            return 200;
        }
        include uwsgi_params;
        uwsgi_pass devops_api;
        uwsgi_read_timeout 30;
    }
}
~~~

