# 中间件

中间件函数是django框架给我们预留的函数接口，让我们可以干预请求和应答的过程

![1580704773151-9ab33fc8-04c2-44eb-a2b2-e3f15453ac89](D:\Note\python\Django\图片\1580704773151-9ab33fc8-04c2-44eb-a2b2-e3f15453ac89.png)![1581914742751-1494b6fc-09e4-4041-9a40-8b09c20d170f](D:\Note\python\Django\图片\1581914742751-1494b6fc-09e4-4041-9a40-8b09c20d170f.webp)



## 应用场景

1. 做IP限制

​		放在中间件类的列表中，阻止某些IP访问了

2. URL访问过滤

​		如果用户访问的是login视图（放过）

​		如果访问其他视图（需要检测是不是有session已经有了放行，没有返回		login），这样就省得在多个视图函数上写装饰器了！

3. 缓存(CDN)

​		客户端请求来了，中间件去缓存看看有没有数据，有直接返回给用户，		没有再去逻辑层执行视图函数

4. 统一记录日志，错误处理

~~~ python
class CustomException(object):
	def process_exception(self, request, exception):
        '''视图函数发生异常时调用'''
        logger.exception(exception)
        return render_json({'code'=-10006,'message':exception.message})
    
    
另外需要在setting.py添加以下内容:
MIDDLEWARE_CLASSES = (
    'path.CustomException',
~~~

~~~ python
MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]
~~~



## 中间件的顺序问题

`MIDDLEWARE` 的顺序很重要，具有先后关系，因为有些中间件会依赖其他中间件。例如： `AuthenticationMiddleware` 需要在会话中间件中存储的经过身份验证的用户信息，因此它必须在 `SessionMiddleware` 后面运行 。

**在请求阶段，调用视图之前，Django 按照定义的顺序执行中间件** `**MIDDLEWARE**`**，自顶向下。**

你可以把它想象成一个`洋葱`：每个中间件类都是一个“皮层”，它包裹起了洋葱的核心--`实际业务视图`。如果请求通过了洋葱的所有`中间件`层，一直到内核的视图，那么**响应将在返回的过程中以相反的顺序再通过每个中间件层，最终返回给用户**。

**如果某个层的执行过程认为当前的请求应该被拒绝，或者发生了某些错误，导致短路，直接返回了一个响应，那么剩下的中间件以及核心的视图函数都不会被执行。**



## 自定义中间件

### 五大钩子函数

| 钩子函数                  | 执行时机                                          | 执行顺序                                                     | 返回值                     |
| ------------------------- | ------------------------------------------------- | ------------------------------------------------------------ | -------------------------- |
| process_request           | 请求刚到来，执行视图之前                          | 只有一个参数，也就是request请求内容，和视图函数中的request是一样的。所有的中间件都是同样的request，不会发生变化。它的返回值可以是None也可以是HttpResponse对象。返回None的话，表示一切正常，继续走流程，交给下一个中间件处理。返回HttpResponse对象，则发生短路，不继续执行后面的中间件，也不执行视图函数，而将响应内容返回给浏览器。 | None或者HttpResponse对象   |
| process_response          | 视图执行完毕，返回响应时                          | 有两个参数，request和response。request是请求内容，response是视图函数返回的HttpResponse对象。该方法的返回值必须是一个HttpResponse对象，不能是None。process_response()方法在视图函数执行完毕之后执行，并且按配置顺序的逆序执行。 | HttpResponse对象           |
| process_view              | process_request之后，路由转发到视图，执行视图之前 | 请务必牢记：`**process_view()**` **在Django调用真正的业务视图之前被执行，并且以正序执行**。当process_request()正常执行完毕后，会进入urlconf路由阶段，并查找对应的视图，在执行视图函数之前，会先执行`process_view()` 中间件钩子。这个方法必须返回`None` 或者一个 `HttpResponse` 对象。如果返回的是None，Django将继续处理当前请求，执行其它的 `process_view()` 中间件钩子，最后执行对应的视图。如果返回的是一个 `HttpResponse` 对象，Django不会调用业务视图，而是执行响应中间件，并返回结果。 | None或者HttpResponse对象   |
| process_exception         | 视图执行中发生异常时                              | 当一个视图在执行过程中引发了异常，Django将自动调用中间件的 `process_exception()`方法。 `process_exception()` 要么返回一个 `None` ，要么返回一个 `HttpResponse` 对象。如果返回的是`HttpResponse`对象 ，模板响应和响应中间件将被调用 ，否则进行正常的异常处理流程。同样的，此时也是以逆序的方式调用每个中间件的 `process_exception`方法，以短路的机制。 | None或者HttpResponse对象   |
| process_template_response | 视图刚执行完毕，process_response之前              | 正常情况下一个视图执行完毕，会渲染一个模板，作为响应返回给用户。使用这个钩子方法，你可以重新处理渲染模板的过程，添加你需要的业务逻辑。对于 `process_template_response()`方法，也是采用逆序的方式进行执行的。 | 实现了render方法的响应对象 |

~~~ python 
class MiddleWare1(MiddlewareMixin):
    # 重定向方法
    # 处理请求前：request对象产生之后
    def process_request(self, request):
        path = request.path
        if path in login_list:
            if not request.user.is_authenticated:
                # 如果未登陆并请求非login界面，将被重定向
                return redirect(reverse('user:login'))

    # url匹配之后，调用view视图函数之前
    def process_view(self, request, callback,callback_args, callback_kwargs):
        print('callback_args:',callback_args)
        print('callback_kwargs:',callback_kwargs)
        print('------------->view',callback)
        # callback(request,callback_args,callback_kwargs)

    # 调用view视图函数之后，返回response对象之前
    def process_template_response(self):
        pass

    # 处理响应后：视图函数调用之后，所有响应返回浏览器之前被调用，在每个请求上调用
    def process_response(self, request, response):
        return response

    def process_exception(self, request, exception):
        pass
~~~

**结论：**如果注册的多个中间件类中包含process_exception函数的时候，调用的顺序跟注册的顺序是相反的