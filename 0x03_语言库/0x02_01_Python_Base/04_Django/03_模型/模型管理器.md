# 模型管理器

## 作用

objects是Django帮我自动生成的管理器对象，通过这个管理器可以实现对数据的查询。

自定义管理器之后Django不再帮我们生成默认的objects管理器。



## 模型类的属性

属性objects：管理器，是models.Manager类型的对象，用于与数据库进行交互。

> 当没有为模型类定义管理器时，Django会为每一个模型类生成一个名为objects的管理器，自定义管理器后，Django不再生成默认管理器objects。

为模型类BookInfo定义管理器books语法如下：

~~~ python
class BookInfo(models.Model):
    ...
    books = models.Manager()
~~~



## 管理器Manager

管理器是Django的模型进行数据库操作的接口，Django应用的每个模型类都拥有至少一个管理器。Django支持自定义管理器类，继承自models.Manager。



## 自定义管理器类主要用于两种情况

1. 改变查询的结果集，重写all()方法
2. 管理器类中定义一个方法帮我们操作数据表，如向数据库中插入数据。

对模型类对应的数据表进行操作时，推荐将这些操作数据表的方法封装起来，放到模型管理器类中。



**a）打开booktest/models.py文件，定义方法create。**

~~~ python
from django.db import models

# 编写 AddressManager 类来继承 models.Manager
class AddressManager(models.Manager):
    """地址模型管理器"""
    def get_default_address(self, user):
        """获取用户默认收货地址"""
        try:
            address = self.get(user=user, is_default=True)
        except self.model.DoesNotExist:
            address = None

        return address


class Address(BaseModel):
    '''地址模型类'''
    user = models.ForeignKey('User', verbose_name='所属账户')
    receiver = models.CharField(max_length=20, verbose_name='收件人')
    addr = models.CharField(max_length=256, verbose_name='收件地址')
    zip_code = models.CharField(max_length=6, null=True, verbose_name='邮政编码')
    phone = models.CharField(max_length=11, verbose_name='联系电话')
    is_default = models.BooleanField(default=False, verbose_name='是否默认')

    objects = AddressManager()

    class Meta:
        db_table = 'df_address'
        verbose_name = '地址'
        verbose_name_plural = verbose_name
~~~



**b）调用管理器语法如下**

~~~ python
from django.shortcuts import render
from apps.user.models import Address

class UserAddressView(View):
    """用户中心-地址页"""
    def get(self, request):
        """显示地址页"""
        # 调用管理器方法
        address = Address.objects.get_default_address(request.user)
        return render(request, 'user_center_site.html', {'page': 'address', 'address': address})
~~~



## 元选项

在模型类中定义类Meta，用于设置元信息，如使用db_table自定义表的名字。

数据表的默认名称为：

~~~ python
<app_name>_<model_name>
例：
booktest_bookinfo
~~~

**例：指定BookInfo模型类生成的数据表名为bookinfo。**

在BookInfo模型类中添加如下内容，代码如下：

~~~ python
#定义图书模型类BookInfo
class BookInfo(models.Model):
    ...
    #定义元选项
    class Meta:
		db_table='bookinfo' #指定BookInfo生成的数据表名为bookinfo
~~~

