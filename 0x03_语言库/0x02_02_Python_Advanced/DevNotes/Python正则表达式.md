Python 正则表达式
<a name="hZIkk"></a>
## 1. 正则表达式语法
<a name="56lW1"></a>
### 1.1 字符与字符类
<a name="DRndJ"></a>
#### 1.1.1 特殊字符
`.^$?+*{}|`以上特殊字符要想使用字面值，必须使用进行转义
<a name="NWLqH"></a>
#### 1.1.2 字符类
1. 包含在`[]`中的一个或者多个字符被称为字符类，字符类在匹配时如果没有指定量词则只会匹配其中的一个。<br />2. 字符类内可以指定范围，比如`[a-zA-Z0-9]`表示a到z，A到Z，0到9之间的任何一个字符<br />3. 左方括号后跟随一个，表示否定一个字符类，比如`[0-9]`表示可以匹配一个任意非数字的字符。<br />4. 字符类内部，除了之外，其他特殊字符不再具备特殊意义，都表示字面值。放在第一个位置表示否定，放在其他位置表示本身，`-`放在中间表示范围，放在字符类中的第一个字符，则表示-本身。<br />5. 字符类内部可以使用速记法，比如d s w

| 字符 | 含义 | 例子 |
| --- | --- | --- |
| `.` | 匹配任意一个字符 | ab.可以匹配abc或者abd |
| `[]` | 匹配括号中的任意1个字符 | [abcd]可以匹配ab、bc、cd |
| `-` | 在[ ]内表示的字符范围内进行匹配 | [0-9a-fA-F]可以匹配任意一个16进制的数字 |
| `^` | 位于[ ]括号内的开头，匹配除括号中的字符之外的任意1个字符 | [^xy]匹配xy之外的任意一个字符，比如[^xy]1可以匹配A1、B1但是不能匹配x1、y1 |

<a name="qhV50"></a>
#### 1.1.3 速记法
可以匹配除换行符之外的任何字符，如果有re.DOTALL标志，则匹配任意字符包括换行d匹配一个Unicode数字，如果带`re.ASCII`，则匹配0-9D 匹配Unicode非数字s匹配Unicode空白，如果带有`re.ASCII`，则匹配中的一个S 匹配Unicode非空白w匹配Unicode单词字符，如果带有`re.ascii`,则匹配`[a-zA-Z0-9_]`中的一个W 匹配Unicode非单子字符
<a name="Qj4G0"></a>
### 1.2 量词
1. `?`匹配前面的字符0次或1次<br />2. `*`匹配前面的字符0次或多次<br />3. `+`匹配前面的字符1次或者多次<br />4. `{m}`匹配前面表达式`m`次<br />5. `{m,}`匹配前面表达式至少`m`次<br />6. `{,n}`匹配前面的正则表达式最多`n`次<br />7. `{m,n}`匹配前面的正则表达式至少`m`次，最多`n`次注意点：以上量词都是贪婪模式，会尽可能多的匹配，如果要改为非贪婪模式，通过在量词后面跟随一个`?`来实现

| 字符 | 含义 | 例子 |
| --- | --- | --- |
| ？ | 匹配前面紧跟字符的0次或者1次 | [0-9]?，匹配1、2、3 |
| + | 匹配前面紧跟字符的1次或者多次 | [0-9]+，匹配1、12、123等 |
| * | 匹配前面紧跟字符的0次或者多次 | [0-9]*，不匹配或者12、123 |
| {N} | 匹配前面紧跟字符精确到N次 | [1-9][0-9]{2}，匹配100到999的整数，{2}表示[0-9]匹配两个数字 |
| {,M} | 匹配前面紧跟字符<br />**最多**<br />M次 | [0-9]{,1}，指的是最多匹配0-9之间的1个整数，相当于是0次或者1次，等价于[0-9]? |
| {N,M} | 匹配前面紧跟字符的至少N次，最多M次 | `[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}`<br />，匹配IP地址，其中.号是特殊字符，需要使用转义字符\\ |

<a name="O7rWf"></a>
#### 位置相关
| 字符 | 含义 | 例子 |
| --- | --- | --- |
| ^ | 匹配开头的位置；通过<br />`\\A` | `^hello`<br />  匹配<br />`hello`<br />开头的字符内容 |
| $ | 匹配结束的位置同<br />`\\Z` | `;$`<br />  匹配一行结尾的<br />`;`<br />符号   <br />`^$`<br />匹配空行 |
| < | 匹配单词开头的位置 | <th  匹配…this但是不能匹配ethernet等 |
| > | 匹配单词结尾的位置 | p>  匹配leap等，但是不能匹配parent、sleepy等不是p结尾的单词 |
| \\b | 匹配单词开头或结尾的位置 | \\bat 匹配…at…，但是不能匹配cat、atexit、batch（非at开头） |
| \\B | 匹配非单词开头或者结尾的单词 | \\Bat匹配battery，但是不能匹配attend/hat等以at开头的单词 |

<a name="M588B"></a>
#### 特殊字符
| 字符 | 含义 | 例子 |
| --- | --- | --- |
| \\ | 转义字符，保持后面字符的原义，使其不被转义 | `\\.`<br /> 输出. |
| ( ) | 将表达式的一部分括起来，可以对整个单元使用数量限定符，匹配括号中的内容 | `([0-9]{1,3}\\.){3}[0-9]{1,3}`<br />表示将括号内的内容匹配3次 |
| &#124; | 连接两个子表达式，相当于或的关系 | n(o&#124;either)匹配no或者neither |
| \\d | 数字字符 | 相当于是[0-9] |
| \\D | 非数字字符 | 相当于是[^0-9] |
| \\w | 数字字母下划线 | [a-zA-Z0-9_] |
| \\W | 非数字字母下划线，匹配特殊字符 | [^\\w] |
| \\s | 空白区域 | `[\\r\\t\\n\\f]`<br />表格、换行等空白区域 |
| \\S | [^\\s] | 非空白区域 |

<a name="VhNUk"></a>
### 1.3 组与捕获
<a name="DFxVd"></a>
#### 1.3.1 `()`的作用
1. 捕获`()`中正则表达式的内容以备进一步利用处理，可以通过在左括号后面跟随`?:`来关闭这个括号的捕获功能<br />2. 将正则表达式的一部分内容进行组合，以便使用量词或者|
<a name="aqtkC"></a>
#### 1.3.2 反响引用前面`()`内捕获的内容
1. 通过组号反向引用每一个没有使用`?:`的小括号都会分配一个组好，从1开始，从左到右递增，可以通过i引用前面()内表达式捕获的内容<br />2. 通过组名反向引用前面小括号内捕获的内容可以通过在左括号后面跟随`?P<name>`,尖括号中放入组名来为一个组起一个别名，后面通过`(?P=name)`来引用 前面捕获的内容。如`(? P<word>w+)s+(?P=word)`来匹配重复的单词。
<a name="a7ed63ed"></a>
#### 1.3.3 注意点
反向引用不能放在字符类`[]`中使用。
<a name="bQj2r"></a>
### 1.4 断言与标记
断言不会匹配任何文本，只是对断言所在的文本施加某些约束
<a name="865a9bf6"></a>
#### 1.4.1 常用断言
1. 匹配单词的边界，放在字符类[]中则表示backspace<br />2. B 匹配非单词边界，受ASCII标记影响<br />3. A 在起始处匹配<br />4. ^在起始处匹配，如果有MULTILINE标志，则在每个换行符后匹配<br />5. Z 在结尾处匹配<br />6. $在结尾处匹配，如果有MULTILINE标志，则在每个换行符前匹配<br />7. (?=e)正前瞻<br />8. (?!e)负前瞻<br />9. (?<=e)正回顾10.(?<!e)负回顾
<a name="hxSRw"></a>
#### 1.4.2 前瞻回顾的解释前瞻
`exp1(?=exp2) exp1`后面的内容要匹配exp2负前瞻: `exp1(?!exp2) exp1`后面的内容不能匹配exp2后顾: `(?<=exp2)exp1 exp1`前面的内容要匹配exp2负后顾: `(?<!exp2)exp1 exp1`前面的内容不能匹配exp2例如：要查找hello，但是hello后面必须是world，正则表达式可以这样写：`"(hello)s+(?=world)"`,用来匹配"hello wangxing"和"hello world"只能匹配到后者的hello
<a name="2b29V"></a>
### 1.5 条件匹配
`(?(id)yes_exp|no_exp)`:对应id的子表达式如果匹配到内容，则这里匹配yes_exp，否则匹配no_exp
<a name="iMr4L"></a>
### 1.6 正则表达式的标志
<a name="786787eb"></a>
#### 1.6.1. 正则表达式的标志有两种使用方法
1. 通过给compile方法传入标志参数，多个标志使用|分割的方法,如`re.compile(r"#[da-f]{6}"`, `re.IGNORECASE|re.MULTILINE)`<br />2. 通过在正则表达式前面添加(?标志)的方法给正则表达式添加标志，如`(?ms)#[da-z]{6}`
<a name="7SlTO"></a>
#### 1.6.2. 常用的标志
re.A或者re.ASCII， 使 B s S w W d D都假定字符串为假定字符串为ASCIIre.I或者re.IGNORECASE使正则表达式忽略大小写`re.M`或者`re.MULTILINE` 多行匹配，使每个^在每个回车后，每个$在每个回车前匹配re.S或者re.DOTALL 使.能匹配任意字符，包括回车re.X或者re.VERBOSE 这样可以在正则表达式跨越多行，也可以添加注释，但是空白需要使用s或者[ ]来表示，因为默认的空白不再解释。如：re.compile(r"""<imgs +)#标签的开始[^>]*?#不是src的属性src=#src属性的开始(?:(?P<quote>["'])#左引号(?P<image_name>[^>]+?)#图片名字(?P=quote)#右括号""",re.VERBOSE|re.IGNORECASE)
<a name="wKA8N"></a>
## 2. Python正则表达式模块
<a name="KqUuQ"></a>
### 2.1 正则表达式处理字符串主要有四大功能
1. 匹配 查看一个字符串是否符合正则表达式的语法，一般返回true或者false<br />2. 获取正则表达式来提取字符串中符合要求的文本<br />3. 替换查找字符串中符合正则表达式的文本，并用相应的字符串替换<br />4. 分割使用正则表达式对字符串进行分割。
<a name="8a218a3d"></a>
### 2.2 Python中re模块使用正则表达式的两种方法
1. 使用`re.compile(r, f)`方法生成正则表达式对象，然后调用正则表达式对象的相应方法。这种做法的好处是生成正则对象之后可以多次使用。<br />2. re模块中对正则表达式对象的每个对象方法都有一个对应的模块方法，唯一不同的是传入的第一个参数是正则表达式字符串。此种方法适合于只使用一次的正则表达式。
<a name="2d7MQ"></a>
### 2.3 正则表达式对象的常用方法
1. `rx.findall(s,start, end)`:返回一个列表，如果正则表达式中没有分组，则列表中包含的是所有匹配的内容，如果正则表达式中有分组，则列表中的每个元素是一个元组，元组中包含子分组中匹配到的内容，但是没有返回整个正则表达式匹配的内容<br />2. `rx.finditer(s, start, end)`:返回一个可迭代对象对可迭代对象进行迭代，每一次返回一个匹配对象，可以调用匹配对象的`group()`方法查看指定组匹配到的内容，0表示整个正则表达式匹配到的内容<br />3. `rx.search(s, start, end)`:返回一个匹配对象,倘若没匹配到，就返回Nonesearch方法只匹配一次就停止，不会继续往后匹配<br />4. `rx.match(s, start, end)`:如果正则表达式在字符串的起始处匹配，就返回一个匹配对象，否则返回None<br />5. `rx.sub(x, s, m)`:返回一个字符串。每一个匹配的地方用x进行替换，返回替换后的字符串，如果指定m，则最多替换m次。对于x可以使用/i或者/g<id>id可以是组名或者编号来引用捕获到的内容。模块方法`re.sub(r, x, s, m)`中的x可以使用一个函数。此时就可以对捕获到的内容推过这个函数进行处理后再替换匹配到的文本。<br />6. `rx.subn(x, s, m)`:与`re.sub()`方法相同，区别在于返回的是二元组，其中一项是结果字符串，一项是做替换的个数。<br />7. `rx.split(s, m)`:分割字符串返回一个列表用正则表达式匹配到的内容对字符串进行分割如果正则表达式中存在分组，则把分组匹配到的内容放在列表中每两个分割的中间作为列表的一部分，如：`rx = re.compile(r"(d)[a-z]+(d)")``s = "ab12dk3klj8jk9jks5"``result = rx.split(s)`返回`['ab1', '2', '3', 'klj', '8', '9', 'jks5']`<br />8. `rx.flags()`:正则表达式编译时设置的标志<br />9. `rx.pattern()`:正则表达式编译时使用的字符串
<a name="u0vg4"></a>
### 2.4 匹配对象的属性与方法
01. `m.group(g, ...)`返回编号或者组名匹配到的内容，默认或者0表示整个表达式匹配到的内容，如果指定多个，就返回一个元组<br />02. `m.groupdict(default)`返回一个字典。字典的键是所有命名的组的组名，值为命名组捕获到的内容如果有default参数，则将其作为那些没有参与匹配的组的默认值。<br />03. `m.groups(default)`返回一个元组。包含所有捕获到内容的子分组，从1开始，如果指定了default值，则这个值作为那些没有捕获到内容的组的值<br />04. `m.lastgroup()`匹配到内容的编号最高的捕获组的名称，如果没有或者没有使用名称则返回None(不常用)<br />05. `m.lastindex()`匹配到内容的编号最高的捕获组的编号，如果没有就返回None。<br />06. `m.start(g)`当前匹配对象的子分组是从字符串的那个位置开始匹配的,如果当前组没有参与匹配就返回-1<br />07. `m.end(g)`当前匹配对象的子分组是从字符串的那个位置匹配结束的，如果当前组没有参与匹配就返回-1<br />08. `m.span()`返回一个二元组，内容分别是`m.start(g)`和`m.end(g)`的返回值<br />09. `m.re()`产生这一匹配对象的正则表达式<br />10. `m.string()`传递给`match`或者`search`用于匹配的字符串<br />11. `m.pos()`搜索的起始位置。即字符串的开头，或者`start`指定的位置(不常用)<br />12. `m.endpos()`搜索的结束位置。即字符串的末尾位置，或者`end`指定的位置(不常用)
<a name="XVF8P"></a>
### 2.5 总结
1. 对于正则表达式的匹配功能，Python没有返回`true`和`false`的方法，但可以通过对`match`或者`search`方法的返回值是否是None来判断<br />2. 对于正则表达式的搜索功能，如果只搜索一次可以使用`search`或者`match`方法返回的匹配对象得到，对于搜索多次可以使用`finditer`方法返回的可迭代对象来迭代访问<br />3. 对于正则表达式的替换功能，可以使用正则表达式对象的`sub`或者`subn`方法来实现，也可以通过`re`模块方法`sub`或者`subn`来实现，区别在于模块的`sub`方法的替换文本可以使用一个函数来生成<br />4. 对于正则表达式的分割功能，可以使用正则表达式对象的`split`方法，需要注意如果正则表达式对象有分组的话，分组捕获的内容也会放到返回的列表中
<a name="HHfHZ"></a>
## 3. Python中常用正则表达式
<a name="PKUOX"></a>
### 1.邮箱
包含大小写字母，下划线，阿拉伯数字，点号，中划线<br />表达式：<br />`[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(?:\.[a-zA-Z0-9_-]+)`<br />案例：
```python
pattern = re.compile(r"[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(?:\.[a-zA-Z0-9_-]+)")
strs = '我的私人邮箱是zhuwjwh@outlook.com，公司邮箱是123456@qq.org，麻烦登记一下？'
result = pattern.findall(strs)
print(result)
```
```
['zhuwjwh@outlook.com', '123456@qq.org']
```
<a name="VNnIv"></a>
### 2. 身份证号
xxxxxx yyyy MM dd 375 0     十八位

- 地区：[1-9]\d{5}
- 年的前两位：(18|19|([23]\d))       1800-2399
- 年的后两位：\d{2}
- 月份：((0[1-9])|(10|11|12))
- 天数：(([0-2][1-9])|10|20|30|31)          闰年不能禁止29+
- 三位顺序码：\d{3}
- 两位顺序码：\d{2}
- 校验码：[0-9Xx]

表达式：<br />`[1-9]\d{5}(18|19|([23]\d))\d{2}((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d{3}[0-9Xx]`<br />案例：
```python
pattern = re.compile(r"[1-9]\d{5}(?:18|19|(?:[23]\d))\d{2}(?:(?:0[1-9])|(?:10|11|12))(?:(?:[0-2][1-9])|10|20|30|31)\d{3}[0-9Xx]")
strs = '小明的身份证号码是342623198910235163，手机号是13987692110'
result = pattern.findall(strs)
print(result)
```
```
['342623198910235163']
```
<a name="QlR3y"></a>
### 3. 国内手机号码
手机号都为11位，且以1开头，第二位一般为3、5、6、7、8、9 ，剩下八位任意数字<br />例如：13987692110、15610098778<br />表达式：<br />`1(3|4|5|6|7|8|9)\d{9}`<br />案例：
```python
pattern = re.compile(r"1[356789]\d{9}")
strs = '小明的手机号是13987692110，你明天打给他'
result = pattern.findall(strs)
print(result)
```
```
['13987692110']
```
<a name="f6224f58"></a>
### 4. 国内固定电话
区号3~4位，号码7~8位<br />例如：0511-1234567、021-87654321<br />表达式：<br />`\d{3}-\d{8}|\d{4}-\d{7}`<br />案例：
```python
pattern = re.compile(r"\d{3}-\d{8}|\d{4}-\d{7}")
strs = '0511-1234567是小明家的电话，他的办公室电话是021-87654321'
result = pattern.findall(strs)
print(result)
```
```
['0511-1234567', '021-87654321']
```
<a name="nWD2O"></a>
### 5. 域名
包含http:\\或https:\\<br />表达式：<br />`(?:(?:http:\/\/)|(?:https:\/\/))?(?:[\w](?:[\w\-]{0,61}[\w])?\.)+[a-zA-Z]{2,6}(?:\/)`<br />案例：
```python
pattern = re.compile(r"(?:(?:http:\/\/)|(?:https:\/\/))?(?:[\w](?:[\w\-]{0,61}[\w])?\.)+[a-zA-Z]{2,6}(?:\/)")
strs = 'Python官网的网址是https://www.python.org/'
result = pattern.findall(strs)
print(result)
```
```
['https://www.python.org/']
```
<a name="5b6eb4c4"></a>
### 6. IP地址
IP地址的长度为32位(共有2^32个IP地址)，分为4段，每段8位，用十进制数字表示<br />每段数字范围为0～255，段与段之间用句点隔开　<br />表达式：<br />`((?:(?:25[0-5]|2[0-4]\d|[01]?\d?\d)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d?\d))`<br />案例：
```python
pattern = re.compile(r"((?:(?:25[0-5]|2[0-4]\d|[01]?\d?\d)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d?\d))")
strs = '''请输入合法IP地址，非法IP地址和其他字符将被过滤！
增、删、改IP地址后，请保存、关闭记事本！
192.168.8.84
192.168.8.85
192.168.8.86
0.0.0.1
256.1.1.1
192.256.256.256
192.255.255.255
aa.bb.cc.dd'''
result = pattern.findall(strs)
print(result)
```
```
['192.168.8.84', '192.168.8.85', '192.168.8.86', '0.0.0.1', '56.1.1.1', '192.255.255.255']
```
<a name="aadcbd13"></a>
### 7. 日期
常见日期格式：yyyyMMdd、yyyy-MM-dd、yyyy/MM/dd、yyyy.MM.dd<br />表达式：<br />`\d{4}(?:-|\/|.)\d{1,2}(?:-|\/|.)\d{1,2}`<br />案例：
```python
pattern = re.compile(r"\d{4}(?:-|\/|.)\d{1,2}(?:-|\/|.)\d{1,2}")
strs = '今天是2020/12/20，去年的今天是2019.12.20，明年的今天是2021-12-20'
result = pattern.findall(strs)
print(result)
```
```
['2020/12/20', '2019.12.20', '2021-12-20']
```
<a name="oRPoM"></a>
### 8. 国内邮政编码
我国的邮政编码采用四级六位数编码结构<br />前两位数字表示省（直辖市、自治区）<br />第三位数字表示邮区；第四位数字表示县（市）<br />最后两位数字表示投递局（所）<br />表达式：<br />`[1-9]\d{5}(?!\d)`<br />案例：
```python
pattern = re.compile(r"[1-9]\d{5}(?!\d)")
strs = '上海静安区邮编是200040'
result = pattern.findall(strs)
print(result)
```
```
['200040']
```
<a name="NRp0k"></a>
### 9. 密码
密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)<br />表达式：<br />`[a-zA-Z]\w{5,17}`<br />强密码(以字母开头，必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)<br />表达式：<br />`[a-zA-Z](?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}`
```python
pattern = re.compile(r"[a-zA-Z]\w{5,17}")
strs = '密码：q123456_abc'
result = pattern.findall(strs)
print(result)
```
```
['q123456_abc']
```
```python
pattern = re.compile(r"[a-zA-Z](?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}")
strs = '强密码：q123456ABc，弱密码：q123456abc'
result = pattern.findall(strs)
print(result)
```
```
['q123456ABc，']
```
<a name="XrrNA"></a>
### 10. 中文字符
表达式：<br />`[\u4e00-\u9fa5]`<br />案例：
```python
pattern = re.compile(r"[\u4e00-\u9fa5]")
strs = 'apple：苹果'
result = pattern.findall(strs)
print(result)
```
```
['苹', '果']
```
<a name="B4Mk9"></a>
### 11. 数字

- 验证数字：`^[0-9]*$`
- 验证n位的数字：`^\d{n}$`
- 验证至少n位数字：`^\d{n,}$`
- 验证m-n位的数字：`^\d{m,n}$`
- 验证零和非零开头的数字：`^(0|[1-9][0-9]*)$`
- 验证有两位小数的正实数：`^[0-9]+(.[0-9]{2})?$`
- 验证有1-3位小数的正实数：`^[0-9]+(.[0-9]{1,3})?$`
- 验证非零的正整数：`^\+?[1-9][0-9]*$`
- 验证非零的负整数：`^\-[1-9][0-9]*$`
- 验证非负整数（正整数 + 0） `^\d+$`
- 验证非正整数（负整数 + 0） `^((-\d+)|(0+))$`
- 整数：`^-?\d+$`
- 非负浮点数（正浮点数 + 0）：`^\d+(\.\d+)?$`
- 正浮点数 `^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$`
- 非正浮点数（负浮点数 + 0） `^((-\d+(\.\d+)?)|(0+(\.0+)?))$`
- 负浮点数 `^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$`
- 浮点数 `^(-?\d+)(\.\d+)?$`
<a name="6tdHM"></a>
### 12. 字符串

- 英文和数字：`^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$`
- 长度为3-20的所有字符：`^.{3,20}$`
- 由26个英文字母组成的字符串：`^[A-Za-z]+$`
- 由26个大写英文字母组成的字符串：`^[A-Z]+$`
- 由26个小写英文字母组成的字符串：`^[a-z]+$`
- 由数字和26个英文字母组成的字符串：`^[A-Za-z0-9]+$`
- 由数字、26个英文字母或者下划线组成的字符串：`^\w+$ 或 ^\w{3,20}$`
- 中文、英文、数字包括下划线：`^[\u4E00-\u9FA5A-Za-z0-9_]+$`
- 中文、英文、数字但不包括下划线等符号：`^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$`
- 可以输入含有^%&',;=?$\”等字符：`[^%&',;=?$\x22]+`
- 禁止输入含有~的字符：`[^~\x22]+`
<a name="iXUlC"></a>
## 附：正则表达式语法详解
| 字符 | 描述 |
| --- | --- |
| `\\` | 将下一个字符标记为一个特殊字符（File Format Escape，清单见本表）、或一个原义字符（Identity Escape，有^$()*+?.[{&#124;共计12个)、或一个向后引用（backreferences）、或一个八进制转义符。例如，“<br />`n`<br />”匹配字符“<br />`n`<br />”。“<br />`\\n`<br />”匹配一个换行符。序列“<br />`\\\\`<br />”匹配“<br />`\\`<br />”而“<br />`\\(`<br />”则匹配“<br />`(`<br />”。 |
| `^` | 匹配输入字符串的开始位置 |
| `$` | 匹配输入字符串的结束位置 |
| `*` | 匹配前面的子表达式零次或多次。例如，zo*能匹配“<br />`z`<br />”、“<br />`zo`<br />”以及“<br />`zoo`<br />”。*等价于{0,}。 |
| `+` | 匹配前面的子表达式一次或多次。例如，“<br />`zo+`<br />”能匹配“<br />`zo`<br />”以及“<br />`zoo`<br />”，但不能匹配“<br />`z`<br />”。+等价于{1,}。 |
| `?` | 匹配前面的子表达式零次或一次。例如，“<br />`do(es)?`<br />”可以匹配“<br />`does`<br />”中的“<br />`do`<br />”和“<br />`does`<br />”。?等价于{0,1}。 |
| `{n}` | n是一个非负整数。匹配确定的n次。例如，“<br />`o{2}`<br />”不能匹配“<br />`Bob`<br />”中的“<br />`o`<br />”，但是能匹配“<br />`food`<br />”中的两个o。 |
| `{n,}` | n是一个非负整数。至少匹配n次。例如，“<br />`o{2,}`<br />”不能匹配“<br />`Bob`<br />”中的“<br />`o`<br />”，但能匹配“<br />`foooood`<br />”中的所有o。“<br />`o{1,}`<br />”等价于“<br />`o+`<br />”。“<br />`o{0,}`<br />”则等价于“<br />`o*`<br />”。 |
| `{n,m}` | m和n均为非负整数，其中n<=m。最少匹配n次且最多匹配m次。例如，“<br />`o{1,3}`<br />”将匹配“<br />`fooooood`<br />”中的前三个o。“<br />`o{0,1}`<br />”等价于“<br />`o?`<br />”。请注意在逗号和两个数之间不能有空格。 |
| `?` | 非贪心量化（Non-greedy quantifiers）：当该字符紧跟在任何一个其他重复修饰符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是<br />**「非」**<br />贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“<br />`oooo`<br />”，“<br />`o+?`<br />”将匹配单个“<br />`o`<br />”，而“<br />`o+`<br />”将匹配所有“<br />`o`<br />”。 |
| `.` | 匹配除“<br />`\\r`<br />”“<br />`\\n`<br />”之外的任何单个字符。要匹配包括“<br />`\\r`<br />”“<br />`\\n`<br />”在内的任何字符，请使用像“<br />`(.\\&#124;\\r\\&#124;\\n)`<br />”的模式。 |
| `(pattern)` | 匹配pattern并获取这一匹配的子字符串。该子字符串用于向后引用。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“<br />`\\(`<br />”或“<br />`\\)`<br />”。可带数量后缀。 |
| `(?:pattern)` | 匹配pattern但不获取匹配的子字符串（shy groups），也就是说这是一个非获取匹配，不存储匹配的子字符串用于向后引用。这在使用或字符“<br />`(\\&#124;)`<br />”来组合一个模式的各个部分是很有用。例如“<br />`industr(?:y\\&#124;ies)`<br />”就是一个比“<br />`industry\\&#124;industries`<br />”更简略的表达式。 |
| `(?=pattern)` | 正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“<br />`Windows(?=95\\&#124;98\\&#124;NT\\&#124;2000)`<br />”能匹配“<br />`Windows2000`<br />”中的“<br />`Windows`<br />”，但不能匹配“<br />`Windows3.1`<br />”中的“<br />`Windows`<br />”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 |
| `(?!pattern)` | 正向否定预查（negative assert），在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“<br />`Windows(?!95\\&#124;98\\&#124;NT\\&#124;2000)`<br />”能匹配“<br />`Windows3.1`<br />”中的“<br />`Windows`<br />”，但不能匹配“<br />`Windows2000`<br />”中的“<br />`Windows`<br />”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始 |
| `(?<=pattern)` | 反向（look behind）肯定预查，与正向肯定预查类似，只是方向相反。例如，“<br />`(?<=95\\&#124;98\\&#124;NT\\&#124;2000)Windows`<br />”能匹配“<br />`2000Windows`<br />”中的“<br />`Windows`<br />”，但不能匹配“<br />`3.1Windows`<br />”中的“<br />`Windows`<br />”。 |
| `(?<!pattern)` | 反向否定预查，与正向否定预查类似，只是方向相反。例如“<br />`(?<!95\\&#124;98\\&#124;NT\\&#124;2000)Windows`<br />”能匹配“<br />`3.1Windows`<br />”中的“<br />`Windows`<br />”，但不能匹配“<br />`2000Windows`<br />”中的“<br />`Windows`<br />”。 |
| `x\\&#124;y` | 没有包围在()里，其范围是整个正则表达式。例如，“<br />`z\\&#124;food`<br />”能匹配“<br />`z`<br />”或“<br />`food`<br />”。“<br />`(?:z\\&#124;f)ood`<br />”则匹配“<br />`zood`<br />”或“<br />`food`<br />”。 |
| `[xyz]` | 字符集合（character class）。匹配所包含的任意一个字符。例如，“<br />`[abc]`<br />”可以匹配“<br />`plain`<br />”中的“<br />`a`<br />”。特殊字符仅有反斜线\\保持特殊含义，用于转义字符。其它特殊字符如星号、加号、各种括号等均作为普通字符。脱字符^如果出现在首位则表示负值字符集合；如果出现在字符串中间就仅作为普通字符。连字符 - 如果出现在字符串中间表示字符范围描述；如果如果出现在首位（或末尾）则仅作为普通字符。右方括号应转义出现，也可以作为首位字符出现。 |
| `[^xyz]` | 排除型字符集合（negated character classes）。匹配未列出的任意字符。例如，“<br />`[^abc]`<br />”可以匹配“<br />`plain`<br />”中的“<br />`plin`<br />”。 |
| `[a-z]` | 字符范围。匹配指定范围内的任意字符。例如，“<br />`[a-z]`<br />”可以匹配“<br />`a`<br />”到“<br />`z`<br />”范围内的任意小写字母字符。 |
| `[^a-z]` | 排除型的字符范围。匹配任何不在指定范围内的任意字符。例如，“<br />`[^a-z]`<br />”可以匹配任何不在“<br />`a`<br />”到“<br />`z`<br />”范围内的任意字符。 |
| `[:name:]` | 增加命名字符类（named character class）中的字符到表达式。只能用于<br />**「方括号表达式」**<br />。 |
| `[=elt=]` | 增加当前locale下排序（collate）等价于字符“elt”的元素。例如，[=a=]可能会增加ä、á、à、ă、ắ、ằ、ẵ、ẳ、â、ấ、ầ、ẫ、ẩ、ǎ、å、ǻ、ä、ǟ、ã、ȧ、ǡ、ą、ā、ả、ȁ、ȃ、ạ、ặ、ậ、ḁ、ⱥ、ᶏ、ɐ、ɑ 。只能用于方括号表达式。 |
| `[.elt.]` | 增加排序元素elt到表达式中。这是因为某些排序元素由多个字符组成。例如，29个字母表的西班牙语， "CH"作为单个字母排在字母C之后，因此会产生如此排序“cinco, credo, chispa”。只能用于方括号表达式。 |
| `\\b` | 匹配一个单词边界，也就是指单词和空格间的位置。例如，“<br />`er\\b`<br />”可以匹配“<br />`never`<br />”中的“<br />`er`<br />”，但不能匹配“<br />`verb`<br />”中的“<br />`er`<br />”。 |
| `\\B` | 匹配非单词边界。“<br />`er\\B`<br />”能匹配“<br />`verb`<br />”中的“<br />`er`<br />”，但不能匹配“<br />`never`<br />”中的“<br />`er`<br />”。 |
| `\\cx` | 匹配由x指明的控制字符。x的值必须为<br />`A-Z`<br />或<br />`a-z`<br />之一。否则，将c视为一个原义的“<br />`c`<br />”字符。控制字符的值等于x的值最低5比特（即对32<br />10进制<br />的余数）。例如，\\cM匹配一个Control-M或回车符。\\ca等效于\\u0001, \\cb等效于\\u0002, 等等… |
| `\\d` | 匹配一个数字字符。等价于[0-9]。注意Unicode正则表达式会匹配全角数字字符。 |
| `\\D` | 匹配一个非数字字符。等价于[^0-9]。 |
| `\\f` | 匹配一个换页符。等价于\\x0c和\\cL。 |
| `\\n` | 匹配一个换行符。等价于\\x0a和\\cJ。 |
| `\\r` | 匹配一个回车符。等价于\\x0d和\\cM。 |
| `\\s` | 匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \\f\\n\\r\\t\\v]。注意Unicode正则表达式会匹配全角空格符。 |
| `\\S` | 匹配任何非空白字符。等价于[^ \\f\\n\\r\\t\\v]。 |
| `\\t` | 匹配一个制表符。等价于\\x09和\\cI。 |
| `\\v` | 匹配一个垂直制表符。等价于\\x0b和\\cK。 |
| `\\w` | 匹配包括下划线的任何单词字符。等价于“<br />`[A-Za-z0-9_]`<br />”。注意Unicode正则表达式会匹配中文字符。 |
| `\\W` | 匹配任何非单词字符。等价于“<br />`[^A-Za-z0-9_]`<br />”。 |
| `\\xnn` | 十六进制转义字符序列。匹配两个十六进制数字nn表示的字符。例如，“<br />`\\x41`<br />”匹配“<br />`A`<br />”。“<br />`\\x041`<br />”则等价于“<br />`\\x04&1`<br />”。正则表达式中可以使用ASCII编码。. |
| `\\num` | 向后引用（back-reference）一个子字符串（substring），该子字符串与正则表达式的第num个用括号围起来的捕捉群（capture group）子表达式（subexpression）匹配。其中num是从1开始的十进制正整数，其上限可能是9、31、99，甚至无限。例如：“<br />`(.)\\1`<br />”匹配两个连续的相同字符。 |
| `\\n` | 标识一个八进制转义值或一个向后引用。如果\\n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n为一个八进制转义值。 |
| `\\nm` | 3位八进制数字，标识一个八进制转义值或一个向后引用。如果\\nm之前至少有nm个获得子表达式，则nm为向后引用。如果\\nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则\\nm将匹配八进制转义值nm。 |
| `\\nml` | 如果n为八进制数字（0-3），且m和l均为八进制数字（0-7），则匹配八进制转义值nml。 |
| `\\un` | Unicode转义字符序列。其中n是一个用四个十六进制数字表示的Unicode字符。例如，\\u00A9匹配著作权符号（©）。 |

<a name="CIWnK"></a>
## 优先权
| 优先权 | 符号 |
| --- | --- |
| 最高 | `\\` |
| 高 | `()`<br />、<br />`(?:)`<br />、<br />`(?=)`<br />、<br />`[]` |
| 中 | `*`<br />、<br />`+`<br />、<br />`?`<br />、<br />`{n}`<br />、<br />`{n,}`<br />、<br />`{n,m}` |
| 低 | `^`<br />、<br />`$`<br />、中介字符 |
| 次最低 | 串接，即相邻字符连接在一起 |
| 最低 | `\\&#124;` |

