开始学socket的时候，云里雾里的，对socket的概念很模糊。<br />这里打算从一个初学者的角度开始聊起，了解下socket是什么以及socket的原理和内核实现。
<a name="Kgbyu"></a>
## socket的概念
故事要从一个**插头**说起。<br />![插头与插座](https://cdn.nlark.com/yuque/0/2023/png/396745/1678935306899-f9530296-a497-4bfe-aa5f-ccb995c503c1.png#averageHue=%23dae4e7&clientId=ufd534af0-a0c2-4&from=paste&id=u63eac6f5&originHeight=486&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=u4f3c648a-cfdc-4ad7-a571-a66989c3e52&title=%E6%8F%92%E5%A4%B4%E4%B8%8E%E6%8F%92%E5%BA%A7 "插头与插座")<br />将**插头**插入**插座**，那看起来就像是将两者连起来了。<br />![风扇与电力系统建立"连接"](https://cdn.nlark.com/yuque/0/2023/png/396745/1678935306928-e710032c-b262-4a7c-b52d-6d57fe99610d.png#averageHue=%23dae5e8&clientId=ufd534af0-a0c2-4&from=paste&id=uf131da51&originHeight=405&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=u58998c78-8050-4f45-bfa4-f40d3eb8242&title=%E9%A3%8E%E6%89%87%E4%B8%8E%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F%E5%BB%BA%E7%AB%8B%22%E8%BF%9E%E6%8E%A5%22 "风扇与电力系统建立"连接"")<br />而插座的英文，又叫socket。<br />巧了，程序员搞网络编程时也会用到一个叫socket的东西。<br />其实两者非常相似。通过socket，可以与某台机子建立"**连接**"，建立"连接"的过程，就像是将插口插入插槽一样。<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1678935307057-1816b876-da9a-41a7-a3d2-4161b3ede497.png#averageHue=%23dde6e9&clientId=ufd534af0-a0c2-4&from=paste&id=u61dd4133&originHeight=450&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u9207f966-6109-4227-9cc9-ac0ff21fa6a&title=)<br />大概概念是了解了，相信各位对socket其实还是很模糊。<br />从大家最熟悉的**使用场景**开始说起。
<a name="mLHzI"></a>
## socket的使用场景
想要将数据从A电脑的某个进程发到B电脑的某个进程。<br />这时候需要选择将数据发过去的**方式**，如果需要确保数据要能发给对方，那就选可靠的TCP协议，如果数据丢了也没关系，看天意，那就选择不可靠的UDP协议。<br />初学者毫无疑问，首选TCP。<br />![TCP是什么](https://cdn.nlark.com/yuque/0/2023/png/396745/1678935306946-9b5acce6-d61e-4264-8096-2e249a86e840.png#averageHue=%23c2d5de&clientId=ufd534af0-a0c2-4&from=paste&id=u6e069f39&originHeight=540&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=uce81130c-14bc-45f5-a293-2d45831b678&title=TCP%E6%98%AF%E4%BB%80%E4%B9%88 "TCP是什么")<br />那这时候就需要用socket进行编程。<br />于是第一步就是创建个关于TCP的socket。就像下面这样。
```c
sock_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
```
这个方法会返回`socket_fd`，它是socket文件的句柄，是个数字，相当于socket的身份证号。<br />得到了`socket_fd`之后，对于服务端，就可以依次执行`bind()`, `listen()`, `accept()`方法，然后坐等客户端的连接请求。<br />对于客户端，得到`socket_fd`之后，就可以执行`connect()`方法向服务端发起建立连接的请求，此时就会发生TCP三次握手。<br />![握手建立连接流程](https://cdn.nlark.com/yuque/0/2023/gif/396745/1678935307080-8d88f2e7-0f82-49a5-a465-c810e55f32f7.gif#averageHue=%23f1f5fc&clientId=ufd534af0-a0c2-4&from=paste&id=ud7d80904&originHeight=607&originWidth=1079&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=u3132cf26-d6f4-43be-aee6-cf7cb562ad7&title=%E6%8F%A1%E6%89%8B%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E6%B5%81%E7%A8%8B "握手建立连接流程")<br />连接建立完成后，**客户端**可以执行`send()` 方法发送消息，**服务端**可以执行`recv()`方法接收消息，反过来，**服务器**也可以执行`send()`，**客户端**执行`recv()`方法。<br />到这里为止，就是大部分程序员最熟悉的使用场景。
<a name="LABwd"></a>
## socket的设计
现在，socket见过，也用过，但对大部分程序员来说，它是个**黑盒**。<br />那既然是黑盒，索性假设忘了socket。重新设计一个内核网络传输功能。<br />网络传输，从操作上来看，无非就是，发数据和远端之间**互相**收发数据。也就是对应着**写数据**和**读数据**。<br />![读写收发](https://cdn.nlark.com/yuque/0/2023/png/396745/1678935308557-e41bbaa2-93e9-4c7f-a57b-17f792fbc196.png#averageHue=%23b4c8d4&clientId=ufd534af0-a0c2-4&from=paste&id=u335638b9&originHeight=450&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=u28c39cdc-adbb-4256-a7e6-e387892b52a&title=%E8%AF%BB%E5%86%99%E6%94%B6%E5%8F%91 "读写收发")<br />但显然，事情没那么简单。<br />这里还有两个问题。<br />第一个是，接收端和发送端可能不止一个，因此需要一些信息做下区分，这个大家肯定很熟悉，可以用IP和端口。**IP用来定位是哪台电脑，端口用来定位是这台电脑上的哪个进程。**<br />第二个是，发送端和接收端的传输方式有很多区别，可以是可靠的TCP协议，也可以是不可靠的UDP协议，甚至还需要支持基于icmp协议的ping命令。
<a name="NnXQm"></a>
### sock是什么
写过代码的都知道，为了支持这些功能，需要定义一个**数据结构**去支持这些功能。<br />这个数据结构，叫sock。<br />为了解决上面的第一个问题，可以在sock里加入**IP和端口**字段。<br />![sock加入IP和端口字段](https://cdn.nlark.com/yuque/0/2023/png/396745/1678935308720-c3876d4b-b4d6-401c-b165-7692b33e8bc8.png#averageHue=%23d5dde4&clientId=ufd534af0-a0c2-4&from=paste&id=ua7d6b309&originHeight=463&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=uaaa689d4-dcba-4762-92fe-290e06d766f&title=sock%E5%8A%A0%E5%85%A5IP%E5%92%8C%E7%AB%AF%E5%8F%A3%E5%AD%97%E6%AE%B5 "sock加入IP和端口字段")<br />而第二个问题，会发现这些协议虽然各不相同，但还是有一些功能相似的地方，比如收发数据时的一些逻辑完全可以复用。按面向对象编程的思想，可以将不同的协议当成是不同的**对象类（或结构体）**，将公共的部分提取出来，通过"**继承**"的方式，复用功能。
<a name="eT4W2"></a>
### 基于各种sock实现网络传输功能
于是，将功能**重新划分**下，定义了一些数据结构。<br />![继承sock的各类sock](https://cdn.nlark.com/yuque/0/2023/png/396745/1678935308749-7070f502-85a1-4fcf-8df1-04c6f1e812e0.png#averageHue=%23d0dce3&clientId=ufd534af0-a0c2-4&from=paste&id=u721bec1e&originHeight=581&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=u475dca10-3d04-4141-a5db-87f27ecb1d7&title=%E7%BB%A7%E6%89%BFsock%E7%9A%84%E5%90%84%E7%B1%BBsock "继承sock的各类sock")<br />sock是**最基础**的结构，维护一些任何协议都有可能会用到的收发数据缓冲区。<br />inet_sock特指用了**网络传输**功能的sock，在sock的基础上还加入了TTL，**端口，IP地址**这些跟网络传输相关的字段信息。说到这里大家就懵了，难道还有不是用网络传输的？有，比如Unix domain socket，用于本机进程之间的通信，直接读写文件，不需要经过网络协议栈。这是个非常有用的东西，以后一定讲讲（画饼）。<br />`inet_connection_sock `是指**面向连接**的sock，在inet_sock的基础上加入面向连接的协议里相关字段，比如accept队列，数据包分片大小，握手失败重试次数等。虽然现在提到面向连接的协议就是指TCP，但设计上linux需要支持扩展**其他**面向连接的**新协议**，<br />tcp_sock 就是正儿八经的**tcp协议**专用的sock结构了，在`inet_connection_sock`基础上还加入了tcp特有的**滑动窗口**、**拥塞避免**等功能。同样udp协议也会有一个专用的数据结构，叫`udp_sock`。<br />好了，现在有了这套数据结构，将它们跟**硬件**网卡对接一下，就实现了网络传输的功能。
<a name="tvdep"></a>
### 提供socket层
可以想象得到，这里面的代码肯定非常复杂，同时还操作了网卡硬件，需要比较高的**操作系统权限**，再考虑到性能和安全，于是决定将它放在**操作系统内核**里。<br />既然网络传输功能做在内核里，那用户空间的应用程序想要用这部分功能的话，该怎么办呢？<br />这个好办，本着不重复造轮子的原则，将这部分功能抽象成一个个**简单的接口**。以后别人只需要调用这些接口，就可以驱动写好的这一大堆复杂的数据结构去发送数据。<br />那么问题来了，**怎么样将这部分功能暴露出去呢？让其他程序员更方便的使用呢？**<br />既然跟远端服务端进程收发数据可以抽象为“**读和写**”，操作文件也可以抽象为"**读和写**"，正好有句话叫，"**linux里一切皆是文件**"，那索性**将内核的sock封装成文件**就好了。创建sock的同时也创建一个**文件**，**文件有个句柄fd**，说白了就是个**文件系统**里的**身份证号码**，通过它可以**唯一确定**是哪个sock。<br />这个文件句柄fd其实就是 `sock_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)` 里的sock_fd。<br />将句柄暴露给用户，之后用户就可以像操作**文件句柄**那样去操作这个**sock句柄**。在用户空间里操作这个句柄，**文件系统**就会将操作**指向**内核sock结构。<br />是的，操作这个特殊的**文件**就相当于操作内核里对应的sock。<br />![通过文件找到sock](https://cdn.nlark.com/yuque/0/2023/png/396745/1678935309285-160483b1-323c-499b-a3ef-9511f3ed5a30.png#averageHue=%23e0e9ea&clientId=ufd534af0-a0c2-4&from=paste&id=u6135f366&originHeight=757&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=ue3c554ae-639f-4fa7-8ca9-74301263719&title=%E9%80%9A%E8%BF%87%E6%96%87%E4%BB%B6%E6%89%BE%E5%88%B0sock "通过文件找到sock")<br />有了sock_fd句柄之后，就需要提供一些接口方法，让用户更方便的实现特定的网络编程功能。这些接口列了一下，发现需要有`send()`，`recv()`，`bind()`，`listen()`，`connect()`这些。到这里，核网络传输功能就算设计完成了。<br />现在是不是眼熟了，**上面这些接口方法其实就是socket提供出来的接口**。<br />所以说，socket其实就是个**代码库 or 接口层**，它介于**内核和应用程序之间**，提供了一些**高度封装过**的接口，去使用**内核网络传输功能**。<br />![基于sock实现网络传输功能](https://cdn.nlark.com/yuque/0/2023/png/396745/1678935309170-8451d8bf-7a72-418c-a261-66dc3b3b4a27.png#averageHue=%23cadbdf&clientId=ufd534af0-a0c2-4&from=paste&id=ua3f84ec4&originHeight=1080&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=u364e2e65-0f90-43a3-841f-1ecf98a1da0&title=%E5%9F%BA%E4%BA%8Esock%E5%AE%9E%E7%8E%B0%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%8A%9F%E8%83%BD "基于sock实现网络传输功能")<br />到这里，应该明白了。平时写的应用程序里代码里虽然用了socket实现了收发数据包的功能，但其实真正执行网络通信功能的，不是应用程序，而是**linux内核**。相当于应用程序通过socket提供的接口，将网络传输的这部分工作**外包**给了**linux内核**。<br />这听起来像不像最熟悉的**前后端分离**的服务架构，**虽然这么说不太严谨**，但看上去linux就像是被分成了**应用程序和内核两个服务**。内核就像是**后端**，暴露了好多个**api接口**，其中一类就是socket的`send()`和`recv()`这些方法。应用程序就像是**前端**，负责调用内核提供的接口来实现想要的功能。<br />![进程通过socket调用内核功能](https://cdn.nlark.com/yuque/0/2023/png/396745/1678935309632-cf2ddbfe-e193-4226-8bee-8ceec38ee2a2.png#averageHue=%23d8e3e7&clientId=ufd534af0-a0c2-4&from=paste&id=ua65c6500&originHeight=617&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=u848f4204-fab1-436e-85cf-0ffc541d17e&title=%E8%BF%9B%E7%A8%8B%E9%80%9A%E8%BF%87socket%E8%B0%83%E7%94%A8%E5%86%85%E6%A0%B8%E5%8A%9F%E8%83%BD "进程通过socket调用内核功能")<br />看到这里，担心大家会有点混乱，来做个小的**总结**。<br />**在操作系统内核空间里，实现网络传输功能的结构是sock，基于不同的协议和应用场景，会被泛化为各种类型的xx_sock，它们结合硬件，共同实现了网络传输功能。为了将这部分功能暴露给用户空间的应用程序使用，于是引入了socket层，同时将sock嵌入到文件系统的框架里，sock就变成了一个特殊的文件，用户就可以在用户空间使用文件句柄，也就是socket_fd来操作内核sock的网络传输能力。**<br />这个socket_fd是一个**int类型的数字**。现在回去看socket的中文翻译，**套接字**，将它理解为一**套**用于连**接**的数**字**，是不是就觉得特别合理了。<br />![网络分层与基于sock实现网络传输功能](https://cdn.nlark.com/yuque/0/2023/png/396745/1678935309556-ef3a38c7-73fb-42ed-9130-d3435262952a.png#averageHue=%23b0ccd2&clientId=ufd534af0-a0c2-4&from=paste&id=u634c762e&originHeight=900&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=uf16f2e28-d6ea-4db2-92a7-8a9f3f00eae&title=%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E4%B8%8E%E5%9F%BA%E4%BA%8Esock%E5%AE%9E%E7%8E%B0%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%8A%9F%E8%83%BD "网络分层与基于sock实现网络传输功能")
<a name="q4DaR"></a>
## socket如何实现网络通信
上面关于怎么实现网络通信功能这一块一笔带过了。<br />现在来聊聊。<br />这套sock的结构其实非常复杂。以最常用的TCP协议为例，简单了解下它是怎么实现网络传输功能的。<br />将它分为两阶段，分别是**建立连接**和**数据传输**。
<a name="ia3Db"></a>
### 建立连接
对于TCP，要传数据，就得先在客户端和服务端中间**建立连接**。<br />在客户端，代码执行socket提供的`connect(sockfd, "ip:port")`方法时，会通过**sockfd句柄**找到对应的**文件**，再根据文件里的信息**指向**内核的sock结构。通过这个sock结构主动发起三次握手。<br />![TCP三次握手](https://cdn.nlark.com/yuque/0/2023/png/396745/1678935309584-21e4c286-6632-4e86-961b-49e5d6739d93.png#averageHue=%23d1d7dd&clientId=ufd534af0-a0c2-4&from=paste&id=ua0367981&originHeight=990&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=u9ecdb2fa-1a9d-4418-b3ec-c8112991ef3&title=TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B "TCP三次握手")<br />在服务端握手次数还没达到"三次"的连接，叫**半连接**，完成好三次握手的连接，叫**全连接**。它们分别会用**半连接队列**和**全连接队列**来存放，这两个队列会在执行`listen()`方法的时候创建好。当服务端执行`accept()`方法时，就会从全连接队列里拿出一条全连接。<br />![半连接队列和全连接队列](https://cdn.nlark.com/yuque/0/2023/png/396745/1678935310065-0bd9d313-910e-4d0b-87fb-4867c31350f6.png#averageHue=%23d6dbe1&clientId=ufd534af0-a0c2-4&from=paste&id=u7ad2670c&originHeight=800&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=ub73da5c6-39dc-4052-b96f-1999f5bfac6&title=%E5%8D%8A%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E5%92%8C%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97 "半连接队列和全连接队列")<br />至此，连接就算准备好了，之后，就可以**开始传输数据**。<br />虽然都叫队列，但半连接队列其实是个hash表，而全连接队列其实是个链表。
<a name="ZopRm"></a>
### 数据传输
为了实现发送和接收数据的功能，sock结构体里带了**一个发送缓冲区和一个接收缓冲区**，说是**缓冲区**，但其实就是个**链表**，上面挂着一个个准备要发送或接收的数据。<br />当应用执行`send()`方法**发送数据**时，同样也会通过`sock_fd`句柄找到对应的文件，根据文件指向的`sock`结构，找到这个`sock`结构里带的**发送缓冲区**，将数据会放到发送缓冲区，然后结束流程，内核看心情决定什么时候将这份数据发送出去。<br />**接收数据**流程也类似，当数据送到linux内核后，数据不是立马给到应用程序的，而是先放在接收缓冲区中，数据静静躺着，卑微的等待**应用程序**什么时候执行`recv()`方法来拿一下。<br />![sock的发送和接收缓冲区](https://cdn.nlark.com/yuque/0/2023/png/396745/1678935310607-79349245-cd03-4b6d-b4f2-599ebd1a1bd8.png#averageHue=%23ccd8e1&clientId=ufd534af0-a0c2-4&from=paste&id=u692cb8ef&originHeight=618&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=uec21d782-5883-4da3-96cf-dd74703241d&title=sock%E7%9A%84%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E6%94%B6%E7%BC%93%E5%86%B2%E5%8C%BA "sock的发送和接收缓冲区")<br />IP和端口其实不在sock下，而在inet_sock下，上面这么画只是为了简化。。。<br />那么问题来了，发送数据是应用程序主动发起，这个大家都没问题。<br />**那接收数据呢？数据从远端发过来了，怎么通知并给到应用程序呢？**<br />这就需要用到**等待队列**。<br />![sock内的等待队列](https://cdn.nlark.com/yuque/0/2023/png/396745/1678935311045-d2a48ab2-8add-4b98-afc9-3f2e48866980.png#averageHue=%23cddae2&clientId=ufd534af0-a0c2-4&from=paste&id=u15fd5b18&originHeight=741&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=u6ae13c77-df7f-422e-98b5-de68c4f2ab1&title=sock%E5%86%85%E7%9A%84%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97 "sock内的等待队列")<br />当应用进程执行`recv()`方法尝试获取（阻塞场景下）接收缓冲区的数据时。

- 如果有数据，那正好，取走就好了。这点没啥疑问。
- 但如果没数据，就会将自己的**进程**信息注册到这个sock用的**等待队列**里，然后进程**休眠**。如果这时候有数据从远端发过来了，数据进入到接收缓冲区时，内核就会取出sock的等待队列里的进程，**唤醒**进程来取数据。

![recv时无数据进程进入等待队列](https://cdn.nlark.com/yuque/0/2023/png/396745/1678935311128-a325c08b-9b79-4429-82a6-6b019f29cf1c.png#averageHue=%23cfdee2&clientId=ufd534af0-a0c2-4&from=paste&id=ue474df3b&originHeight=1200&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=u27241013-047e-4a84-ad5a-992cebf44f6&title=recv%E6%97%B6%E6%97%A0%E6%95%B0%E6%8D%AE%E8%BF%9B%E7%A8%8B%E8%BF%9B%E5%85%A5%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97 "recv时无数据进程进入等待队列")<br />有时候，会看到**多个进程**通过fork的方式，listen了同一个socket_fd。在内核，它们都是**同一个sock**，多个进程执行`listen()`之后，都嗷嗷等待连接进来，所以都会将自身的进程信息注册到这个socket_fd对应的内核sock的**等待队列**中。如果这时真来了一个连接，是该唤醒等待队列里的哪个进程来接收连接呢？这个问题的答案比较有趣。

- 在linux 2.6以前，会唤醒等待队列里的所有进程。但最后其实只有一个进程会处理这个连接请求，其他进程又重新进入休眠，这些被唤醒了又无事可做最后只能重新回去休眠的进程会消耗一定的资源。就好像在广东的街头，想问路，叫一声靓仔，几十个人同时回头，但其实只需要其中一个靓仔告诉你路该怎么走。你这种一不小心**惊**动这**群**靓仔的场景，在计算机领域中，就叫**惊群效应**。
- 在linux 2.6之后，只会唤醒等待队列里的其中一个进程。是的，socket监听的惊群效应问题被修复了。

![惊群效应](https://cdn.nlark.com/yuque/0/2023/png/396745/1678935311109-b3b9cf33-b173-48de-8438-b09d09fce850.png#averageHue=%23dae3e7&clientId=ufd534af0-a0c2-4&from=paste&id=u4dceaf3b&originHeight=555&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=u324d9944-f134-478a-82a0-3dd63344616&title=%E6%83%8A%E7%BE%A4%E6%95%88%E5%BA%94 "惊群效应")<br />看到这里，问题又来了。<br />**服务端 listen 的时候，那么多数据到一个 socket 怎么区分多个客户端的？**<br />以TCP为例，服务端执行listen方法后，会等待客户端发送数据来。客户端发来的数据包上会有**源IP地址和端口**，以及**目的IP地址和端口**，这四个元素构成一个**四元组**，可以用于唯一标记一个客户端。<br />其实说四元组并不严谨，因为过程中还有很多其他信息，也可以说是五元组。。。但大概理解就好，就这样吧。。。<br />![四元组](https://cdn.nlark.com/yuque/0/2023/png/396745/1678935312338-9c99bfdd-081a-45e6-9e41-1d859067aff6.png#averageHue=%23b6cad6&clientId=ufd534af0-a0c2-4&from=paste&id=u01b6f0cf&originHeight=450&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=uf815daa7-f545-4b66-a9a4-8e2393236b9&title=%E5%9B%9B%E5%85%83%E7%BB%84 "四元组")<br />服务端会创建一个新的内核sock，并用四元组生成一个hash key，将它放入到一个hash表中。<br />![四元组映射成hash键](https://cdn.nlark.com/yuque/0/2023/png/396745/1678935312327-96a0a8b2-52df-4e3c-bc8f-57156c64d424.png#averageHue=%23dce6e9&clientId=ufd534af0-a0c2-4&from=paste&id=ud1ba87f8&originHeight=339&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=u318c0e5e-5487-4bf7-8391-80127248e88&title=%E5%9B%9B%E5%85%83%E7%BB%84%E6%98%A0%E5%B0%84%E6%88%90hash%E9%94%AE "四元组映射成hash键")<br />下次再有消息进来的时候，通过消息自带的四元组生成hash key再到这个hash表里重新取出**对应的sock**就好了。所以说**服务端是通过四元组来区分多个客户端的**。<br />![多个hash_key对应多个客户端](https://cdn.nlark.com/yuque/0/2023/png/396745/1678935312422-d9668663-abb7-4d4e-803e-b1e9e7b1ae48.png#averageHue=%23d7e0e4&clientId=ufd534af0-a0c2-4&from=paste&id=ubcf7f40a&originHeight=480&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=ub747b8eb-75cd-4154-8b52-6b97d57a7ca&title=%E5%A4%9A%E4%B8%AAhash_key%E5%AF%B9%E5%BA%94%E5%A4%9A%E4%B8%AA%E5%AE%A2%E6%88%B7%E7%AB%AF "多个hash_key对应多个客户端")
<a name="F8dew"></a>
## sock怎么实现"继承"
最后遗留一个问题。<br />大家都知道linux内核是C语言实现的，而**C语言没有类也没有继承的特性，是怎么做到"继承"的效果的呢？**<br />在C语言里，结构体里的内存是**连续**的，将要继承的"父类"，放到结构体的**第一位**，就像下面这样。
```c
struct tcp_sock {
    /* inet_connection_sock has to be the first member of tcp_sock */
    struct inet_connection_sock inet_conn;
    // 其他字段
}

struct inet_connection_sock {
    /* inet_sock has to be the first member! */
    struct inet_sock   icsk_inet;
    // 其他字段
}
```
然后就可以通过结构体名的长度来强行截取内存，这样就能转换结构体，从而实现类似"继承"的效果。
```c
// sock 转为 tcp_sock
static inline struct tcp_sock *tcp_sk(const struct sock *sk)
{
    return (struct tcp_sock *)sk;
}
```
![内存布局](https://cdn.nlark.com/yuque/0/2023/png/396745/1678935312551-bc477e42-e923-4f76-a072-ff70ff99e2ae.png#averageHue=%23d0dce3&clientId=ufd534af0-a0c2-4&from=paste&id=u9f32d4ca&originHeight=581&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=ub7667b52-fc80-42ce-828e-a97f64b717b&title=%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80 "内存布局")
<a name="SRNnF"></a>
## 总结

- socket中文套接字，可以理解为一**套**用于连**接**的数**字**。当然这并不一定准确，但有助于理解。
- sock在内核，socket_fd在用户空间，socket层介于内核和用户空间之间。
- 在操作系统内核空间里，实现网络传输功能的结构是sock，基于不同的协议和应用场景，会被泛化为各种类型的xx_sock，它们结合硬件，共同实现了网络传输功能。为了将这部分功能暴露给用户空间的应用程序使用，于是引入了socket层，同时将sock嵌入到文件系统的框架里，sock就变成了一个特殊的文件，用户就可以在用户空间使用文件句柄，也就是socket_fd来操作内核sock的网络传输能力。
- 服务端可以通过四元组来区分多个客户端。
- 内核通过c语言"结构体里的内存是连续的"这一特点实现了类似继承的效果。
