LInux
<a name="CrC3c"></a>
## 前言
同步就是进程与进程之间，进程与系统资源之间的交互。由于 Linux内核采用的是多任务，所以在多个进程之间，必须要有同步机制来保证彼此协调。<br />在 Linux内核中，有很多种同步机制。这里主要讲一下 kernel中的异步和同步机制，其中重点介绍一下 kernel中的异步机制，kernel中的异步机制分为两种：一种是应用层的同步机制，也就是应用层线程之间的通信，另一种是内核的同步机制。<br />当一个线程进入到内核态后，就可以直接跟内核沟通了， kernel中有两个线程是这样的：一个是线程A，它进入内核态后，会直接跟内核沟通，告诉它我要去干啥了，等我干完了就会通知你。（这个操作叫它 semi）当一个线程进入到内核态后，会先去跟内核沟通一次，然后就可以直接去执行了。<br />kernel中的同步机制，本质上就是线程间的通信机制，它们之间的通信就是通过同步机制来实现的。
<a name="uOxPb"></a>
## 一、进程间的通信
为了保证系统的正确性和一致性， Linux内核会在进程间通信的过程中使用阻塞队列来处理进程间的通信。阻塞队列是指在消息队列中的某个元素在消息发出时就被创建，但并不是所有的消息都会被发送出去，只有当某一条消息的等待队列满了才会被发送出去。如果接收方等待队列中没有消息，则会接收到通知，如果接收方等待队列中有消息，则不会收到通知。<br />在内核中，对阻塞队列进行了抽象，即当某个进程发出了一个消息后，它就被阻塞了。因此，阻塞队列实际上是一种同步机制。阻塞队列通过一个特定的函数来创建一个新的对象，该对象包含一个等待队列指针（Push/Pop）。当等待队列满了之后，系统将把该等待队列指针指向的对象作为第一个发出通知的进程的线程。也就是说，该进程会收到通知后才能继续执行它的任务。
<a name="rVLa3"></a>
## 二、信号量
信号量可以用来发送或接收消息。当一个进程拥有了一个信号量，就意味着他已经拥有了一个属于自己的信号量，这个信号量是他自己的一个私有变量。这个私有变量是不能被其它进程拿到的。信号量用来表示一个进程所拥有的信号量数量，当这个进程拥有了这个信号量之后，就可以向其它进程发送消息。这个私有变量只允许这个进程自己使用，不可以把它拿到其它进程的进程中去。<br />当一个线程拥有了自己的信号量之后，就可以通过共享变量来与其它线程进行通信了。共享变量也是在其它线程中进行使用的，其它线程使用共享变量来和自己进行通信。
<a name="V0Td2"></a>
## 三、互斥量
互斥量主要是针对系统资源来说的。Linux内核中的互斥量又可以分为两种：共享资源和全局互斥资源。<br />共享资源就是进程之间共享的，比如一个进程有多个线程，那么每个线程都可以访问这个共享的内存空间。全局互斥资源就是进程和线程之间只能访问到自己所在的全局内存空间。在一个系统中，可以使用互斥量来实现多个进程同时在内存中执行。但是如果要实现多个进程同时执行，就需要使用同步机制，这样才能保证所有的进程都能够在同一个内存中运行。使用互斥量，一个进程只能访问到自己所在的全局内存空间，而无法访问其它内存空间。但是互斥量有一个很大的好处，那就是不会出现进程阻塞等情况。
<a name="VM3VU"></a>
## 四、消息队列
消息队列的出现，对进程间通信进行了很大的扩展。在 kernel中，除了同步机制外，还有另外一种异步机制，那就是消息队列。都知道，Linux内核是支持消息队列的。虽然在内核中也有关于消息队列的详细信息，但是由于内核是不支持用户态的消息队列的，所以还是要从应用层入手来了解一下消息队列。<br />**首先先了解一下消息队列是什么？**<br />消息队列是一种特殊的队列，它能够满足多个应用线程之间的同步需要。消息队列用于提供应用程序与其他进程或线程之间的异步通信。如果需要进行异步通信，那么就可以通过使用消息队列来进行。比如当调用 `clear()` 函数时，就可以直接使用一个已注册的消息队列。<br />那么如何创建一个消息队列呢？当使用ext2. json时，可以在 `JAR.json.clear()` 中使用 semaphore命令创建一个消息队列。
<a name="poj9D"></a>
## 五、共享内存
在共享内存中，使用的是共享锁，但因为共享锁是与某个进程共享内存，所以当想要获取共享锁的时候，需要向其他进程请求。<br />就像在上面的例子中，通过 `volatile`关键字来访问共享内存。此时并没有向其他进程请求，所以当想要获取这个共享锁时，只需要向其他进程请求。这样就避免了两个进程之间的互相竞争，同时还能实现数据的同步。<br />由于共享锁是与某个进程共享内存，所以必须向该进程请求访问它的地址。对于这种情况来说，最简单的解决方案就是使用线程池。<br />在线程池中有一个叫做“byte”的对象，它也是一个共享锁。当想要获取这个锁时，只需要向 byte对象发送请求就可以了。这时候 byte对象会将请求发送到该线程的队列中，当该线程收到请求时，它就会返回一个响应消息。
<a name="YmXhi"></a>
## 六、线程池
线程池是一个非常好的线程管理工具，它可以让多个线程同时运行，还可以减少线程之间的死锁和冲突。它还有一个最重要的特点就是，可以有效地利用系统的内存，达到提高效率的目的。<br />线程池的使用非常简单，就是把要执行的任务分配到相应的线程池中。当要执行的任务分配到相应线程池后，就可以执行了。使用线程池会带来很多好处：

1. 可以更快地完成任务。当一个任务被分配到了线程池中，就会被循环执行下去，直到执行完成或者是线程重新创建完成。
2. 提高了资源利用效率。当一个任务需要很多资源时，例如 CPU、内存等，就可以使用线程池来管理这些资源，使每个线程都有足够的 CPU和内存来执行这个任务。
<a name="MkORc"></a>
## 七、内核态的同步机制
上面介绍了两种同步机制，那么来看看内核态的同步机制，在内核态有四种同步方式：

1. 信号量：它是用来操作锁的，当一个线程占用了一个锁时，它会向系统发送一个信号量。
2. 信号量传递：这个机制是由操作系统提供的，在调用`sys_thread`函数后，会进入中断状态，此时调用`sys_thread`函数时，就会将信号量传递给系统。
3. 互斥锁：这种方式主要是通过优先级的高低来控制对资源的访问。
4. 互斥锁和信号量都是用来解决进程之间的同步问题的。
5. 还有一种同步方式是通过线程池来实现的。在这个过程中，线程池会创建一个线程，通过这个线程来跟其他线程进行交互，从而达到同步效果。
<a name="FkUXS"></a>
## 八、总结
通过上面的分析了解到，同步是一个复杂的问题，在内核态是如何完成同步的呢？<br />首先，在内核态有三个进程：这三个进程都可以互相访问对方的资源，也可以在资源被其他进程请求时进行同步。<br />当某个进程被阻塞时，它的所有子进程会从等待队列中取出一个子进程（或者其它子进程），并把它加到阻塞队列中。当所有子进程都被阻塞时，阻塞队列中就没有子进程了。这时，等待队列中的其他子进程就会把当前线程加到等待队列中。这三个进程在等待过程中不会互相影响，三个线程可以通过设置自己的优先级和其他线程进行同步。
