Linux
<a name="fC1xU"></a>
## Linux 目录结构
对于每一个Linux学习者来说，了解Linux文件系统的目录结构，是学好Linux的至关重要的一步，深入了解linux文件目录结构的标准和每个目录的详细功能，对于用好linux系统至关重要。<br />当在使用Linux的时候，如果通过`ls –l /` 就会发现，在`/`下包涵很多的目录，比如etc、usr、var、bin ... ... 等目录，而在这些目录中，发现也有很多的目录或文件。文件系统在Linux下看上去就像树形结构，所以可以把文件系统的结构形象的称为树形结构。<br />文件系统的是用来组织和排列文件存取的，所以她是可见的，在Linux中，可以通过`ls`等工具来查看其结构，在Linux系统中，见到的都是树形结构；比如操作系统安装在一个文件系统中，表现为由/ 起始的树形结构。linux文件系统的最顶端是`/`，称`/`为Linux的root，也就是 Linux操作系统的文件系统。Linux的文件系统的入口就是`/`，所有的目录、文件、设备都在/之下，/就是Linux文件系统的组织者，也是最上级的领导者。<br />由于linux是开放源代码，各大公司和团体根据linux的核心代码做各自的操作，编程。这样就造成在根下的目录的不同。这样就造成个人不能使用他人的linux系统的PC。因为根本不知道一些基本的配置，文件在哪里。这就造成了混乱。这就是FHS（Filesystem Hierarchy Standard ）机构诞生的原因。该机构是linux爱好者自发的组成的一个团体，主要是是对linux做一些基本的要求，不至于是操作者换一台主机就成了linux的‘文盲’。<br />根据FHS(http://www.pathname.com/fhs/)的官方文件指出， 他们的主要目的是希望让使用者可以了解到已安装软件通常放置于那个目录下， 所以他们希望独立的软件开发商、操作系统制作者、以及想要维护系统的用户，都能够遵循FHS的标准。 也就是说，FHS的重点在于规范每个特定的目录下应该要放置什么样子的数据而已。 这样做好处非常多，因为Linux操作系统就能够在既有的面貌下(目录架构不变)发展出开发者想要的独特风格。<br />事实上，FHS是根据过去的经验一直再持续的改版的，FHS依据文件系统使用的频繁与否与是否允许使用者随意更动， 而将目录定义成为四种交互作用的形态，用表格来说有点像底下这样：

|  | **可分享的(shareable)** | **不可分享的(unshareable)** |
| --- | --- | --- |
| **不变的(static)** | /usr (软件放置处) | /etc (配置文件) |
|  | /opt (第三方协力软件) | /boot (开机与核心档) |
| **可变动的(variable)** | /var/mail (使用者邮件信箱) | /var/run (程序相关) |
|  | /var/spool/news (新闻组) | /var/lock (程序相关) |

**四种类型:**<br />**1、可分享的：**<br />可以分享给其他系统挂载使用的目录，所以包括执行文件与用户的邮件等数据， 是能够分享给网络上其他主机挂载用的目录；<br />**2、不可分享的：**<br />自己机器上面运作的装置文件或者是与程序有关的socket文件等， 由于仅与自身机器有关，所以当然就不适合分享给其他主机了。<br />**3、不变的：**<br />有些数据是不会经常变动的，跟随着distribution而不变动。 例如函式库、文件说明文件、系统管理员所管理的主机服务配置文件等等；<br />**4、可变动的：**<br />经常改变的数据，例如登录文件、一般用户可自行收受的新闻组等。<br />事实上，FHS针对目录树架构仅定义出三层目录底下应该放置什么数据而已，分别是底下这三个目录的定义：<br />**/ (root, 根目录)：与开机系统有关；**<br />**/usr (unix software resource)：与软件安装/执行有关；**<br />**/var (variable)：与系统运作过程有关。**
<a name="XCWB9"></a>
### 一、根目录 (/) 的意义与内容
根目录是整个系统最重要的一个目录，因为不但所有的目录都是由根目录衍生出来的， 同时根目录也与开机/还原/系统修复等动作有关。 由于系统开机时需要特定的开机软件、核心文件、开机所需程序、 函式库等等文件数据，若系统出现错误时，根目录也必须要包含有能够修复文件系统的程序才行。 因为根目录是这么的重要，所以在FHS的要求方面，他希望根目录不要放在非常大的分区， 因为越大的分区内会放入越多的数据，如此一来根目录所在分区就可能会有较多发生错误的机会。<br />因此FHS标准建议：根目录(/)所在分区应该越小越好， 且应用程序所安装的软件最好不要与根目录放在同一个分区内，保持根目录越小越好。 如此不但效能较佳，根目录所在的文件系统也较不容易发生问题。**说白了，就是根目录和Windows的C盘一个样。**<br />根据以上原因，FHS认为根目录(/)下应该包含如下子目录：

| **目录** | **应放置档案内容** |
| --- | --- |
| /bin | 系统有很多放置执行档的目录，但/bin比较特殊。因为/bin放置的是在单人维护模式下还能够被操作的指令。在/bin底下的指令可以被root与一般帐号所使用，主要有：cat,chmod(修改权限), chown, date, mv, mkdir, cp, bash等等常用的指令。 |
| /boot | 主要放置开机会使用到的档案，包括Linux核心档案以及开机选单与开机所需设定档等等。Linux kernel常用的档名为：vmlinuz ，如果使用的是grub这个开机管理程式，则还会存在/boot/grub/这个目录。 |
| /dev | 在Linux系统上，任何装置与周边设备都是以档案的型态存在于这个目录当中。 只要通过存取这个目录下的某个档案，就等于存取某个装置。比要重要的档案有/dev/null, /dev/zero, /dev/tty , /dev/lp*, / dev/hd*, /dev/sd*等等 |
| /etc | 系统主要的设定档几乎都放置在这个目录内，例如人员的帐号密码档、各种服务的启始档等等。 一般来说，这个目录下的各档案属性是可以让一般使用者查阅的，但是只有root有权力修改。FHS建议不要放置可执行档(binary)在这个目录中。 比较重要的档案有：/etc/inittab, /etc/init.d/, /etc/modprobe.conf, /etc/X11/, /etc/fstab, /etc/sysconfig/等等。 另外，其下重要的目录有：/etc/init.d/ ：所有服务的预设启动script都是放在这里的，例如要启动或者关闭iptables的话： /etc/init.d/iptables start、/etc/init.d/ iptables stop<br />/etc/xinetd.d/ ：这就是所谓的super daemon管理的各项服务的设定档目录。<br />/etc/X11/ ：与X Window有关的各种设定档都在这里，尤其是xorg.conf或XF86Config这两个X Server的设定档。 |
| /home | 这是系统预设的使用者家目录(home directory)。 在新增一个一般使用者帐号时，预设的使用者家目录都会规范到这里来。比较重要的是，家目录有两种代号： ~ ：代表当前使用者的家目录，而 ~guest：则代表用户名为guest的家目录。 |
| /lib | 系统的函式库非常的多，而/lib放置的则是在开机时会用到的函式库，以及在/bin或/sbin底下的指令会呼叫的函式库而已 。 什么是函式库呢？可以将他想成是外挂，某些指令必须要有这些外挂才能够顺利完成程式的执行之意。 尤其重要的是/lib/modules/这个目录，因为该目录会放置核心相关的模组(驱动程式)。 |
| /media | media是媒体的英文，顾名思义，这个/media底下放置的就是可移除的装置。 包括软碟、光碟、DVD等等装置都暂时挂载于此。 常见的档名有：/media/floppy, /media/cdrom等等。 |
| /mnt | 如果想要暂时挂载某些额外的装置，一般建议可以放置到这个目录中。在很早时候，这个目录的用途与/media相同。 只是有了/media之后，这个目录就用来暂时挂载用了。 |
| /opt | 这个是给第三方协力软体放置的目录 。 什么是第三方协力软体？举例来说，KDE这个桌面管理系统是一个独立的计划，不过他可以安装到Linux系统中，因此KDE的软体就建议放置到此目录下了。 另外，如果要自行安装额外的软体(非原本的distribution提供的)，那么也能够将要安装的软体安装到这里来。 不过，以前的Linux系统中，还是习惯放置在/usr/local目录下。 |
| /root | 系统管理员(root)的家目录。 之所以放在这里，是因为如果进入单人维护模式而仅挂载根目录时，该目录就能够拥有root的家目录，所以会希望root的家目录与根目录放置在同一个分区中。 |
| /sbin | Linux有非常多指令是用来设定系统环境的，这些指令只有root才能够利用来设定系统，其他使用者最多只能用来查询而已。放在/sbin底下的为开机过程中所需要的，里面包括了开机、修复、还原系统所需要的指令。至于某些伺服器软体程式，一般则放置到/usr/sbin/当中。至于本机自行安装的软体所产生的系统执行档(system binary)，则放置到/usr/local/sbin/当中了。常见的指令包括：fdisk, fsck, ifconfig, init, mkfs等等。 |
| /srv | srv可以视为service的缩写，是一些网路服务启动之后，这些服务所需要取用的资料目录。 常见的服务例如WWW, FTP等等。 举例来说，WWW伺服器需要的网页资料就可以放置在/srv/www/里面。 |
| /tmp | 这是让一般使用者或者是正在执行的程序暂时放置档案的地方。这个目录是任何人都能够存取的，所以需要定期的清理一下。当然，重要资料不可放置在此目录。 因为FHS甚至建议在开机时，应该要将/tmp下的资料都删除。 |

事实上FHS针对根目录所定义的标准就仅限于上表，不过仍旧有些目录也需要了解一下，具体如下：

| **目录** | **应放置文件内容** |
| --- | --- |
| /lost+found | 这个目录是使用标准的ext2/ext3档案系统格式才会产生的一个目录，目的在于当档案系统发生错误时，将一些遗失的片段放置到这个目录下。 这个目录通常会在分割槽的最顶层存在，例如加装一个硬盘于/disk中，那在这个系统下就会自动产生一个这样的目录/disk/lost+found |
| /proc | 这个目录本身是一个虚拟文件系统(virtual filesystem)。 他放置的资料都是在内存当中，例如系统核心、(process)、周边装置的状态及网络状态等等。因为这个目录下的资料都是在记忆体（内存）当中，所以本身不占任何硬盘空间。比较重要的档案（目录）例如： /proc/cpuinfo, /proc/dma, /proc/interrupts, /proc/ioports, /proc/net/*等等。 |
| /sys | 这个目录其实跟/proc非常类似，也是一个虚拟的档案系统，主要也是记录与核心相关的资讯。 包括目前已载入的核心模组与核心侦测到的硬体装置资讯等等。 这个目录同样不占硬盘容量。 |

除了这些目录的内容之外，另外要注意的是，因为根目录与开机有关，开机过程中仅有根目录会被挂载， 其他分区则是在开机完成之后才会持续的进行挂载的行为。就是因为如此，因此根目录下与开机过程有关的目录， 就不能够与根目录放到不同的分区去。那哪些目录不可与根目录分开呢？有底下这些：<br />/etc：配置文件<br />/bin：重要执行档<br />/dev：所需要的装置文件<br />/lib：执行档所需的函式库与核心所需的模块<br />/sbin：重要的系统执行文件<br />这五个目录千万不可与根目录分开在不同的分区。
<a name="39d68730"></a>
### 二、`/usr` 的意义与内容
依据FHS的基本定义，/usr里面放置的数据属于可分享的与不可变动的(shareable, static)， 如果知道如何透过网络进行分区的挂载(例如在服务器篇会谈到的NFS服务器)，那么/usr确实可以分享给局域网络内的其他主机来使用。<br />/usr不是user的缩写，其实usr是Unix Software Resource的缩写， 也就是Unix操作系统软件资源所放置的目录，而不是用户的数据。这点要注意。FHS建议所有软件开发者，应该将他们的数据合理的分别放置到这个目录下的次目录，而不要自行建立该软件自己独立的目录。<br />因为是所有系统默认的软件(distribution发布者提供的软件)都会放置到/usr底下，因此这个目录有点类似Windows 系统的C:\Windows\ + C:\Program files\这两个目录的综合体，系统刚安装完毕时，这个目录会占用最多的硬盘容量。 一般来说，/usr的次目录建议有底下这些：

| **目录** | **应放置文件内容** |
| --- | --- |
| /usr/X11R6/  | 为X Window System重要数据所放置的目录，之所以取名为X11R6是因为最后的X版本为第11版，且该版的第6次释出之意。  |
| /usr/bin/  | 绝大部分的用户可使用指令都放在这里。请注意到他与/bin的不同之处。(是否与开机过程有关)  |
| /usr/include/  | c/c++等程序语言的档头(header)与包含档(include)放置处，当以tarball方式 (*.tar.gz 的方式安装软件)安装某些数据时，会使用到里头的许多包含档。  |
| /usr/lib/  | 包含各应用软件的函式库、目标文件(object file)，以及不被一般使用者惯用的执行档或脚本(script)。 某些软件会提供一些特殊的指令来进行服务器的设定，这些指令也不会经常被系统管理员操作， 那就会被摆放到这个目录下。要注意的是，如果使用的是X86_64的Linux系统， 那可能会有/usr/lib64/目录产生  |
| /usr/local/  | 统管理员在本机自行安装自己下载的软件(非distribution默认提供者)，建议安装到此目录， 这样会比较便于管理。举例来说，你的distribution提供的软件较旧，你想安装较新的软件但又不想移除旧版， 此时可以将新版软件安装于/usr/local/目录下，可与原先的旧版软件有分别。 可以自行到/usr/local去看看，该目录下也是具有bin, etc, include, lib...的次目录  |
| /usr/sbin/  | 非系统正常运作所需要的系统指令。最常见的就是某些网络服务器软件的服务指令(daemon)  |
| /usr/share/  | 放置共享文件的地方，在这个目录下放置的数据几乎是不分硬件架构均可读取的数据， 因为几乎都是文本文件嘛。在此目录下常见的还有这些次目录：/usr/share/man：联机帮助文件<br />/usr/share/doc：软件杂项的文件说明<br />/usr/share/zoneinfo：与时区有关的时区文件 |
| /usr/src/  | 一般原始码建议放置到这里，src有source的意思。至于核心原始码则建议放置到/usr/src/linux/目录下。  |

<a name="gv79g"></a>
### 三、 `/var` 的意义与内容
如果/usr是安装时会占用较大硬盘容量的目录，那么/var就是在系统运作后才会渐渐占用硬盘容量的目录。 因为/var目录主要针对常态性变动的文件，包括缓存(cache)、登录档(log file)以及某些软件运作所产生的文件， 包括程序文件(lock file, run file)，或者例如MySQL数据库的文件等等。常见的次目录有：

| **目录** | **应放置文件内容** |
| --- | --- |
| /var/cache/ | 应用程序本身运作过程中会产生的一些暂存档 |
| /var/lib/ | 程序本身执行的过程中，需要使用到的数据文件放置的目录。在此目录下各自的软件应该要有各自的目录。 举例来说，MySQL的数据库放置到/var/lib/mysql/而rpm的数据库则放到/var/lib/rpm去 |
| /var/lock/ | 某些装置或者是文件资源一次只能被一个应用程序所使用，如果同时有两个程序使用该装置时， 就可能产生一些错误的状况，因此就得要将该装置上锁(lock)，以确保该装置只会给单一软件所使用。 举例来说，刻录机正在刻录一块光盘，如果有两个人同时在使用一个刻录机烧片？ 如果两个人同时刻录，那片子写入的是谁的数据？所以当第一个人在刻录时该刻录机就会被上锁， 第二个人就得要该装置被解除锁定(就是前一个人用完了)才能够继续使用 |
| /var/log/ | 非常重要。这是登录文件放置的目录。里面比较重要的文件如/var/log/messages, /var/log/wtmp(记录登入者的信息)等。 |
| /var/mail/ | 放置个人电子邮件信箱的目录，不过这个目录也被放置到/var/spool/mail/目录中，通常这两个目录是互为链接文件。 |
| /var/run/ | 某些程序或者是服务启动后，会将他们的PID放置在这个目录下 |
| /var/spool/ | 这个目录通常放置一些队列数据，所谓的“队列”就是排队等待其他程序使用的数据。 这些数据被使用后通常都会被删除。举例来说，系统收到新信会放置到/var/spool/mail/中， 但使用者收下该信件后该封信原则上就会被删除。信件如果暂时寄不出去会被放到/var/spool/mqueue/中， 等到被送出后就被删除。如果是工作排程数据(crontab)，就会被放置到/var/spool/cron/目录中。 |

由于FHS仅是定义出最上层(/)及次层(/usr, /var)的目录内容应该要放置的文件或目录数据， 因此，在其他次目录层级内，就可以随开发者自行来配置了。
<a name="s6wxN"></a>
### 四、目录树(directory tree) 
在Linux底下，所有的文件与目录都是由根目录开始的。那是所有目录与文件的源头, 然后再一个一个的分支下来，因此，也称这种目录配置方式为：目录树(directory tree), 这个目录树的主要特性有：<br />目录树的启始点为根目录 (/, root)；<br />每一个目录不止能使用本地端的 partition 的文件系统，也可以使用网络上的 filesystem 。举例来说， 可以利用 Network File System (NFS) 服务器挂载某特定目录等。<br />每一个文件在此目录树中的文件名(包含完整路径)都是独一无二的。<br />如果将整个目录树以图的方法来显示，并且将较为重要的文件数据列出来的话，那么目录树架构就如下图所示：<br />![](https://cdn.nlark.com/yuque/0/2020/webp/396745/1608772671399-aa584079-b175-41f0-81e7-fa091cc6bb92.webp#averageHue=%23f0f0f0&height=599&id=rk4ba&originHeight=432&originWidth=488&originalType=binary&ratio=1&rotation=0&showTitle=false&size=0&status=done&style=shadow&title=&width=677)
<a name="d6216115"></a>
### 五、绝对路径与相对路径
除了需要特别注意的FHS目录配置外，在文件名部分也要特别注意。因为根据档名写法的不同，也可将所谓的路径(path)定义为绝对路径(absolute)与相对路径(relative)。 这两种文件名/路径的写法依据是这样的：<br />**绝对路径：**<br />由根目录(/)开始写起的文件名或目录名称， 例如 /home/dmtsai/.bashrc；<br />**相对路径：**<br />相对于目前路径的文件名写法。 例如 ./home/dmtsai  等等。反正开头不是 / 就属于相对路径的写法<br />必须要了解的是相对路径是以当前所在路径的相对位置来表示的。举例来说，目前在 /home 这个目录下， 如果想要进入 /var/log 这个目录时，可以怎么写呢？<br />cd /var/log   (absolute)<br />cd ../var/log (relative)<br />因为在 /home 底下，所以要回到上一层 (`../`) 之后，才能继续往 /var 来移动的，特别注意这两个特殊的目录：<br />`.`  ：代表当前的目录，也可以使用 `./` 来表示；<br />`..` ：代表上一层目录，也可以 `../` 来代表。<br />这个 `.` 与 `..` 目录概念是很重要的，常常会看到 cd .. 或 ./command 之类的指令下达方式， 就是代表上一层与目前所在目录的工作状态。<br />**实例1：如何先进入/var/spool/mail/目录，再进入到/var/spool/cron/目录内？**<br />**命令**：
```bash
cd /var/spool/mail
cd ../cron
```
**说明：**<br />由于/var/spool/mail与/var/spool/cron是同样在/var/spool/目录中。如此就不需要在由根目录开始写起了。这个相对路径是非常有帮助的，尤其对于某些软件开发商来说。 一般来说，软件开发商会将数据放置到/usr/local/里面的各相对目录。 但如果用户想要安装到不同目录呢？就得要使用相对路径。<br />**实例2：网络文件常常提到类似./run.sh之类的数据，这个指令的意义为何？**<br />**说明：**<br />由于指令的执行需要变量的支持，若执行文件放置在本目录，并且本目录并非正规的执行文件目录(/bin, /usr/bin等为正规)，此时要执行指令就得要严格指定该执行档。./代表本目录的意思，所以./run.sh代表执行本目录下， 名为run.sh的文件。
<a name="s8xxt"></a>
## Linux文件类型与扩展名
Linux文件类型和Linux文件的文件名所代表的意义是两个不同的概念。通过一般应用程序而创建的比如file.txt、file.tar.gz ，这些文件虽然要用不同的程序来打开，但放在Linux文件类型中衡量的话，大多是常规文件（也被称为普通文件）。
<a name="m1L49"></a>
### 一、文件类型
Linux文件类型常见的有：普通文件、目录文件、字符设备文件和块设备文件、符号链接文件等，现在进行一个简要的说明。
<a name="46c56b4f"></a>
#### 1、普通文件 
用 ls -lh 来查看某个文件的属性，可以看到有类似-rwxrwxrwx，值得注意的是第一个符号是 - ，这样的文件在Linux中就是普通文件。这些文件一般是用一些相关的应用程序创建，比如图像工具、文档工具、归档工具... .... 或 cp工具等。这类文件的删除方式是用rm 命令。 另外，依照文件的内容，又大略可以分为：
<a name="aITbh"></a>
##### 1>纯文本档(ASCII)：
这是Linux系统中最多的一种文件类型，称为纯文本档是因为内容为人类可以直接读到的数据，例如数字、字母等等。 只要可以用来做为设定的文件都属于这一种文件类型。 举例来说，可以用命令： cat ~/.bashrc 来看到该文件的内容。 (cat 是将一个文件内容读出来的指令).
<a name="lBd13"></a>
##### 2>二进制文件(binary)：
Linux系统其实仅认识且可以执行二进制文件(binary file)。Linux当中的可执行文件(scripts, 文字型批处理文件不算)就是这种格式的文件。 刚刚使用的命令cat就是一个binary file。
<a name="Ozb2o"></a>
##### 3>数据格式文件(data)： 
有些程序在运作的过程当中会读取某些特定格式的文件，那些特定格式的文件可以被称为数据文件 (data file)。举例来说，Linux在使用者登录时，都会将登录的数据记录在 /var/log/wtmp那个文件内，该文件是一个data file，他能够透过last这个指令读出来！ 但是使用cat时，会读出乱码～因为他是属于一种特殊格式的文件？
<a name="njBCy"></a>
#### 2、目录文件
当在某个目录下执行，看到有类似 drwxr-xr-x ，这样的文件就是目录，目录在Linux是一个比较特殊的文件。注意它的第一个字符是d。创建目录的命令可以用 mkdir 命令，或cp命令，cp可以把一个目录复制为另一个目录。删除用rm 或rmdir命令。 
<a name="DAjvw"></a>
#### 3、字符设备或块设备文件 
进入/dev目录，列一下文件，会看到类似如下的:
```bash
[root@localhost ~]# ls -al /dev/tty
crw-rw-rw- 1 root tty 5, 0 11-03 15:11 /dev/tty
[root@localhost ~]# ls -la /dev/sda1
brw-r----- 1 root disk 8, 1 11-03 07:11 /dev/sda1
```
可以看到/dev/tty的属性是 crw-rw-rw- ，注意前面第一个字符是 c ，这表示字符设备文件。比如猫等串口设备。可以看到 /dev/sda1 的属性是 brw-r----- ，注意前面的第一个字符是b，这表示块设备，比如硬盘，光驱等设备。<br />这个种类的文件，是用mknode来创建，用rm来删除。目前在最新的Linux发行版本中，一般不用自己来创建设备文件。因为这些文件是和内核相关联的。<br />与系统周边及储存等相关的一些文件， 通常都集中在/dev这个目录之下！通常又分为两种：
<a name="LjPn3"></a>
##### 区块(block)设备档 
就是一些储存数据， 以提供系统随机存取的接口设备，举例来说，硬盘与软盘等就是！ 可以随机的在硬盘的不同区块读写，这种装置就是成组设备！可以自行查一下/dev/sda看看， 会发现第一个属性为[ b ]！
<a name="5HcJm"></a>
##### 字符(character)设备文件
亦即是一些串行端口的接口设备， 例如键盘、鼠标等等！这些设备的特色就是一次性读取的，不能够截断输出。 举例来说，不可能让鼠标跳到另一个画面，而是滑动到另一个地方！第一个属性为 [ c ]。
<a name="MUIlS"></a>
#### 4、数据接口文件(sockets)
数据接口文件（或者：套接口文件），这种类型的文件通常被用在网络上的数据承接了。可以启动一个程序来监听客户端的要求， 而客户端就可以透过这个socket来进行数据的沟通了。第一个属性为 [ s ]， 最常在/var/run这个目录中看到这种文件类型了。<br />例如：当启动MySQL服务器时，会产生一个mysql.sock的文件。
```bash
[root@localhost ~]# ls -lh /var/lib/mysql/mysql.sock 
srwxrwxrwx 1 mysql mysql 0 04-19 11:12 /var/lib/mysql/mysql.sock
```
注意这个文件的属性的第一个字符是 s。
<a name="dabb0fa4"></a>
#### 5、符号链接文件
当查看文件属性时，会看到有类似 lrwxrwxrwx,注意第一个字符是l，这类文件是链接文件。是通过`ln -s` 源文件名 新文件名 。上面是一个例子，表示setup.log是install.log的软链接文件。怎么理解呢？这和Windows操作系统中的快捷方式有点相似。<br />符号链接文件的创建方法举例:
```bash
[root@localhost test]# ls -lh log2012.log
-rw-r--r-- 1 root root 296K 11-13 06:03 log2012.log
[root@localhost test]# ln -s log2012.log  linklog.log
[root@localhost test]# ls -lh *.log
lrwxrwxrwx 1 root root   11 11-22 06:58 linklog.log -> log2012.log
-rw-r--r-- 1 root root 296K 11-13 06:03 log2012.log
```
<a name="Tb3SM"></a>
#### 6、数据输送文件（FIFO,pipe）
FIFO也是一种特殊的文件类型，他主要的目的在解决多个程序同时存取一个文件所造成的错误问题。FIFO是first-in-first-out的缩写。第一个属性为[p] 。
<a name="llXFp"></a>
### 二、Linux文件扩展名
<a name="TzicR"></a>
#### 1、扩展名类型
基本上，Linux的文件是没有所谓的扩展名的，一个Linux文件能不能被执行，与他的第一栏的十个属性有关， 与档案名根本一点关系也没有。这个观念跟Windows的情况不相同！在Windows下， 能被执行的文件扩展名通常是 .com .exe .bat等等，而在Linux底下，只要权限当中具有`x`的话，例如[ -rwx-r-xr-x ] 即代表这个文件可以被执行。<br />不过，可以被执行跟可以执行成功是不一样的～举例来说，在root家目录下的install.log 是一个纯文本档，如果经由修改权限成为 -rwxrwxrwx 后，这个文件能够真的执行成功吗？ 当然不行～因为他的内容根本就没有可以执行的数据。所以说，这个x代表这个文件具有可执行的能力， 但是能不能执行成功，当然就得要看该文件的内容.<br />虽然如此，不过仍然希望可以藉由扩展名来了解该文件是什么东西，所以，通常还是会以适当的扩展名来表示该文件是什么种类的。底下有数种常用的扩展名：<br />*.sh ： 脚本或批处理文件 (scripts)，因为批处理文件为使用shell写成的，所以扩展名就编成 .sh<br />*Z, *.tar, *.tar.gz, *.zip, *.tgz： 经过打包的压缩文件。这是因为压缩软件分别为 gunzip, tar 等等的，由于不同的压缩软件，而取其相关的扩展名！<br />*.html, *.php：网页相关文件，分别代表 HTML 语法与 PHP 语法的网页文件。 .html 的文件可使用网页浏览器来直接开启，至于 .php 的文件， 则可以透过 client 端的浏览器来 server 端浏览，以得到运算后的网页结果。<br />基本上，Linux系统上的文件名真的只是了解该文件可能的用途而已，真正的执行与否仍然需要权限的规范才行。例如虽然有一个文件为可执行文件，如常见的/bin/ls这个显示文件属性的指令，不过，如果这个文件的权限被修改成无法执行时，那么ls就变成不能执行。<br />上述的这种问题最常发生在文件传送的过程中。例如在网络上下载一个可执行文件，但是偏偏在Linux系统中就是无法执行！那么就是可能文件的属性被改变了。不要怀疑，从网络上传送到 Linux系统中，文件的属性与权限确实是会被改变的。
<a name="UKJLP"></a>
#### 2、Linux文件名长度限制
在Linux底下，使用预设的Ext2/Ext3文件系统时，针对文件名长度限制为：<br />单一文件或目录的最大容许文件名为 255 个字符<br />包含完整路径名称及目录 (/) 之完整档名为 4096 个字符<br />是相当长的档名！Linux的文件名可以一看就知道该文件的作用， 所以档名通常是很长很长。
<a name="3SQ1N"></a>
#### 3、Linux文件名的字符的限制
由于Linux在文字接口下的一些指令操作关系，一般来说，在设定Linux底下的文件名时， 最好可以避免一些特殊字符比较好！例如底下这些：<br />`* ? > < ; & ! [ ] | \ ' " ` ( ) { }`<br />因为这些符号在文字接口下，是有特殊意义的。另外，文件名的开头为小数点“`.`”时， 代表这个文件为隐藏文件！同时，由于指令下达当中，常常会使用到 -option 之类的选项， 所以最好也避免将文件档名的开头以 - 或 + 来命名。
<a name="49c3897f"></a>
## linux文件属性详解
Linux 文件或目录的属性主要包括：文件或目录的节点、种类、权限模式、链接数量、所归属的用户和用户组、最近访问或修改的时间等内容。具体情况如下：**命令：** ls -lih**输出：**
```bash
[root@localhost test]# ls -lih
总计 316K
2095120 lrwxrwxrwx 1 root root   11 11-22 06:58 linklog.log -> log2012.log
2095112 -rw-r--r-- 1 root root 296K 11-13 06:03 log2012.log
2095110 -rw-r--r-- 1 root root   61 11-13 06:03 log2013.log
2095107 -rw-r--r-- 1 root root    0 11-13 06:03 log2014.log
2095117 -rw-r--r-- 1 root root    0 11-13 06:06 log2015.log
2095118 -rw-r--r-- 1 root root    0 11-16 14:41 log2016.log
2095119 -rw-r--r-- 1 root root    0 11-16 14:43 log2017.log
2095113 drwxr-xr-x 6 root root 4.0K 10-27 01:58 scf
2095109 drwxrwxr-x 2 root root 4.0K 11-13 06:08 test3
2095131 drwxrwxr-x 2 root root 4.0K 11-13 05:50 test4
```
**说明：**第一列：inode第二列：文件种类和权限；第三列： 硬链接个数；第四列： 属主；第五列：所归属的组；第六列：文件或目录的大小；第七列和第八列：最后访问或修改时间；第九列：文件名或目录名<br />以log2012.log为例：
```bash
2095112 -rw-r--r-- 1 root root 296K 11-13 06:03 log2012.log
```
inode 的值是：2095112 文件类型：文件类型是-，表示这是一个普通文件； 关于文件的类型，请参考：Linux文件类型与扩展名 文件权限：文件权限是rw-r--r-- ，表示文件属主可读、可写、不可执行，文件所归属的用户组不可写，可读，不可执行，其它用户不可写，可读，不可执行；<br />硬链接个数： log2012.log这个文件没有硬链接；因为数值是1，就是他本身；文件属主：也就是这个文件归哪于哪个用户 ，它归于root，也就是第一个root；文件属组：也就是说，对于这个文件，它归属于哪个用户组，在这里是root用户组；文件大小：文件大小是296k个字节；访问可修改时间 ：这里的时间是最后访问的时间，最后访问和文件被修改或创建的时间，有时并不是一致的；当然文档的属性不仅仅包括这些，这些是最常用的一些属性。**关于inode：**inode 译成中文就是索引节点。每个存储设备或存储设备的分区（存储设备是硬盘、软盘、U盘等等）被格式化为文件系统后，应该有两部份，一部份是inode，另一部份是Block，Block是用来存储数据用的。而inode呢，就是用来存储这些数 据的信息，这些信息包括文件大小、属主、归属的用户组、读写权限等。inode为每个文件进行信息索引，所以就有了inode的数值。操作系统根据指令， 能通过inode值最快的找到相对应的文件。做个比喻，比如一本书，存储设备或分区就相当于这本书，Block相当于书中的每一页，inode 就相当于这本书前面的目录，一本书有很多的内容，如果想查找某部份的内容，可以先查目录，通过目录能最快的找到想要看的内容。虽然不太恰当，但还是比较形象。当用ls 查看某个目录或文件时，如果加上-i 参数，就可以看到inode节点了；比如前面所说的例子：
```bash
[root@localhost test]#  ls -li log2012.log 
2095112 -rw-r--r-- 1 root root 302108 11-13 06:03 log2012.log
```
log2012.log 的inode值是 2095112 ； 查看一个文件或目录的inode，要通过`ls` 命令的的 `-i`参数。
