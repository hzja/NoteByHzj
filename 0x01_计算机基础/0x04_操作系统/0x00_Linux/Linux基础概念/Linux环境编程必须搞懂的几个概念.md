Linux<br />Linux环境编程对于初学者来说，必须深刻理解重点概念才能更好地编写代码，实现业务功能，下面就几个重要的及常用的知识点进行说明。搞懂这几个概念后以免在将来的编码出现混淆。
<a name="MjR0e"></a>
## 系统调用
所有的操作系统在其内核里都有一些内建的函数，这些函数可以用来完成一些系统级别的功能。在Linux系统使用的这样的函数叫做“系统调用”，英文是systemcall。这些函数代表了从用户空间到内核空间的一种转换。

- 系统调用是Linux操作系统提供的服务，是编写应用程序与内核之间通信的接口，也就是函数。相对于普通的函数调用来说，系统调用的性能消耗相对来说是大的。所以在程序追求性能的同时，尽量避免系统调用。
- 用户态的程序默认是通过栈来传递参数的。而对于系统调用来说，内核态和用户态使用的是不同的栈，这使得系统调用的参数只能通过寄存器的方式进行传递。
<a name="rB1Jw"></a>
## IO操作
什么是IO，通俗来讲就是输入输出

- IO分为标准IO和文件IO，常用的scanf、printf、getchar、putchar、gets、puts这些都是标准输入输出。Linux系统下一切皆文件的概念，所以在linux下的编程中对文件的IO操作有标准IO和文件IO两种操作类型。标准IO是带缓冲的IO属于库函数，文件IO是不带缓冲的属于系统调用。

标准IO：

1. 标准IO是由ANSIC标准定义
2. 跨平台，可以在windows下运行，也可以在Linux下运行
3. 通过缓冲机制来减少系统调用，实现更高的效率
4. 文件流 标准IO用结构体类型来存放文件的相关信息，标准IO所有操作围绕着FILE来操作。

文件IO：

1. 文件IO是POSIX提供的一组函数
2. 只能运行在可移植操作系统中，不能跨平台
3. 没有缓冲机制
4. 文件描述符是一个非负整数，每打开一个文件，系统会自动分配一个文件描述符（即从系统最小的且没有被用的描述符来分配）
<a name="niKsL"></a>
## 原子操作
原子在化学课程中是不可再分的颗粒。而对于Linux系统来说所谓原子操作是为了确保对一个整型数据的更改具有排他性。原子操作就是要么不执行，一旦执行就会执行完成，是不可被打断的一个，或一系列的动作，即在完成任务前不会被其他事件所打断，就像原子不可被分割成颗粒一样。单处理中，可以用单条指令完成的指令可以被看成是一个原子操作。软件中的原子操作依赖于硬件原子操作的支持。当然原子操作，也可以当引用计数使用。

- 原子操作其实本质上和锁实现同样的功能，都是为了保护共享对象，它具有原子性，和顺序性。原子性确保指令执行期间不被打断，要么全部执行，要么根本不执行。而顺序性确保即使两条或多条指令出现在独立的执行线程中，甚至独立的处理器上，它们本该执行的顺序依然要保持。
<a name="Qdu6V"></a>
## 线程安全
所谓线程安全，就是指代码可以在多线程环境下安全地执行，输出想要的结果。即符合正确的逻辑，是程序员期望的正常执行结果。为了实现线程安全，Linux系统提供一些列的方法，或者只能使用局部变量或资源，或者就是利用锁等同步机制，来实现全局变量或资源的访问。

- 线程安全在Linux环境编程中极其重要，不仅要了解概念，更重要的是要在实际的编程中学会实现线程安全方式。下面来看一个简单的例子：
```c
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>

static int nCnt = 0;

void * Thread(void * arg)
{
    for (int i = 0; i < 10000; ++i) 
    {
        ++nCnt;
    }

    return NULL;
}
int main()
{
    pthread_t t1;
    pthread_t t2;

    /* 创建两个线程 */
    pthread_create(&t1, NULL, thread, NULL);
    pthread_create(&t2, NULL, thread, NULL);

    pthread_join(t1, NULL);
    pthread_join(t2, NULL);

    printf("nCnt is %d by threads\n", nCnt);

    return 0;
}
```

- 大家看出上面例子的问题了吗？
- 对，没错，在此例子中创建了两个线程，线程函数是同一个函数，在线程函数中是对全局变量nCnt的自增操作。这个例子中输出结果想要的是不一样，就是因为nCnt执行指令并不是原子的，两个个线程对nCnt的并发访问出现了问题。利用锁就可以解决此问题。
<a name="RcWxK"></a>
## 阻塞与非阻塞
Linux环境编程中的阻塞与非阻塞，都是指I/O操作。而所有的I/O系统调用默认都是阻塞的。那什么是阻塞？ 阻塞的系统调用是指当进行系统调用时除非出错或被信号打断，那么系统调用将会一直陷入内核态直到调用完成。非阻塞的系统调用是指无论I/O操作成功与否，调用都会立刻返回。阻塞和非阻塞IO是访问设备的两种模式，驱动程序可以灵活的支持这两种用户空间对设备的访问方式。

- 阻塞操作是指在执行操作时，若不能获得资源，则阻塞进程直到满足条件再进行操作。被阻塞的进程进入睡眠状态，被调度器的运行队列移走，直到等待的条件满足
- 非阻塞是指在进行操作时，若不能获得资源，他要么放弃，要么返回后重新查询，直到可以进行操作为止。
- 当数据准备好时二者的模式相同，即IO操作都是将进程阻塞，直到IO操作完成
- 阻塞、非阻塞是设备文件、网络文件的属性
<a name="ZZP8k"></a>
## 同步与异步
同步与异步，也是指I/O操作。POSIX定义如下：A synchronous I/O operation causes the requesting process to beblocked until that I/O operation completes An asynchronous I/O operation does not cause the requesting processto be blocked

- 两者的区别就在于同步IO做IO操作时会将进程阻塞，而异步IO做IO操作时不会阻塞进程
- 当把阻塞、非阻塞、同步和异步放在一起时，难免会出现混淆。同步是否就是阻塞，异步是否就是非阻塞？实际上在I/O操作中，它们是不同的概念。同步既可以是阻塞的，也可以是非阻塞的，而常用的Linux的I/O调用实际上都是同步的。这里的同步和异步，是指I/O数据的复制工作是否同步执行。
- 以系统调用read为例。阻塞的read会一直陷入内核态直到read返回；而非阻塞的read在数据未准备就绪时，会直接返回，而当有数据时，非阻塞的read同样会一直陷入内核态，直到read完成。这个read就是同步的操作， 即I/O的完成是在当前执行流程下同步完成的。如果是异步，则I/O操作不是随系统调用同步完成的。调用返回后，I/O操作并没有完成，而是由操作系统或者某个线程负责真正的I/O操作，等完成后通知原来的线程
