Linux
<a name="vKtS1"></a>
## 1、简介
存储、内存和 CPU（中央处理器）等系统资源不足会极大地影响应用程序的性能。因此，监控这些组件至关重要。<br />与磁盘和内存不同，监控 Linux 系统上的 CPU 使用率并不那么简单。将了解如何解释 CPU 指标并以人类可读的格式显示它们。
<a name="aQWVE"></a>
## 2、CPU 负载与 CPU 使用率
尽管 CPU 负载和 CPU 使用率听起来很相似，但它们是不可互换的。CPU 负载定义为在单个时间点使用或等待使用一个内核的进程数。<br />假设有一个单核系统，CPU 平均负载始终低于 0.6。这表明每个需要使用 CPU 的进程都可以立即使用它，而无需等待。如果 CPU 平均负载大于 1，则表示有进程需要使用 CPU，但由于 CPU 不可用，目前无法使用。<br />但是，多处理器系统中高于 1 的平均负载不会成为问题，因为有更多内核可用。<br />uptime命令为提供了以 1、5 和 15 分钟为间隔的平均负载视图：
```bash
[root@localhost ~]# uptime
 12:40:05 up  2:29,  1 user,  load average: 0.37, 0.08, 0.03
```
如果不知道系统的核心数，就无法解释平均负载：
```bash
[root@localhost ~]# cat /proc/cpuinfo |grep core
core id        : 0
cpu cores    : 1
```
另一方面，CPU 使用率是 CPU 处理非空闲任务所花费的时间百分比。CPU 使用率只能在指定的时间间隔内测量。可以通过将空闲时间的百分比从 100 中减去来确定 CPU 使用率。
<a name="SeBdW"></a>
## 3、计算CPU使用率
<a name="lb6cw"></a>
### 3.1 使用vmstat获取 CPU 使用率
vmstat命令近乎实时地显示 CPU 活动：
```bash
[root@localhost ~]# vmstat 3 4
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 4  0      0 1347080   6120 941464    0    0    68    11   72  137  1  2 97  0  0
 1  0      0 1347080   6120 941464    0    0     0     0   84  157  1  2 97  0  0
 1  0      0 1347080   6120 941464    0    0     0     0   59  107  1  1 98  0  0
 1  0      0 1347080   6120 941464    0    0     0     1   59  104  1  1 98  0  0
```
CPU 下的列提供了处理器时间花费在哪里的概览：<br />us - 运行非内核代码所花费的时间<br />sy - 运行内核代码所花费的时间<br />id - 空闲时间<br />wa - 等待 I/O 所花费的时间<br />st - 从虚拟机中窃取时间<br />id列是主要的。延迟一秒，使用 vmstat 计算CPU使用率：
```bash
[root@localhost ~]# echo "CPU Usage: "$[100-$(vmstat 1 2|tail -1|awk '{print $15}')]"%"
CPU Usage: 2%
```
没有提供任何参数的vmstat命令将给出自引导以来的 CPU 时间。这不会提供准确的 CPU 使用百分比。因此，参数只能是 1 和 2，采用一秒钟后计算的指标：
```bash
vmstat 1 2
```
<a name="JWoij"></a>
### 3.2 使用/proc/stat获取 CPU 使用率
CPU 活动也可以从/proc/stat文件中提取。该文件包含自启动以来有关系统的各种指标：
```bash
[root@localhost ~]# cat /proc/stat 
cpu  3020 28 1863 22404 35 432 47 0 0 0
cpu0 3020 28 1863 22404 35 432 47 0 0 0
intr 96468 28 100 0 0 0 0 0 0 1 0 0 0 1263 0 0 0 3696 0 153 928 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 207 0 41 14600 0 0 0 0 0 0 0 0 0 0 0 0 0 0 343 97 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
ctxt 340950
btime 1628404433
processes 3276
procs_running 2
procs_blocked 0
softirq 112867 1 16857 56 269 510 0 261 0 0 94913
```
第一行，  'cpu'  是系统所有核心指标的聚合。在具有 4 个内核的系统上，将有 4条cpu线——cpu0、cpu1、cpu2和cpu3。' cpu ' 行中的列表示处理不同任务所花费的时间：<br />user - 在用户模式下花费的时间<br />nice - 在用户模式下处理 nice 进程所花费的时间<br />system - 执行内核代码所花费的时间<br />idle - 空闲时间<br />iowait - 等待 I/O 所花费的时间<br />irq - 服务中断所花费的时间<br />softirq -  服务软件中断所花费的时间<br />steal - 从虚拟机中窃取的时间<br />guest - 为来宾操作系统运行虚拟 CPU 所花费的时间<br />guest_nice -  为“不错的”客户操作系统运行虚拟 CPU 所花费的时间<br />将使用这些指标来计算平均空闲百分比。随后，将使用计算值来计算 CPU 使用率。需要注意的是，较旧的 Linux 发行版不计算窃取、来宾或来宾_nice指标。如果使用的是旧系统，会在计算中忽略这些指标：
```bash
平均空闲时间 (%) = (idle * 100) / (user + nice + system + idle + iowait + irq + softirq +steal + guest + guest_nice)

cat /proc/stat |grep cpu |tail -1|awk '{print ($5*100)/($2+$3+$4+$5+$6+$7+$8+$9+$10)}'|awk '{print "CPU Usage: " 100-$1}'
CPU Usage: 2.4219
```
由于正在开发单核系统，因此“cpu”行将与“cpu1 ”相同。因此，tail -1 的使用是 只检索其中一行。然而，会在多处理器系统上使用“ cpu ”行，因为它是所有内核上的指标的集合。
<a name="hz0Kb"></a>
### 3.3 使用top获取 CPU 使用率
通常，top命令通常用于显示系统上的活动进程以及这些进程消耗了多少资源。不过，可以使用这个命令来测量 CPU 的状态：
```bash
[root@localhost ~]# top

top - 07:08:31 up  2:41,  1 user,  load average: 0.00, 0.00, 0.00
Tasks: 322 total,   2 running, 320 sleeping,   0 stopped,   0 zombie
%Cpu(s): 10.0 us, 15.0 sy,  0.0 ni, 97.8 id,  0.0 wa,  5.0 hi,  0.0 si,  0.0 st
MiB Mem :   3709.4 total,   1483.1 free,   1402.0 used,    824.4 buff/cache
MiB Swap:   2048.0 total,   2048.0 free,      0.0 used.   2053.4 avail Mem 
```
此外，需要注意的是，top 命令显示了单个内核的 CPU 百分比。在多处理器系统中，CPU 百分比可能超过 100%。例如，如果 4 个核心为 75%，top命令将显示 CPU 为 300%。<br />需要获取空闲时间的值，以便可以从 100 中减去它来获得使用情况：
```bash
[root@localhost ~]# top -bn2 | grep '%Cpu' | tail -1 | grep -P '(....|...) id,'|awk '{print "CPU Usage: " 100-$8 "%"}'
CPU Usage: 2.2%
```
`-n`选项是top命令在结束前应该使用的迭代次数。避免使用第一个循环，因为检索的指标将是自启动以来的值。因此，进行了第二次迭代。<br />或者，在多处理器系统中，必须将给定的“ id”值除以内核数，然后从 100 中减去该值。例如，如果在四核系统上运行，并且“ id ”值为 304%，将 CPU 使用率计算为：
```bash
CPU 使用率 % = 100 – (304/4)
```
```bash
[root@localhost ~]# top -bn2 | grep '%Cpu' | tail -1 | grep -P '(....|...) id,'|awk '{print "CPU Usage: " 100-($8/4) "%"}'
```
<a name="EPh0J"></a>
## 4、结论
讨论了 CPU 使用率和 CPU 负载之间的区别。许多人交替使用这两个概念，这是不正确的。之后，深入研究了用于检索 CPU 利用率指标的各种方法。

 
