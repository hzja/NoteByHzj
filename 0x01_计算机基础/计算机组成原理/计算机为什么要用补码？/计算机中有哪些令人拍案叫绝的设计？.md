二战时期的飞机，在进行空战过程中自己飞机射出的子弹难道不会击中自己飞机的桨叶吗？其实小时候看这部电影就有这样的疑问，直到后来学习了《机械原理》后，解其背后的原理后：<br />![](https://cdn.nlark.com/yuque/0/2022/gif/396745/1671280600963-c247762b-32eb-484d-a580-bf2aac3a8975.gif#averageHue=%23f9f6f6&clientId=u6a9b7e09-981d-4&from=paste&id=u492e0353&originHeight=150&originWidth=200&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uabdb8816-1eec-4894-9806-c4df1ab6fce&title=)<br />机枪射击协调器：它是一战中在盟军中服役的荷兰人安东尼·福克发明的，他把凸轮安装在螺旋桨轴上面，凸轮的三个凸起与桨叶刚好错开一个角度，当突起部分碰到金属棒后，金属棒后端连接的机枪发射装置就会被激活，继而完成子弹发射，反之，当桨叶与枪管形成一条直线时，机枪自动停止射击。这个巧妙的设计完美地避开了战斗机出现自残的事故。<br />让人虎躯一震的发明往往看上去都非常简单，而且经常会想，这么简单，嗯，我怎么没想到？<br />简单即是美，但是简单往往比复杂困难得多。<br />其实计算机的设计也是一门艺术的博弈，计算机补码的运算，它看似简单，但是这个设计也是精妙绝伦。
<a name="sm4iU"></a>
## 一、逻辑电路是如何计算加法的
1938年，香农在麻省理工学院发表了那篇题为《继电器和开关电路的符号分析》（_A Symbolic Analysis of Relay and Switching Circuits_）的著名硕士论文，这是一篇具有划时代意义的论文，他在文中清晰地阐述：电子工程师可以运用布尔代数的所有工具去设计开关电路。也就是说逻辑运算居然可以用电路来进行实现，随后人们根据这一理论设计出了各种逻辑门（_Logic Gate_）来进行数据运算，后期的电子计算机的运算原理都是基于这一理论进行实现的，比如人们根据继电器或者晶体管的特性，设计了异或门：<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1671280601056-8b58d487-87cb-4b4a-826d-e2cb05bd90cd.png#averageHue=%23f9f8f7&clientId=u6a9b7e09-981d-4&from=paste&id=u2ce4d192&originHeight=441&originWidth=639&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ub29f9a8b-b6af-41ca-b906-85924524517&title=)<br />当开关 A 闭合，线圈产生磁性将开关 M 吸合，接通灯泡的回路，灯泡就会亮，这是一个最简单的逻辑回路。能想象人类发明CPU甚至所有的存储设备其实就是这一堆堆开关组合成的吗，虽然现代CPU用的是晶体管（速度更快、体积更小），但是原理都是一样的。比如苹果最新发布的M2芯片上面集成了200亿个晶体管，翻译成人话就是上面放了200亿个开关。<br />这就像咱们老祖宗说的那句话，一生二，二生三，三生万物。<br />后来人们根据上面那个电路进行简单改造，无非就是开关的常开变常闭，或者常闭变常开等等，发明出了各种不同的逻辑门，可以实现更多的逻辑回路，比如与门（_AND_）、与非门（_NAND_）、或门（_OR_）、或非门（_NOR_）、异或门（_XOR_）等等。<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1671280600978-345f7054-08cb-413d-a01f-cc2a48bece78.png#averageHue=%23faf9f9&clientId=u6a9b7e09-981d-4&from=paste&id=udff9d622&originHeight=411&originWidth=473&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ue93b715a-3570-4b49-beca-610787e168a&title=)<br />比如下面这个与门就是连个开关A与B必须同时闭合灯泡才能亮：<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1671280601003-ccf2eba2-7faf-4fa7-bc95-94a4b1d0e25c.png#averageHue=%23f9f8f6&clientId=u6a9b7e09-981d-4&from=paste&id=u47280b8e&originHeight=644&originWidth=611&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ue6e91cf4-a71b-4448-b2d8-4398e719e67&title=)<br />这样的电路人们没想到居然会与二进制的加法存在着某些联系，比如二进制1+1=10的进位是1，而这个与门电路双开关必须同时闭合才会亮，如果闭合代表1，断开代表2，那么逻辑关系就是1 AND 1 = 1。<br />有一天，人们惊奇地发现，一个异或门并联一个与门居然能做简单的二进制位的加法运算，给它命名叫半加器。之所以叫半加器，是因为它还没有办法将进位的输出纳入下一位的运算，比如 1+1=10，等号右边的进位暂时还不能纳入下一位的运算。<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1671280600979-856a9862-5916-4b45-97e1-fd2d66754fa9.png#averageHue=%23f9f9f8&clientId=u6a9b7e09-981d-4&from=paste&id=u5cc1af00&originHeight=352&originWidth=740&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ubcf65a06-ca83-430f-b886-0941fa72b61&title=)<br />把这一堆符号合成一个整体：<br />![半加器](https://cdn.nlark.com/yuque/0/2022/png/396745/1671280601310-9a5e0913-f664-458a-aec1-2e0bf6e1a283.png#averageHue=%23f6f5f5&clientId=u6a9b7e09-981d-4&from=paste&id=u5b6e7e07&originHeight=230&originWidth=845&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=uf92fabba-320a-46da-8cf5-1dfabeaadfd&title=%E5%8D%8A%E5%8A%A0%E5%99%A8 "半加器")<br />后来，人们改进了这个电路，用两个半加器再加一个或门，组成一个全加器，这次就厉害了，全加器弥补了半加器不能计算让进位参与运算的缺点，可以将前一位的进位纳入本位进行一块计算，所以全加器输入端有三个输入：<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1671280601394-4b815afb-2bcf-4aec-8f0f-90de80282cb2.png#averageHue=%23f9f8f8&clientId=u6a9b7e09-981d-4&from=paste&id=u8c142a21&originHeight=221&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1fc0731c-583d-4db0-a924-2ee7032a333&title=)<br />把上面这一堆符号合成一个整体：<br />![全加器](https://cdn.nlark.com/yuque/0/2022/png/396745/1671280601518-e8dd1d63-f420-4bdc-b35e-ce30402c0e08.png#averageHue=%23f5f5f5&clientId=u6a9b7e09-981d-4&from=paste&id=u2d460265&originHeight=292&originWidth=956&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=u7e86ef9f-6931-499c-8f7d-a5f1406f671&title=%E5%85%A8%E5%8A%A0%E5%99%A8 "全加器")<br />多个全加器组合在一块就能计算多位的二进制加法，下面这组加法器就能计算四位二进制的加法：<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1671280601448-bd51cc30-056f-45da-984d-108cdab1acd7.png#averageHue=%23f9f8f8&clientId=u6a9b7e09-981d-4&from=paste&id=ue3324db0&originHeight=660&originWidth=805&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u9ef705a9-ad24-4e3e-b875-e987deabb1a&title=)<br />通过这组加法器的组合，就能计算十进制的 5+3=8 运算，很难想象，这样的运算居然是通过几个开关实现的！实际上这正是现代计算机进行加法计算的原理。<br />到这里，已经能够通过设计的逻辑电路来计算加法了，但是还有个重要的问题：减法如何计算呢？因为计算减法涉及到借位这种繁琐的操作，而上面设计的电路只能进位，难道还要为减法设计特定的逻辑电路吗，答案肯定是否定的，那样的电路就会非常复杂，考虑的是如何通过现有的逻辑电路，也就是如何通过加法来计算减法呢？<br />这个问题特别有意思，有人会说了，减去一个数等于加上这个数的负数，比如 5-3=2 这个式子，可问题是这样的说法实际上还是在计算减法，按照目前设计的开关电路是实现不了的，那怎么办呢？<br />想象一下，上小学的时候，刚开始学习三位数的减法的时候，都不喜欢一些带有借位的减法，比如![image.png](https://cdn.nlark.com/yuque/0/2022/png/396745/1671281072522-b036f278-7747-4ca6-899e-5a42d375147d.png#averageHue=%23f8f8f8&clientId=u6a9b7e09-981d-4&from=paste&height=101&id=ud9bf1a20&originHeight=253&originWidth=350&originalType=binary&ratio=1&rotation=0&showTitle=false&size=6476&status=done&style=none&taskId=u7c8d7291-7618-448d-8e32-e43f57f408d&title=&width=140)<br />这个算式计算起来很不舒服，首先从个位，3小于7，所以要从十位进位，而十位数借位后还小于4，还要从百位借位。<br />这里用一个技巧，先用 999 减去减数 147，显然这个算式不会产生借位：![image.png](https://cdn.nlark.com/yuque/0/2022/png/396745/1671281150551-94586fcc-2265-4379-b90a-c0bcc316951b.png#averageHue=%23f8f8f8&clientId=u6a9b7e09-981d-4&from=paste&height=102&id=u0a1a2a50&originHeight=256&originWidth=358&originalType=binary&ratio=1&rotation=0&showTitle=false&size=7905&status=done&style=none&taskId=u510053a1-de5a-4d98-916c-a75450dfc33&title=&width=143.2)这个 852 称为9的补数，用这个结果与被减数213相加![image.png](https://cdn.nlark.com/yuque/0/2022/png/396745/1671281164595-b6e505d1-8689-450c-a0d0-b3c5172d7a14.png#averageHue=%23f7f7f7&clientId=u6a9b7e09-981d-4&from=paste&height=103&id=u7611a506&originHeight=258&originWidth=356&originalType=binary&ratio=1&rotation=0&showTitle=false&size=8792&status=done&style=none&taskId=u0e0a9417-d81c-407f-90d9-acc4ab1960b&title=&width=142.4)最后将结果加1，然后再减去1000： 居然得到了想要的答案，而且没用到借位。<br />为什么这个间接的运算会正确呢？这是因为的原题目可以化成下面的运算：看到了吧，实际上是加了1000最后又给减去了，再把上式组合一下：其实计算结果是一样的，而且避免了借位的运算。<br />到这里，你可能会有疑惑：可这个式子还用到了减法，而且是两次，难道计算机在计算的时候还会有技巧跳过这个减法吗？<br />在这里，神奇的事情发生了，由于计算机采用的是二进制，第一个减法也就是求补数是从一串1的数字中减去的，而二进制求补的运算不像十进制那样，前者根本不需要做减法，而是将原来二进制中的数字1变为0, 0变为1即可（这与直接计算减法结果是一样的，但是这个技巧对计算机来说就省下了做减法的运算），这个求相反数可以称为反码，可以通过逻辑电路中的反向器来实现，第二个减法在二进制中减的是最高位，而这个对计算机来说只需要通过一个逻辑门电路来限制最高位输出即可实现。<br />下面来看一下使用二进制计算这一过程有多奇妙<br />第一步，求补运算：<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1671280601457-ff421093-2e04-48f4-bd46-6d79fccd761f.png#averageHue=%23f5f3f2&clientId=u6a9b7e09-981d-4&from=paste&id=u5bdf1011&originHeight=182&originWidth=759&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u7720f005-5eb1-4036-b633-695b323e78e&title=)<br />第二步，将结果加上被减数 213：<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1671280601686-38ff462e-f8dc-4dd2-b48c-43e26a1ae7ff.png#averageHue=%23f4f2f0&clientId=u6a9b7e09-981d-4&from=paste&id=u2f6f7187&originHeight=172&originWidth=663&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u61138cda-ca82-4866-b64e-a22d3c1fff2&title=)<br />第三步，将第二步的结果加 1：<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1671280601785-5c0e9a14-c4f5-459e-a5a8-30f5dea04ccb.png#averageHue=%23f7f5f4&clientId=u6a9b7e09-981d-4&from=paste&id=u0778c13d&originHeight=179&originWidth=730&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u3eac6835-3809-4a29-ae43-8d6d37d1e6b&title=)<br />第四步，将第三步的结果最高位取反，相当于减去了256：<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1671280601782-4710d8c1-6507-4a7d-906d-23b2cd2c4a22.png#averageHue=%23f2efed&clientId=u6a9b7e09-981d-4&from=paste&id=u7d0603e7&originHeight=185&originWidth=767&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u72c0fe8d-d966-470c-bb8d-95e3b40ddb1&title=)<br />这样就最终得出了想要的结果：66，整个过程虽然采用了两次减法，但是在二进制看来，根本没有使用减法。
<a name="qHPO9"></a>
## 二、为什么采用补码来存储整数
但是，上面这个电路还有局限性，它只能计算被减数大于减数的运算，而且不能表示负数，想要的结果是使用现有的电路，让它能够计算加法、减法、还有负数，换句话说，让所有的运算都按照加法来实现，该如何实现呢？<br />这时候，补码运算就登场了。<br />首先，计算机为了区分整数与负数，规定了符号位，规定最高位为「符号位」，0代表正数，1代表负数，剩下的才是「数字位」。例如对于两个字节 short 类型数字 1 在计算机内部是这样表示的：<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1671280601804-caae49b9-da64-487f-9966-ba1e0a3e4753.png#averageHue=%23f6ede4&clientId=u6a9b7e09-981d-4&from=paste&id=u84d4a4a4&originHeight=312&originWidth=836&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u63bc5710-f730-4758-b744-cb90c1b6b6c&title=)<br />而整数 -1 的表示方法是这样的，只是符号位变为了 1：<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1671280601784-b15d8c32-290b-488f-872e-4c47e6658d90.png#averageHue=%23f6eee4&clientId=u6a9b7e09-981d-4&from=paste&id=u4a84a629&originHeight=317&originWidth=828&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u9168d3b3-60cc-46e6-8929-6a54758dc88&title=)<br />但这样做是有代价的，意味着数据位的表示实际上是少了一位，导致原本能表示的数字没那么大了。例如单字节原本能表示 0 ~ 255 之间的数字，但是因为符号位占据了 1 位，实际表示数据的位数变为了 7 位，最大只能表示 127。<br />这时候，引出反码还有补码这个概念：正数的反码补码都是其原码，而复数的反码比较特殊，符号位不变，数据位取反就是反码，反码加 1 就是补码：<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1671280602031-bc4210a6-4963-4836-a983-5f402906a044.png#averageHue=%23f7f0e8&clientId=u6a9b7e09-981d-4&from=paste&id=uf98d1a15&originHeight=590&originWidth=850&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8bdf8a2e-6bc1-411d-ac8f-01631b11f39&title=)<br />计算机内部所有的运算都采用补码的形式，那么为什么要这样呢？<br />先来看如果采用原码的形式进行计算，假设要计算 1 - 3，实际上就是1+(-3)：<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1671280602143-9af76457-8c01-4c31-8d79-b30160c27562.png#averageHue=%23f6ede2&clientId=u6a9b7e09-981d-4&from=paste&id=u18522893&originHeight=505&originWidth=895&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u67aaa87a-6b59-4334-bb42-8037788f005&title=)<br />这样得出的结果竟然是 1 + (-3) = -4，结果显然是不正确的<br />那么如果采用反码进行计算，会怎样呢？<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1671280602285-2236bcbc-aefd-4be7-a722-d05be7cf0135.png#averageHue=%23f8eee4&clientId=u6a9b7e09-981d-4&from=paste&id=udfb13808&originHeight=556&originWidth=986&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u90f00e3a-f2b0-4f54-967f-975ed447007&title=)<br />这样得出的结果就是正确的，与预期的一样，但是如果计算 3-1 会怎么样呢，再试试：<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1671280602200-0fbf5551-f86d-4a92-bca8-868ca9ddbc30.png#averageHue=%23f7eee3&clientId=u6a9b7e09-981d-4&from=paste&id=u952ada6f&originHeight=461&originWidth=809&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua37eb30a-c9e4-4bd2-8122-747816e180c&title=)<br />最后居然得出 3+(-1)=1 的结果，这说明采用反码运算，小数减大数没问题，但是大数减小数结果就出了问题，直觉告诉我们，结果差了1。<br />随后，人们想出了补码这种神奇般的操作，看一下它的结果是怎样的：<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1671280602202-220c6f1d-ccf8-467b-88b5-58dabade0f3e.png#averageHue=%23f7ede2&clientId=u6a9b7e09-981d-4&from=paste&id=u4cc223d5&originHeight=448&originWidth=811&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=udd3d6872-7dd3-4f35-9a9b-4106cf6cf77&title=)<br />这样计算的结果就与期待的一样，是正确的。<br />再细品一下，为什么补码运算会正确呢，仔细分析一下：<br />当大数减去小数的时候，结果一定是正数。而之前采用的反码运算，结果总是少了1，如果采用补码来计算的话，负数从反码转为补码要加上1，在计算出结果后，因为正数的补码与反码相同，所以不用再减去，所以刚好相当于把结果加了1。妙，不可言；<br />当小数减去大数的时候，结果一定是负数。如果采用补码运算，负数从反码转化为补码要加上1，而恰恰，结果是负数，这个负数从补码转为原码又要减去1，刚好抵消，结果不受影响。妙，不可言。<br />补码的发明，彻底简化了硬件电路，不必为减法设计额外的电路，仅仅通过加法电路就能计算减法，真是太神奇了。
