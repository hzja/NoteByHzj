<a name="an8ZJ"></a>
# 页面替换算法
功能：当缺页中断发生，需要调入新的页面而内存已满时，选择内存当中哪个物理页面被置换。<br />目标：尽可能地减少页面的换进换出次数（即缺页中断的次数）。具体来说，把未来不再使用的或短期内较少使用的页面换出，通常只能在局部原理指导下依据过去的统计数据来进行预测。
<a name="kp48H"></a>
## 最优页面替换算法
基本思路：当一个缺页中断发生时，对于保存在内存当中的每一个逻辑页面，计算在它的下一次访问之前，还需等待多长时间，从中选择等待时间最长的那个作为被置换的页面。<br />这只是一种理想情况，在实际中无法实现，因为操作系统无法知道每一个页面要等待多长时间以后才会被再次访问。<br />可用作其它算法的性能评价的依据(在一个模拟器上运行某个程序，并记录每一次的页面访问情况，在第二遍运行时即可使用最优算法)。<br />简单一句话，最优页面替换算法就是替换在将来最长时间内不需要的页面。<br />假设页帧（Page Frames）的大小为 4， 请求页面序列为：7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2，采用最优页面替换算法的缺页异常（Page Fault）的次数为多少？<br />![2021-05-11-08-31-40-024898.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1620693222501-a0ecaa4d-851a-4577-8a92-495d5cf2c089.png#clientId=ue21318f1-4050-4&from=ui&id=ua9905729&originHeight=514&originWidth=1080&originalType=binary&size=142124&status=done&style=shadow&taskId=u82a53271-a3a8-4ec9-9cc4-1e524f83815)<br />初始时，页槽均为空，所以请求页面7 0 1 2被分配到空的页槽，产生 4 次缺页异常。<br />紧接着，请求页面0 时，发现已经存在页帧中，0 次缺页异常；<br />当请求页面 3 时，页面 7 由于为在将来最长时间内不需要访问，所以被 3 替换，1 次缺页异常。<br />0 号页面命中，0 次页面异常；<br />请求页面 4 不存在页帧中，替换页面 1 ，1 次缺页异常；<br />对之后的请求页面序列2，3，0，3，2而言，均命中，固无缺页异常。<br />所以总共发生了6次缺页异常，即图中的 Miss 状态，其中的 Hit 表示命中，无缺页异常产生。
<a name="ousBf"></a>
### 模拟实现一个最优页面替换算法：
输入 : 页帧数 fn = 3  <br />页面 pg[] = {7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1}; <br />输出 : 命中次数 hits = 11 缺页异常 miss = 9<br />输入 : 页帧数 fn = 4  页面 pg[] = {7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2}; <br />输出 : 命中次数 hits = 7 缺页异常 miss = 6<br />我们以页帧数 4 ，请求序列{7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2}为例进行说明。<br />首先我们创建一个空的数组fr模拟页帧：<br />![2021-05-11-08-31-40-155616.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1620693232252-fc61e43c-f4f9-4564-ba9a-f29bfd8dd542.png#clientId=ue21318f1-4050-4&from=ui&id=u802acf21&originHeight=247&originWidth=660&originalType=binary&size=7647&status=done&style=none&taskId=ue28c9491-04fe-4977-affc-a9bbdd20caf)<br />请求页面 7，发现不在数组fr当中且数组fr的大小fr.size() < fn页帧大小，则直接将请求页面 7 插入数组fr中：<br />![2021-05-11-08-31-40-239394.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1620693240640-29094f2d-cebe-4829-9fc4-254047b22c04.png#clientId=ue21318f1-4050-4&from=ui&id=uc44e3135&originHeight=262&originWidth=607&originalType=binary&size=7904&status=done&style=shadow&taskId=u13872c37-9749-475c-bd4c-0740bf895fb)<br />请求页面{0,1,2}与请求页面 7 情况类似，则依次将其添加到数组当中：<br />![2021-05-11-08-31-40-340125.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1620693277050-e3b6a219-4eb0-4089-b4de-4ccdb950336a.png#clientId=ue21318f1-4050-4&from=ui&id=uef616fde&originHeight=273&originWidth=634&originalType=binary&size=8918&status=done&style=shadow&taskId=u741ad20b-0747-4de7-bf61-a693e01b066)<br />紧接着请求页面 0，遍历数组fr，发现 0 号页面已经在其中了，则命中次数hit加 1。<br />请求 3 号页面，遍历数组fr，发现不在其中且数组已满（fr.size == fn），则需要找到要替换的页面，此时选择替换在将来最长时间内不需要的页面。这里的将来最长时间不需要的页面，我们可以使用页面数组pg[]的下标进行表示。<br />遍历数组fr[]，并结合请求页面数组pg[]找到在将来最长时间内不需要的页面。<br />fr[0] = 7，我们从 3 号页面开始在数组pg[]中向后查找 7 号页面，发现其根本不存在，也就说 7 号页面就是在将来最长时间内不需要的页面。所以 3 号页面替换 7 号页面。<br />![2021-05-11-08-31-40-841783.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1620693287533-c0b782d2-a5f2-49e3-a979-5df1ee1e6b0a.png#clientId=ue21318f1-4050-4&from=ui&id=ue700da5f&originHeight=259&originWidth=655&originalType=binary&size=9200&status=done&style=shadow&taskId=u3605f024-9ff7-46a4-979e-0c6b66fb2b6)<br />再访问 0 号页面，发现存在，则跳过；<br />访问 4 号页面，发现不在页帧数组fr当中，则替换掉在将来最长时间内不需要的页面 1：<br />![2021-05-11-08-31-41-026290.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1620693298068-5ee80f0b-a9b0-4be1-8376-c70a9da8a154.png#clientId=ue21318f1-4050-4&from=ui&id=u0b84dec8&originHeight=252&originWidth=651&originalType=binary&size=9228&status=done&style=shadow&taskId=uc7204d22-5b1f-4276-92db-f20e0f5a300)<br />之后访问页面{2, 3, 0, 3, 2}均为命中，总共命中 6 次。
<a name="ISZy4"></a>
### 参考实现
```cpp
#include <bits/stdc++.h>
using namespace std;

// 用于检查页帧中是否存在当前要访问的页 key
bool search(int key, vector<int>& fr)
{
     for (int i = 0; i < fr.size(); i++)
        if (fr[i] == key)
           return true;
     return false;
}

// 用于预测将来
int predict(int pg[], vector<int>& fr, int pn, int index)
{
    // 存储在将来最近要使用的页面的索引
    int res = -1, farthest = index;
    for (int i = 0; i < fr.size(); i++) {
        int j;
        for (j = index; j < pn; j++) {
           if (fr[i] == pg[j]) {
                if (j > farthest) {
                     farthest = j;
                     res = i;
                }
                break;
            }
        }

        // 如果某个页面将来从未被引用过，请将其返回。
        if (j == pn)
             return i;
     }
      // 如果 fr 中的所有页在将来都没出现过，则返回其中任何页，我们返回 0。否则我们将返回 res。
     return (res == -1) ? 0 : res;
}

/**
 * pg[] 请求页面序列
 * pn 请求页面数
 * fn 页帧数
 */

void optimalPage(int pg[], int pn, int fn)
{
    // 为给定数量的帧创建一个数组，并将其初始化为空。
   vector<int> fr;

   // 遍历页面引用数组并检查未命中和命中。
   int hit = 0;
   for (int i = 0; i < pn; i++) {
      // 在内存中命中页面 : HIT
      if (search(pg[i], fr)) {
         hit++;
         continue;
      }
      // 页面在内存中不存在 : MISS
      // 如果页帧中有可用的空间，则直接将缺失页加入其中。
      if (fr.size() < fn) {
           fr.push_back(pg[i]);
      }
      else { // 找到要替换的页
           int j = predict(pg, fr, pn, i + 1);
           fr[j] = pg[i];
        }
     }
     cout << "命中次数 = " << hit << endl;
     cout << "未命中次数 = " << pn - hit << endl;
}

int main()
{
     int pg[] = { 7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2 };
     int pn = sizeof(pg) / sizeof(pg[0]);
     int fn = 4;
     optimalPage(pg, pn, fn);
     return 0;
}
```
其中的`search`函数大家可以换成哈希或者二分查找等，其中最关键的是`predict()`函数，用于查找在将来最长时间内不会使用到的页面，其实也就是两层for循环嵌套。
<a name="TYvyC"></a>
## 先进先出算法
FIFO（First In，First Out）就是先进先出算法。<br />基本思路：选择在内存中驻留时间最长的页面并淘汰。具体来说，系统维护着一个链表，记录了所有位于内存当中的逻辑页面。从链表的排列顺序来看，链首页面的驻留时间最长，链尾页面的驻留时间最短。当发生一个缺页中断时，把链首页面淘汰出局，并把新的页面添加到链表的末尾。<br />性能较差，调出的页面可能是经常要访问的页面，并且产生 Belady 现象，FIFO 算法很少单独使用。<br />假设页帧（Page Frames）的大小为 4， 请求页面序列为：7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2，采用 FIFO 算法的缺页异常的次数为多少？<br />![2021-05-11-08-31-41-259664.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1620693312524-bbcd6cd8-a4e6-407b-8a1e-d51a696f2b19.png#clientId=ue21318f1-4050-4&from=ui&id=u0662b0e6&originHeight=397&originWidth=1080&originalType=binary&size=111047&status=done&style=shadow&taskId=u688f735a-7ad2-4bc9-93ce-c290224d349)<br />如上图所示，FIFO，先进先出，类似队列的特性。<br />对于请求页面7，0，1，2，发生 4 次缺页中断，分别为其分配页；<br />访问页面 0 时，命中；<br />访问页面 3 时，缺页异常，此时会淘汰掉位于队列头的页面7，将页面 3 插入到队尾，即选择在内存中驻留时间最长的页面并淘汰。<br />页面 0 命中；<br />访问页面 4 时，发生缺页异常，此时淘汰页面 0 ；<br />访问页面 2 和 3 时，均命中；<br />访问页面 0 时，缺页异常，淘汰页面 1 ，插入页面 0 ；<br />最后访问页面 3 和 2 均命中。<br />共发生缺页异常次数为 7 次。
<a name="ALcJ2"></a>
## 最近最少使用算法
<a name="hnD9H"></a>
## 时钟页面置换算法
Clock 页面置换算法，LRU 的近似，对 FIFO 的一种改进；<br />基本思路：

- 需要用到页表顶当中的访问位（Access Bit），当一个页面被装入内存时，把该位初始化为 0。然后如果这个页面被访问（读写），则把该位置置为 1。
- 把各个页面组织成环形链表（类似钟表面），把指针指向最老的页面（最先进来的页面）；
- 当发生一个缺页中断时，考察指针所指向的最老页面，若它的访问位为 0 ，立即淘汰；若访问位为 1，则把该位置置为 0，然后指针向下移动一格。如此下去，直到找到被淘汰的页面，然后把指针移动到它的下一格。

假设页帧（Page Frames）的大小为 4， 请求页面序列为：7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2，采用 时钟页面替换算法的缺页异常的次数为多少？<br />初始时，页帧为空，如下图所示的一个环形链表，是不是很想一个时钟：<br />![2021-05-11-08-31-41-407269.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1620693328670-c160d0be-f5f1-414e-9788-c551f47cf71f.png#clientId=ue21318f1-4050-4&from=ui&id=ue1a01c83&originHeight=465&originWidth=1005&originalType=binary&size=108910&status=done&style=none&taskId=ue4abff1b-7101-4b71-b880-03329ba3479)<br />请求页面 7，产生缺页中断，则将其装入内存，把该页面的访问位初始化为 0：<br />![2021-05-11-08-31-41-569836.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1620693328644-d1f724d3-d1cf-47b9-9f25-265b4f11ed62.png#clientId=ue21318f1-4050-4&from=ui&id=VkehF&originHeight=477&originWidth=967&originalType=binary&size=31606&status=done&style=none&taskId=u9df43665-fcb9-4111-90fd-fff533c0bad)<br />依次访问页面 0、1 和 2，与前面的方法类似：<br />![2021-05-11-08-31-41-713451.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1620693328647-c33df5ac-e1fb-4ace-8a4f-593a88902e6d.png#clientId=ue21318f1-4050-4&from=ui&id=hx8yU&originHeight=477&originWidth=864&originalType=binary&size=26810&status=done&style=shadow&taskId=uec4640ec-1ed4-4e33-ab39-9a3dc632b70)<br />紧接着请求页面 0 ，发现页面 0 已经在内存中了，则硬件会把访问位置为 1，并将指针下移：<br />![2021-05-11-08-31-41-950815.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1620693328663-cfbd43d8-1be0-4551-939f-0b35aa37d8ea.png#clientId=ue21318f1-4050-4&from=ui&id=vqcuo&originHeight=479&originWidth=877&originalType=binary&size=27165&status=done&style=shadow&taskId=ued29f8e2-1201-4edf-93ef-9b75d440b70)<br />请求页面 3 时，发生缺页中断，此时指针所指向的页面 7 的访问位为 0，则立即淘汰掉并替换为页面 3，访问位为 1：<br />![2021-05-11-08-31-42-032597.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1620693328662-7b8b1ca0-ed0a-4fd7-a3e2-816c9a1314d2.png#clientId=ue21318f1-4050-4&from=ui&id=omtB5&originHeight=481&originWidth=848&originalType=binary&size=27145&status=done&style=shadow&taskId=uc079c505-230c-40fa-a417-273d35cf181)<br />请求页面 0，已存在内存中，硬件将其访问位置为 1，与上图一样，没有变化；<br />请求页面 4，发生缺页中断，首先将 3号页面的访问位置为 0， 0 号页面的访问位置为 0，指针下移，发现 1 号页面的访问位为0，则淘汰页面 1，替换为 4，访问位置 1 并下移指针：<br />![2021-05-11-08-31-42-360719.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1620693329196-148e224a-24dc-4019-81db-0602189248ef.png#clientId=ue21318f1-4050-4&from=ui&id=TmaTk&originHeight=474&originWidth=844&originalType=binary&size=28240&status=done&style=shadow&taskId=u7f211531-dfbb-43d0-a54b-2182af36155)<br />请求页面 2 ，已存在内存中，硬件将其访问位置 1：<br />![2021-05-11-08-31-42-547221.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1620693450819-68a21d77-e2f0-4589-972a-4188387e9860.png#clientId=ue21318f1-4050-4&from=ui&id=u6bb83a47&originHeight=470&originWidth=844&originalType=binary&size=27881&status=done&style=shadow&taskId=ue150266a-e8e9-43ac-b0f5-7954f9826f3)<br />请求 3 号页面，将 3 号页面的访问位置为 1，将指针下移：<br />![2021-05-11-08-31-42-684854.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1620693458153-d99385c8-eb80-4580-b8c0-e86ba7bdefdc.png#clientId=ue21318f1-4050-4&from=ui&id=u6ca37cd0&originHeight=475&originWidth=839&originalType=binary&size=26880&status=done&style=shadow&taskId=u8d2e13c7-6be0-4984-8f52-f43551a9903)<br />请求 0 号页面，将 0 号页面的访问位置 1，指针下移：<br />![2021-05-11-08-31-43-116698.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1620693467878-e949b918-7d08-413a-a674-31f43fa76fb6.png#clientId=ue21318f1-4050-4&from=ui&id=u36c92d25&originHeight=484&originWidth=841&originalType=binary&size=26456&status=done&style=shadow&taskId=u109b9e41-ee82-428c-bde5-c7199f7671b)<br />总的缺页中断次数为 5 次。
<a name="oO68R"></a>
## 最不常用算法 LFU
基本思路：当一个缺页中断发生时，选择访问次数最少的那个页面，并淘汰之。<br />实现方法：对每一个页设置一个访问计数器，每当一个页面被访问时，该页面的访问计数器加 1。在发生缺页中断时，淘汰计数值最小的那个页面。如果所有页具有相同的频率，则对该页采取 LRU 方法并删除该页。<br />LRU 和 LFU 的区别：LRU 考察的是多久未访问，时间越短越好；而 LFU 考虑的是访问次数或频度，访问次数越多越好。
