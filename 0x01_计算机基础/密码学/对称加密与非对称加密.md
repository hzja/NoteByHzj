计算机网络在带来便利的同时，也存在很多安全隐患，比如信息伪造，病毒入侵，端点监听，SQL 注入等，给我们日常生活造成很严重的影响。<br />那么这里聊聊常见的网络安全隐患，只作为科普，不能作为网安系列文章。
<a name="IEVUg"></a>
## 网络安全性威胁的种类
在网络通信中可能会受到各种各样的潜在的安全性威胁，这些威胁总的来讲可以大致分为下面几类：

- 截获(interception)：攻击者从网络上窃听他人的通信内容。
- 中断(interruption)：攻击者会强制中断其他人在网络上的通信。
- 篡改(modification)：攻击者会修改他人在网络上发出的报文。
- 伪造(fabrication)：攻击者会在网络上发出伪造信息产生误导。

在上面四种网络安全类型中，截获是属于被动攻击的，因为截获主要为了窃听信息，它并没有攻击行为；而中断、篡改和伪造都是主动攻击，他们会产生攻击行为。<br />这里先来认识一个新的概念叫 PDU ，PDU 的官方解释是**协议数据单元**，但是它其实指的就是计算机网络这几层模型里面所描述的数据单元，比如应用层交换的就是应用数据，TCP 层的 PDU 交换的就是段。<br />在被动攻击中，攻击者只是观察和分析 PDU ，并没有对通信内容造成干扰。通过观察和分析 PDU，进而了解通信双方的通信类型，通信双方的地址和身份，这种被动攻击又叫做**流量分析（traffic analysis）**。<br />主动攻击是指攻击者对通信内容中的 PDU 进行各种处理。比如有选择的更改、替换 PDU 中的记录，甚至还可以伪造 PDU ，记录之前截获的 PDU ，在其他连接中释放此 PDU ，造成通信干扰和破坏。<br />主动攻击还可以细分为下面三种类型：

- 更改报文信息：这个就是上面说到的替换修改甚至伪造报文信息，对 PDU 的真实性和完整性进行攻击。
- 拒绝服务：攻击者会在网络上发送大量的分组，使得目标服务无法处理大量的分组信息，使得目标服务器无法提供正常有效的服务，这种攻击又叫做 拒绝服务 Dos(Denial of Service)，还有一种由成千上万个分布式节点一起对目标服务器发起攻击的方式，叫做 分布式拒绝服务 DDos(Distributed Denial of Service)。
- 连接伪造：攻击者试图使用之前记录下来的信息和身份进行伪造发起连接请求。

那么该如何知道计算机被攻击了呢？<br />对于被动攻击，通常是无法检测出来的，对于主动攻击，通常会以下面这几个大前提进行防范：

- 防止析出报文内容
- 防止流量分析
- 检测更改报文内容
- 检测 DDos
- 检测伪造初始化连接

对于被动攻击，可以采用各种数据的加密技术；对于主动攻击，可以采用防范措施与加密技术结合防范。<br />还有一种威胁比较大的是恶意程序，会对互联网造成比较大的影响，据史料记载，互联网编年体到现在出现比较大规模影响的病毒有：**计算机病毒、计算机蠕虫、特洛伊木马、逻辑炸弹、勒索软件**等。
<a name="EfLTm"></a>
## 数据加密的模型
由于通信存在不安全性，所以出现了加密技术，使用加密技术对报文进行加密后，再传到目标服务器后再进行解密，一般的加密和解密模型如下图所示：<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1703206338511-f5b44065-46f4-4cfa-92bb-1665963f634f.png#averageHue=%23fafafa&clientId=u07ca8087-83bb-4&from=paste&id=u3d607cf1&originHeight=275&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u257cf0e9-8a5f-4559-9144-85112b62bb0&title=)<br />上图所示的加密密钥和解密密钥所使用的密钥 K 通常是一串字符串，一般来说会有下面这种公式<br />Y = Ek（X）<br />通过加密算法使用加密密钥对明文 X 进行加密。<br />解密算法是加密算法的逆运算，再进行解密时如果不使用事先约定好的密钥 K 就无法完成解密工作。<br />Dk（Y） = Dk（Ek（x）） = X<br />这里我们假设了加密密钥和解密密钥是相同的，但真实情况未必一定是相同的，只不过加密密钥和解密密钥存在着某种关联性，这个密钥通常由密钥中心提供。当密钥进行传输时，一定要经过安全信道，否则会有安全风险。<br />这里延伸出来了两个新的概念，密码编码学(cryptography) 和 密码分析学(cryptanalysis)。密码编码学着重对密码进行设计的学科，密码分析学着重对报文进行分析，提炼出加密所使用明文或者密钥的学科。这两个学科合起来就是密码学。**其实密码学归根结底就是做好加密和解密的这个过程**。
<a name="An4Li"></a>
## 对称加密和非对称加密
从很早以前人类就有了对通话内容进行加密的思想，进入 20 世纪以来，随着电子信息、线性代数以及计算复杂性理论等学科的研究深入，密码学进入了一个新的发展阶段，一共出现了两种密码机制：对称加密和非对称加密。
<a name="KW216"></a>
### 对称加密
所谓的对称加密，起归根结底在于**加密和解密的密钥是相同的**。<br />数据加密标准 DES(Data Encryption Standard) 就是一种对称加密的标准，DES 可以说是用途最广泛的对称加密算法。<br />DES 是一种分组密码，在加密前首先先对整个报文进行分组，每一组都是 64 位的二进制数据。然后对每一个 64 位的二进制数据进行加密，产生一组 64 位的密文数据，最后将各组密文串起来，就是整个加密密文。使用的密钥是 64 位（实际使用 56 位，最后 8 位于奇偶校验）。<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1703206338533-c6f883e3-8a5e-49af-8c47-0dc50fa33450.png#averageHue=%23fafafa&clientId=u07ca8087-83bb-4&from=paste&id=u0e1cde44&originHeight=1005&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u7919b1b1-dca2-45ea-ba77-55cd698c069&title=)<br />在 DES 分组加密机制中，进行保密的只是加密密钥，而加密算法是公开的。<br />不过 DES 的这种加密机制是存在弊端的：由于 DES 会把报文拆开成为一组一组的 64 位数据，64 位二进制数据有 56 位可用，所以数据总量是 2 ^ 56 次方，它的密码生命周期非常段，这个数据总量在现在的计算机世界非常容易被破解！在 1999 年当时价值 100 万和 1000 万美元的超级计算机暴力破解 DES 的密码分别用了 3.5 小时和 21 分钟。<br />在 DES 之后出现了 IDEA(International Data Encryption Algorithm) 算法，IDEA 使用的是 128 位密钥进行加密，这个长度很难被破解了。
<a name="UMImZ"></a>
### 非对称加密
非对称加密其实还有一个叫法是**公钥密码加密**，非对称加密使用的是**不同的加密密钥和解密密钥**。<br />非对称加密出现的原因大概是基于两个方面：一是由于对称加密的密钥分配问题，二是由于对数字签名的要求。在对称加密中，加密解密双方用的是同一种密钥，这是如何做到的呢？一种是事先约定，另外一种是使用互联网信使来传送。在大规模互联网中，用信使来传输密钥显然是不太合适的，但是如果采用事先约定的方式，那么对于后续的更新和迭代来说又比较困难。还有一种方式是使用安全系数比较高的**密钥分配中心（Key Distribution Center）**，也会使网络的成本增加。<br />同时，一些需要对信息内容进行保密的机构越来越需要数字签名，根据数字签名，对方才知道某项内容是由特定的人或者公司产生的。根据这两项原因导致了非对称加密的出现。<br />非对称加密主要的算法有三种：RSA、DSA、ECDSA，目前使用最广泛、最普遍的非对称加密算法就是 RSA。RSA 采用的是数论中的大数分解方式。<br />非对称加密的特点是这样的：<br />某些能够生产公钥和私钥的密钥生成器会生产出一对公钥和私钥给接受者 B ：即加密密钥 PKB 和 解密密钥 SKB。发送者所使用的加密密钥也是 PKB，这个密钥是公开的，而接受者的解密密钥 SKB 是非公开的，接受者 B 特有的。<br />发送者利用接受者的密钥 PKB 通过加密算法 E 对密钥进行加密，得出了密文 Y 再发送给接受者 B：<br />Y = E（PKB（X））<br />接受者 B 用自己的私钥通过解密算法 D 对密文 Y 进行解密，得出密文 X ：<br />D（SKB（Y））= D（SKB）（ E（PKB（X））） = X<br />下图是这个加密解密过程：<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1703206338532-5a01632c-23c8-4471-ae5f-f3e36e690b14.png#averageHue=%23fbfbfa&clientId=u07ca8087-83bb-4&from=paste&id=u2684d828&originHeight=272&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u3ac2ce9e-5523-48fe-8dd2-210139a0281&title=)<br />这里需要注意一点的是，任何加密方法的安全性都取决于密钥的长度，以及攻破密文所需要的计算量，而不是简单的取决于加密本身。
<a name="Spia1"></a>
## 数字签名
在日常写信、上交某些材料的时候都需要亲笔签名或者使用手印、印章的方式来验证真实性，那么在互联网中如何验证其真实性呢？在网络通信中，使用数字签名的方式来验证，数字签名必须实现下面三点功能：

1. 接受者能够核实发送者对报文的签名，确定报文是由发送者发出的，别人无法进行伪造，这叫做**报文鉴别**。
2. 接受者确信所收到数据和发送者发送的数据是一致的，没有被篡改过，这叫做**报文完整性**。
3. 发送者事后不能抵赖自己发送的报文，这叫做**不可否认**。

下面来讨论一下数字签名的鉴别过程：<br />首先，发送者 A 用自己的私钥 SKA 对报文 A 经过算法 D 后得出密文 D（SKA（X）），算法 D 不是解密运算，它只是一个能得到不可读的密文的算法。A 把经过算法 D 运算后得出来的密文传给 B，B 对其进行验签。B 会用 A 的公钥进行 E 运算，还原出报文 X 。<br />这里需要注意一点：任何人用 A 的公钥 PKA 进行 E 运算后都会得出 A 发送的明文 X ，所以下图中的 D 和 E 算法并不是加密解密算法。<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1703206338541-4c0bdc44-8225-4995-9a5e-0afb6e13699a.png#averageHue=%23fafaf8&clientId=u07ca8087-83bb-4&from=paste&id=u2c14ff2d&originHeight=278&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u791ec21d-3eb7-48e5-b5bd-40de92491fd&title=)<br />除了 A 之外没有人持有 A 的私钥 SKA ，所以除 A 外没有人能产生密文 D（SKA（X））。这样，B 就相信报文 X 是签名 A 发送的，这就叫做报文鉴别。如果其他人篡改过报文，但是却无法使用私钥 A 的签名 SKA，那么 B 使用公钥解密后就知道报文被篡改过，这样就保证了报文的完整性。如果 A 想要抵赖自己层发给过报文 B ，那么 B 就可以把 X 以及密文 D（SKA（X））拿给公证的第三者，很容易证明。这就是不可否认。<br />但是上述过程仅仅对报文进行了签名，却并没有对报文本身进行任何加密操作，如果传输的过程中被攻击者截获到了 D（SKA（X））并且知道发送者身份的人，就可以通过查阅相关手册知道 A 的公钥，从而得知 A 的明文，这显然是不安全的，如何解决呢？<br />需要使用上面的非对称加密算法再对明文 X 进行加密一波，示意图如下。<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1703206338527-f50f8bfa-63cf-4857-bcdf-3836a3d6acb5.png#averageHue=%23fbfbfa&clientId=u07ca8087-83bb-4&from=paste&id=u1e2ee196&originHeight=431&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=ubd6e1c6d-09d2-46b0-95c9-c68eae63d2f&title=)<br />示意图画出来，估计大家也好理解，无非就是增加了一步用 B 的公钥加密，在用 B 的私钥解密的过程。
