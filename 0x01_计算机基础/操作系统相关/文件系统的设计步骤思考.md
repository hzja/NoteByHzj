文件系统<br />**假设这里有一块硬盘，大小为 1T**<br />![](https://cdn.nlark.com/yuque/0/2021/png/396745/1618451977284-83ba6787-afe3-4017-99a8-966d9339802f.png#clientId=uaaa877d0-a3d6-4&from=paste&id=u6e25cfc9&originHeight=140&originWidth=140&originalType=url&status=done&style=none&taskId=u79c11c7a-5f02-48f7-a806-4fef27d2ffb)<br />**还有一堆文件**<br />![](https://cdn.nlark.com/yuque/0/2021/webp/396745/1618451977232-acdbb3bf-9be7-4f60-ac6d-77fb4e313ad2.webp#clientId=uaaa877d0-a3d6-4&from=paste&id=uf5c8e1a6&originHeight=140&originWidth=140&originalType=url&status=done&style=shadow&taskId=u85fb6ebc-e558-40f6-8762-6e72ad7be3d)<br />这些文件在硬盘看来，就是一堆二进制数据而已<br />![](https://cdn.nlark.com/yuque/0/2021/webp/396745/1618451977412-9e2be7a6-5f93-416f-ba05-8b1fdd1c2101.webp#clientId=uaaa877d0-a3d6-4&from=paste&id=ua1f47d6e&originHeight=140&originWidth=140&originalType=url&status=done&style=shadow&taskId=u5c47f2b6-a8a9-465d-93b4-12a9e9383d4)<br />准备把这些文件存储在硬盘上，并在需要的时候读取出来。<br />要设计怎样的软件，才能更方便地在硬盘中读写这些文件呢？<br />首先不想和复杂的扇区，设备驱动等细节打交道，因此先实现了一个简单的功能，将硬盘按逻辑分成一个个的**块**，并可以以块为单位进行读写。<br />每个块就定义为两个物理扇区的大小，即 1024 字节，就是 1KB 啦。<br />硬盘太大不好分析，就假设硬盘只有 1MB，那么这块硬盘则有 1024 个块。<br />![](https://cdn.nlark.com/yuque/0/2021/webp/396745/1618451977528-98239953-ce33-4b4c-b2eb-7efe882ea612.webp#clientId=uaaa877d0-a3d6-4&from=paste&id=u168b8823&originHeight=140&originWidth=140&originalType=url&status=done&style=shadow&taskId=ub1388572-7c21-4d59-a49c-d725a97b826)<br />可以开始存文件了！准备一个文件<br />![](https://cdn.nlark.com/yuque/0/2021/png/396745/1618451977552-05e69d43-57f7-4d1b-9232-7759d0591b0d.png#clientId=uaaa877d0-a3d6-4&from=paste&id=u6fa3233b&originHeight=140&originWidth=140&originalType=url&status=done&style=shadow&taskId=u1bb73dcc-593d-4d58-b138-c2a828b9143)<br />随便选个块放进去，3 号块吧！<br />![](https://cdn.nlark.com/yuque/0/2021/webp/396745/1618451979106-9ea0a955-7c5e-4e21-8bd9-589679445fbc.webp#clientId=uaaa877d0-a3d6-4&from=paste&id=uc57235ad&originHeight=140&originWidth=140&originalType=url&status=done&style=shadow&taskId=ue5de0358-7c0f-42f8-b01e-f2c891e82cf)<br />再存一个文件！<br />这里有问题了，万一这个文件也存到了 3 号块，不是把原来的文件覆盖了么？不行，得有一个地方记录，现在可使用的块有哪些，像这样。

- 块 0：未使用
- 块 1：未使用
- 块 2：未使用
- 块 3：已使用
- 块 4：未使用
- ...
- 块 1023：未使用

那就用 0 号块，来记录所有块的使用情况吧！怎么记录呢？<br />**位图！**<br />![](https://cdn.nlark.com/yuque/0/2021/gif/396745/1618451979334-d084792d-1faa-47e9-ae98-89f659137df0.gif#clientId=uaaa877d0-a3d6-4&from=paste&id=ue0fa712b&originHeight=140&originWidth=140&originalType=url&status=done&style=shadow&taskId=ub9c98feb-edbd-4c3a-9bf3-9121224be72)<br />给块 0 起个名字，叫**块位图**，之后这个块 0 就专门用来记录所有块的使用情况，不再用来存具体文件了。<br />![](https://cdn.nlark.com/yuque/0/2021/webp/396745/1618451979251-77b1262e-9079-4223-841d-ada2d322532e.webp#clientId=uaaa877d0-a3d6-4&from=paste&id=ue1116381&originHeight=140&originWidth=140&originalType=url&status=done&style=shadow&taskId=u5ac1158c-382a-4a3a-bd4e-3fe1e3fa380)<br />当再存入一个新文件时，只需要在块位图中找到第一个为 0 的位，就可以找到第一个还未被使用的块，将文件存入。同时，别忘了把块位图中的相应位置 1。<br />下面，尝试读取刚刚的文件。<br />又遇到问题了，怎么找到刚刚的文件呢？根据块号么？这也太蠢了，就像去书店找书，店员让提供书的编号，而不是书名，显然不合理。<br />因此给每个文件起一个名字，叫**文件名**，通过它来寻找这个文件。<br />那必然就要有一个地方，记录文件名与块号的对应关系，像这样。

- 葵花宝典.txt：3 号块
- 数学期末复习资料.mp4：5 号块
- 低并发编程的秘密.pdf：10 号块
- ...

既然都要选一个地方记录文件名称了，不妨多记录一点关心的信息吧，比如文件大小、文件创建时间、文件权限等。<br />这些东西自然也要保存在硬盘上，选择用一个固定大小的空间，来表示这些信息，多大空间呢？128 字节吧。<br />![](https://cdn.nlark.com/yuque/0/2021/png/396745/1618451979297-461c5b97-9fd5-4cec-82ae-b5af4a4adf8f.png#clientId=uaaa877d0-a3d6-4&from=paste&id=u138d8bcc&originHeight=140&originWidth=140&originalType=url&status=done&style=shadow&taskId=uc24ebf57-11e1-480e-a4e6-867c51de318)<br />将这 128 字节的结构体，叫做一个**inode**。<br />之后，每存入一个新的文件，不但要占用一个块来存放这个文件本身，还要占用一个 inode 来存放文件的这些**元信息**，并且这个 inode 的**所在块号**这个字段，就指向这个文件所在的块号。<br />![](https://cdn.nlark.com/yuque/0/2021/webp/396745/1618451979331-5b0ee601-b8e9-4eb1-bc44-b50c47f95ec7.webp#clientId=uaaa877d0-a3d6-4&from=paste&id=ubc502eff&originHeight=140&originWidth=140&originalType=url&status=done&style=shadow&taskId=u34a112e4-80c3-4bf1-98fc-774956d3f91)<br />如果一个 inode 为 128 字节，那么一个块就可以容纳 8 个 inode，可以将这些 inode 编上号。<br />![](https://cdn.nlark.com/yuque/0/2021/webp/396745/1618451980800-60f9cd6e-ad8b-4c5d-9092-cf7ddba990cc.webp#clientId=uaaa877d0-a3d6-4&from=paste&id=ud2b1eb8d&originHeight=140&originWidth=140&originalType=url&status=done&style=shadow&taskId=u6ea45799-52b6-4224-8108-d5e74742c9a)<br />如果觉得 inode 数不够，也可以用两个或者多个块来存放 inode 信息，但这样用于存放数据的块就少了，这就看自己的平衡了。<br />![](https://cdn.nlark.com/yuque/0/2021/webp/396745/1618451981086-7992dff5-3ce6-40f1-b603-fadba17f3113.webp#clientId=uaaa877d0-a3d6-4&from=paste&id=ue966baa7&originHeight=140&originWidth=140&originalType=url&status=done&style=shadow&taskId=u7d2b43eb-220d-45eb-a623-d9237125595)<br />同样，和块位图管理块的使用情况一样，也需要一个**inode 位图**，来管理 inode 的使用情况。就把 inode 位图，放在 1 号块吧！<br />同时，把 inode 信息，放在 2 号块，一共存 8 条 inode，这样 2 号块就叫做**inode 表**。<br />现在文件系统结构，变成了下面这个样子。<br />![](https://cdn.nlark.com/yuque/0/2021/webp/396745/1618451981223-2c32c232-8652-4c81-92ea-e0eaa39f14bc.webp#clientId=uaaa877d0-a3d6-4&from=paste&id=u61cd0bc6&originHeight=140&originWidth=140&originalType=url&status=done&style=shadow&taskId=u1841fa7f-0090-4867-afb9-14af04b296b)<br />注意：块位图是管理可用的块，每一位代表一个块的使用与否。inode 位图管理的是一条一条的 inode，并不是 inode 所占用的块，比如上图中有 8 条 inode，则 inode 位图中就有 8 位是管理他们的使用与否。<br />现在文件很小，一个块就能容下。<br />但如果需要两个块、三个块、四个块呢？<br />很简单，只需要采用**连续存储法**，而 inode 则只记录文件的第一个块，以及后面还需要多少块，即可。<br />这种办法的缺点就是：容易留下大大小小的**空洞**，新的文件到来以后，难以找到合适的空白块，空间会被浪费。<br />![](https://cdn.nlark.com/yuque/0/2021/png/396745/1618451981154-f17d7090-b65d-405e-a793-3d156a793387.png#clientId=uaaa877d0-a3d6-4&from=paste&id=u29e64f2a&originHeight=140&originWidth=140&originalType=url&status=done&style=shadow&taskId=ud607abc6-aa04-4ff2-b59c-c8d86cb7fb8)<br />看来这种方式不行，那怎么办呢？<br />既然在 inode 中记录了文件所在的块号，为什么不扩展一下，多记录几块呢？<br />![](https://cdn.nlark.com/yuque/0/2021/png/396745/1618451981542-6a7b511c-984d-43d7-aec9-10361465751e.png#clientId=uaaa877d0-a3d6-4&from=paste&id=udb2bd2d1&originHeight=140&originWidth=140&originalType=url&status=done&style=shadow&taskId=ua0bc6191-0018-4a23-a02a-1b2fa70bff3)<br />原来在 inode 中只记录了一个块号，现在扩展一下，记录 8 个块号！而且这些块**不需要连续**。<br />![](https://cdn.nlark.com/yuque/0/2021/png/396745/1618451982762-d1ac2b2d-d690-4790-a5ae-c6826dfdccb5.png#clientId=uaaa877d0-a3d6-4&from=paste&id=u7e7d4af3&originHeight=140&originWidth=140&originalType=url&status=done&style=shadow&taskId=u0c59ef0d-c38c-45a3-b359-fbdfa11612f)<br />这是个可行的办法！<br />但是这也仅仅能表示 8 个块，能记录的最大文件是 8K（记住，一个块是 1K）, 现在的文件轻松就超过这个限制了，这怎么办？<br />很简单，可以让其中一个块，作为**间接索引**。<br />![](https://cdn.nlark.com/yuque/0/2021/png/396745/1618451982791-94139aa4-3247-4324-89ba-c7314ac7faee.png#clientId=uaaa877d0-a3d6-4&from=paste&id=u58624d6e&originHeight=140&originWidth=140&originalType=url&status=done&style=shadow&taskId=u08e17958-090a-4af5-86e9-e60f637b191)<br />这样瞬间就有 263 个块（多了 256 -1 个块）可用了，这种索引叫**一级间接索引**。<br />如果还嫌不够，就再弄一个块做一级间接索引，或者做二级间接索引（二级间接索引则可以多出 256 * 256 - 1 个块）。<br />文件系统暂且先只弄一个一级间接索引。硬盘一共才 1024 个块，一个文件 263 个块够大了。再大了不允许。<br />好了，现在已经可以保存很大的文件了，并且可以通过文件名和文件大小，将它们准确读取出来啦！<br />但得精益求精，再想想看这个文件系统有什么毛病。<br />比如，inode 数量不够时，怎么得知的呢？是不是需要在 inode 位图中找，找不到了才知道不够用了？<br />同样，对于块数量不够时，也是如此。<br />要是有个全局的地方，来记录这一切，就好了，也方便随时调整，比如这样<br />inode 数量<br />空闲 inode 数量<br />块数量<br />空闲块数量<br />那就再占用一个块来存储这些数据吧！由于他们看起来像是站在上帝视角来描述这个文件系统的，所以把它放在最开始的块上，并把它叫做**超级块**，现在的布局如下。<br />![](https://cdn.nlark.com/yuque/0/2021/webp/396745/1618451983067-512a5d17-f352-4128-a8a2-cd79e5fd4292.webp#clientId=uaaa877d0-a3d6-4&from=paste&id=ue135d3b1&originHeight=140&originWidth=140&originalType=url&status=done&style=shadow&taskId=ub89e7ef5-8316-4267-b270-3eedb192eae)<br />继续精益求精。<br />现在，**块位图**、**inode 位图**、**inode 表**，都是是固定地占据这块 1、块 2、块 3 这三个位置。<br />假如之后 inode 的数量很多，使得 inode 表或者 inode 位图需要占据多个块，怎么办？<br />或者，块的数量增多（硬盘本身大了，或者每个块变小了），块位图需要占据多个块，怎么办？<br />程序是死的，不告诉它哪个块表示什么，它可不会自己猜。<br />很简单，与超级块记录信息一样，这些信息也选择一个块来记录，就不怕了。那就选择紧跟在超级块后面的 1 号块来记录这些信息吧，并把它称之为**块描述符**。<br />![](https://cdn.nlark.com/yuque/0/2021/webp/396745/1618451983269-3af5e446-07a2-43ae-8837-b8c4db83079b.webp#clientId=uaaa877d0-a3d6-4&from=paste&id=u5eeecabe&originHeight=140&originWidth=140&originalType=url&status=done&style=shadow&taskId=ude3f1691-643f-479f-b5f1-8d947228d3b)<br />当然，这些所在块号只是记录起始块号，块位图、inode 位图、inode 表分别都可以占用多个块。<br />好了，大功告成！<br />现在，再尝试存入一批文件。

- 葵花宝典.txt
- 数学期末复习资料.mp4
- 赘婿1.mp4
- 赘婿2.mp4
- 赘婿3.mp4
- 赘婿4.mp4
- 低并发编程的秘密.pdf

这看着好不爽，所有的文件都是平铺开的，能不能拥有**层级关系**呢？比如这样

- 葵花宝典.txt
- 数学期末复习资料.mp4
- 赘婿
   - 赘婿1.mp4
   - 赘婿2.mp4
   - 赘婿3.mp4
   - 赘婿4.mp4
- 低并发编程的秘密.pdf

将葵花宝典.txt 这种称为**普通文件**，将赘婿这种称为**目录文件**，如果要访问赘婿1.mp4，那全文件名要写成<br />赘婿/赘婿1.mp4。<br />如何做到这一点呢？那又得把 inode 结构拿出来说事了。<br />![](https://cdn.nlark.com/yuque/0/2021/png/396745/1618451983961-de8b5efc-e20e-4bb1-8825-8289fcef7e2d.png#clientId=uaaa877d0-a3d6-4&from=paste&id=u7bf7fdcc&originHeight=140&originWidth=140&originalType=url&status=done&style=shadow&taskId=u6245335c-878a-4867-a98b-8268d604df9)<br />此时需要一个属性来区分这个文件是普通文件，还是目录文件。<br />缺什么就补什么，已经很熟悉了，专门加一个 4 字节，来表示**文件类型**。<br />![](https://cdn.nlark.com/yuque/0/2021/png/396745/1618451984212-499e13f7-3a1a-4121-9e41-ce8b8c648b1d.png#clientId=uaaa877d0-a3d6-4&from=paste&id=u651f9029&originHeight=140&originWidth=140&originalType=url&status=done&style=shadow&taskId=ua23c49fd-b233-41d6-99a5-78591262daa)<br />如果是**普通文件**，则这个 inode 所指向的数据块仍然和之前一样，就是文件本身原封不动的内容。<br />但如果是**目录文件**，则这个 inode 所指向的数据块，就需要重新规划了。<br />这个数据块里应该是什么样子呢？可以是一个一个指向不同 inode 的紧挨着的结构体，比如这样。<br />![](https://cdn.nlark.com/yuque/0/2021/png/396745/1618451984851-90f91aeb-8789-4602-8a6f-9c767940db62.png#clientId=uaaa877d0-a3d6-4&from=paste&id=u1af85ae1&originHeight=140&originWidth=140&originalType=url&status=done&style=shadow&taskId=u9c2b5a30-5fcf-4275-9b72-a525d1fb62b)<br />这样先通过 **赘婿 **这个目录文件，找到所在的数据块。再根据这个数据块里的一个个带有**inode**信息的结构体，找到这个目录下的所有文件。<br />不过这样的话，想想看，如果想要查看一下赘婿**这个目录下的所有文件**（比如 ll 命令），将文件名和文件类型都展示出来，怎么办呢？<br />就需要把一个个结构体指向的 inode 从 inode 表中取出，再把文件名和文件类型取出，这很是浪费时间。<br />而让用户看到一个目录下的所有文件，又是一个极其常见的操作。<br />所以，不如把文件名和文件类型这种常见的信息，放在数据块中的结构体里吧。<br />![](https://cdn.nlark.com/yuque/0/2021/png/396745/1618451985150-e55e86f5-9e8c-4657-a2a8-6a08f998740f.png#clientId=uaaa877d0-a3d6-4&from=paste&id=ua3ea5acd&originHeight=140&originWidth=140&originalType=url&status=done&style=shadow&taskId=uc1dc0c57-2a05-49c6-9e92-fcb92176d1f)<br />同时，inode 结构中的文件名，好像就没啥用了，这种变长的东西放在这种定长的结构中本身就很讨厌，早就想给它去掉了。而且还能给其他信息省下空间，比如文件所在块的数组，就能再多几个了。<br />太好了，去掉它！<br />![](https://cdn.nlark.com/yuque/0/2021/png/396745/1618451985041-8e179941-52d4-4068-84dc-bd1be323ec8f.png#clientId=uaaa877d0-a3d6-4&from=paste&id=u9039fb1e&originHeight=140&originWidth=140&originalType=url&status=done&style=shadow&taskId=uc2526aed-1596-406c-aedf-fb1a9c53ec6)<br />大功告成，现在就可以给文件分门别类放进不同目录下了，还可以在目录下创建目录！<br />现在的文件系统，已经比较完善了，只是还有一点不太爽。<br />访问到一个目录下，可以很舒服地看到目录里的文件，然后再根据名称访问这个目录下的文件或者目录，整个过程都是一个套路。<br />但是，最上层的目录下的所有文件，即**根目录**，现在仍然需要通过遍历所有的 inode 来获得，能不能和上面的套路统一呢？<br />答案非常简单，规定，**inode 表中的 0 号 inode，就表示根目录**，一切的访问，就从这个根目录开始！<br />![](https://cdn.nlark.com/yuque/0/2021/png/396745/1618451985894-6ba83e33-c5bf-4cc9-aefe-80e84e6d4896.png#clientId=uaaa877d0-a3d6-4&from=paste&id=ud3e77692&originHeight=140&originWidth=140&originalType=url&status=done&style=shadow&taskId=ue92543ea-229a-4e7c-ab94-7c51ebaeacc)<br />好了，这回没有然后了！<br />最后来欣赏下文件系统架构。<br />![](https://cdn.nlark.com/yuque/0/2021/png/396745/1618451986145-c64df7b5-a6b7-423f-a04f-f6ef30cd2707.png#clientId=uaaa877d0-a3d6-4&from=paste&id=u14a27b8b&originHeight=140&originWidth=140&originalType=url&status=done&style=shadow&taskId=u537fb20e-4cb3-4165-a6ee-d12173c4964)
<a name="QwHbm"></a>
# 后记
这个文件系统，和 linux 上的经典文件系统**ext2**基本相同。<br />下面是 ext2 文件系统的结构（字段部分只画了核心字段）<br />![](https://cdn.nlark.com/yuque/0/2021/png/396745/1618451987170-ffb1979c-44ff-4289-ab02-82525a413030.png#clientId=uaaa877d0-a3d6-4&from=paste&id=u520ccf5c&originHeight=140&originWidth=140&originalType=url&status=done&style=shadow&taskId=u32b287fc-8507-48e9-85dd-712c1e3b68c)<br />主要异同点：<br />1. 超级块前面是启动块，这个是 PC 联盟给硬盘规定的 1KB 专属空间，任何文件系统都不能用它。<br />2. ext2 文件系统首先将整个硬盘分为很多块组，但如果只有一个块组的话，和文件系统整体结构就完全一样了，分别是超级块、块描述符、块位图、inode 位图、inode 表、数据块。<br />3.ext2 文件系统的 inode 表中用 15 个块来定位文件，其中第 13 个块为一级间接索引、14 个为二级间接索引、15 个为三级间接索引。<br />4.ext2 文件系统的文件类型分得更多，还有常见的如块设备文件、字符设备文件、管道文件、socket 文件等。<br />5.ext2 文件系统的超级块、块描述符、inode 表中记录的信息更多，但核心的文件系统一样，而且这些字段在后续的 ext3 和 ext4 中不断增加，保持向前兼容。<br />6. ext2 文件系统的2 号 inode 为根目录，而系统是 0 号 inode 为根目录，这个很随意，设计一个文件系统定一个 187 号 inode 为根目录也没人拦着。<br />如果想了解 ext2 文件系统的全部细节，有三种方式。<br />1. 看源码，linux1.0 后的源码都有 ext2 文件系统的实现，源码是最准确的。<br />2. 看官方文档，这里有个 pdf 连接。https://www.nongnu.org/ext2-doc/ext2.pdf<br />3. 看优质博客，这里推荐一个。http://docs.linuxtone.org/ebooks/C&CPP/c/ch29s02.html<br />4. 用 linux 的 mke2fs 命令生成一个 ext2 文件系统的磁盘镜像，然后一个字节一个字节分析其格式。
