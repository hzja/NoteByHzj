<a name="GttKS"></a>
# 两个简单的测试程序
定义一个同样大小的二维数组，然后循环遍历，对数组元素赋值。

- array1.c 对数组按行进行访问

![](https://cdn.nlark.com/yuque/0/2023/png/396745/1701665534693-7f5fdf49-9012-43dd-a186-f08050177885.png#averageHue=%23314e6b&clientId=u328e178a-c081-4&from=paste&id=u7be2300a&originHeight=842&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u3d46ecb2-907c-43c0-9245-a73b846e764&title=)

- array2.c 对数组按列进行访问

![](https://cdn.nlark.com/yuque/0/2023/png/396745/1701665534732-30e6303e-db41-4e33-ac75-38935fd4954d.png#averageHue=%23314e6b&clientId=u328e178a-c081-4&from=paste&id=u688bce82&originHeight=842&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=uc5e62d74-d869-4733-ae5e-039e355240e&title=)<br />编译运行，并用time命令统计一下运行时间：<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1701665534773-79b7b7fd-4edf-48e1-ad89-af834fdf2367.png#averageHue=%23324f6d&clientId=u328e178a-c081-4&from=paste&id=u548c8d63&originHeight=842&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u93362089-c04e-4b8e-9c09-adb49d3ec04&title=)<br />**array1用时0.528秒，array2用时10.310秒。array2耗时居然是array1的将近20倍！**<br />有没有被这个结果震惊到？为什么会有如此之大的性能差异呢？
<a name="GoFci"></a>
# 重要说明
要想真正理解这个问题，必须要先补充一些关于现代计算机存储系统相关的背景知识，这也是理解这个问题的关键所在。为方便大家理解，尽量以白话的形式进行讲解，尽可能避免枯燥无味的纯理论描述。
<a name="Iih79"></a>
## 存储金字塔
相信不少人都听过“存储金字塔”这个词，或者至少见过类似下面这张图：<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1701665534755-ec717304-6ee0-477e-a023-d70a3f6d12c1.png#averageHue=%23110f0d&clientId=u328e178a-c081-4&from=paste&id=u9e1be313&originHeight=696&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=ua27eab4c-cdaa-4ee4-b2be-c684ca1daae&title=)<br />这张图很直观地描述了现代计算机系统的分级存储模型。<br />可以认为CPU就位于金字塔的顶点上，越靠近塔顶，离CPU越近，访问速度越快，但生产成本越高，相应的容量也就越小。在所有存储器中，寄存器直接内嵌在CPU中，访问速度最快，容量也最小，一般CPU上也就最多几十个通用寄存器供应用程序使用。<br />反之，越往下靠近塔底，访问速度越慢，生产成本越低，相应的容量也就越大。比如图中最底部的网络存储设备，相对其他存储设备而言是访问速度最慢的，但其容量却几乎可以认为是无限制的。<br />那么，这种金字塔式结构中，不同层级的存储设备之间究竟是如何协调工作的呢？<br />用一句话概括：**高一级的存储设备，往往是作为低一级存储设备的缓存来使用的。**<br />简单来说，系统运行时，为了提升数据访问效率，把程序中最近最经常访问的数据，尽可能放到访问速度更快的高一级存储器中。这样一来，每次访问数据时，从金字塔的顶端开始，都先尝试在高一级存储器中查找，如果被访问的数据存在且有效，则直接访问，否则，就逐级到更低级的存储器中去查找。<br />这种金字塔式的分级存储模型之所以能够以近乎完美的方式运行，实际上都是建立在现代计算机科学中的一个非常重要的理论基础之上：**程序的局部性原理**。
<a name="yBNxf"></a>
## 局部性原理
一个程序的局部性，包含两个维度：时间局部性和空间局部性。

- • **时间局部性**。如果一个数据在某个时间点被CPU访问了，那么在接下来很短的一段时间内，这个数据很有可能会再次被CPU访问到。
- • **空间局部性**。如果一个数据在某个时间点被CPU访问了，那么与这个数据临近的其他数据，很有可能也会很快被CPU访问到。
<a name="TFCMn"></a>
## 高速缓存 - Cache
根据常识，程序要想被CPU正常执行，必须要先被加载到内存中。（当然也有例外，有童鞋知道哪些程序不是在内存中运行的吗？欢迎添加作者微信CreCoding讨论！）<br />但是，内存的访问速度与CPU运行速度相比，要慢好几个数量级，可以想象一下，如果CPU每次都直接从内存中存取数据，会造成大量的计算资源浪费，程序性能严重受损，假如真是这样的话，还能像现在这样愉快的吃鸡吗？<br />为了解决CPU和内存之间速度严重不匹配的问题，在CPU和内存之间设计了高速缓存，即Cache。<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1701665534772-19da3b47-33fe-4056-b242-5a46be4a724e.png#averageHue=%23453a07&clientId=u328e178a-c081-4&from=paste&id=u7e36abbe&originHeight=228&originWidth=492&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=ucb6718f6-def8-4548-aae9-c8b1cad5f85&title=)<br />目前，主流CPU一般都有三级（或更多级）的Cache，依次是L1 Cache、L2 Cache、L3 Cache。其中L1 Cache速度最快，几乎可以和内嵌在CPU中的寄存器媲美，容量也最小，而L3 Cache速度最慢（但仍然比内存快很多），但容量最大。<br />CPU读取数据时，会在L1、L2、L3Cache中逐级查找，如果找到，就从Cache直接读取，找不到再从内存读取，并且把数据存放到Cache中，以便提高下次访问的效率。<br />在这个过程中，如果在Cache中找到所需数据，称为**Cache命中(Cache Hit)**, 找不到称为**Cache未命中(Cache Miss)**。<br />不难看出，L1 Cache命中的时候，读取数据最快，性能最好，而当L1、L2、L3 Cache全部未命中时，就必须要直接从内存中读取数据，性能最差！
<a name="zxx8e"></a>
## Cache Line
**Cache Line 是 Cache和内存之间进行数据传输的最小单位。**<br />根据上文讲解的程序的局部性原理，如果一个数据被CPU访问了，那么这个数据相邻的其他数据也很快会被访问到。因此，为了提高内存数据的读取效率，并且最大化利用CPU资源，数据在Cache和内存之间传输时，不是一个字节一个字节进行传输的，而是以缓存行(Cache Line)为单位进行传输的。<br />不同CPU的Cache line大小可能不同，典型的CPU Cache line大小是64个字节。<br />通过下面一个简单的例子，加深一下理解。
<a name="HxHip"></a>
## Cache Line 实例讲解
在一个Cache Line大小为64字节的机器上，定义个数组：
```c
int a[16] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};
```
假设数组a的起始地址是Cache Line对齐的，可以简单理解为a的地址能被64整除。假设，数组a还从来没有被访问过，如果此时需要访问a中的一个元素a[5]，如：
```c
int x = a[5];
```
由于在此之前数组a没有被访问过，所以理论上讲，数组a应该只存在于内存中，并未被加载到Cache中。因此，此时CPU在Cache中找不到a[5]，触发Cache Miss，然后需要从内存中读取数据，并更加载到Cache中。前面提到，Cache和内存之间是以Cache Line为单位进行数据传输的，因此，这里会把一个Cache line大小（64字节）的数据从内存读取出来加载到Cache中。由于a的起始地址恰巧是Cache line对齐的，所以CPU会把整个数组（64个字节，刚好一个Cache Line）都加载到Cache中。<br />紧接着，如果再访问数组a的元素，如：
```c
int y = a[10];
```
此时，整个数组都在Cache中，所以CPU在访问时，触发Cache Hit，直接从Cache读取数据即可，不需要再从内存中读取。<br />了解了Cache的背景知识，现在来分析下array1.c和array2.c为什么会存在这么巨大的性能差异。
<a name="O5LRX"></a>
## 按行、列访问的真正差异 - Cache
首先，必须要知道一点：**C语言的数组，所有元素是存放在地址连续的内存中的，此外，C语言的多维数组，是按行进行存储的**。<br />array1.c按行对数组进行访问，也就是从数组起始地址开始，一直连续访问到数组的最后一个元素的地址处。第一次访问一个Cache Line的首个元素时，触发Cache Miss，与该元素临近的几个元素会组成一个Cache Line，被一起加载到Cache中。如此，在访问下一个元素的时候，就会Cache Hit，直接从Cache读取数据即可。<br />而array2.c按列对数组进行访问，因此并不是按照连续地址进行访问的，而是每次间隔10240 * 4个字节进行访问。第一次访问一个Cache Line的首个元素时，假设地址为x，尽管该元素临近的一个Cache Line大小的元素也会被一起加载进Cache中，但是程序接下来访问的并不是临近的元素，而是地址为x + 10240 * 4处的元素，因此会再次触发Cache Miss。而当程序回过头来访问x + 4地址处的元素时，这个Cache Line可能已经被其他数据冲刷掉了。因为，尽管Cache会尽量缓存最近访问过的数据，但毕竟大小有限，当Cache被占满时，一些旧的数据就会被冲刷替换掉。<br />可以看出，无论是时间局部性还是空间局部性，array1.c都要比array2.c好很多！相比array1.c，array2.c会触发大量的Cache Miss，这也是为什么array2的性能会如此之差！<br />下面用perf来对比下这两个程序的性能指标。
<a name="fx7DY"></a>
# 用perf观测性能指标
perf是Linux提供的一个功能强大的实用性能调优工具，它可以用来观测几乎所有CPU相关的性能指标，但perf工具本身，不是本文重点，以后会有专门文章详细介绍perf的使用。<br />先获取array1.c的性能指标：<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1701665538017-14f4bc9d-80d8-4986-848e-90ab442caffb.png#averageHue=%232f475d&clientId=u328e178a-c081-4&from=paste&id=udf5297e0&originHeight=842&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=ue03b3119-3fe4-482f-aaaa-137d3793304&title=)<br />再看下array2.c的性能指标：<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1701665538069-26c70627-68ea-4004-8257-48966af2a347.png#averageHue=%232f475d&clientId=u328e178a-c081-4&from=paste&id=u0644ee97&originHeight=842&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u997d2e6f-06e1-46dd-8919-bae23ffd8f3&title=)<br />这里只关注一个最重要的性能指标：L1 Data Cache的Miss率。<br />对比一下，array1.c的**L1-dcache-load-misses**率只有3.10%， 而按列访问的array2.c，则达到了惊人的93.03%！这就是两者性能差异如此巨大的真相！
