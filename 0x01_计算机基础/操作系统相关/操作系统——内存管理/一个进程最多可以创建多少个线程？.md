![](https://cdn.nlark.com/yuque/0/2023/jpeg/396745/1698715656116-6fae2903-6c80-4d92-9872-a5da186cc7a3.jpeg)
<a name="HEXg8"></a>
## Linux 虚拟内存知识回顾
<a name="Ycrsw"></a>
### 虚拟内存空间长啥样
在 Linux 操作系统中，虚拟地址空间的内部又被分为**内核空间和用户空间**两部分，不同位数的系统，地址空间的范围也不同。比如最常见的 32 位和 64 位系统，如下所示：<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1698715349170-f61b9f1c-1849-457b-9548-d88224349a9a.png#averageHue=%23efbf90&clientId=uf2591d2b-d4a7-4&from=paste&id=ua98b0911&originHeight=415&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u375cf705-30c1-4a0a-8584-de7274ff7aa&title=)<br />通过这里可以看出：<br />32 位系统的内核空间占用 1G，位于最高处，剩下的 3G 是用户空间；<br />64 位系统的内核空间和用户空间都是 128T，分别占据整个内存空间的最高和最低处，剩下的中间部分是未定义的。
<a name="WtWGr"></a>
### 32 位虚拟内存空间
![](https://cdn.nlark.com/yuque/0/2023/png/396745/1698715349300-b339cc6e-137c-4f39-b079-20ea85d0566c.png#averageHue=%23f6f2f1&clientId=uf2591d2b-d4a7-4&from=paste&id=u52991f4f&originHeight=977&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u761dc7a9-346e-4f30-a99e-3f607400720&title=)<br />通过这张图可以看到，用户空间内存，从**低到高**分别是 6 种不同的内存段：<br />0x0000 0000 到 0x0804 8000 这段虚拟内存地址是一段不可访问的保留区，因为在大多数操作系统中，数值比较小的地址通常被认为不是一个合法的地址，这块小地址是不允许访问的。比如在 C 语言中通常会将一些无效的指针设置为 NULL，指向这块不允许访问的地址。<br />代码段，包括二进制可执行代码；<br />数据段，包括已初始化的静态常量和全局变量；<br />BSS 段，包括未初始化的静态变量和全局变量；<br />**堆段，包括动态分配的内存，从低地址开始向上增长；**<br />堆空间的上边是一段待分配区域，用于扩展堆空间的使用<br />文件映射段，包括动态库、共享内存等，从低地址开始向上增长<br />**栈段，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 8 MB。当然系统也提供了参数，以便自定义大小；**<br />在上面的内存段中，堆和文件映射段的内存是动态分配的。比如说，使用 C 标准库的 malloc() 或者 mmap() ，就可以分别在堆和文件映射段动态分配内存。
<a name="RaDtP"></a>
### 64 位虚拟内存空间
在 32 位机器上，指针的寻址范围为 2^32，所能表达的虚拟内存空间为 4 GB。<br />那么可能会认为在 64 位机器上，指针的寻址范围为 2^64，所能表达的虚拟内存空间为 16 EB 。虚拟内存地址范围为：0x0000 0000 0000 0000 0000 - 0xFFFF FFFF FFFF FFFF 。<br />事实上在目前的 64 位系统下只使用了 48 位来描述虚拟内存空间，寻址范围为 2^48 ，所能表达的虚拟内存空间为 256TB。<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1698715349272-01bab0d3-1db0-411f-b07b-c34766ec620f.png#averageHue=%23f8f4f2&clientId=uf2591d2b-d4a7-4&from=paste&id=ufffa724e&originHeight=1072&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=udc7c2eeb-b022-4ca7-bea0-c727adc9b53&title=)<br />从上图中可以看出 64 位系统中的虚拟内存布局和 32 位系统中的虚拟内存布局大体上是差不多的。
<a name="mrnBi"></a>
## 创建一个线程需要消耗多大虚拟内存
前面也介绍了**栈段，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 8 MB。当然系统也提供了参数，以便自定义大小；**<br />现在来验证一下，执行 `ulimit -a` 这条命令，查看进程创建线程时默认分配的栈空间大小<br />![](https://cdn.nlark.com/yuque/0/2023/jpeg/396745/1698715349208-ca70b562-2a5b-4cda-ab90-d31ae8b04157.jpeg#averageHue=%23f4f6f8&clientId=uf2591d2b-d4a7-4&from=paste&id=u05d5e435&originHeight=723&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u0e95438d-7035-4674-a925-728024cbdd3&title=)
<a name="qKJc1"></a>
## 影响一个进程可创建多少线程的条件
**进程的虚拟内存空间上限**，因为创建一个线程，操作系统需要为其分配一个栈空间，如果线程数量越多，所需的栈空间就要越大，那么虚拟内存就会占用的越多。<br />**系统参数限制**，虽然 Linux 并没有内核参数来控制单个进程创建的最大线程个数，但是有系统级别的参数来控制整个系统的最大线程个数。
<a name="LQYnC"></a>
### 虚拟内存空间上限
<a name="WnnJL"></a>
#### 32位系统
在 32 位 Linux 系统里，一个进程的虚拟空间是 4G，内核分走了1G，**用户能用的只有 3G**。<br />创建一个线程需要占用 8M 虚拟内存，总共有 3G 虚拟内存可以使用。于是可以算出，最多可以创建差不多 380个（3G/8M）左右的线程。<br />如果想使得进程创建上千个线程，那么可以调整创建线程时分配的栈空间大小，比如调整为 512k：
```bash
[ecs-user@iZ2ze923utbhhwxwgc0pd9Z ~]$ ulimit -s 512
```
<a name="gICr1"></a>
#### 64位系统
64 位系统意味着用户空间的虚拟内存最大值是 128T，这个数值是很大的，一个线程需占用 8M 栈空间的情况来算，那么理论上可以创建 128T/8M 个线程，也就是 1000多万个线程，有点魔幻！<br />所以按 64 位系统的虚拟内存大小，理论上可以创建无数个线程。
<a name="KyuV5"></a>
### 系统参数限制
前面了解到了64 位系统的虚拟内存大小，理论上可以创建无数个线程。不过事实上，肯定创建不了那么多线程，除了虚拟内存的限制，还有系统的限制。<br />比如下面这三个内核参数的大小，都会影响创建线程的上限：<br />**/proc/sys/kernel/threads-max**，表示系统支持的最大线程数，默认值是 14553；<br />**/proc/sys/kernel/pid_max**，表示系统全局的 PID 号数值的限制，每一个进程或线程都有 ID，ID 的值超过这个数，进程或线程就会创建失败，默认值是 32768；<br />**/proc/sys/vm/max_map_count**，表示限制一个进程可以拥有的VMA(虚拟内存区域)的数量，具体什么意思我也没搞清楚，反正如果它的值很小，也会导致创建线程失败，默认值是 65530。
<a name="QN7q8"></a>
## 总结
最后简单总结下：<br />32 位系统，用户态的虚拟空间只有 3G，默认创建线程时分配的栈空间是 8M，那么一个进程最多只能创建 380 个左右的线程。<br />64 位系统，用户态的虚拟空间大到有 128T，理论上不会受虚拟内存大小的限制，而会受系统的参数或性能限制。
