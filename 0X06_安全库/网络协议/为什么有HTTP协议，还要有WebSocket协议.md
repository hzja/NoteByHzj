网络协议HTTPWebSocket<br />平时打开网页，比如购物网站某宝。都是点一下**列表商品**，跳转一下网页就到了**商品详情**。<br />从HTTP协议的角度来看，就是点一下网页上的某个按钮，**前端发一次HTTP请求，网站返回一次HTTP响应**。<br />这种由客户端主动请求，服务器响应的方式也满足大部分网页的功能场景。<br />但有没有发现，这种情况下，服务器从来就不会**主动**给客户端发一次消息。<br />就像你喜欢的女生从来不会主动找你一样。<br />但如果现在，你在刷网页的时候**右下角**突然弹出一个**小广告**，提示你【**一个人在家偷偷才能玩哦**】。<br />**求知，好学，勤奋**，这些刻在你DNA里的东西都动起来了。<br />你点开后发现。<br />长相平平无奇的古某提示你"道士9条狗，全服横着走"。<br />影帝某辉老师跟你说"系兄弟就来砍我"。<br />来都来了，你就选了个角色进到了游戏界面里。<br />这时候，上来就是一个小怪，从远处走来，然后疯狂拿木棒子抽你。<br />**你全程没点任何一次鼠标**。服务器就自动将怪物的移动数据和攻击数据源源不断发给你了。<br />这….太暖心了。<br />感动之余，问题就来了，<br />像这种**看起来服务器主动发消息给客户端的场景**，是怎么做到的？<br />在真正回答这个问题之前，先来聊下一些相关的知识背景。
<a name="BgiMw"></a>
### 使用HTTP不断轮询
其实问题的痛点在于，**怎么样才能在用户不做任何操作的情况下，网页能收到消息并发生变更。**<br />最常见的解决方案是，**网页的前端代码里不断定时发HTTP请求到服务器，服务器收到请求后给客户端响应消息。**<br />这其实时一种**伪**服务器推的形式。<br />它其实并不是服务器主动发消息到客户端，而是客户端自己不断偷偷请求服务器，只是用户无感知而已。<br />用这种方式的场景也有很多，最常见的就是**扫码登录**。<br />比如某信公众号平台，登录页面二维码出现之后，**前端**网页根本不知道用户扫没扫，于是不断去向**后端**服务器询问，看有没有人扫过这个码。而且是以大概1到2秒的间隔去不断发出请求，这样可以保证用户在扫码后能在1到2s内得到及时的反馈，不至于**等太久**。<br />![使用HTTP定时轮询](https://cdn.nlark.com/yuque/0/2022/png/396745/1668572590106-f9bcb7e9-0450-4a18-903c-6c4a47bd9601.png#averageHue=%23dae0e5&clientId=ud39aee1a-03c4-4&from=paste&id=uffa9972a&originHeight=792&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=u17016076-c4c1-4bbf-9f59-00e887c4ca4&title=%E4%BD%BF%E7%94%A8HTTP%E5%AE%9A%E6%97%B6%E8%BD%AE%E8%AF%A2 "使用HTTP定时轮询")<br />但这样，会有两个比较明显的问题

- 当你打开F12页面时，你会发现满屏的HTTP请求。虽然很小，但这其实也消耗带宽，同时也会增加下游服务器的负担。
- 最坏情况下，用户在扫码后，需要等个1~2s，正好才触发下一次http请求，然后才跳转页面，用户会感到**明显的卡顿**。

使用起来的体验就是，二维码出现后，手机扫一扫，然后在手机上点个确认，这时候**卡顿等个1~2s**，页面才跳转。<br />![不断轮询查看是否有扫码](https://cdn.nlark.com/yuque/0/2022/png/396745/1668572590107-51fa8780-5dae-432c-a2d1-bf534d94a83e.png#averageHue=%23f0f1ef&clientId=ud39aee1a-03c4-4&from=paste&id=u4bfccb42&originHeight=376&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=u7d4cb375-cb6c-4744-9338-7bbeb16785f&title=%E4%B8%8D%E6%96%AD%E8%BD%AE%E8%AF%A2%E6%9F%A5%E7%9C%8B%E6%98%AF%E5%90%A6%E6%9C%89%E6%89%AB%E7%A0%81 "不断轮询查看是否有扫码")<br />那么问题又来了，**有没有更好的解决方案？**<br />有，而且实现起来成本还非常低。
<a name="t2mwH"></a>
### 长轮询
HTTP请求发出后，一般会给服务器留一定的时间做响应，比如3s，规定时间内没返回，就认为是超时。<br />如果HTTP请求**将超时设置的很大**，比如30s，**在这30s内只要服务器收到了扫码请求，就立马返回给客户端网页。如果超时，那就立马发起下一次请求。**<br />这样就减少了HTTP请求的个数，并且由于大部分情况下，用户都会在某个30s的区间内做扫码操作，所以响应也是及时的。<br />![长轮询](https://cdn.nlark.com/yuque/0/2022/png/396745/1668572590110-f57b19d3-a2aa-42d6-b7ac-26ec7ef9c0c6.png#averageHue=%23d7dce2&clientId=ud39aee1a-03c4-4&from=paste&id=ubb096b9d&originHeight=792&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=ue13a8e9d-f491-447a-b912-ca348a52a91&title=%E9%95%BF%E8%BD%AE%E8%AF%A2 "长轮询")<br />比如，某度云网盘就是这么干的。所以你会发现一扫码，手机上点个确认，电脑端网页就**秒跳转**，体验很好。<br />![长轮询的方式来替代](https://cdn.nlark.com/yuque/0/2022/png/396745/1668572590229-0df663d7-4589-4960-8ddb-86255ec7747c.png#averageHue=%23ef8b71&clientId=ud39aee1a-03c4-4&from=paste&id=ud09224ce&originHeight=457&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=u4dfdadef-1e17-4c88-b87a-94d69c2f93f&title=%E9%95%BF%E8%BD%AE%E8%AF%A2%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9D%A5%E6%9B%BF%E4%BB%A3 "长轮询的方式来替代")<br />真一举两得。<br />像这种发起一个请求，在较长时间内等待服务器响应的机制，就是所谓的**长训轮机制**。常用的消息队列RocketMQ中，消费者去取数据时，也用到了这种方式。<br />![RocketMQ的消费者通过长轮询获取数据](https://cdn.nlark.com/yuque/0/2022/png/396745/1668572590104-4275bfb7-6649-41fe-8fec-1c4493ebbdc9.png#averageHue=%23dbdee4&clientId=ud39aee1a-03c4-4&from=paste&id=u86358982&originHeight=491&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=u62561d2b-1063-490a-a9bc-53e76b97e97&title=RocketMQ%E7%9A%84%E6%B6%88%E8%B4%B9%E8%80%85%E9%80%9A%E8%BF%87%E9%95%BF%E8%BD%AE%E8%AF%A2%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE "RocketMQ的消费者通过长轮询获取数据")<br />像这种，在用户不感知的情况下，服务器将数据推送给浏览器的技术，就是所谓的**服务器推送**技术，它还有个毫不沾边的英文名，**comet**技术，大家听过就好。<br />上面提到的两种解决方案，本质上，其实还是客户端主动去取数据。<br />对于像扫码登录这样的**简单场景**还能用用。<br />但如果是网页游戏呢，游戏一般会有大量的数据需要从服务器主动推送到客户端。<br />这就得说下**websocket**了。
<a name="HXxNW"></a>
### websocket是什么
TCP连接的两端，**同一时间里**，**双方**都可以**主动**向对方发送数据。这就是所谓的**全双工**。<br />而现在使用最广泛的HTTP1.1，也是基于TCP协议的，**同一时间里**，客户端和服务器**只能有一方主动**发数据，这就是所谓的**半双工**。<br />也就是说，好好的全双工TCP，被HTTP用成了半双工。<br />为什么？<br />这是由于HTTP协议设计之初，考虑的是看看网页文本的场景，能做到**客户端发起请求再由服务器响应**，就够了，根本就没考虑网页游戏这种，客户端和服务器之间都要互相主动发大量数据的场景。<br />所以为了更好的支持这样的场景，需要另外一个**基于TCP的新协议**。<br />于是新的应用层协议**websocket**就被设计出来了。<br />大家别被这个名字给带偏了。虽然名字带了个socket，但其实socket和websocket之间，就跟雷峰和雷峰塔一样，二者接近**毫无关系**。<br />![websocket在四层网络协议中的位置](https://cdn.nlark.com/yuque/0/2022/png/396745/1668572591295-f27f364b-6528-40a1-ad6a-383a6c93b19a.png#averageHue=%23d5dfe5&clientId=ud39aee1a-03c4-4&from=paste&id=u1e6dfe2f&originHeight=576&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=uf2581b53-a36b-4ec6-aa25-03841393cf3&title=websocket%E5%9C%A8%E5%9B%9B%E5%B1%82%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84%E4%BD%8D%E7%BD%AE "websocket在四层网络协议中的位置")
<a name="IUJvr"></a>
### 怎么建立websocket连接
平时刷网页，一般都是在浏览器上刷的，一会刷刷图文，这时候用的是**HTTP协议**，一会打开网页游戏，这时候就得切换成新介绍的**websocket协议**。<br />为了兼容这些使用场景。浏览器在**TCP三次握手**建立连接之后，都**统一使用HTTP协议**先进行一次通信。

- 如果此时是**普通的HTTP请求**，那后续双方就还是老样子继续用普通HTTP协议进行交互，这点没啥疑问。
- 如果这时候是**想建立websocket连接**，就会在HTTP请求里带上一些**特殊的header头**。
```
Connection: Upgrade
Upgrade: websocket
Sec-WebSocket-Key: T2a6wZlAwhgQNqruZ2YUyg==\r\n
```
这些header头的意思是，浏览器想**升级协议（Connection: Upgrade）**，并且**想升级成websocket协议（Upgrade: websocket）**。<br />同时带上一段**随机生成的base64码（Sec-WebSocket-Key）**，发给服务器。<br />如果服务器正好支持升级成websocket协议。就会走websocket握手流程，同时根据客户端生成的base64码，用某个**公开的**算法变成另一段字符串，放在HTTP响应的 Sec-WebSocket-Accept 头里，同时带上101状态码，发回给浏览器。
```
HTTP/1.1 101 Switching Protocols\r\n
Sec-WebSocket-Accept: iBJKv/ALIW2DobfoA4dmr3JHBCY=\r\n
Upgrade: websocket\r\n
Connection: Upgrade\r\n
```
http状态码=200（正常响应）的情况，大家见得多了。101确实不常见，它其实是指**协议切换**。<br />![base64转为新的字符串](https://cdn.nlark.com/yuque/0/2022/png/396745/1668572591339-6d95f3e0-3b6f-40d1-a2bb-562397e0e996.png#averageHue=%23dce6e9&clientId=ud39aee1a-03c4-4&from=paste&id=u954c60ef&originHeight=339&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=uc7a6810d-cf37-4c24-bc13-37fb185b417&title=base64%E8%BD%AC%E4%B8%BA%E6%96%B0%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2 "base64转为新的字符串")<br />之后，浏览器也用同样的**公开算法**将base64码转成另一段字符串，如果这段字符串跟服务器传回来的**字符串一致**，那验证通过。<br />![对比客户端和服务端生成的字符串](https://cdn.nlark.com/yuque/0/2022/png/396745/1668572591518-54c5d18c-1ee7-4cdc-8910-601c22555b31.png#averageHue=%23dde6e9&clientId=ud39aee1a-03c4-4&from=paste&id=u1387e4a5&originHeight=432&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=ue6bf0d25-4b53-4d81-a40f-5e503670eb4&title=%E5%AF%B9%E6%AF%94%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%94%9F%E6%88%90%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2 "对比客户端和服务端生成的字符串")<br />就这样经历了一来一回两次HTTP握手，websocket就建立完成了，后续双方就可以使用webscoket的数据格式进行通信了。<br />![建立websocket连接.drawio](https://cdn.nlark.com/yuque/0/2022/png/396745/1668572591826-036d5456-468d-4301-ae3e-d4a307660eb5.png#averageHue=%23cad4db&clientId=ud39aee1a-03c4-4&from=paste&id=u41c7aa76&originHeight=990&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=u10837da1-2000-469d-b040-eb5c8d70315&title=%E5%BB%BA%E7%AB%8Bwebsocket%E8%BF%9E%E6%8E%A5.drawio "建立websocket连接.drawio")
<a name="C3FJS"></a>
### websocket抓包
可以用wireshark抓个包，实际看下数据包的情况。<br />![客户端请求升级为websocket](https://cdn.nlark.com/yuque/0/2022/png/396745/1668572591911-207fc85a-229f-4a42-a920-fc7322ac04b9.png#averageHue=%23dffac3&clientId=ud39aee1a-03c4-4&from=paste&id=u7a08e8c5&originHeight=487&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=u8d95b19c-76e7-4aa6-ac3d-71061a3519d&title=%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%B7%E6%B1%82%E5%8D%87%E7%BA%A7%E4%B8%BAwebsocket "客户端请求升级为websocket")<br />上面这张图，注意画了红框的第2445行报文，是websocket的**第一次握手**，意思是发起了一次带有特殊Header的HTTP请求。<br />![服务器同意升级为websocket协议](https://cdn.nlark.com/yuque/0/2022/png/396745/1668572591841-1dbf81ef-1b70-4d65-88b7-1fb407f409c1.png#averageHue=%23dbfbc1&clientId=ud39aee1a-03c4-4&from=paste&id=u8e7d7c8f&originHeight=472&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=uc7d66370-bef0-4b43-9317-2a717f8e956&title=%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%8C%E6%84%8F%E5%8D%87%E7%BA%A7%E4%B8%BAwebsocket%E5%8D%8F%E8%AE%AE "服务器同意升级为websocket协议")<br />上面这个图里画了红框的4714行报文，就是服务器在得到第一次握手后，响应的**第二次握手**，可以看到这也是个HTTP类型的报文，返回的状态码是101。同时可以看到返回的报文header中也带有各种websocket相关的信息，比如Sec-WebSocket-Accept。<br />![两次HTTP请求之后正式使用websocket通信](https://cdn.nlark.com/yuque/0/2022/png/396745/1668572591853-3b9cb11c-4b3e-41ca-be5d-4c4d933a67d0.png#averageHue=%2371a07c&clientId=ud39aee1a-03c4-4&from=paste&id=ud36b014d&originHeight=514&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=ud5e4c93c-a14d-4c60-a6e6-0af882bbff2&title=%E4%B8%A4%E6%AC%A1HTTP%E8%AF%B7%E6%B1%82%E4%B9%8B%E5%90%8E%E6%AD%A3%E5%BC%8F%E4%BD%BF%E7%94%A8websocket%E9%80%9A%E4%BF%A1 "两次HTTP请求之后正式使用websocket通信")<br />上面这张图就是全貌了，从截图上的注释可以看出，websocket和HTTP一样都是基于TCP的协议。经历了三次TCP握手之后，利用HTTP协议升级为websocket协议。<br />你在网上可能会看到一种说法："websocket是基于HTTP的新协议"，**其实这并不对**，因为websocket只有在建立连接时才用到了HTTP，**升级完成之后就跟HTTP没有任何关系了**。<br />这就好像你喜欢的女生通过你要到了你大学室友的微信，然后他们自己就聊起来了。你能说这个女生是通过你去跟你室友沟通的吗？不能。你跟HTTP一样，都只是个**工具人**。<br />这就有点"**借壳生蛋**"的那意思。<br />![HTTP和websocket的关系](https://cdn.nlark.com/yuque/0/2022/png/396745/1668572592143-c2696f0a-7853-4a00-af5f-529965dd72cc.png#averageHue=%23bcd4d7&clientId=ud39aee1a-03c4-4&from=paste&id=uea61a1b2&originHeight=464&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=u1a2f2108-3788-4e1b-b5b6-2ec0a150cb2&title=HTTP%E5%92%8Cwebsocket%E7%9A%84%E5%85%B3%E7%B3%BB "HTTP和websocket的关系")
<a name="xxR8W"></a>
### websocket的消息格式
上面提到在完成协议升级之后，两端就会用webscoket的数据格式进行通信。<br />数据包在websocket中被叫做**帧**。<br />来看下它的数据格式长什么样子。<br />![websocket报文格式](https://cdn.nlark.com/yuque/0/2022/png/396745/1668572592579-c762ac47-72d1-4b58-b25f-e9bb23742004.png#averageHue=%2383c0bf&clientId=ud39aee1a-03c4-4&from=paste&id=u1f9c51fb&originHeight=450&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=u904e5afd-9273-4174-aad1-1a1ec3232b1&title=websocket%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F "websocket报文格式")<br />这里面字段很多，但只需要关注下面这几个。<br />**opcode字段**：这个是用来标志这是个**什么类型**的数据帧。比如。

- 等于1时是指text类型（string）的数据包
- 等于2是二进制数据类型（[]byte）的数据包
- 等于8是关闭连接的信号

**payload字段**：存放的是**真正想要传输的数据的长度**，单位是**字节**。比如你要发送的数据是字符串"111"，那它的长度就是3。<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1668572593583-70fe43b3-9c7a-4a0c-8657-0d90588fd1bb.png#averageHue=%23f1ebea&clientId=ud39aee1a-03c4-4&from=paste&id=u88b983fa&originHeight=432&originWidth=860&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=udc572063-537b-4d93-be91-9ea196139a6&title=)<br />另外，可以看到，存放**payload长度的字段有好几个**，既可以用最前面的7bit, 也可以用后面的7+16bit或7+64bit。<br />那么问题就来了。<br />在数据层面，大家都是01二进制流。怎么知道**什么情况下应该读7bit，什么情况下应该读7+16bit呢？**<br />websocket会用最开始的7bit做标志位。不管接下来的数据有多大，都**先读最先的7个bit**，根据它的取值决定还要不要再读个16bit或64bit。

- 如果最开始的7bit的值是 0~125，那么它就表示了 **payload 全部长度**，只读最开始的7个bit就完事了。

![payload长度在0到125之间](https://cdn.nlark.com/yuque/0/2022/png/396745/1668572593657-2b9a0f6f-1d23-462b-8cae-d9197c532df5.png#averageHue=%23b2d6d7&clientId=ud39aee1a-03c4-4&from=paste&id=u449439e2&originHeight=450&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=u44b3c577-ea66-49b2-a90b-e18cb1d024b&title=payload%E9%95%BF%E5%BA%A6%E5%9C%A80%E5%88%B0125%E4%B9%8B%E9%97%B4 "payload长度在0到125之间")

- 如果是126（0x7E）。那它表示payload的长度范围在 126~65535 之间，接下来还需要**再读16bit**。这16bit会包含payload的真实长度。

![payload长度在126到65535之间](https://cdn.nlark.com/yuque/0/2022/png/396745/1668572593626-5de73edc-1efe-44af-8de2-e56c10a71b11.png#averageHue=%23b5d7d8&clientId=ud39aee1a-03c4-4&from=paste&id=uf3f9fd8a&originHeight=450&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=u74d11d7a-e937-47bd-9cc8-b711199468d&title=payload%E9%95%BF%E5%BA%A6%E5%9C%A8126%E5%88%B065535%E4%B9%8B%E9%97%B4 "payload长度在126到65535之间")

- 如果是127（0x7F）。那它表示payload的长度范围&gt;=65536，接下来还需要**再读64bit**。这64bit会包含payload的长度。这能放2的64次方byte的数据，换算一下好多个TB，肯定够用了。

![payload长度大于等于65536的情况](https://cdn.nlark.com/yuque/0/2022/png/396745/1668572593664-afa7ab31-bd8d-411b-950d-d62e9355415f.png#averageHue=%2385c3c2&clientId=ud39aee1a-03c4-4&from=paste&id=u997ad50c&originHeight=450&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=ub8117a7d-3837-4398-9b05-159b1a066fb&title=payload%E9%95%BF%E5%BA%A6%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E65536%E7%9A%84%E6%83%85%E5%86%B5 "payload长度大于等于65536的情况")<br />**payload data字段**：这里存放的就是真正要传输的数据，在知道了上面的payload长度后，就可以根据这个值去截取对应的数据。<br />大家有没有发现一个小细节，websocket的数据格式也是  **数据头（内含payload长度） + payload data** 的形式。<br />之前写的《既然有HTTP协议，为什么还要有RPC》提到过，TCP协议本身就是全双工，但直接使用**纯裸TCP**去传输数据，会有**粘包**的"问题"。为了解决这个问题，上层协议一般会用**消息头+消息体**的格式去重新包装要发的数据。<br />而**消息头**里一般含有**消息体的长度**，通过这个长度可以去截取真正的消息体。<br />HTTP协议和大部分RPC协议，以及今天介绍的websocket协议，都是这样设计的。<br />![消息边界长度标志](https://cdn.nlark.com/yuque/0/2022/png/396745/1668572593914-3519d6fe-78c1-441c-9058-2e79f297600f.png#averageHue=%23e3eaeb&clientId=ud39aee1a-03c4-4&from=paste&id=u62752455&originHeight=360&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=u947168c0-186d-4540-85ef-b9fa98f319c&title=%E6%B6%88%E6%81%AF%E8%BE%B9%E7%95%8C%E9%95%BF%E5%BA%A6%E6%A0%87%E5%BF%97 "消息边界长度标志")
<a name="NhJi7"></a>
### websocket的使用场景
websocket完美继承了TCP协议的**全双工**能力，并且还贴心的提供了解决粘包的方案。它适用于**需要服务器和客户端（浏览器）频繁交互**的大部分场景。比如网页/小程序游戏，网页聊天室，以及一些类似飞书这样的网页协同办公软件。<br />回到文章开头的问题，在使用websocket协议的网页游戏里，怪物移动以及攻击玩家的行为是**服务器逻辑**产生的，对玩家产生的伤害等数据，都需要由**服务器主动发送给客户端**，客户端获得数据后展示对应的效果。<br />![websocket的使用场景](https://cdn.nlark.com/yuque/0/2022/png/396745/1668572594483-b0e0adfe-fdc5-41b5-a581-128d012f4abe.png#averageHue=%23cfdee2&clientId=ud39aee1a-03c4-4&from=paste&id=ua35f344b&originHeight=450&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=u805076c4-b7ef-4f45-ba64-796fadc8fbb&title=websocket%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF "websocket的使用场景")
<a name="BtzkD"></a>
### 总结

- TCP协议本身是**全双工**的，但最常用的HTTP1.1，虽然是基于TCP的协议，但它是**半双工**的，对于大部分需要服务器主动推送数据到客户端的场景，都不太友好，因此需要使用支持全双工的websocket协议。
- 在HTTP1.1里。只要客户端不问，服务端就不答。基于这样的特点，对于登录页面这样的简单场景，可以使用**定时轮询或者长轮询**的方式实现**服务器推送**(comet)的效果。
- 对于客户端和服务端之间需要频繁交互的复杂场景，比如网页游戏，都可以考虑使用websocket协议。
- websocket和socket几乎没有任何关系，只是叫法相似。
- 正因为各个浏览器都支持HTTP协议，所以websocket会先利用HTTP协议加上一些特殊的header头进行握手升级操作，升级成功后就跟HTTP没有任何关系了，之后就用websocket的数据格式进行收发数据。
