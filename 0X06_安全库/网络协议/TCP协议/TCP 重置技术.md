TCP<br />**如何关闭一个 TCP 连接？**<br />可能大家第一反应是「杀掉进程」不就行了吗？<br />是的，这个是最粗暴的方式，杀掉客户端进程和服务端进程影响的范围会有所不同：

- 在客户端杀掉进程的话，就会发送 FIN 报文，来断开这个客户端进程与服务端建立的所有 TCP 连接，这种方式影响范围只有这个客户端进程所建立的连接，而其他客户端或进程不会受影响。
- 而在服务端杀掉进程影响就大了，此时所有的 TCP 连接都会被关闭，服务端无法继续提供访问服务。

所以，**关闭进程的方式并不可取，最好的方式要精细到关闭某一条 TCP 连接**。<br />有的小伙伴可能会说，**伪造一个四元组相同的 RST 报文不就行了？**<br />这个思路很好，「伪造 RST 报文来关闭 TCP 连接」的方式其实有个专业术语叫：**TCP 重置攻击**。<br />![from 维基百科](https://cdn.nlark.com/yuque/0/2023/png/396745/1674050199482-30fe3ea1-1635-4234-97ec-227cf1089c13.png#averageHue=%23fdfdfd&clientId=ud08502ba-56e3-4&from=paste&id=u76012981&originHeight=244&originWidth=1070&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=ueccf15c9-0943-4c81-ba91-377c7424ebb&title=from%20%E7%BB%B4%E5%9F%BA%E7%99%BE%E7%A7%91 "from 维基百科")<br />我们的墙，在过滤网站的时候，其实就是这么干的。当然，墙除了 TCP 重置连接的方式外，还有很多方式来过滤网站，比如域名劫持、IP封锁、HTTPS 证书过滤等等。<br />这次只重点关注 **TCP 重置技术**。
<a name="REIwP"></a>
## TCP 重置技术
伪造 RST 报文说来简单，但是不要忘了还有个「序列号」的问题，伪造的 RST 报文的序列号一定能被对方接受吗？<br />如果 RST 报文的序列号不是对方期望收到的序列号，那么这个 RST 报文则会被对方丢弃，就达不到重置 TCP 连接的效果了。<br />举个例子，下面这个场景，客户端发送了一个长度为 100 的 TCP 数据报文，服务端收到后响应了 ACK 报文，表示收到了这个 TCP 数据报文。**服务端响应的这个 ACK 报文中的确认号（ack = x + 100）就是表明服务端下一次期望收到的序列号是 x + 100**。<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1674050199205-72c13044-c1f7-48e8-8c82-c4954df0c294.png#averageHue=%23f8f6f5&clientId=ud08502ba-56e3-4&from=paste&id=u42a8877b&originHeight=816&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u0fc78962-10c8-46b0-ae16-8afe0ea740b&title=)<br />所以，要伪造一个有用的 RST 报文**，关键是要拿到对方下一次期望收到的序列号**。<br />这里介绍两个关闭一个 TCP 连接的工具：**tcpkill** 和 **killcx**。<br />这两个工具都是通过伪造 RST 报文来关闭指定的 TCP 连接，但是它们拿到正确的序列号的实现方式是不同的。

- tcpkill 工具是在双方进行 TCP 通信时，拿到对方下一次期望收到的序列号，然后将序列号填充到伪造的 RST 报文，并将其发送给对方，达到关闭 TCP 连接的效果。
- killcx 工具是主动发送一个 SYN 报文，对方收到后会回复一个携带了正确序列号和确认号的 ACK 报文，这个 ACK 被称之为 Challenge ACK，这时就可以拿到对方下一次期望收到的序列号，然后将序列号填充到伪造的 RST 报文，并将其发送给对方，达到关闭 TCP 连接的效果。

可以看到， 这两个工具在获取对方下一次期望收到的序列号的方式是不同的。<br />tcpkill 工具属于被动获取，就是在双方进行 TCP 通信的时候，才能获取到正确的序列号，很显然**这种方式无法关闭非活跃的 TCP 连接**，只能用于关闭活跃的 TCP 连接。因为如果这条 TCP 连接一直没有任何数据传输，则就永远获取不到正确的序列号。<br />killcx 工具则是属于主动获取，它是主动发送一个 SYN 报文，通过对方回复的 Challenge ACK 来获取正确的序列号，所以这种方式**无论 TCP 连接是否活跃，都可以关闭**。<br />接下来，就用这两个工具做个实验，给大家演示一下，它们是如何关闭一个 TCP 连接的。
<a name="waPtP"></a>
## tcpkill 工具
在这里， 用 nc 工具来模拟一个 TCP 服务端，监听 8888 端口。<br />![模拟一个 TCP 服务端](https://cdn.nlark.com/yuque/0/2023/png/396745/1674050199243-116b8f41-d62c-41a9-a05e-85770ccafa04.png#averageHue=%230e1018&clientId=ud08502ba-56e3-4&from=paste&id=ue3f72711&originHeight=134&originWidth=926&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=ud77c40f6-4e28-4c45-82a3-011e555f678&title=%E6%A8%A1%E6%8B%9F%E4%B8%80%E4%B8%AA%20TCP%20%E6%9C%8D%E5%8A%A1%E7%AB%AF "模拟一个 TCP 服务端")<br />接着，在客户端机子上，用 nc 工具模拟一个 TCP 客户端，连接刚才启动的服务端，并且指定了客户端的端口为 11111。<br />![客户端连接服务端](https://cdn.nlark.com/yuque/0/2023/png/396745/1674050199175-81b01953-c8d6-4df2-a977-4c1919a0f2d4.png#averageHue=%2310121a&clientId=ud08502ba-56e3-4&from=paste&id=uae0f1160&originHeight=107&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=u6539d4d3-8df3-4adb-ad83-48f72e3319d&title=%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E7%AB%AF "客户端连接服务端")<br />这时候， 服务端就可以看到这条 TCP 连接了。<br />![TCP 连接的四元组信息](https://cdn.nlark.com/yuque/0/2023/png/396745/1674050199233-824e4229-dc14-4f9b-8a66-c8a3749d7dcd.png#averageHue=%2310111a&clientId=ud08502ba-56e3-4&from=paste&id=u3d8e2fc4&originHeight=157&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=ub7e9a7f0-ff62-46f0-966f-1a70011a29b&title=TCP%20%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%9B%9B%E5%85%83%E7%BB%84%E4%BF%A1%E6%81%AF "TCP 连接的四元组信息")<br />注意，这台服务端的公网 IP 地址是 121.43.173.240，私网 IP 地址是 172.19.11.21，在服务端通过 netstat 命令查看 TCP 连接的时候，则会将服务端的地址显示成私网 IP 地址 。至此，前期工作就做好了。<br />接下来，在服务端执行 tcpkill 工具，来关闭这条 TCP 连接，看看会发生什么？<br />在这里，指定了要关闭的客户端 IP 为 114.132.166.90 和端口为 11111 的 TCP 连接。<br />![执行 tcpkill](https://cdn.nlark.com/yuque/0/2023/png/396745/1674050199636-cd8d0f1b-bed2-410e-aa85-02a7163c1e53.png#averageHue=%230f111a&clientId=ud08502ba-56e3-4&from=paste&id=u648ab7d0&originHeight=133&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=u5a4a87e9-a9d8-435c-9f3e-b3b1cedb22e&title=%E6%89%A7%E8%A1%8C%20tcpkill "执行 tcpkill")<br />可以看到，tcpkill 工具阻塞中，没有任何输出，而且此时的 TCP 连接还是存在的，并没有被干掉。<br />![TCP 连接还存在](https://cdn.nlark.com/yuque/0/2023/png/396745/1674050199683-e347eca0-8d15-4f80-992f-ddee956fc525.png#averageHue=%2310111a&clientId=ud08502ba-56e3-4&from=paste&id=u1b4ebd47&originHeight=157&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=uc7b6c363-2834-4cd1-a850-1c8f129c75b&title=TCP%20%E8%BF%9E%E6%8E%A5%E8%BF%98%E5%AD%98%E5%9C%A8 "TCP 连接还存在")<br />为什么 TCP 连接没用被干掉？<br />因为在执行 tcpkill 工具后，这条 TCP 连接并没有传输任何数据，而 tcpkill 工具是需要拦截双方的 TCP 通信，才能获取到正确的序列号，从而才能伪装出正确的序列号的 RST 报文。<br />所以，从这里也说明了，**tcpkill 工具不适合关闭非活跃的 TCP 连接**。<br />接下来，尝试在客户端发送一个数据。<br />![客户端断开了](https://cdn.nlark.com/yuque/0/2023/png/396745/1674050199967-5d68a138-18a9-49dd-a4e4-44ea54f33a46.png#averageHue=%2310121a&clientId=ud08502ba-56e3-4&from=paste&id=u00310e75&originHeight=145&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=u991273ac-8d4b-4794-90f2-775875450bb&title=%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%96%AD%E5%BC%80%E4%BA%86 "客户端断开了")<br />可以看到，在发送了「hi」数据后，客户端就断开了，并且错误提示连接被对方关闭了。<br />此时，服务端已经查看不到刚才那条 TCP 连接了。<br />![刚才那条 TCP 连接已经不存在](https://cdn.nlark.com/yuque/0/2023/png/396745/1674050199703-4e0d5732-6ed4-48f3-a626-2fb47d8f744b.png#averageHue=%23101219&clientId=ud08502ba-56e3-4&from=paste&id=u0a39c35f&originHeight=111&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=u2e08f1dd-5d58-44ed-b8b4-b3736be7f60&title=%E5%88%9A%E6%89%8D%E9%82%A3%E6%9D%A1%20TCP%20%E8%BF%9E%E6%8E%A5%E5%B7%B2%E7%BB%8F%E4%B8%8D%E5%AD%98%E5%9C%A8 "刚才那条 TCP 连接已经不存在")<br />然后，在服务端看看 tcpkill 工具输出的信息。<br />![tcpkill 工具输出的信息](https://cdn.nlark.com/yuque/0/2023/png/396745/1674050199961-a0686523-3132-4bab-bc89-250c89ff8d59.png#averageHue=%2310121b&clientId=ud08502ba-56e3-4&from=paste&id=u6db4eac0&originHeight=182&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=ufcdc3cd1-5475-43eb-aaea-d8ac435b02f&title=tcpkill%20%E5%B7%A5%E5%85%B7%E8%BE%93%E5%87%BA%E7%9A%84%E4%BF%A1%E6%81%AF "tcpkill 工具输出的信息")<br />可以看到， **tcpkill 工具给服务端和客户端都发送了伪造的 RST 报文，从而达到关闭一条 TCP 连接的效果**。<br />到这里知道了， 运行 tcpkill 工具后，只有目标连接有新 TCP 包发送/接收的时候，才能关闭一条 TCP 连接。因此，**tcpkill 只适合关闭活跃的 TCP 连接，不适合用来关闭非活跃的 TCP 连接**。<br />上面的实验过程，也抓了数据包，流程如下：<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1674050200105-7b4fb316-9c66-4a19-8d25-daa773f97c7f.png#averageHue=%23e2dbd9&clientId=ud08502ba-56e3-4&from=paste&id=ua5debd48&originHeight=428&originWidth=1020&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u09701476-3b73-479f-91c4-5072f362380&title=)<br />最后一个 RST 报文就是 tcpkill 工具伪造的 RST 报文。
<a name="jSMud"></a>
## killcx 工具
在前面提到过，killcx 工具则是属于主动获取，它是主动发送一个 SYN 报文，通过对方回复的 Challenge ACK 来获取正确的序列号，然后将这个正确的序列号填充到伪造的 RST 报文，并将  RST 报文发送给对方，达到关闭连接的效果。<br />可能有的小伙伴听到发送 SYN 报文觉得很奇怪，SYN 报文不是建立 TCP 连接时才发送的吗？为什么都已经建立好的 TCP 连接，还要发送 SYN 报文？<br />不着急，先说说「已建立连接的TCP，收到 SYN 会发生什么？」<br />**处于 Establish 状态的服务端，如果收到了客户端的 SYN 报文，会回复一个携带了正确序列号和确认号的 ACK 报文，这个 ACK 被称之为 Challenge ACK。**<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1674050200149-b88ae28d-43e2-4b88-8b40-62c28c2b0080.png#averageHue=%23fbf9f6&clientId=ud08502ba-56e3-4&from=paste&id=uc856710b&originHeight=806&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u5ca7517e-1836-4e9c-b195-41d01b4e25c&title=)<br />**上图中，服务端针对 SYN 报文响应的 Challenge ACK 报文里的「确认号」，就是服务端下一次期望收到的序列号，Challenge ACK 报文里的「序列号」，就是客户端下一次期望收到的序列号。**<br />killcx 工具正是通过**伪造一个四元组相同的 SYN 报文，来拿到“合法”的序列号的！**<br />如果处于 establish 状态的连接，在收到四元组相同的 SYN 报文后，**会回复一个 Challenge ACK，这个 ACK 报文里的「确认号」，正好是下一次想要接收的序列号，说白了，就是可以通过这一步拿到对方下一次预期接收的序列号。**<br />**然后用这个确认号作为 RST 报文的序列号，发送给对方，此时对方会认为这个 RST 报文里的序列号是合法的，于是就会释放连接！**<br />killcx 的工具使用方式也很简单，如果在服务端执行 killcx 工具，只需指明客户端的 IP 和端口号，如果在客户端执行 killcx 工具，则就指明服务端的  IP 和端口号。
```bash
killcx <IP地址>:<端口号>
```
killcx 工具的工作原理，如下图，下图是在客户端执行 killcx 工具。<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1674050200136-1ca60bef-5a37-4af5-8fe1-c3da2ab79325.png#averageHue=%23f9f8f8&clientId=ud08502ba-56e3-4&from=paste&id=u5a9f4ec0&originHeight=839&originWidth=782&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u397d04b7-32d8-4382-8ef8-88f78554400&title=)<br />killcx 工具伪造客户端发送 SYN 报文，服务端收到后就会回复一个携带了正确「序列号和确认号」的 ACK 报文（Challenge ACK），然后就可以利用这个 ACK 报文里面的信息，伪造两个 RST 报文：

- 用 Challenge ACK 里的「确认号」伪造 RST 报文发送给服务端，服务端收到 RST 报文后就会释放连接。
- 用 Challenge ACK 里的「序列号」伪造 RST 报文发送给客户端，客户端收到 RST 也会释放连接。

正是通过这样的方式，成功将一个 TCP 连接关闭了！<br />这里给大家贴一个使用 killcx 工具关闭连接的抓包图，大家多看看序列号和确认号的变化。<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1674050200487-c9b4ca9e-ec20-457a-bfb7-c8d88862327f.png#averageHue=%23f9a079&clientId=ud08502ba-56e3-4&from=paste&id=ue10d6094&originHeight=213&originWidth=586&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u23e0d078-e127-4ad2-bc21-1a0c3996f51&title=)
<a name="kWi5O"></a>
## 总结
要伪造一个能关闭 TCP 连接的 RST 报文，必须同时满足「四元组相同」和「序列号是对方期望的」这两个条件。<br />这里介绍了两种关闭 TCP 连接的工具：tcpkill 和 killcx 工具。<br />这两种工具都是通过伪造 RST 报文来关闭 TCP 连接的，但是它们获取「对方下一次期望收到的序列号的方式是不同的，也正因此，造就了这两个工具的应用场景有区别。

- tcpkill 工具只能用来关闭活跃的 TCP 连接，无法关闭非活跃的 TCP 连接，因为 tcpkill 工具是等双方进行 TCP 通信后，才去获取正确的序列号，如果这条 TCP 连接一直没有任何数据传输，则就永远获取不到正确的序列号。
- killcx 工具可以用来关闭活跃和非活跃的 TCP 连接，因为 killcx 工具是主动发送 SYN 报文，这时对方就会回复  Challenge ACK ，然后  killcx 工具就能从这个 ACK 获取到正确的序列号。
