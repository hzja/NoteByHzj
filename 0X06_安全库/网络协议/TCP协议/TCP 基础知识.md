网络协议 TCP<br />![](https://cdn.nlark.com/yuque/0/2021/webp/396745/1624336096175-9b46f951-2509-42dc-8ca2-b0b9505da9fe.webp#clientId=ud4c79778-e9d8-4&from=paste&id=u7c02105d&originHeight=444&originWidth=992&originalType=url&ratio=3&status=done&style=shadow&taskId=u95b1f6e3-4e4a-4609-a931-1b2d24fe8d1)<br />TCP 是一种面向连接的单播协议，在 TCP 中，并不存在多播、广播的这种行为，因为 TCP 报文段中能明确发送方和接受方的 IP 地址。<br />在发送数据前，相互通信的双方（即发送方和接受方）需要建立一条连接，在发送数据后，通信双方需要断开连接，这就是 TCP 连接的建立和终止。
<a name="Sst6g"></a>
## TCP 连接的建立和终止
TCP 的基本元素有四个：即**发送方的 IP 地址、发送方的端口号、接收方的 IP 地址、接收方的端口号**。而每一方的 IP + 端口号都可以看作是一个套接字，套接字能够被唯一标示。套接字就相当于是门，出了这个门，就要进行数据传输了。<br />TCP 的连接建立 -> 终止总共分为三个阶段<br />![2021-05-17-22-46-43-049217.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1621263021921-6a2a404f-7110-4eda-aa7b-181916d32866.png#clientId=u8df32a21-e1fb-4&from=ui&id=u8a811286&originHeight=113&originWidth=750&originalType=binary&ratio=1&size=35761&status=done&style=shadow&taskId=u8ce3b9ee-3a93-45eb-9b9b-00e6cf4e498)<br />下面所讨论的重点也是集中在这三个层面。<br />下图是一个非常典型的 TCP 连接的建立和关闭过程，其中不包括数据传输的部分。
<a name="dA7WL"></a>
### TCP 建立连接 - 三次握手
![2021-05-17-22-46-43-358390.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1621263040036-c7b38236-67af-4cba-9246-87aa284bda4a.png#clientId=u8df32a21-e1fb-4&from=ui&id=u2077b6ea&originHeight=635&originWidth=756&originalType=binary&ratio=1&size=101546&status=done&style=shadow&taskId=ude219230-aeba-437a-8538-b367b5cd555)

1. 服务端进程准备好接收来自外部的 TCP 连接，一般情况下是调用 bind、listen、socket 三个函数完成。这种打开方式被认为是 被动打开(passive open)。然后服务端进程处于 LISTEN 状态，等待客户端连接请求。
2. 客户端通过 connect 发起主动打开(active open)，向服务器发出连接请求，请求中首部同步位 SYN = 1，同时选择一个初始序号 sequence ，简写 seq = x。SYN 报文段不允许携带数据，只消耗一个序号。此时，客户端进入 SYN-SEND 状态。
3. 服务器收到客户端连接后，，需要确认客户端的报文段。在确认报文段中，把 SYN 和 ACK 位都置为 1 。确认号是 ack = x + 1，同时也为自己选择一个初始序号 seq = y。这个报文段也不能携带数据，但同样要消耗掉一个序号。此时，TCP 服务器进入 SYN-RECEIVED(同步收到) 状态。
4. 客户端在收到服务器发出的响应后，还需要给出确认连接。确认连接中的 ACK 置为 1 ，序号为 seq = x + 1，确认号为 ack = y + 1。TCP 规定，这个报文段可以携带数据也可以不携带数据，如果不携带数据，那么下一个数据报文段的序号仍是 seq = x + 1。这时，客户端进入 ESTABLISHED (已连接) 状态
5. 服务器收到客户的确认后，也进入 ESTABLISHED 状态。

这是一个典型的三次握手过程，通过上面 3 个报文段就能够完成一个 TCP 连接的建立。三次握手的的目的不仅仅在于让通信双方知晓正在建立一个连接，**也在于利用数据包中的选项字段来交换一些特殊信息，交换初始序列号**。<br />一般首个发送 SYN 报文的一方被认为是主动打开一个连接，而这一方通常也被称为客户端。而 SYN 的接收方通常被称为服务端，它用于接收这个 SYN，并发送下面的 SYN，因此这种打开方式是被动打开。<br />TCP 建立一个连接需要三个报文段，释放一个连接却需要四个报文段。
<a name="wcsv3"></a>
### TCP 断开连接 - 四次挥手
数据传输结束后，通信的双方可以释放连接。数据传输结束后的客户端主机和服务端主机都处于 ESTABLISHED 状态，然后进入释放连接的过程。<br />![2021-05-17-22-46-43-653600.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1621263057478-3283bfe2-721a-4dec-b36c-da6fdd1f4ff6.png#clientId=u8df32a21-e1fb-4&from=ui&id=u2cb90628&originHeight=739&originWidth=785&originalType=binary&ratio=1&size=305578&status=done&style=shadow&taskId=u3cbeade6-81bb-4050-97c5-8fe14468212)<br />TCP 断开连接需要历经的过程如下

1. 客户端应用程序发出释放连接的报文段，并停止发送数据，主动关闭 TCP 连接。客户端主机发送释放连接的报文段，报文段中首部 FIN 位置为 1 ，不包含数据，序列号位 seq = u，此时客户端主机进入 FIN-WAIT-1(终止等待 1) 阶段。
2. 服务器主机接受到客户端发出的报文段后，即发出确认应答报文，确认应答报文中 ACK = 1，生成自己的序号位 seq = v，ack = u + 1，然后服务器主机就进入 CLOSE-WAIT(关闭等待) 状态。
3. 客户端主机收到服务端主机的确认应答后，即进入 FIN-WAIT-2(终止等待2) 的状态。等待客户端发出连接释放的报文段。
4. 这时服务端主机会发出断开连接的报文段，报文段中 ACK = 1，序列号 seq = v，ack = u + 1，在发送完断开请求的报文后，服务端主机就进入了 LAST-ACK(最后确认)的阶段。
5. 客户端收到服务端的断开连接请求后，客户端需要作出响应，客户端发出断开连接的报文段，在报文段中，ACK = 1, 序列号 seq = u + 1，因为客户端从连接开始断开后就没有再发送数据，ack = v + 1，然后进入到 TIME-WAIT(时间等待) 状态，请注意，这个时候 TCP 连接还没有释放。必须经过时间等待的设置，也就是 2MSL 后，客户端才会进入 CLOSED 状态，时间 MSL 叫做最长报文段寿命（Maximum Segment Lifetime）。
6. 服务端主要收到了客户端的断开连接确认后，就会进入 CLOSED 状态。因为服务端结束 TCP 连接时间要比客户端早，而整个连接断开过程需要发送四个报文段，因此释放连接的过程也被称为四次挥手。

TCP 连接的任意一方都可以发起关闭操作，只不过通常情况下发起关闭连接操作一般都是客户端。然而，一些服务器比如 Web 服务器在对请求作出相应后也会发起关闭连接的操作。TCP 协议规定通过发送一个 FIN 报文来发起关闭操作。<br />所以综上所述，建立一个 TCP 连接需要三个报文段，而关闭一个 TCP 连接需要四个报文段。TCP 协议还支持一种半开启(half-open) 状态，虽然这种情况并不多见。
<a name="HcnA5"></a>
### TCP 半开启
TCP 连接处于半开启的这种状态是因为连接的一方关闭或者终止了这个 TCP 连接却没有通知另一方，也就是说两个人正在微信聊天，另一个人下线了你不告诉我，我还在跟你侃八卦呢。此时就认为这条连接处于半开启状态。这种情况发生在通信中的一方处于主机崩溃的情况下，我电脑死机了我咋告诉你？只要处于半连接状态的一方不传输数据的话，那么是无法检测出来对方主机已经下线的。<br />另外一种处于半开启状态的原因是通信的一方关闭了**主机电源** 而不是正常关机。这种情况下会导致服务器上有很多半开启的 TCP 连接。
<a name="Ynspb"></a>
### TCP 半关闭
既然 TCP 支持半开启操作，那么可以设想 TCP 也支持半关闭操作。同样的，TCP 半关闭也并不常见。TCP 的半关闭操作是指**仅仅关闭数据流的一个传输方向**。两个半关闭操作合在一起就能够关闭整个连接。在一般情况下，通信双方会通过应用程序互相发送 FIN 报文段来结束连接，但是在 TCP 半关闭的情况下，应用程序会表明_自己的想法_："已经完成了数据的发送发送，并发送了一个 FIN 报文段给对方，但是依然希望接收来自对方的数据直到它发送一个 FIN 报文段"。下面是一个 TCP 半关闭的示意图。<br />![2021-05-17-22-46-44-146701.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1621263078290-646cf6bf-28d6-4e25-a70e-024a5afe8b06.png#clientId=u8df32a21-e1fb-4&from=ui&id=u73b95ae7&originHeight=767&originWidth=758&originalType=binary&ratio=1&size=185551&status=done&style=shadow&taskId=ud4ac317d-598c-4609-a5c1-2b34f71c560)<br />解释一下这个过程：<br />首先客户端主机和服务器主机一直在进行数据传输，一段时间后，客户端发起了 FIN 报文，要求主动断开连接，服务器收到 FIN 后，回应 ACK ，由于此时发起半关闭的一方也就是客户端仍然希望服务器发送数据，所以服务器会继续发送数据，一段时间后服务器发送另外一条 FIN 报文，在客户端收到 FIN 报文回应 ACK 给服务器后，断开连接。<br />TCP 的半关闭操作中，连接的一个方向被关闭，而另一个方向仍在传输数据直到它被关闭为止。只不过很少有应用程序使用这一特性。
<a name="jjt2x"></a>
### 同时打开和同时关闭
还有一种比较非常规的操作，这就是两个应用程序同时主动打开连接。虽然这种情况看起来不太可能，但是在特定的安排下却是有可能发生的。主要讲述这个过程。<br />通信双方在接收到来自对方的 SYN 之前会首先发送一个 SYN，这个场景还要求通信双方都知道对方的 **IP 地址 + 端口号**。<br />比如恋爱中的一对男女，他俩都同时说出了我爱你这个神圣的誓言，然后他俩对彼此的响应进行么么哒，这就是同时打开。<br />下面是同时打开的例子<br />![2021-05-17-22-46-44-253802.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1621263094321-63f89719-6429-4137-bbe1-dfb0a3982d67.png#clientId=u8df32a21-e1fb-4&from=ui&id=ua20cabbe&originHeight=639&originWidth=785&originalType=binary&ratio=1&size=128006&status=done&style=shadow&taskId=u7f80f58c-62d6-43a2-a0e1-b22bbda3c08)<br />如上图所示，通信双方都在收到对方报文前主动发送了 SYN 报文，都在收到彼此的报文后回复了一个 ACK 报文。<br />一个同时打开过程需要交换四个报文段，比普通的三次握手增加了一个，由于同时打开没有客户端和服务器一说，所以这里用了通信双方来称呼。<br />像同时打开一样，同时关闭也是通信双方同时提出主动关闭请求，发送 FIN 报文，下图显示了一个同时关闭的过程。<br />![2021-05-17-22-46-44-390433.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1621263103088-66d1ac56-13e5-4c83-a089-915d0df72893.png#clientId=u8df32a21-e1fb-4&from=ui&id=u8ad16aa8&originHeight=669&originWidth=780&originalType=binary&ratio=1&size=131350&status=done&style=shadow&taskId=u61faaabf-8ae9-4438-b115-0b8be71987b)<br />同时关闭过程中需要交换和正常关闭相同数量的报文段，只不过同时关闭不像四次挥手那样顺序进行，而是交叉进行的。
<a name="hJKKX"></a>
### 初始序列号
初始序列号它是有专业术语表示的，初始序列号的英文名称是**Initial sequence numbers (ISN)**，所以上面表示的 seq = v，其实就表示的 ISN。<br />在发送 SYN 之前，通信双方会选择一个初始序列号。初始序列号是随机生成的，每一个 TCP 连接都会有一个不同的初始序列号。RFC 文档指出初始序列号是一个 32 位的计数器，每 4 us（微秒） + 1。因为每个 TCP 连接都是一个不同的实例，这么安排的目的就是为了防止出现序列号重叠的情况。<br />当一个 TCP 连接建立的过程中，只有正确的 TCP 四元组和正确的序列号才会被对方接收。这也反应了 TCP 报文段容易被伪造 的脆弱性，因为只要伪造了一个相同的四元组和初始序列号就能够伪造 TCP 连接，从而打断 TCP 的正常连接，所以抵御这种攻击的一种方式就是使用初始序列号，另外一种方法就是加密序列号。
<a name="R9Yh0"></a>
## TCP 状态转换
上面聊到了三次握手和四次挥手，提到了一些关于 TCP 连接之间的状态转换，那么下面就从头开始梳理一下这些状态之间的转换。<br />首先第一步，刚开始时服务器和客户端都处于 CLOSED 状态，这时需要判断是主动打开还是被动打开，如果是主动打开，那么客户端向服务器发送 SYN 报文，此时客户端处于 SYN-SEND 状态，SYN-SEND 表示发送连接请求后等待匹配的连接请求，服务器被动打开会处于 LISTEN 状态，用于监听 SYN 报文。如果客户端调用了 close 方法或者经过一段时间没有操作，就会重新变为 CLOSED 状态，这一步转换图如下<br />![2021-05-17-22-46-44-474210.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1621263137582-626cbc22-b357-4d08-b0d0-8c8e4cf853e7.png#clientId=u8df32a21-e1fb-4&from=ui&id=u5e52a672&originHeight=282&originWidth=568&originalType=binary&ratio=1&size=47219&status=done&style=shadow&taskId=u8f39af02-195f-40c4-a393-caed80136f4)<br />这里有个疑问，为什么处于 LISTEN 状态下的客户端还会发送 SYN 变为 SYN_SENT 状态呢？<br />知乎看到了车小胖大佬的回答，这种情况可能出现在 FTP 中，LISTEN -> SYN_SENT 是因为这个连接可能是由于服务器端的应用有数据发送给客户端所触发的，客户端被动接受连接，连接建立后，开始传输文件。也就是说，处于 LISTEN 状态的服务器也是有可能发送 SYN 报文的，只不过这种情况非常少见。<br />处于 SYN_SEND 状态的服务器会接收 SYN 并发送 SYN 和 ACK 转换成为 SYN_RCVD 状态，同样的，处于 LISTEN 状态的客户端也会接收 SYN 并发送 SYN 和 ACK 转换为 SYN_RCVD 状态。如果处于 SYN_RCVD 状态的客户端收到 RST 就会变为 LISTEN 状态。<br />![2021-05-17-22-46-44-594886.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1621263139651-09522372-1c51-406c-99db-ce06dad38499.png#clientId=u8df32a21-e1fb-4&from=ui&id=uf7e41e7b&originHeight=343&originWidth=770&originalType=binary&ratio=1&size=127696&status=done&style=shadow&taskId=ua0daf4d9-2595-4543-a32f-fc6c6c77bb1)<br />这两张图一起看会比较好一些。<br />这里需要解释下什么是 RST<br />这里有一种情况是当主机收到 TCP 报文段后，其 IP 和端口号不匹配的情况。假设客户端主机发送一个请求，而服务器主机经过 IP 和端口号的判断后发现不是给这个服务器的，那么服务器就会发出一个 RST 特殊报文段给客户端。<br />![2021-05-17-22-46-44-703596.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1621263167944-f70b97fb-fb63-4edd-94ab-ae659a2f47e2.png#clientId=u8df32a21-e1fb-4&from=ui&id=ubdc95fe0&originHeight=453&originWidth=813&originalType=binary&ratio=1&size=61111&status=done&style=shadow&taskId=u91b1899d-d428-406f-9bc9-df69837e984)因此，当服务端发送一个 RST 特殊报文段给客户端的时候，它就会告诉客户端_没有匹配的套接字连接，请不要再继续发送了_。<br />RST：（Reset the connection）**用于复位因某种原因引起出现的错误连接，也用来拒绝非法数据和请求**。如果接收到 RST 位时候，通常发生了某些错误。<br />上面没有识别正确的 IP 端口是一种导致 RST 出现的情况，除此之外，RST 还可能由于请求超时、取消一个已存在的连接等出现。<br />位于 SYN_RCVD 的服务器会接收 ACK 报文，SYN_SEND 的客户端会接收 SYN 和 ACK 报文，并发送 ACK 报文，由此，客户端和服务器之间的连接就建立了。<br />![2021-05-17-22-46-44-838235.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1621263175779-a38be571-57db-4486-9e28-aa6a30c3ce11.png#clientId=u8df32a21-e1fb-4&from=ui&id=ub6f487ee&originHeight=418&originWidth=791&originalType=binary&ratio=1&size=150748&status=done&style=shadow&taskId=uad656a8b-641e-459a-8431-47383619733)<br />这里还要注意一点，同时打开的状态在上面没有刻意表示出来，实际上，在同时打开的情况下，它的状态变化是这样的。<br />![2021-05-17-22-46-45-023741.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1621263191198-252473b1-3b0d-4406-833a-7bb966a459d4.png#clientId=u8df32a21-e1fb-4&from=ui&id=u3d52996a&originHeight=687&originWidth=794&originalType=binary&ratio=1&size=239690&status=done&style=shadow&taskId=u932fd231-9436-406a-a71e-98541275ecb)<br />为什么会是这样呢？想一下，在同时打开的情况下，两端主机都发起 SYN 报文，而主动发起 SYN 的主机会处于 SYN-SEND 状态，发送完成后，会等待接收 SYN 和 ACK ， 在双方主机都发送了 SYN + ACK 后，双方都处于 SYN-RECEIVED(SYN-RCVD) 状态，然后等待 SYN + ACK 的报文到达后，双方就会处于 ESTABLISHED 状态，开始传输数据。<br />到现在为止，叙述了一下 TCP 连接建立过程中的状态转换，现在可以泡一壶茶喝点水，等着数据传输了。<br />好了，现在水喝够了，这时候数据也传输完成了，数据传输完成后，这条 TCP 连接就可以断开了。<br />现在把时钟往前拨一下，调整到服务端处于 SYN_RCVD 状态的时刻，因为刚收到了 SYN 包并发送了 SYN + ACK 包，此时服务端很开心，但是这时，服务端应用进程关闭了，然后应用进程发了一个 FIN 包，就会让服务器从 SYN_RCVD -> FIN_WAIT_1 状态。<br />![2021-05-17-22-46-45-226197.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1621263200798-c836baad-0d23-4df9-99cb-e4b2fd495736.png#clientId=u8df32a21-e1fb-4&from=ui&id=u9afecc56&originHeight=525&originWidth=806&originalType=binary&ratio=1&size=210274&status=done&style=shadow&taskId=u685b17f4-fb1d-4b76-ae65-b8c17eceb67)<br />然后把时钟调到现在，客户端和服务器现在已经传输完数据了 ，此时客户端发送了一条 FIN 报文希望断开连接，此时客户端也会变为 FIN_WAIT_1 状态，对于服务器来说，它接收到了 FIN 报文段并回复了 ACK 报文，就会从 ESTABLISHED -> CLOSE_WAIT 状态。<br />![2021-05-17-22-46-45-373803.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1621263209033-42a2b185-ee6a-41e6-9f24-0d2fc787bffd.png#clientId=u8df32a21-e1fb-4&from=ui&id=ud4293859&originHeight=578&originWidth=809&originalType=binary&ratio=1&size=243058&status=done&style=shadow&taskId=u2c83be5d-33dc-447d-b9c7-085b00e4b5f)<br />位于 CLOSE_WAIT 状态的服务端会发送 FIN 报文，然后把自己置于 LAST_ACK 状态。处于 FIN_WAIT_1 的客户端接收 ACK 消息就会变为 FIN_WAIT_2 状态。<br />这里需要先解释一下 CLOSING 这个状态，FIN_WAIT_1 -> CLOSING 的转换比较特殊<br />CLOSING 这种状态比较特殊，实际情况中应该是很少见，属于一种比较罕见的例外状态。正常情况下，当发送FIN 报文后，按理来说是应该先收到（或同时收到）对方的 ACK 报文，再收到对方的 FIN 报文。但是 CLOSING 状态表示发送 FIN 报文后，并没有收到对方的 ACK 报文，反而却也收到了对方的 FIN 报文。<br />什么情况下会出现此种情况呢？其实细想一下，也不难得出结论：那就是如果双方在同时关闭一个链接的话，那么就出现了同时发送 FIN 报文的情况，也即会出现 CLOSING 状态，表示双方都正在关闭连接。<br />FIN_WAIT_2 状态的客户端接收服务端主机发送的 FIN + ACK 消息，并发送 ACK 响应后，会变为 TIME_WAIT 状态。处于 CLOSE_WAIT 的客户端发送 FIN 会处于 LAST_ACK 状态。<br />这里不少图和博客虽然在图上画的是 FIN + ACK 报文后才会处于 LAST_ACK 状态，但是描述的时候，一般通常只对于 FIN 进行描述。也就是说 CLOSE_WAIT 发送 FIN 才会处于 LAST_ACK 状态。<br />![2021-05-17-22-46-45-530384.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1621263216625-58ec5533-40f8-43b9-a44a-d473f22d17d0.png#clientId=u8df32a21-e1fb-4&from=ui&id=ua2d15a88&originHeight=707&originWidth=816&originalType=binary&ratio=1&size=242675&status=done&style=shadow&taskId=ua76a59a0-8e74-4c99-9010-bcf0126c9db)<br />所以这里 FIN_WAIT_1 -> TIME_WAIT 的状态也就是接收 FIN 和 ACK 并发送 ACK 之后，客户端处于的状态。<br />然后位于 CLOSINIG 状态的客户端这时候还有 ACK 接收的话，会继续处于 TIME_WAIT 状态，可以看到，TIME_WAIT 状态相当于是客户端在关闭前的最后一个状态，它是一种主动关闭的状态；而 LAST_ACK 是服务端在关闭前的最后一个状态，它是一种被动打开的状态。<br />上面有几个状态比较特殊，这里解释下。
<a name="NVSCu"></a>
### TIME_WAIT 状态
通信双方建立 TCP 连接后，主动关闭连接的一方就会进入 TIME_WAIT 状态。TIME_WAIT 状态也称为 2MSL 的等待状态。在这个状态下，TCP 将会等待**最大段生存期(Maximum Segment Lifetime, MSL)** 时间的两倍。<br />这里需要解释下 MSL<br />MSL 是 TCP 段期望的最大生存时间，也就是在网络中存在的最长时间。这个时间是有限制的，TCP 是依靠 IP 数据段来进行传输的，IP 数据报中有 TTL 和跳数的字段，这两个字段决定了 IP 的生存时间，一般情况下，TCP 的最大生存时间是 2 分钟，不过这个数值是可以修改的，根据不同操作系统可以修改此值。<br />基于此，来探讨 TIME_WAIT 的状态。<br />当 TCP 执行一个主动关闭并发送最终的 ACK 时，TIME_WAIT 应该以 2 * 最大生存时间存在，这样就能够让 TCP 重新发送最终的 ACK 以避免出现丢失的情况。重新发送最终的 ACK 并不是因为 TCP 重传了 ACK，而是因为通信另一方重传了 FIN，客户端经常回发送 FIN，因为它需要 ACK 的响应才能够关闭连接，如果生存时间超过了 2MSL 的话，客户端就会发送 RST，使服务端出错。
