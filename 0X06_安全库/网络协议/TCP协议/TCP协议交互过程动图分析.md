网络 TCP<br />**假设有一台电脑，他的名字叫 A**<br />![2021-05-17-22-35-56-160790.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1621262250165-f03d0ada-e306-4b60-a7ed-efb0365ec540.png#clientId=ud29875ac-c1d3-4&from=ui&id=uf14af2e1&originHeight=157&originWidth=174&originalType=binary&size=1105&status=done&style=shadow&taskId=u9d5066e5-b845-4d07-8eeb-65a58008bec)<br />只要知道另一台电脑 B 的 IP 地址，且他们之间的网络是通的，无论多远，都可以将一个数据包发送给 B。<br />![2021-05-17-22-35-56-203673.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1621262258904-3dec5e01-06e5-4600-87a6-140e7cf6c8d9.png#clientId=ud29875ac-c1d3-4&from=ui&id=u540719af&originHeight=199&originWidth=512&originalType=binary&size=7193&status=done&style=shadow&taskId=u697620b7-12f0-4555-b7ab-28c7e8614ab)<br />这就是物理层、数据链路层、网络层这三层所做的事情。<br />![2021-05-17-22-35-58-616707.gif](https://cdn.nlark.com/yuque/0/2021/gif/396745/1621262270697-4b3ba57a-3ef7-4157-a765-9c48b27f43a9.gif#clientId=ud29875ac-c1d3-4&from=ui&id=u4968f32f&originHeight=338&originWidth=484&originalType=binary&size=3370502&status=done&style=shadow&taskId=u6e462f82-fc16-4f59-b1b8-558f77f085c)<br />虽然此时TCP还什么都没干，但还是给自己这一层起了个响亮的名字，叫做**传输层**。<br />本以为自己所在的第四层万事大吉，啥事没有，但很快问题就接踵而至。
<a name="UhziX"></a>
## 问题来了
前三层协议只能把数据包从一个主机搬到另外一台主机，但是，到了目的地以后，数据包具体交给哪个**程序**（进程）呢？<br />![2021-05-17-22-35-58-751347.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1621262278382-1779b293-e806-4f37-849f-b360322ec0be.png#clientId=ud29875ac-c1d3-4&from=ui&id=u3928c853&originHeight=626&originWidth=1080&originalType=binary&size=185330&status=done&style=shadow&taskId=u4cd72e6b-fb83-46af-8481-963a45378bb)<br />所以，你需要把通信的进程区分开来，于是就给每个进程分配一个数字编号，你给它起了一个响亮的名字：**端口号**。<br />![2021-05-17-22-35-59-027827.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1621262288113-bc84f92e-5fa8-41e0-9815-36bd8d5103a8.png#clientId=ud29875ac-c1d3-4&from=ui&id=ub0b80847&originHeight=482&originWidth=1080&originalType=binary&size=135343&status=done&style=shadow&taskId=u1dc7ca69-b8f5-4a15-87ba-194f109f4a3)<br />然后在要发送的数据包上，增加了传输层的头部，**源端口号**与**目标端口号**。<br />![2021-05-17-22-35-59-101654.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1621262296672-e398697a-a70b-47ab-87bb-bd185058deb1.png#clientId=ud29875ac-c1d3-4&from=ui&id=u9b419dba&originHeight=224&originWidth=646&originalType=binary&size=19374&status=done&style=shadow&taskId=u8831d973-e65a-4e46-8fac-d95db1aa2ed)<br />这样TCP将原本主机到主机的通信，升级为了**进程和进程之间的通信**。<br />不知不觉实现了**UDP 协议**！<br />（当然 UDP 协议中不光有源端口和目标端口，还有数据包长度和校验值，暂且略过）<br />就这样，用 UDP 协议无忧无虑地同 B 进行着通信，一直没发生什么问题。<br />![2021-05-17-22-35-59-194382.gif](https://cdn.nlark.com/yuque/0/2021/gif/396745/1621262306896-17012bde-fdeb-4c0f-8b08-7fd51e4bd389.gif#clientId=ud29875ac-c1d3-4&from=ui&id=u09c5fa16&originHeight=170&originWidth=530&originalType=binary&size=155438&status=done&style=shadow&taskId=u6eeb3a1f-54b7-48b5-a919-cddc6e0281a)<br />但很快，发现事情变得非常复杂......
<a name="byD6n"></a>
## 丢包问题
由于网络的不可靠，数据包可能在半路丢失，而 A 和 B 却无法察觉。<br />![2021-05-17-22-35-59-313660.gif](https://cdn.nlark.com/yuque/0/2021/gif/396745/1621262316338-d12fa518-40ec-4dfd-9e30-43433922a17e.gif#clientId=ud29875ac-c1d3-4&from=ui&id=u922b70e7&originHeight=170&originWidth=530&originalType=binary&size=225500&status=done&style=shadow&taskId=uf6c8c1fd-3a1f-4b87-81b9-9069f06ae27)<br />对于丢包问题，只要解决两个事就好了。<br />**第一个，A 怎么知道包丢了？**<br />答案：让 B 告诉 A<br />**第二个，丢了的包怎么办？**<br />答案：重传<br />于是设计了如下方案，A 每发一个包，都必须收到来自 B 的**确认**（ACK），再发下一个，否则在一定时间内没有收到确认，就**重传**这个包。<br />![](https://cdn.nlark.com/yuque/0/2021/gif/396745/1618629145463-30dcc3fb-9640-4540-b2ef-15ee5da4a472.gif#clientId=uf038b086-8f2f-4&from=paste&height=0&id=u43767135&originHeight=1&originWidth=1&originalType=url&size=70&status=done&style=none&taskId=u4ed7c103-a347-4722-bf58-f6c2fb82394&width=0.3333333333333333)![2021-05-17-22-35-59-426360.gif](https://cdn.nlark.com/yuque/0/2021/gif/396745/1621262328633-39a6020d-a9b1-4685-8721-2653c186ebcf.gif#clientId=ud29875ac-c1d3-4&from=ui&id=ue5c08e0c&originHeight=170&originWidth=530&originalType=binary&size=139018&status=done&style=shadow&taskId=u296d603d-6206-408f-b0e8-860ba960450)<br />它叫**停止等待协议**。只要按照这个协议来，虽然 A 无法保证 B 一定能收到包，但 A 能够确认 B 是否收到了包，收不到就重试，尽最大努力让这个通信过程变得可靠，于是现在的通信过程又有了一个新的特征，**可靠交付**。
<a name="qFIb5"></a>
## 效率问题
停止等待虽然能解决问题，但是效率太低了，A 原本可以在发完第一个数据包之后立刻开始发第二个数据包，但由于停止等待协议，A 必须等数据包到达了 B ，且 B 的 ACK 包又回到了 A，才可以继续发第二个数据包，这效率慢得可不是一点两点。<br />于是对这个过程进行了改进，采用**流水线**的方式，不再傻傻地等。<br />![2021-05-17-22-35-59-755957.gif](https://cdn.nlark.com/yuque/0/2021/gif/396745/1621262367928-aa918f65-ef07-4898-b09b-78890a0fe05b.gif#clientId=ud29875ac-c1d3-4&from=ui&id=u2c324c39&originHeight=170&originWidth=530&originalType=binary&size=254715&status=done&style=shadow&taskId=uba97b68e-e3a4-4328-b0fd-ae0fe4f7492)
<a name="djwKm"></a>
## 顺序问题
但是网路是复杂的、不可靠的。<br />有的时候 A 发出去的数据包，分别走了不同的路由到达 B，可能无法保证和发送数据包时一样的顺序。<br />![2021-05-17-22-35-59-872012.gif](https://cdn.nlark.com/yuque/0/2021/gif/396745/1621262336779-c648dde5-bc37-4934-ad91-7a9e620576af.gif#clientId=ud29875ac-c1d3-4&from=ui&id=xL3uE&originHeight=180&originWidth=530&originalType=binary&size=229649&status=done&style=shadow&taskId=u17cc1a8f-1008-49f7-a28b-1d58f8016c0)<br />在流水线中有多个数据包和ACK包在**乱序流动**，他们之间对应关系就乱掉了。<br />难道还回到停止等待协议？A 每收到一个包的确认（ACK）再发下一个包，那就根本不存在顺序问题。应该有更好的办法！<br />A 在发送的数据包中增加一个**序号**（seq），同时 B 要在 ACK 包上增加一个**确认号**（ack），这样不但解决了停止等待协议的效率问题，也通过这样标序号的方式解决了顺序问题。<br />![](https://cdn.nlark.com/yuque/0/2021/gif/396745/1618629145849-602cbb4e-dd20-4d6d-b776-051df0738422.gif#clientId=uf038b086-8f2f-4&from=paste&height=0&id=ufd279542&originHeight=1&originWidth=1&originalType=url&size=70&status=done&style=none&taskId=u69fe716d-e9f3-440c-a001-776a2d718e1&width=0.3333333333333333)![2021-05-17-22-35-59-992375.gif](https://cdn.nlark.com/yuque/0/2021/gif/396745/1621262382839-ebdd0116-43ba-456a-8d0c-e5c6a18fb133.gif#clientId=ud29875ac-c1d3-4&from=ui&id=ued6f05e9&originHeight=170&originWidth=530&originalType=binary&size=243979&status=done&style=shadow&taskId=u6b3189c8-812c-4cb3-bce6-84f4e4ee0d1)<br />而 B 这个确认号意味深长：比如 B 发了一个确认号为 ack = 3，它不仅仅表示 A 发送的序号为 2 的包收到了，还表示 2 之前的数据包都收到了。这种方式叫**累计确认**或**累计应答**。<br />![](https://cdn.nlark.com/yuque/0/2021/gif/396745/1618629145867-2abae688-4545-4dce-b32c-94a2aec6fff4.gif#clientId=uf038b086-8f2f-4&from=paste&height=0&id=u85cd7b59&originHeight=1&originWidth=1&originalType=url&size=70&status=done&style=none&taskId=uce85ffe4-c937-4943-b397-aaaa402ff5a&width=0.3333333333333333)![2021-05-17-22-36-06-493014.gif](https://cdn.nlark.com/yuque/0/2021/gif/396745/1621262398378-c71b0784-b40c-425f-a27f-1bdd5e81967d.gif#clientId=ud29875ac-c1d3-4&from=ui&id=uceebaceb&originHeight=170&originWidth=530&originalType=binary&size=407628&status=done&style=shadow&taskId=u2b60cae1-f59a-4762-93a9-3d40320f438)
:::tips
注意，实际上 ack 的号是收到的最后一个数据包的序号 seq + 1，也就是告诉对方下一个应该发的序号是多少。但图中为了便于理解，ack 就表示收到的那个序号，不必纠结。
:::
<a name="Ry0lr"></a>
## 流量问题
有的时候，A 发送数据包的速度太快，而 B 的接收能力不够，但 B 却没有告知 A 这个情况。<br />![2021-05-17-22-36-06-751831.gif](https://cdn.nlark.com/yuque/0/2021/gif/396745/1621262451270-57b36423-d937-4134-bad1-82dfc8716bf4.gif#clientId=ud29875ac-c1d3-4&from=ui&id=u5742f2cb&originHeight=170&originWidth=530&originalType=binary&size=628969&status=done&style=shadow&taskId=ucb87b21c-66f4-405c-a910-e5d5f1525cf)<br />怎么解决呢？<br />很简单，B 告诉 A 自己的接收能力，A 根据 B 的接收能力，相应控制自己的**发送速率**，就好了。<br />B 怎么告诉 A 呢？得有一个严谨的规范。<br />于是 B 决定，每次发送数据包给 A 时，顺带传过来一个值，叫**窗口大小**（win)，这个值就表示 B 的**接收能力**。同理，每次 A 给 B 发包时也带上自己的窗口大小，表示 A 的接收能力。<br />![2021-05-17-22-36-06-921659.gif](https://cdn.nlark.com/yuque/0/2021/gif/396745/1621262451163-91a0df8f-466b-4814-addd-c66f141f337e.gif#clientId=ud29875ac-c1d3-4&from=ui&id=u318993f0&originHeight=170&originWidth=530&originalType=binary&size=299567&status=done&style=shadow&taskId=ua6407ed1-178d-4634-97c2-84e72d0c9a4)<br />B 告诉了 A 自己的窗口大小值，A 怎么利用它去做 A 这边发包的流量控制呢？<br />很简单，假如 B 给 A 传过来的窗口大小 win = 5，那 A 根据这个值，把自己要发送的数据分成这么几类。<br />![2021-05-17-22-36-07-043333.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1621262451076-29383bfb-fc59-4a17-b206-cbe94043f835.png#clientId=ud29875ac-c1d3-4&from=ui&id=uc7bdd2a9&originHeight=383&originWidth=900&originalType=binary&size=125298&status=done&style=shadow&taskId=u652dd5e2-d3aa-49d8-b38b-69b81742a1b)<br />当 A 不断发送数据包时，**已发送的最后一个序号**就往右移动，直到碰到了窗口的上边界，此时 A 就无法继续发包，达到了流量控制。<br />![](https://cdn.nlark.com/yuque/0/2021/gif/396745/1618629146450-14e1e06f-4783-479c-8485-c85c71364d17.gif#clientId=uf038b086-8f2f-4&from=paste&height=0&id=u7f56cedd&originHeight=1&originWidth=1&originalType=url&size=70&status=done&style=none&taskId=ud578b0f0-28a8-4cd9-8488-47012b03fa0&width=0.3333333333333333)![2021-05-17-22-36-07-767395.gif](https://cdn.nlark.com/yuque/0/2021/gif/396745/1621262453087-81c8ac30-de5b-4fe1-b2e5-df2843f5e17e.gif#clientId=ud29875ac-c1d3-4&from=ui&id=u62a6048e&originHeight=383&originWidth=900&originalType=binary&size=1922249&status=done&style=shadow&taskId=u1ed7f6a3-478d-4bb5-8750-63266d748ff)<br />但是当 A 不断发包的同时，A 也会收到来自 B 的确认包，此时**整个窗口**会往右移动，因此上边界也往右移动，A 就能发更多的数据包了。<br />![2021-05-17-22-36-08-609672.gif](https://cdn.nlark.com/yuque/0/2021/gif/396745/1621262466148-d82af6ad-13d6-4162-bf37-764e363a9dc2.gif#clientId=ud29875ac-c1d3-4&from=ui&id=ua59abb61&originHeight=383&originWidth=900&originalType=binary&size=1979292&status=done&style=shadow&taskId=u93702f35-cf2b-465d-8e0e-0ad4f6b38ba)<br />以上都是在窗口大小不变的情况下，而 B 在发给 A 的 ACK 包中，每一个都可以**重新设置**一个新的窗口大小，如果 A 收到了一个新的窗口大小值，A 会随之调整。<br />如果 A 收到了比原窗口值更大的窗口大小，比如 win = 6，则 A 会直接将窗口上边界向右移动 1 个单位。<br />![2021-05-17-22-36-21-509232.gif](https://cdn.nlark.com/yuque/0/2021/gif/396745/1621262504454-a2d92ba1-0f6e-4c87-995c-26cb6b7aef48.gif#clientId=ud29875ac-c1d3-4&from=ui&id=ud2234cef&originHeight=383&originWidth=900&originalType=binary&size=1139406&status=done&style=shadow&taskId=u1465f2bc-5fd3-4423-a927-2bf3c0cc1e7)<br />如果 A 收到了比原窗口值小的窗口大小，比如 win = 4，则 A 暂时不会改变窗口大小，更不会将窗口上边界向左移动，而是等着 ACK 的到来，不断将左边界向右移动，直到窗口大小值收缩到新大小为止。<br />![2021-05-17-22-36-35-387715.gif](https://cdn.nlark.com/yuque/0/2021/gif/396745/1621262510049-eb21f9f0-94ea-4638-b437-456338fdd31e.gif#clientId=ud29875ac-c1d3-4&from=ui&id=u20b2166d&originHeight=383&originWidth=900&originalType=binary&size=989183&status=done&style=shadow&taskId=u73388f55-b453-4274-b08a-6be9c05237d)<br />OK，终于将流量控制问题解决得差不多了，看着上面一个个小动图，给这个窗口起了一个更生动的名字，**滑动窗口**。
<a name="IixsA"></a>
## 拥塞问题
但有的时候，不是 B 的接受能力不够，而是网络不太好，造成了**网络拥塞**。<br />![](https://cdn.nlark.com/yuque/0/2021/gif/396745/1618629147137-547ff295-06d7-4083-a3cd-21fa070a68cf.gif#clientId=uf038b086-8f2f-4&from=paste&height=0&id=ueb315ae1&originHeight=1&originWidth=1&originalType=url&size=70&status=done&style=none&taskId=u8db98fda-4f02-4b52-98e0-036df98797a&width=0.3333333333333333)![2021-05-17-22-36-47-504395.gif](https://cdn.nlark.com/yuque/0/2021/gif/396745/1621262521207-178c7769-87c8-4167-a396-9e7bccab82bf.gif#clientId=ud29875ac-c1d3-4&from=ui&id=ua01eddc0&originHeight=170&originWidth=530&originalType=binary&size=460580&status=done&style=shadow&taskId=u1f432bcf-719d-4b78-bb2a-cb956d2ab41)<br />拥塞控制与流量控制有些像，但流量控制是受 B 的接收能力影响，而拥塞控制是受**网络环境**的影响。<br />拥塞控制的解决办法依然是通过设置一定的窗口大小，只不过，流量控制的窗口大小是 B 直接告诉 A 的，而拥塞控制的窗口大小按理说就应该是网络环境主动告诉 A。<br />但网络环境怎么可能主动告诉 A 呢？只能 A 单方面通过**试探**，不断感知网络环境的好坏，进而确定自己的拥塞窗口的大小。<br />![2021-05-17-22-37-11-817633.gif](https://cdn.nlark.com/yuque/0/2021/gif/396745/1621262538808-a95fa90e-48e6-47ce-a048-db7a98233caf.gif#clientId=ud29875ac-c1d3-4&from=ui&id=u2739060d&originHeight=170&originWidth=530&originalType=binary&size=904987&status=done&style=shadow&taskId=u10673121-9125-464b-a362-317c189d721)<br />拥塞窗口大小的计算有很多复杂的算法，就不在本文中展开了，假如**拥塞窗口的大小为  cwnd**，上一部分流量控制的**滑动窗口的大小为 rwnd**，那么窗口的右边界受这两个值共同的影响，需要取它俩的最小值。<br />**窗口大小 = **`**min(cwnd, rwnd)**`<br />含义很容易理解，当 B 的接受能力比较差时，即使网络非常通畅，A 也需要根据 B 的接收能力限制自己的发送窗口。当网络环境比较差时，即使 B 有很强的接收能力，A 也要根据网络的拥塞情况来限制自己的发送窗口。正所谓受其**短板**的影响嘛~
<a name="fXSyM"></a>
## 连接问题
有的时候，B 主机的相应进程还没有准备好或是挂掉了，A 就开始发送数据包，导致了浪费。<br />![2021-05-17-22-37-19-061567.gif](https://cdn.nlark.com/yuque/0/2021/gif/396745/1621262550332-5ea44461-6f7a-4ab2-b3bc-fb4fda913014.gif#clientId=ud29875ac-c1d3-4&from=ui&id=u3a5bfa85&originHeight=170&originWidth=530&originalType=binary&size=778009&status=done&style=shadow&taskId=u6dc7f332-3453-4c6d-8dca-c3cf3060abd)<br />这个问题在于，A 在跟 B 通信之前，没有事先确认 B 是否已经准备好，就开始发了一连串的信息。就好比和另一个人打电话，还没有"喂"一下确认对方有没有在听，就说了一堆。<br />这个问题该怎么解决呢？<br />地球人都知道，**三次握手**嘛！<br />A：我准备好了(SYN)<br />B：我知道了(ACK)，我也准备好了(SYN)<br />A：我知道了(ACK)<br />![2021-05-17-22-37-19-455063.gif](https://cdn.nlark.com/yuque/0/2021/gif/396745/1621262652962-6a49f994-8fd3-4b10-80f5-8caee3fc8ef7.gif#clientId=ud29875ac-c1d3-4&from=ui&id=uaf5ecaf5&originHeight=170&originWidth=530&originalType=binary&size=795275&status=done&style=shadow&taskId=u99a7c814-2d2d-4d2e-ab6e-2ffbfde62b6)<br />A 与 B 各自在内存中维护着自己的状态变量，三次握手之后，双方的状态都变成了**连接已建立**（ESTABLISHED）。<br />虽然就只是发了三次数据包，并且在各自的内存中维护了状态变量，这个过程相当于双方建立连接的过程，就叫它**面向连接**吧。
:::tips
注意：这个连接是虚拟的，是由 A 和 B 这两个终端共同维护的，在网络中的设备根本就不知道连接这回事儿！
:::
但凡事有始就有终，有了建立连接的过程，就要考虑释放连接的过程，又是地球人都知道，**四次挥手**嘛！<br />A：再见，我要关闭了(FIN)<br />B：我知道了(ACK)<br />     给 B 一段时间把自己的事情处理完...<br />B：再见，我要关闭了(FIN)<br />A：我知道了(ACK)<br />![2021-05-17-22-37-20-362300.gif](https://cdn.nlark.com/yuque/0/2021/gif/396745/1621262606596-31c9e4b5-77d0-4974-8fbb-50dee7bd7381.gif#clientId=ud29875ac-c1d3-4&from=ui&id=u9f78f9de&originHeight=170&originWidth=530&originalType=binary&size=892925&status=done&style=shadow&taskId=ua5f89308-f4d9-4429-842e-b684da8b26f)
<a name="pFH50"></a>
## 总结
以上讲述的，就是 TCP 协议的核心思想，上面过程中需要传输的信息，就体现在 TCP 协议的头部，这里放上最常见的 TCP 协议头解读的图。<br />![2021-05-17-22-37-20-672899.png](https://cdn.nlark.com/yuque/0/2021/png/396745/1621262660423-12b981d5-4135-4c87-8b86-7f340d62d348.png#clientId=ud29875ac-c1d3-4&from=ui&id=u803182e5&originHeight=439&originWidth=668&originalType=binary&size=26117&status=done&style=shadow&taskId=u18372151-8148-4adf-9fb9-4ea13052e56)<br />不知道现在再看下面这句话，是否能理解：<br />**TCP 是面向连接的、可靠的、基于字节流的传输层通信协议**<br />面向连接、可靠，这两个词通过上面的讲述很容易理解，那什么叫做基于字节流呢？<br />很简单，TCP 在建立连接时，需要告诉对方 MSS（最大报文段大小）。<br />也就是说，如果要发送的数据很大，在 TCP 层是需要按照 MSS 来切割成一个个的**TCP 报文段 **的。<br />切割的时候不管原来的数据表示什么意思，需要在哪里断句啥的，就把它当成一串毫无意义的字节，在想要切割的地方咔嚓就来一刀，标上序号，只要接收方再根据这个序号拼成最终想要的完整数据就行了。<br />在 TCP 传输这里，就把它当做一个个的**字节**，也就是基于字节流的含义了。<br />![2021-05-17-22-37-20-781956.jpeg](https://cdn.nlark.com/yuque/0/2021/jpeg/396745/1621262668954-995934a5-2869-4a3f-b918-efba83386372.jpeg#clientId=ud29875ac-c1d3-4&from=ui&id=u0efd65e7&originHeight=526&originWidth=905&originalType=binary&size=41443&status=done&style=shadow&taskId=u7b12a12e-633a-44f3-8a2e-a02a280c259)
