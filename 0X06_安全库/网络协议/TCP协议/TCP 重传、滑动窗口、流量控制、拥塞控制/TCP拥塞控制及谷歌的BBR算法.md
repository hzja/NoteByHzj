TCP<br />BBR(bottleneck bandwidth and RTT)算法是google提出的一个用于网络拥塞控制的算法，在linux的内核以及QUIC中均有BBR算法的实现。<br />TCP BBR（Bottleneck Bandwidth and Round-trip propagation time）是由Google 设计，于2016年发布的拥塞算法。<br />以往的大部分拥塞控制算法都是基于丢包来作为降低传输速率的信号，而BBR 则基于模型主动探测。目前已经在Google 内部大范围使用并随着linux 4.9 版本正式发布。<br />TCP 拥塞控制的目标是最大化利用网络上瓶颈链路的带宽。<br />简单来说是将网络链路比喻成一根水管，如果希望尽可能地使用网络传输数据，方法就是给水管注水，就有如下公式：<br />水管内的水的数量 = 水管的容积 = 水管粗细 × 水管长度。<br />对应的网络名词就是：<br />网络内尚未被确认收到的数据包数量 = 网络链路上能容纳的数据包数量 = 链路带宽 × 往返延迟。<br />BBR对TCP性能的提升是巨大的，它能更有效的使用当下网络环境，Youtube应用后在吞吐量上有平均4%提升（对于日本这样的网络环境有14%以上的提升）：<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1663060347126-71e1d852-ad26-4afa-9c3f-6668a247bd81.png#clientId=u52a14c34-3490-4&from=paste&id=u39b571cd&originHeight=418&originWidth=700&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=u949c4ef4-09bd-43e9-afcc-3a6e23440c3&title=)<br />报文的往返时延RTT降低了33%，这样如视频这样的大文件传输更快，用户体验更好：<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1663060347177-50f61c25-7156-46da-b5e4-e0a14f6ab843.png#clientId=u52a14c34-3490-4&from=paste&id=udf77e859&originHeight=435&originWidth=700&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=u0cf8867f-427b-45e2-bbd3-95a671faf43&title=)<br />不像CUBIC这种基于丢包做拥塞控制，常导致瓶颈路由器大量报文丢失，所以重新缓存的平均间隔时间也有了11%提升：<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1663060347094-86a3ce80-d07e-47de-811d-db281e68efd0.png#clientId=u52a14c34-3490-4&from=paste&id=uf43925e8&originHeight=435&originWidth=700&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=uf3b25dde-ca52-4741-95ba-083ef9f0951&title=)<br />在Linux4.19内核中已经将拥塞控制算法从CUBIC（该算法从2.6.19内核就引入Linux了）改为BBR，而即将面世的基于UDP的HTTP3也使用此算法。<br />TCP协议是面向字符流的协议，它允许应用层基于read/write方法来发送、读取任意长的字符流：<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1663060347030-5199a3ef-4c05-41a3-8ddc-5a83191a1f7a.png#clientId=u52a14c34-3490-4&from=paste&id=u54354176&originHeight=478&originWidth=722&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=u49c25b69-6869-465e-8bb7-3f6d1dc637f&title=)<br />但TCP之下的IP层是基于块状的Packet报文来分片发送的，因此，TCP协议需要将应用交付给它的字符流拆分成多个Packet（在TCP传输层被称为Segment）发送，由于网速有变化且接收主机的处理性能有限，TCP还要决定何时发送这些Segment。TCP滑动窗口解决了Client、Server这两台主机的问题，但没有去管连接中大量路由器、交换机转发IP报文的问题，因此当瓶颈路由器的输入流大于其输出流时，便会发生拥塞：<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1663060347147-efbd4a84-c7ce-46aa-bdbc-4345f5dd594a.png#clientId=u52a14c34-3490-4&from=paste&id=u80af2a15&originHeight=364&originWidth=1004&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=u8479f320-d678-48d1-af8e-34f57e8c0c6&title=)<br />这虽然是IP网络层的事，但如果TCP基于分层原则不去管，互联网上大量主机的TCP程序便会造成网络恶性拥堵。上图中瓶颈路由器已经造成了网速下降，但如果发送方不管不顾，那么瓶颈路由器的缓冲队列填满后便会发生大量丢包，且此时RTT（报文往返时间）由于存在长队列而极高。<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1663060347503-53769fdc-cecd-4657-ac72-a4292cc9a444.png#clientId=u52a14c34-3490-4&from=paste&id=u8fbef294&originHeight=562&originWidth=968&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=u3c76ebfd-b83b-4440-b7a7-c825d9f16e3&title=)<br />如上图，最好的状态是没有队列，此时RTT最低，而State2中RTT升高，但没有丢包，到State 3队列满时开始发生丢包。<br />TCP的拥塞控制便用于解决这个问题。在BBR出现前，拥塞控制分为四个部分：慢启动、拥塞避免、快速重传、快速恢复：<br />![](https://cdn.nlark.com/yuque/0/2022/jpeg/396745/1663060347629-872d973f-d2bb-4063-8f9c-5778d4d66fea.jpeg#clientId=u52a14c34-3490-4&from=paste&id=ufaff0186&originHeight=550&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=uf0510504-27e7-446a-bd32-ab42ab7e105&title=)<br />慢启动在BBR中仍然保留，它的意义是在不知道连接的瓶颈带宽时，以起始较低的发送速率，以每RTT两倍的速度快速增加发送速率，直到到达一个阈值，对应上图中0-4秒。到该阈值后，进入线性提高发送速率的阶段，该阶段叫做拥塞避免，直到发生丢包，对应上图中8-11秒。丢包后，发速速率大幅下降，针对丢包使用快速重传算法重送发送，同时也使用快速恢复算法把发送速率尽量平滑的升上来。<br />如果瓶颈路由器的缓存特别大，那么这种以丢包作为探测依据的拥塞算法将会导致严重问题：TCP链路上长时间RTT变大，但吞吐量维持不变。<br />事实上，传输速度在3个阶段被不同的因素限制：1、应用程序限制阶段，此时RTT不变，随着应用程序开始发送大文件，速率直线上升；2、BDP限制阶段，此时RTT开始不断上升，但吞吐量不变，因为此时瓶颈路由器已经达到上限，缓冲队列正在不断增加；3、瓶颈路由器缓冲队列限制阶段，此时开始大量丢包。如下所示：<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1663060347669-cd74328a-9a6f-4da4-8a28-501efcc5019b.png#clientId=u52a14c34-3490-4&from=paste&id=u4021d9a8&originHeight=720&originWidth=521&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=u39e1cb77-909d-489a-a1ee-40222d18c10&title=)<br />如CUBIC这样基于丢包的拥塞控制算法在第2条灰色竖线发生作用，这已经太晚了，更好的作用点是BDP上限开始发挥作用时，也就是第1条灰色竖线。<br />什么叫做BDP呢？它叫做带宽时延积，例如一条链路的带宽是100Mbps，而RTT是40ms，那么
```
BDP=100Mbps*0.04s=4Mb=0.5MB
```
即平均每秒飞行中的报文应当是0.5MB。因此Linux的接收窗口缓存常参考此设置：<br />![](https://cdn.nlark.com/yuque/0/2022/jpeg/396745/1663060347701-093ae8cc-d8c9-4574-82f0-8ef0e182b809.jpeg#clientId=u52a14c34-3490-4&from=paste&id=u1a48ce82&originHeight=573&originWidth=975&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=u6041aaec-8bee-44b5-9e6b-0ec526b356d&title=)<br />第1条灰色竖线，是瓶颈路由器的缓冲队列刚刚开始积压时的节点。随着内存的不断降价，路由器设备的缓冲队列也会越来越大，CUBIC算法会造成更大的RTT时延！<br />而BBR通过检测RTprop和BtlBw来实现拥塞控制。什么是RTprop呢？这是链路的物理时延，因为RTT里含有报文在路由器队列里的排队时间、ACK的延迟确认时间等。什么叫延迟确认呢？TCP每个报文必须被确认，确认动作是通过接收端发送ACK报文实现的，但由于TCP和IP头部有40个字节，如果不携带数据只为发送ACK网络效率过低，所以会让独立的ACK报文等一等，看看有没有数据发的时候顺便带给对方，或者等等看多个ACK一起发。所以，可以用下列公式表示RTT与RTprop的差别：<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1663060347734-0e41a2ac-9a85-4604-b4f9-936db6b85d58.png#clientId=u52a14c34-3490-4&from=paste&id=ua2cf8827&originHeight=25&originWidth=260&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=u71551507-cacd-4558-8d01-256b7fc3b9f&title=)<br />RTT可以测量得出，RTprop呢，只需要找到瓶颈路由器队列为空时多次RTT测量的最小值即可：<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1663060348076-d1c39b3b-026d-4f84-af08-84b82fc48038.png#clientId=u52a14c34-3490-4&from=paste&id=ued7d8c02&originHeight=30&originWidth=623&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=u3ce6c636-6386-464f-811e-219d389eb65&title=)<br />而BtlBw全称是bottleneck bandwith，即瓶颈带宽，可以通过测量已发送但未ACK确认的飞行中字节除以飞行时间deliveryRate来测量：<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1663060348061-b42fe83f-52db-40d5-988a-be15f3b09064.png#clientId=u52a14c34-3490-4&from=paste&id=uab7af9a5&originHeight=39&originWidth=624&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=udce0b3e9-95a2-4ed0-a2b9-0b1198c975e&title=)<br />早在1979年Leonard Kleinrock就提出了第1条竖线是最好的拥塞控制点，但被Jeffrey M. Jaffe证明不可能实现，因为没有办法判断RTT变化到底是不是因为链路变化了，从而不同的设备瓶颈导致的，还是瓶颈路由器上的其他TCP连接的流量发生了大的变化。但有了RTprop和BtlBw后，当RTprop升高时便得到了BtlBw，这便找到第1条灰色竖线最好的拥塞控制点，也有了后续发送速率的依据。<br />基于BBR算法，由于瓶颈路由器的队列为空，最直接的影响就是RTT大幅下降，可以看到下图中CUBIC红色线条的RTT比BBR要高很多：<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1663060348322-68553f81-5be1-4ccf-ae55-6a248029f905.png#clientId=u52a14c34-3490-4&from=paste&id=u3bb943c9&originHeight=397&originWidth=720&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=ub25c6b4b-4b93-416a-9674-cfbd49b2934&title=)<br />而因为没有丢包，BBR传输速率也会有大幅提升，下图中插入的图为CDF累积概率分布函数，从CDF中可以很清晰的看到CUBIC下大部分连接的吞吐量都更低：<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1663060348520-53e7a3ad-f805-4a25-aa0a-f7d58d4b8961.png#clientId=u52a14c34-3490-4&from=paste&id=u7ccf8885&originHeight=720&originWidth=719&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=u5dbf8296-479d-4c39-96c4-ee41bbb55f4&title=)<br />如果链路发生了切换，新的瓶颈带宽升大或者变小怎么办呢？BBR会尝试周期性的探测新的瓶颈带宽，这个周期值为1.25、0.75、1、1、1、1，如下所示：<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1663060348289-ec287576-12dd-401d-a077-fcdfc70abe30.png#clientId=u52a14c34-3490-4&from=paste&id=u9fac2a12&originHeight=659&originWidth=720&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=ud08d3d0f-8e0b-40c0-8c46-89e4ec84fcc&title=)<br />1.25会使得BBR尝试发送更多的飞行中报文，而如果产生了队列积压，0.75则会释放队列。下图中是先以10Mbps的链路传输TCP，在第20秒网络切换到了更快的40Mbps链路，由于1.25的存在BBR很快发现了更大的带宽，而第40秒又切换回了10Mbps链路，2秒内由于RTT的快速增加BBR调低了发送速率，可以看到由于有了pacing_gain周期变换BBR工作得很好。<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1663060348668-e5066011-f1db-40f6-91cc-5bbc17f8eb5a.png#clientId=u52a14c34-3490-4&from=paste&id=u10dba836&originHeight=720&originWidth=416&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=u0a412ac0-d17d-493d-b92d-89eb2d75b51&title=)<br />pacing_gain周期还有个优点，就是可以使多条初始速度不同的TCP链路快速的平均分享带宽，如下图所示，后启动的连接由于过高估计BDP产生队列积压，早先连接的BBR便会在数个周期内快速降低发送速率，最终由于不产生队列积压下RTT是一致的，故平衡时5条链路均分了带宽：<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1663060348925-6f3a8a8d-aa85-42b4-9caa-e45d8b39b24a.png#clientId=u52a14c34-3490-4&from=paste&id=u4958757f&originHeight=398&originWidth=720&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=ub754b176-564d-4c3b-b45d-4933a8099d1&title=)<br />再来看看慢启动阶段，下图网络是10Mbps、40ms，因此未确认的飞行字节数应为10Mbps*0.04s=0.05MB。红色线条是CUBIC算法下已发送字节数，而蓝色是ACK已确认字节数，绿色则是BBR算法下的已发送字节数。显然，最初CUBIC与BBR算法相同，在0.25秒时飞行字节数显然远超过了0.05MB字节数，大约在 0.1MB字节数也就是2倍BDP：<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1663060348788-a6dd1ffc-2ac0-4920-9749-01f48d75e556.png#clientId=u52a14c34-3490-4&from=paste&id=u37f32e5d&originHeight=623&originWidth=720&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=u2aa4307f-7d1d-4c49-93d0-1469de99008&title=)<br />大约在0.3秒时，CUBIC开始线性增加拥塞窗口，而到了0.5秒后BBR开始降低发送速率，即排空瓶颈路由器的拥塞队列，到0.75秒时飞行字节数调整到了BDP大小，这是最合适的发送速率。<br />当繁忙的网络出现大幅丢包时，BBR的表现也远好于CUBIC算法。下图中，丢包率从0.001%到50%时，可以看到绿色的BBR远好于红色的CUBIC。大约当丢包率到0.1%时，CUBIC由于不停的触发拥塞算法，所以吞吐量极速降到10Mbps只有原先的1/10，而BBR直到5%丢包率才出现明显的吞吐量下降。<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1663060348962-053191e2-78a7-47ec-8051-795fb9ed7e74.png#clientId=u52a14c34-3490-4&from=paste&id=u21c34136&originHeight=399&originWidth=720&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=u0299c565-6ff2-4ff8-b0f8-caa2247cf3d&title=)<br />CUBIC造成瓶颈路由器的缓冲队列越来越满，RTT时延就会越来越大，而操作系统对三次握手的建立是有最大时间限制的，这导致建CUBIC下的网络极端拥塞时，新连接很难建立成功，如下图中RTT中位数达到 100秒时 Windows便很难建立成功新连接，而200秒时Linux/Android也无法建立成功。<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1663060349253-b4a9d3c9-0935-4b09-b200-02d62c239323.png#clientId=u52a14c34-3490-4&from=paste&id=u4dd08f24&originHeight=402&originWidth=720&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=ufb2f42cc-028c-4b0e-827a-5bb9435ee60&title=)<br />BBR算法的伪代码如下，这里包括两个流程，收到ACK确认以及发送报文：
```javascript
function onAck(packet) 
  rtt = now - packet.sendtime 
  update_min_filter(RTpropFilter, rtt) 
  delivered += packet.size 
  delivered_time = now 
  deliveryRate = (delivered - packet.delivered) / (delivered_time - packet.delivered_time) 
  if (deliveryRate > BtlBwFilter.currentMax || ! packet.app_limited) 
     update_max_filter(BtlBwFilter, deliveryRate) 
  if (app_limited_until > 0) 
     app_limited_until = app_limited_until - packet.size
```
这里的app_limited_until是在允许发送时观察是否有发送任务决定的。发送报文时伪码为：
```javascript
function send(packet) 
  bdp = BtlBwFilter.currentMax × RTpropFilter.currentMin 
  if (inflight >= cwnd_gain × bdp) 
     // wait for ack or retransmission timeout 
     return 
  if (now >= nextSendTime) 
     packet = nextPacketToSend() 
     if (! packet) 
        app_limited_until = inflight 
        return 
     packet.app_limited = (app_limited_until > 0) 
     packet.sendtime = now 
     packet.delivered = delivered 
     packet.delivered_time = delivered_time 
     ship(packet) 
     nextSendTime = now + packet.size / (pacing_gain × BtlBwFilter.currentMax) 
  timerCallbackAt(send, nextSendTime)
```
pacing_gain便是决定链路速率调整的关键周期数组。<br />BBR算法对网络世界的拥塞控制有重大意义，尤其未来可以想见路由器的队列一定会越来越大。HTTP3放弃了TCP协议，这意味着它需要在应用层（各框架中间件）中基于BBR算法实现拥塞控制，所以，BBR算法其实离我们很近。理解BBR，便能更好的应对网络拥塞导致的性能问题，也会对未来的拥塞控制算法发展脉络更清晰。
