网络协议 TCP
<a name="jqxUA"></a>
### 为什么 TCP 三次握手期间，为什么客户端和服务端的初始化序列号要求不一样的呢？
主要原因是为了防止历史报文被下一个相同四元组的连接接收。
<a name="SZrEh"></a>
### TCP 四次挥手中的 TIME_WAIT 状态不是会持续 2 MSL 时长，历史报文不是早就在网络中消失了吗？
是的，如果能正常四次挥手，由于 TIME_WAIT 状态会持续  2 MSL 时长，历史报文会在下一个连接之前就会自然消失。<br />但是来了，并不能保证每次连接都能通过四次挥手来正常关闭连接。<br />假设每次建立连接，客户端和服务端的初始化序列号都是从 0 开始：<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1649864232548-45f63f74-a19d-4e17-a399-22d5bdb70714.png#clientId=u030f4860-ae82-4&from=paste&id=u3dcf5735&originHeight=1112&originWidth=1031&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=u5368ae38-f3b7-4087-b45a-1cbba72ab79&title=)<br />过程如下：

- 客户端和服务端建立一个 TCP 连接，在客户端发送数据包被网络阻塞了，而此时服务端的进程重启了，于是就会发送 RST 报文来断开连接。
- 紧接着，客户端又与服务端建立了与上一个连接相同四元组的连接；
- 在新连接建立完成后，上一个连接中被网络阻塞的数据包正好抵达了服务端，刚好该数据包的序列号正好是在服务端的接收窗口内，所以该数据包会被服务端正常接收，就会造成数据错乱。

可以看到，如果每次建立连接，客户端和服务端的初始化序列号都是一样的话，很容易出现历史报文被下一个相同四元组的连接接收的问题。
<a name="Lwyx7"></a>
### 客户端和服务端的初始化序列号不一样不是也会发生这样的事情吗？
是的，即使客户端和服务端的初始化序列号不一样，也会存在收到历史报文的可能。<br />但是要清楚一点，历史报文能否被对方接收，还要看该历史报文的序列号是否正好在对方接收窗口内，如果不在就会丢弃，如果在才会接收。<br />如果每次建立连接客户端和服务端的初始化序列号都「不一样」，就有大概率因为历史报文的序列号「不在」对方接收窗口，从而很大程度上避免了历史报文，比如下图：<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1649864232468-90f3c929-044e-4c40-bfdf-bf05bbc5bf1d.png#clientId=u030f4860-ae82-4&from=paste&id=udb100c24&originHeight=927&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=u56432591-8994-400a-b5f1-c2b40399706&title=)<br />相反，如果每次建立连接客户端和服务端的初始化序列号都「一样」，就有大概率遇到历史报文的序列号刚「好在」对方的接收窗口内，从而导致历史报文被新连接成功接收。<br />所以，每次初始化序列号不一样能够很大程度上避免历史报文被下一个相同四元组的连接接收，注意是很大程度上，并不是完全避免了。
<a name="mmPrc"></a>
### 那客户端和服务端的初始化序列号都是随机的，那还是有可能随机成一样的？
RFC793 提到初始化序列号 ISN 随机生成算法：ISN = M + F(localhost, localport, remotehost, remoteport)。

- M是一个计时器，这个计时器每隔4毫秒加1。
- F 是一个 Hash 算法，根据源IP、目的IP、源端口、目的端口生成一个随机数值，要保证 hash 算法不能被外部轻易推算得出。

可以看到，随机数是会基于时钟计时器递增的，基本不可能会随机成一样的初始化序列号。
<a name="fC7Jt"></a>
### 客户端和服务端初始化序列号都是随机生成的话，就能避免连接接收历史报文了。
是的，但是也不是完全避免了。<br />为了能更好的理解这个原因，先来了解序列号（SEQ）和初始序列号（ISN）。

- **序列号**，是 TCP 一个头部字段，标识了 TCP 发送端到 TCP 接收端的数据流的一个字节，因为 TCP 是面向字节流的可靠协议，为了保证消息的顺序性和可靠性，TCP 为每个传输方向上的每个字节都赋予了一个编号，以便于传输成功后确认、丢失后重传以及在接收端保证不会乱序。**序列号是一个 32 位的无符号数，因此在到达 4G 之后再循环回到 0**。
- **初始序列号**，在 TCP 建立连接的时候，客户端和服务端都会各自生成一个初始序列号，它是基于时钟生成的一个随机数，来保证每个连接都拥有不同的初始序列号。**初始化序列号可被视为一个 32 位的计数器，该计数器的数值每 4 微秒加 1，循环一次需要 4.55 小时**。

给大家抓了一个包，下图中的 Seq 就是序列号，其中红色框住的分别是客户端和服务端各自生成的初始序列号。<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1649864232453-7f8a74f0-9a03-4d8e-ac18-a3aeb6c6ca3f.png#clientId=u030f4860-ae82-4&from=paste&id=u2538e26d&originHeight=545&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=uc0301984-c957-440a-af7d-4a18c47e0a9&title=)<br />通过前面知道，**序列号和初始化序列号并不是无限递增的，会发生回绕为初始值的情况，这意味着无法根据序列号来判断新老数据**。<br />不要以为序列号的上限值是 4GB，就以为很大，很难发生回绕。在一个速度足够快的网络中传输大量数据时，序列号的回绕时间就会变短。如果序列号回绕的时间极短，就会再次面临之前延迟的报文抵达后序列号依然有效的问题。<br />为了解决这个问题，就需要有 TCP 时间戳。tcp_timestamps 参数是默认开启的，开启了 tcp_timestamps 参数，TCP 头部就会使用时间戳选项，它有两个好处，**一个是便于精确计算 RTT ，另一个是能防止序列号回绕（PAWS）**。<br />试看下面的示例，假设 TCP 的发送窗口是 1 GB，并且使用了时间戳选项，发送方会为每个 TCP 报文分配时间戳数值，假设每个报文时间加 1，然后使用这个连接传输一个 6GB 大小的数据流。<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1649864232549-b02a6697-02f7-4342-a8a8-1a9c8ca66aad.png#clientId=u030f4860-ae82-4&from=paste&id=udaf3634d&originHeight=298&originWidth=956&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&taskId=u4cb28189-e9a1-44e1-b5ee-f3a0800e821&title=)<br />32 位的序列号在时刻 D 和 E 之间回绕。假设在时刻B有一个报文丢失并被重传，又假设这个报文段在网络上绕了远路并在时刻 F 重新出现。如果 TCP 无法识别这个绕回的报文，那么数据完整性就会遭到破坏。<br />使用时间戳选项能够有效的防止上述问题，如果丢失的报文会在时刻 F 重新出现，由于它的时间戳为 2，小于最近的有效时间戳（5 或 6），因此防回绕序列号算法（PAWS）会将其丢弃。<br />防回绕序列号算法要求连接双方维护最近一次收到的数据包的时间戳（Recent TSval），每收到一个新数据包都会读取数据包中的时间戳值跟 Recent TSval 值做比较，**如果发现收到的数据包中时间戳不是递增的，则表示该数据包是过期的，就会直接丢弃这个数据包**。<br />懂了，客户端和服务端的初始化序列号都是随机生成，能很大程度上避免历史报文被下一个相同四元组的连接接收，然后又引入时间戳的机制，从而完全避免了历史报文被接收的问题。
