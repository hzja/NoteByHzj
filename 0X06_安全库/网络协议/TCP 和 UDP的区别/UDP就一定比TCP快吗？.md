UDPTCP<br />**UDP比TCP快吗？**<br />相信就算不是八股文老手，也会下意识的脱口而出："**是**"。<br />这要追问为什么，估计大家也能说出个大概。<br />但这也让人好奇，**用UDP就一定比用TCP快吗？什么情况下用UDP会比用TCP慢？**<br />来聊下这个话题。
<a name="ke7Au"></a>
## 使用socket进行数据传输
作为一个程序员，假设需要在A电脑的进程发一段数据到B电脑的进程，一般会在代码里使用socket进行编程。<br />socket就像是一个**电话或者邮箱**（邮政的信箱）。当你想要发送消息的时候，拨通电话或者将信息塞到邮箱里，socket内核会自动完成将数据传给对方的这个过程。<br />基于socket可以选择使用TCP或UDP协议进行通信。<br />对于TCP这样的可靠性协议，每次消息发出后都能明确知道对方收没收到，就**像打电话一样**，只要"喂喂"两下就能知道对方有没有在听。<br />而UDP就像是**给邮政的信箱寄信一样**，寄出去的信，根本就不知道对方有没有正常收到，丢了也是有可能的。<br />回到socket编程的话题上。<br />创建socket的方式就像下面这样。
```c
fd = socket(AF_INET, 具体协议,0);
```
注意上面的"**具体协议**"，如果传入的是`SOCK_STREAM`，是指使用**字节流**传输数据，说白了就是**TCP协议**。<br />![TCP是什么](https://cdn.nlark.com/yuque/0/2022/png/396745/1667719231494-513ca7c3-fe46-446c-a296-c8dfc0830fbc.png#averageHue=%23c2d5de&clientId=u27fb2028-33e3-4&from=paste&id=uc36f78b2&originHeight=540&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=u4ff00083-acde-4b6d-82bc-bde8a867145&title=TCP%E6%98%AF%E4%BB%80%E4%B9%88 "TCP是什么")<br />如果传入的是SOCK_DGRAM，是指使用**数据报**传输数据，也就是**UDP协议**。<br />![UDP是什么](https://cdn.nlark.com/yuque/0/2022/png/396745/1667719231490-0959dd47-a825-4012-9cde-1bb7f5b84121.png#averageHue=%23c2d4de&clientId=u27fb2028-33e3-4&from=paste&id=u29ef0bdc&originHeight=540&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=uf6d49d0d-626f-4f8e-acd0-6e07aeedbf5&title=UDP%E6%98%AF%E4%BB%80%E4%B9%88 "UDP是什么")<br />返回的fd是指socket句柄，可以理解为socket的**身份证号**。通过这个fd可以在内核中找到**唯一**的socket结构。<br />如果想要通过这个socket发消息，只需要操作这个fd就行了，比如执行 `send(fd, msg, ...)`，内核就会通过这个fd句柄找到socket然后进行发数据的操作。<br />**如果一切顺利**，此时对方执行接收消息的操作，也就是 `recv(fd, msg, ...)`，就能拿到你发的消息。<br />![udp发送接收过程](https://cdn.nlark.com/yuque/0/2022/gif/396745/1667719231572-930aab0f-5b68-4632-94d9-6a10c5dec425.gif#averageHue=%23eef4fc&clientId=u27fb2028-33e3-4&from=paste&id=u6e5f40cf&originHeight=607&originWidth=1079&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=ue9b07c8d-43bf-4d74-a451-0afe0a6548b&title=udp%E5%8F%91%E9%80%81%E6%8E%A5%E6%94%B6%E8%BF%87%E7%A8%8B "udp发送接收过程")
<a name="dPV8j"></a>
## 对于异常情况的处理
**但如果不顺利呢？**<br />比如消息发到一半，丢包了呢?<br />丢包的原因有很多，之前写过的《用了TCP协议，就一定不会丢包吗？》有详细聊到过，这里就不再展开。<br />那UDP和TCP的态度就不太一样了。<br />UDP表示，"哦，是吗？然后呢？关我x事"<br />TCP态度就截然相反了，"啊？那可不行，是不是我发太快了呢？是不是链路太堵被别人影响到了呢？不过你放心，我肯定给你补发"<br />TCP老实人石锤了。来看下这个老实人在背后都默默做了哪些事情。
<a name="Y2uxn"></a>
### 重传机制
对于TCP，它会给发出的消息打上一个**编号（sequence）**，接收方收到后回一个**确认(ack)**。发送方可以通过ack的数值知道接收方收到了哪些sequence的包。<br />如果长时间等不到对方的确认，TCP就会重新发一次消息，这就是所谓的**重传机制**。<br />![TCP重传](https://cdn.nlark.com/yuque/0/2022/png/396745/1667719231496-e12ad0a6-1e60-4e67-8caf-537a5cc31899.png#averageHue=%23e0e8eb&clientId=u27fb2028-33e3-4&from=paste&id=u530b5376&originHeight=417&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=u090da3fd-48e3-4857-9c7c-b224fc09e10&title=TCP%E9%87%8D%E4%BC%A0 "TCP重传")
<a name="NPkS5"></a>
### 流量控制机制
但重传这件事本身对性能影响是比较严重的，所以是**下下策**。<br />于是TCP就需要思考有没有办法可以尽量**避免重传**。<br />因为数据发送方和接收方处理数据能力可能不同，因此如果可以根据双方的能力去调整发送的数据量就好了，于是就有了**发送和接收窗口**，基本上从名字就能看出它的作用，比如**接收窗口的大小**就是指，接收方当前**能接收的数据量大小**，**发送窗口的大小**就指发送方当前能发的数据量大小。TCP根据窗口的大小去控制自己发送的数据量，这样就能大大减少丢包的概率。<br />![流量控制机制](https://cdn.nlark.com/yuque/0/2022/png/396745/1667719231897-123ba223-63c6-4cee-bcc2-06c2d6b1dad8.png#averageHue=%23dce6e8&clientId=u27fb2028-33e3-4&from=paste&id=u66051fb3&originHeight=417&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=u77d90f5d-36eb-4ae8-ade7-369c35d1079&title=%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E6%9C%BA%E5%88%B6 "流量控制机制")
<a name="F3YF0"></a>
### 滑动窗口机制
接收方的接收到数据之后，会不断处理，**处理能力也不是一成不变的**，有时候处理的快些，那就可以收多点数据，处理的慢点那就希望对方能少发点数据。毕竟发多了就有可能处理不过来导致丢包，丢包会导致重传，这可是下下策。因此需要动态的去调节这个接收窗口的大小，于是就有了**滑动窗口机制**。<br />看到这里大家可能就有点迷了，**流量控制和滑动窗口机制貌似很像，它们之间是啥关系？**总结一下。其实现在TCP是**通过滑动窗口机制来实现流量控制机制的**。<br />![滑动窗口机制](https://cdn.nlark.com/yuque/0/2022/png/396745/1667719231971-46895de1-a856-41cf-8036-f5b23690f15c.png#averageHue=%23e2e9eb&clientId=u27fb2028-33e3-4&from=paste&id=u9f052fe9&originHeight=972&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=u72e17a36-5950-48d7-a775-cbedb61624b&title=%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%BA%E5%88%B6 "滑动窗口机制")
<a name="hPljA"></a>
### 拥塞控制机制
但这还不够，有时候发生丢包，**并不是因为发送方和接收方的处理能力问题导致的**。而是跟**网络环境**有关，大家可以将网络想象为一条公路。马路上可能堵满了别人家的车，只留下一辆车的空间。那就算你家有5辆车，目的地也正好有5个停车位，你也没办法同时全部一起上路。于是TCP希望能感知到外部的网络环境，根据网络环境及时调整自己的发包数量，比如马路只够两辆车跑，那我就只发两辆车。但外部环境这么复杂，TCP是怎么感知到的呢？<br />TCP会先慢慢试探的发数据，不断加码数据量，越发越多，先发一个，再发2个，4个…。直到出现丢包，这样TCP就知道现在当前网络大概吃得消几个包了，这既是所谓的**拥塞控制机制**。<br />不少人会疑惑流量控制和拥塞控制的关系。这里小小的总结下。**流量控制**针对的是**单个连接**数据处理能力的控制，**拥塞控制**针对的是**整个网络环境**数据处理能力的控制。<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1667719231943-583157e1-8d0e-45d5-93ab-8558980473d7.png#averageHue=%236ca3a9&clientId=u27fb2028-33e3-4&from=paste&id=u7a287e66&originHeight=324&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ud4a20191-d6e1-439d-9dd4-81993fa76ae&title=)
<a name="cbjuw"></a>
### 分段机制
但上面提到的都是怎么**降低**重传的概率，似乎重传这个事情就是无法避免的，**那如果确实发生了，有没有办法降低它带来的影响呢？**<br />有。当需要发送一个超大的数据包时，如果这个数据包丢了，那就得重传同样大的数据包。但如果能将其分成一小段一小段，那就算真丢了，那也就只需要重传那一小段就好了，大大减小了重传的压力，这就是TCP的**分段机制**。<br />而这个所谓的一小段的长度，在传输层叫**MSS**（**Maximum Segment Size**），数据包长度大于MSS则会分成N个小于等于MSS的包。<br />![MSS分包](https://cdn.nlark.com/yuque/0/2022/gif/396745/1667719232006-1aeb83b5-c58e-40e0-ae77-8d39542af384.gif#averageHue=%23ebf1fa&clientId=u27fb2028-33e3-4&from=paste&id=ud5849068&originHeight=607&originWidth=1079&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=u07b288c9-9d9c-49df-b80f-0c36998bef2&title=MSS%E5%88%86%E5%8C%85 "MSS分包")<br />而在网络层，如果数据包还大于**MTU（Maximum Transmit Unit）**，那还会继续分包。<br />![MTU分包](https://cdn.nlark.com/yuque/0/2022/gif/396745/1667719232064-fef9403f-c700-4f48-9449-3293cf0bef32.gif#averageHue=%23ecf1fa&clientId=u27fb2028-33e3-4&from=paste&id=ubc25c33d&originHeight=607&originWidth=1079&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=u53af5498-2236-417a-830b-fa3f3602c5b&title=MTU%E5%88%86%E5%8C%85 "MTU分包")<br />一般情况下，MSS=MTU-40Byte，所以**TCP分段后，到了IP层大概率就不会再分片了**。<br />![MSS和MTU的区别](https://cdn.nlark.com/yuque/0/2022/png/396745/1667719232249-93c9d337-b964-4305-892a-61ebced2b1da.png#averageHue=%23e8ebee&clientId=u27fb2028-33e3-4&from=paste&id=u75ad6c5a&originHeight=288&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=u17391aa5-721e-4923-8e02-21c44a03d49&title=MSS%E5%92%8CMTU%E7%9A%84%E5%8C%BA%E5%88%AB "MSS和MTU的区别")
<a name="TlkRC"></a>
### 乱序重排机制
既然数据包会被分段，链路又这么复杂还会丢包，那数据包乱序也就显得不奇怪了。比如发数据包1,2,3。1号数据包走了其他网络路径，2和3数据包先到，1数据包后到，于是数据包顺序就成了2,3,1。这一点TCP也考虑到了，依靠数据包的sequence，接收方就能知道数据包的先后顺序。<br />后发的数据包先到是吧，那就先放到专门的**乱序队列**中，等数据都到齐后，重新整理好乱序队列的数据包顺序后再给到用户，这就是**乱序重排机制**。<br />![乱序队列等待数据包的到来](https://cdn.nlark.com/yuque/0/2022/png/396745/1667719232311-00a88c36-83a6-48b8-bf1f-316453daba5d.png#averageHue=%23e0e7e9&clientId=u27fb2028-33e3-4&from=paste&id=u343f1a70&originHeight=360&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=u4c50097a-d355-4c18-a6a3-315274157f3&title=%E4%B9%B1%E5%BA%8F%E9%98%9F%E5%88%97%E7%AD%89%E5%BE%85%E6%95%B0%E6%8D%AE%E5%8C%85%E7%9A%84%E5%88%B0%E6%9D%A5 "乱序队列等待数据包的到来")
<a name="YcJuR"></a>
### 连接机制
前面提到，UDP是无连接的，而TCP是面向连接的。<br />这里提到的**连接**到底是啥？<br />TCP通过上面提到的各种机制实现了数据的可靠性。这些机制背后是通过一个个数据结构来实现的逻辑。而为了实现这套逻辑，操作系统内核需要在两端代码里维护一套复杂的状态机（三次握手，四次挥手，RST，closing等异常处理机制），**这套状态机其实就是所谓的"连接"**。这其实就是TCP的**连接机制**，而UDP用不上这套状态机，因此它是"无连接"的。<br />网络环境链路很长，还复杂，数据丢包是很常见的。<br />平常用TCP做各种数据传输，完全对这些事情无感知。<br />**哪有什么岁月静好，是TCP替你负重前行。**<br />这就是TCP三大特性"面向连接、可靠的、基于字节流"中"**可靠**"的含义。<br />不信你改用UDP试试，丢包那就是真丢了，丢到你怀疑人生。
<a name="c8oax"></a>
## 用UDP就一定比用TCP快吗？
这时候UDP就不服了："**正因为没有这些复杂的TCP可靠性机制，所以我很快啊**"<br />嗯，这也是大部分人认为UDP比TCP快的原因。<br />**实际上大部分情况下也确实是这样的。这话没毛病。**<br />那问题就来了。<br />**有没有用了UDP但却比TCP慢的情况呢？**<br />其实也有。<br />在回答这个问题前，需要先说下**UDP的用途**。<br />实际上，**大部分**人也不会尝试**直接拿裸udp**放到生产环境中去做项目。<br />那UDP的价值在哪？<br />在我看来，UDP的存在，本质是内核提供的一个**最小网络传输功能**。<br />很多时候，大家虽然号称自己用了UDP，但实际上都很**忌惮**它的丢包问题，所以大部分情况下都会在UDP的基础上做各种不同程度的**应用层**可靠性保证。比如王者农药用的KCP，以及最近很火的QUIC（HTTP3.0），其实都**在UDP的基础上做了重传逻辑**，实现了一套**类似**TCP那样的可靠性机制。<br />教科书上最爱提UDP适合用于**音视频传输**，因为这些场景允许丢包。但其实也不是什么包都能丢的，比如重要的关键帧啥的，该重传还得重传。除此之外，还有一些**乱序处理机制**。举个例子吧。<br />打音视频电话的时候，你可能遇到过丢失中间某部分信息的情况，但应该从来没遇到过乱序的情况吧。<br />比如对方打网络电话给你，说了："**我好想给小白来个点赞在看！**"<br />这时候网络信号不好，你可能会听到"我….点赞在看"。<br />但却从来没遇到过"在看小白好想赞"这样的**乱序**场景吧？<br />所以说，**虽然选择了使用UDP，但一般还是会在应用层上做一些重传机制的**。<br />于是问题就来了，**如果现在我需要传一个特别大的数据包**。<br />在TCP里，它内部会根据MSS的大小**分段**，这时候进入到IP层之后，每个包大小都不会超过MTU，因此IP层一般不会再进行分片。这时候发生丢包了，只需要**重传每个MSS分段**就够了。<br />![TCP分段](https://cdn.nlark.com/yuque/0/2022/gif/396745/1667719232326-c9384ed9-c6ca-46dd-b857-983010b2d772.gif#averageHue=%23eff4fb&clientId=u27fb2028-33e3-4&from=paste&id=u24e81cf2&originHeight=607&originWidth=1079&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=ua1dd8887-88c4-42c8-9f37-cc341da9bcb&title=TCP%E5%88%86%E6%AE%B5 "TCP分段")<br />但对于UDP，其本身并不会分段，如果数据过大，到了IP层，就会进行分片。此时发生丢包的话，再次重传，就会**重传整个大数据包**。<br />![UDP不分段](https://cdn.nlark.com/yuque/0/2022/gif/396745/1667719232441-5369fe6d-d28b-4806-8566-3a59caf62055.gif#averageHue=%23eff4fb&clientId=u27fb2028-33e3-4&from=paste&id=uec20ee8c&originHeight=607&originWidth=1079&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=u3529671c-4820-4bf8-b583-9e5a6776b57&title=UDP%E4%B8%8D%E5%88%86%E6%AE%B5 "UDP不分段")<br />对于上面这种情况，**使用UDP就比TCP要慢**。<br />当然，解决起来也不复杂。这里的关键点在于是否实现了数据分段机制，**使用UDP的应用层如果也实现了分段机制的话，那就不会出现上述的问题了**。
<a name="mlO8B"></a>
## 总结

- TCP为了实现可靠性，引入了重传机制、流量控制、滑动窗口、拥塞控制、分段以及乱序重排机制。而UDP则没有实现，因此一般来说TCP比UDP慢。
- TCP是面向连接的协议，而UDP是无连接的协议。这里的"**连接**"其实是，操作系统内核在两端代码里维护的一套复杂状态机。
- 大部分项目，会在基于UDP的基础上，模仿TCP，实现不同程度的可靠性机制。比如王者农药用的KCP其实就在基于UDP在应用层里实现了一套**重传**机制。
- 对于UDP+重传的场景，如果要传**超大数据包**，并且没有实现**分段机制**的话，那数据就会在IP层分片，一旦丢包，那就需要重传整个超大数据包。而TCP则不需要考虑这个，内部会自动分段，丢包重传分段就行了。这种场景下，其实TCP更快。
