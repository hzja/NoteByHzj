# 原创
：  [论文阅读] (20)USENIXSec21 DeepReflect：通过二进制重构发现恶意行为（恶意代码ROI分析经典）

# [论文阅读] (20)USENIXSec21 DeepReflect：通过二进制重构发现恶意行为（恶意代码ROI分析经典）

《娜璋带你读论文》系列主要是督促自己阅读优秀论文及听取学术讲座，并分享给大家，希望您喜欢。由于作者的英文水平和学术能力不高，需要不断提升，所以还请大家批评指正，非常欢迎大家给我留言评论，学术路上期待与您前行，加油。

<font color="red">**前一篇从个人角度介绍英文论文实验评估（Evaluation）的数据集、评价指标和环境设置如何撰写。这篇文章将带来USENIXSec21恶意代码分析的经典论文，DeepReflect，它通过二进制重构发现恶意功能，来自于佐治亚理工。一方面自己英文太差，只能通过最土的办法慢慢提升，另一方面是自己的个人学习笔记，并分享出来希望大家批评和指正。希望这篇文章对您有所帮助，这些大佬是真的值得我们去学习，献上小弟的膝盖~fighting！**</font>

**原文作者**：Evan Downing, Yisroel Mirsky, Kyuhong Park, Wenke Lee<br/> **原文标题**：DeepReflect: Discovering Malicious Functionality through Binary Reconstruction<br/> **原文链接**：[https://www.usenix.org/conference/usenixsecurity21/presentation/downing](https://www.usenix.org/conference/usenixsecurity21/presentation/downing)<br/> **发表会议**：USENIXSec 2021<br/> **代码下载**：[https://github.com/evandowning/deepreflect](https://github.com/evandowning/deepreflect)

**除了原文和作者的理解，本文还参考了下面三位老师的博客，再次感谢，向老师和好友们学习。**

> 
<mark>**作者感受：**</mark><br/> <mark>**这篇论文的框架风格和我的很像，非常值得我学习，尤其是文中的英文表述、创新点、模型设计、四类特征设计以及实验评估（从五个方面评估）。整个工作非常充实，也是恶意代码分析中的一篇经典文章。**</mark>


#### 文章目录

**前文赏析：**

---


## 一.摘要

深度学习已在恶意软件分类任务中表现出良好的结果。然而：

<font color="red">**为了提高静态（或手动）逆向工程的生产力，我们提出了DeepReflect：一种用于定位（localize）和识别（identify）恶意二进制文件中恶意软件组件的工具。**</font>

我们通过5个恶意软件分析人员对超过26k个恶意软件样本进行评估。实验发现，DeepReflect让每个分析人员需要逆向工程的函数数量平均减少了85%。本文方法还可以检测到80%的恶意软件组件，而当使用基于签名的工具CAPA时，该值仅为43%。

此外，DeepReflect提出的自动编码器（autoencoder）比Shap（一种人工智能解释工具）表现得更好。这一点很重要，因为Shap是一种最先进（state-of-the-art）的方法，需要一个标记的数据集，而我们的自动编码器不需要。

---


## 二.引言

> 
由于每篇论文的引言都非常重要，因此该部分作者会全文翻译，后续章节则介绍重点内容。


### 1.背景引出挑战

静态逆向工程恶意软件可能是一个手动且乏味的过程。公司每周可以收到多达 500 万个PE样本。 虽然大多数组织提前对这些样本进行分类（triage），以减少要分析的恶意软件数量（即，<mark>检查 VirusTotal来获取反病毒 (AV) 引擎结果、在受控沙箱中执行样本、提取静态和动态签名等</mark>） ，但最终仍然需要静态逆向工程的恶意软件样本。这是因为**总会有新的恶意软件样本**，没有被反病毒公司分析过，或者缺乏签名来识别这些新样本。最终，该样本有可能会拒绝在分析人员的动态沙箱（sandbox）中执行。

当前的解决方案以为恶意软件样本创建签名、分类和聚类的形式存在。然而，这些解决方案只能预测样本的类别（例如，良性与恶意，或特定的恶意软件家族）。**他们无法定位或解释恶意软件样本本身内部的行为（定位恶意函数位置、解释恶意函数行为），而分析师需要执行（perform）这些行为来生成报告并改进他们公司的恶意软件检测产品**。事实上，由于工作量过大，该领域已呈现了倦怠。

为了确定他们的需求，我们咨询了四名逆向工程恶意软件分析师（一名来自AV公司，三名来自政府部门）。本文发现，如果恶意软件分析师有一个工具可以：

那么，他们的工作将更有效率。开发这样一种工具的挑战在于：

对于第一个挑战，区分良性和恶意是困难的，因为恶意软件和良性软件的行为通常在高层次上重叠。对于第二个挑战，自动标记和验证这些行为是很困难的，因为没有单独标记的恶意软件函数的数据集（与使用反病毒标签的开放数据集的恶意软件检测和分类系统不同）。

---


### 2.如何解决挑战

为了解决这些挑战，我们开发了DEEPREFLECT，它使用：

<mark>**为了定位（locate）二进制文件中的恶意软件组件，我们使用自动编码器(autoencoder，AE)**</mark>。AE是一种基于神经网络的机器学习模型，**其任务是将其输入重构为输出（编码还原）**。由于网络内层存在压缩，AE被迫学习训练分布中的关键概念。我们的直觉是，如果在良性二进制文件上训练AE，它将很难重建恶意二进制文件（即我们没有训练它的样本）。自然地，AE将无法重建（reconstruct）包含恶意行为的二进制数据区域（在良性样本中是不可见或罕见的）。**因此（Thus），重构错误可以用来识别恶意软件中的恶意组件**。此外，由于AE是以无监督的方式训练的，我们不需要数百万标记的样本，公司可以利用自己的恶意软件二进制数据集。

> 
该约束读者需要理解，本文使用恶意样本进行学习和识别。


<mark>**为了对定位的恶意软件组件进行分类**</mark>，我们：

**这种方法是半监督的，因为每个类簇（cluster）只需要少数函数的行为标签（如三个）即可将大多数标签分配给整个集群**。随着时间推移，我们可以将AE识别的函数映射到聚类模型来预测函数的类别（如，C&amp;C、特权升级等），即认为函数和最接近的类簇有相同的行为标签。这反过来又节省了分析人员的时间，因为他们不必一次又一次地对相同的代码进行逆向工程。

注意，无监督 AE 为恶意软件分析人员提供了即时实用程序，无需训练或使用半监督聚类模型。这是因为它：

DEEPREFLECT根据我们是为恶意软件分析人员的反馈进行设计和修改的，并评估其有效性和实用性。

**我们评估了DEEPREFLECT的性能，包括五个工作：**

---


### 3.创新（Contribution）

我们的贡献如下：

---


## 三.Scope &amp; Overview

### 1.Motivation

图1展示了一个典型的恶意软件分析师Molly的工作流程。当给定一个恶意软件样本，Molly的任务是了解该样本在做什么，以便她写一份技术报告并改进公司的检测系统，从而在未来识别该类样本。

然而，当新的样本出现时，Molly需要重复同样的任务。由于这种重复的体力劳动，这项工作对Molly来说变得单调乏味和耗时。

**DEEPREFLECT旨在减轻恶意分析师的分析工作，能逆向一个未知的恶意软件样本，从而减轻他们繁重的任务，并为相似的函数标注行为标签。**

---


### 2.Proposed Solution

我们提出了DEEPREFLECT，该工具能：

虽然分析人员可能首先尝试通过搜索特定的字符串和API调用来静态地识别行为，但这些行为很容易被分析人员混淆或隐藏（ obfuscated or hidden）。<font color="red">**DEEPREFLECT没有做出这样的假设，并试图通过控制流图(control-flow graph，CFG)特性和API调用（API calls）的组合来识别这些相同的行为。**</font>

**DEEPREFLECT通过学习正常情况下良性的二进制函数来工作**。因此，任何异常都表明这些函数不会出现在良性二进制文件中，而可能被用于恶意行为中。这些异常函数更可能是恶意函数，分析师可以只分析它们，从而缩小工作范围。如图5所示，DEEPREFLECT将分析师必须分析的函数数量平均减少了 85%。此外，实验表明我们的方法优于旨在实现相同目标的基于签名的技术。

---


### 3.Research Goals

本文有四个主要目标：

---


## 四.模型设计

### 1.总体框架

DEEPREFLECT的目标是识别恶意软件二进制中的恶意函数。在实践中，它通过定位异常基本块（感兴趣区域 regions of interest，RoI)来识别可能是恶意的函数。然后，分析人员必须确定这些函数是恶意行为还是良性行为。DEEPREFLECT有两个主要步骤，如图2所示：

**(1) 术语 Terminology**<br/> 首先定义恶意行为（malicious behaviors）的含义。我们根据识别恶意软件源代码的核心组件（例如，拒绝服务功能、垃圾邮件功能、键盘记录器功能、命令和控制C&amp;C功能、利用远程服务等）来生成真实情况（ground-truth）。通过MITRE ATT&amp;CK框架描述，如表3所示。

**然而，当静态逆向工程评估恶意软件二进制文件时（即在野恶意软件二进制 in-the-wild malware binaries），我们有时无法肯定地将观察到的低级函数归因于更高级别的描述**。例如，恶意软件可能会因为许多不同的原因修改注册表项，但有时确定哪个注册表项因什么原因而被修改是很困难的，因此只能粗略地标记为“`防御逃避：修改注册表（Defense Evasion: Modify Registry）`”。即使是像CAPA这样的现代工具，也能识别出这些类型的模糊标签。<mark>因此，在我们的评估中，我们将“恶意行为”表示为可由MITRE ATT&amp;CK框架描述的函数。</mark>

**(2) RoI Detection**<br/> <mark>检测的目标是自动识别恶意软件二进制文件中的恶意区域</mark>。例如，我们希望检测C&amp;C逻辑的位置，而不是检测该逻辑的特定组件（例如，网络API调用connect()、send() 和 recv()）。**RoI检测的优点是分析人员可以快速定位启动和操作恶意行为的特定代码区域**。先前的工作只关注于创建临时签名，简单地将二进制文件标识为恶意软件或仅基于API调用的某些函数。这对于分析人员扩大他们的工作特别有用（即不仅仅依赖手动逆向工程和领域专业知识）。

**(3) RoI Annotation**<br/> <mark>注释的目标是自动标记包含RoI的函数的行为，即识别恶意函数在做什么</mark>。由于分析人员为标记集群所执行的初始工作是一个长尾分布。也就是说，只需要前期做比较重要的工作，随着时间推移，工作量会减少。这个过程的优点很简单：它为分析人员提供了一种自动生成未知样本的报告及见解的方法。例如，如果恶意软件示例的变体包含与之前的恶意软件示例相似的逻辑（但对于分析人员来说看起来不同以至于不熟悉），我们的工具为他们提供了一种更快实现这一点的方法。

---


### 2.RoI Detection

首先介绍了AutoEncode（AE）神经网络。此外，先前的工作已经证明，当自动编码器在良性分布上进行训练时，AE可以检测到恶意（异常）行为。我们的假设是，与良性二进制文件相比，恶意软件二进制文件将包含相似但独特的功能。

当使用大量良性样本训练AE后，给定一个随机的样本，可以利用公式(2)计算，超过MSE的即认为是恶意区域，突出显示ROI异常基本块。与先前识别整个样本为恶意区域的工作相比，我们识别了每个样本中的恶意区域。具体而言，我们计算的 `localized MSE` 定义如下：

We denote the mapped set of RoIs identified in sample x as the set

**(1) Features**

我们特征（c）的灵感来自于先前工作中发现的特征，即属性控制流图（attributed control flow graph，ACFG）特征[23,75]。在这些工作中，ACFG特征被选择来执行二进制相似性，因为它们假设这些特征(由结构和数字CFG特征组成)将在多个平台和编译器上是一致的。

为了在二进制样本中定位恶意行为的位置，编码使用的特征必须一对一的映射回原样本。因此，作者将每个二进制文件表示为一个 m×c 的矩阵，该矩阵使用c个静态特征捕获前m个基本块以总结样本的behavior。m设置为20k个基本块，是因为95%的数据集样本具有20k或者更少的基本块， c设置为18个特征。

> 
Our features consist of counts of instruction types within each basic block (a more detailed form of those extracted for ACFG features), structural features of the CFG, and categories of API calls (which have been used to summarize malware program behaviors).


> 
本文工作API特征的选择受到先前恶意软件检测工作[18]的启发。本文使用的ACFG特征比Genius和Gemini更细致。本文没有用字符串特征，因为容易被混淆、隐藏。


---


**(2) Model**

Autoencoder使用U-Net模型，U-Net的优点是其在编码器和解码器之间有跳过连接（skip connections），对样本x可以跳过某些特征的压缩以在重构的x’中保持更高的保真度。

首先收集大量的良性样本，对每个binary抽取上述18个静态特征用于表示该binary。设有用feature表示的样本x，AE重构后得到x’，训练的目标是最小化重构损失，即输入x和输出x’之间的损失。

<mark>**RoI Detection会在m个基本块中检测出一些异常基本块**</mark>。这些基本块分别属于不同的函数，使用例如BinaryNinja的工具就可以确定ROI属于哪些函数，即认为这些函数可能是恶意函数，也就完成了恶意函数定位的任务。后续RoI Annotation就是对这些函数聚类，完成恶意函数行为标记（分类）的任务。

---


### 3.RoI Annotation

给定一个新样本x，我们希望识别其每个函数的行为（类别），并将其报告给Molly。由于标记所有的函数都是不实用的，所以我们只注释了少量的函数，并使用聚类分析来传播结果。

**(1) Clustering Features**<br/> 假设一组脱壳恶意软件，按上述特征提取方式（18种特征）得到每个binary的特征表示，其中一个binary为x。

**(2) Clustering Model**<br/> 使用PCA将特征数从18降维至5，然后使用HDBSCAN算法对5维特征聚类。

---


### 4.Deployment

接下来，我们将描述如何部署和使用它。

<mark>**(1) Initialization**</mark>

人工分析恶意软件手动打标，这些label注释到聚类训练集中，从而评估实验结果。换句话说，每个cluster只需要其中几个函数的label，就可确定整个cluster的label，即确定整个cluster中函数的恶意行为。

**(2) Execution**<br/> 当Molly收到一个新的样本x，DeepReflect会自动定位恶意函数并标注恶意行为。

接下来，Molly分析highlighted functions，从而实现：

---


## 五.实验评估

### 1.Dataset

根据CNET爬取PE文件，然后经过脱壳、过滤得到23307个良性样本。根据VirusTotal ，脱壳、过滤，在沙箱中执行获取家族标签。得到36396个恶意样本，4407个家族。

特征18个：

---


### 2.Evaluation 1 – Reliability（可靠性）

为了评估DeepReflect自动编码器的定位能力，我们与一般方法和领域特定方法进行比较：

静态的分析了三个恶意软件的源代码（rbot, pegasus, carbanak），分析了其中恶意组件的位置。结果如Figure 3，横线为80% True Positive Rate。

---


### 3.Evaluation 2 – Cohesiveness（凝聚）

测试DeepReflect聚类的凝聚性，对恶意函数行为分类的能力。生成了22469个类簇，最大的簇包含6321个函数，最小的簇包含5个，如图10所示。在图10中，我们展示了类簇大小上的分布。图中显示，存在一个长尾分布（这在基于密度的聚类中很常见），其中最多的前10个集群占函数的5%。

在聚类质量分析中，89.7%的分析人员手工聚类功能与DeepReflect创建的功能相匹配。

此外，聚类质量存在问题，相同功能却被聚集在不同类簇中，分析了3个案例，主要因为小地方存在差异，聚类算法过于敏感。

---


### 4.Evaluation 3 – Focus

DeepReflect缩小需要人工分析的函数的范围的能力。如图5所示，很多样本需要分析的函数数量降低了90%以上。平均降低85%。

---


### 5.Evaluation 4 – Insight

为了评估DeepReflect是否为恶意软件家族间的关系及其行为提供了有意义的见解，我们探索了集群多样性。图4的左侧绘制了C中每个类簇中不同家族的数量。由图可知，在家族之间有许多共享的恶意软件技术和变体，部分恶意软件家族间分享了相同的函数，新的恶意软件家族的样本也可以被成功的分类。

---


### 6.Evaluation 5 – Robustness

使用LLVM混淆，继续测试模型的鲁棒性；同时使用对抗样本攻击，将包含本文使用的特征的良性样本的代码插入到恶意样本中，但均未对结果产生显著影响。

---


## 六.限制和相关工作

Every system has weaknesses and ours is no exception.

Related Works

---


## 七.Conclusion

---


## 八.个人感受

写到这里，这篇文章就分享结束了，再次感谢论文作者及引文的老师们。接下来是作者的感受，由于是在线论文读书笔记，仅代表个人观点，写得不好的地方，还请各位老师和博友批评指正，感恩遇见，读博路漫漫，一起加油~

**个人总结：**<br/> 这篇文章确实是恶意代码分析领域的顶级论文，写得非常棒，真心值得我去学习，感谢论文作者及Georgia Institute of Technology团队的分享。同时，论文的写作方式及框架、实验都非常棒，工作量也很大，每个部分甚至都需要我们去理解，具体优点如下：

<font color="red">**这篇文章就写到这里，希望对您有所帮助。由于作者英语实在太差，论文的水平也很低，写得不好的地方还请海涵和批评。同时，也欢迎大家讨论，继续加油！感恩遇见，且看且珍惜。**</font>

(By:Eastmount 2022-04-28 周四夜于武汉 http://blog.csdn.net/eastmount/ )

---


最后给出几段经典的句子：

---

