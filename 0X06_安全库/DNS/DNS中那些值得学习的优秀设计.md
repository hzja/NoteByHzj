网络DNS
<a name="oChSf"></a>
## 为什么要有DNS
如果想要访问某度，可以在浏览器上的搜索栏里输入112.80.248.76这个IP地址，直达页面。<br />![通过IP访问网页](https://cdn.nlark.com/yuque/0/2023/png/396745/1679034471045-dce42625-1db0-456a-abb9-cf86c0e6c04e.png#averageHue=%23dad3cf&clientId=uc0a01572-cc45-4&from=paste&id=u03d82097&originHeight=501&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=u2f99f2b7-ee8c-4c64-9fd7-ad7542b1a2d&title=%E9%80%9A%E8%BF%87IP%E8%AE%BF%E9%97%AE%E7%BD%91%E9%A1%B5 "通过IP访问网页")<br />这样的行为，**合法，但有病**。<br />大部分人，连自己对象的电话号码都记不住，又怎么可能记得住这么一串IP地址呢。<br />回想一下，虽然你记不住对象的电话号码，但却不影响你给她打电话。你的操作过程是不是打开**通讯录**，输入"富婆"，然后就弹出一个电话号码。点击即拨打。<br />在计算机领域，你大概率也记不住IP，所以也需要有类似的**通讯录的功能**。比如，你只需要输入www.baidu.com，它就能帮你找到对应的 112.80.248.76，然后进行访问。<br />![用域名访问](https://cdn.nlark.com/yuque/0/2023/png/396745/1679034471064-3b495081-4aac-4312-adaa-df175304201d.png#averageHue=%23dbd4cf&clientId=uc0a01572-cc45-4&from=paste&id=ucad224ed&originHeight=498&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=u512a8c3e-c6d2-4926-b440-cf325d3140b&title=%E7%94%A8%E5%9F%9F%E5%90%8D%E8%AE%BF%E9%97%AE "用域名访问")<br />其中www.baidu.com 是**域名**，通过这个域名可以获得它背后的IP是112.80.248.76。<br />就像一个人可以有多个电话号码一样，一个域名也可以对应有多个IP地址。<br />而将域名解析为IP的过程，也就是**查"通讯录"的过程**，其实就是**DNS**（**D**omain **N**ame **S**ystem，域名系统）协议需要做的事情。<br />另外需要注意的是，上面的这个IP地址，写这篇文章的时候能访问，不代表大家看文章的时候能访问。因为这背后的IP地址是有可能变更的。可以通过使用 `ping www.baidu.com`获得最新的IP地址。<br />![ping获得IP](https://cdn.nlark.com/yuque/0/2023/png/396745/1679034471062-a9078f51-32ab-4b2a-9b96-610dae3788bb.png#averageHue=%2316191b&clientId=uc0a01572-cc45-4&from=paste&id=u1676a8bb&originHeight=239&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=ua036262d-8585-4827-ae42-2739afdc071&title=ping%E8%8E%B7%E5%BE%97IP "ping获得IP")<br />但问题就来了。<br />普通人的通讯录，一般有一千个电话号码就算是**社交小达人**了，放在通讯录里绰绰有余。<br />然而网站域名，却不一样，据说2015年的时候就已经超过3亿了。<br />如果将这3亿条记录都放在一个服务器里，会有**两个问题**。

- 超过3亿条域名数据，**数据量过大**，并且数据量持续增加
- 需要承受**大量的读请求**。每个网站域名都可能会有成千的访问。这加起来，四舍五入也有千亿qps了。

显然，如果将DNS做成类似手机通讯录这样的单点服务，那是不可能实现这样的能力的，必须得是**分布式系统**。<br />于是，问题就变成了，如何设计一个**支持千亿+qps请求的大型分布式系统**。<br />肯定有人要说："这是服务只有10qps的人该考虑的事情吗？"<br />虽然做的服务可能只有10qps，但这并不妨碍学习DNS里优秀的设计。<br />就从URL的层次结构聊起。
<a name="VEtEp"></a>
## URL的层次结构
举个例子。一个常见的域名，比如 www.baidu.com。<br />可以看到，这个域名中间用了**两个句点**。通过句点符号，可以将域名分为三部分。<br />其中com被称为**一级域**或**顶级域**，其他常见的顶级域还有cn，co等，baidu是**二级域**，www则是**三级域**。<br />除此之后，在com后面，其实还有一个**被省略掉的句点号**。它叫**根域**。<br />![域名的层次结构](https://cdn.nlark.com/yuque/0/2023/png/396745/1679034471173-c7540dfa-351a-445c-b206-c36da214156c.png#averageHue=%23eceff1&clientId=uc0a01572-cc45-4&from=paste&id=ue198642b&originHeight=405&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=u0b99e7d2-5a6a-41ae-aee2-38b0bfd7454&title=%E5%9F%9F%E5%90%8D%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84 "域名的层次结构")<br />当域名多起来了之后，将它们相同的部分抽取出来，多个域名就可以变成这样的**树状层级结构**。<br />![层次结构](https://cdn.nlark.com/yuque/0/2023/png/396745/1679034473459-ab0228d5-3748-4104-b519-04c91224883e.png#averageHue=%23eef0f2&clientId=uc0a01572-cc45-4&from=paste&id=ue5f97b64&originHeight=495&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=u58d43a4d-4db6-4d86-b885-d0288dd2c5e&title=%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84 "层次结构")<br />这时候就可以看到，这些域之间其实是一种**层级关系**，就像是学校，年级，班级那样。<br />当要去定位一个具体域名的时候，你就可以通过这样的层级找到对应的域名。<br />举个例子。大家应该还记得那句广告词，"三年级2班的李小明同学，你妈妈拿了两罐旺仔牛奶给你"，其实李小明的妈妈，就是通过，学校、年级、班级的层级形式，一层层找到人。
<a name="zfcND"></a>
## DNS的原理
重新回来看下大佬们是怎么设计DNS。<br />先直接说最重要的结论。

- **利用层级结构去拆分服务**
- **加入多级缓存**

接下来展开。
<a name="scFLG"></a>
## 利用URL层级结构去拆分服务
DNS承载的流量压力非常大，必须要做成**分布式服务**，于是问题的关键就变成了**如何拆分服务**。<br />既然URL是树状的层级结构，那保存它们的服务，也可以依据这个，非常自然的拆成树状的形式。<br />一台服务器维护一个或多个域的信息。于是服务就变成了下面这样的层级形式。<br />当需要访问www.baidu.com。<br />查询过程就跟下图一样。<br />![DNS查询过程](https://cdn.nlark.com/yuque/0/2023/png/396745/1679034473737-050f984d-c556-4d51-9205-2ed0517b9208.png#averageHue=%23eaedf0&clientId=uc0a01572-cc45-4&from=paste&id=ua845ec89&originHeight=649&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=u0ef63ae1-4221-48d7-9814-f48eb37d375&title=DNS%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B "DNS查询过程")<br />请求会先打到最近的DNS服务器（比如家用路由器）中，如果在DNS服务器中找不到，则DNS服务器会直接询问根域服务器，在根域服务器中虽然没有www.baidu.com这条记录的，但它可以知道这个URL属于com域，于是就找到com域服务器的IP地址，然后访问com域服务器，重复上面的操作，再找到放了baidu域的服务器是哪个，继续往下，直到找到www.baidu.com的那条记录，最后返回对应的IP地址。<br />可以看到，原理比较简单，但这里涉及到两个问题。

- 本机怎么知道最近的DNS服务器IP是什么？
- 最近的DNS服务器怎么知道根域的IP是多少？

一个个来回答。
<a name="CvmaB"></a>
### 本机怎么知道最近的DNS服务器的IP是什么？
插上网线时，机子会通过DHCP协议获得本机的IP地址，子网掩码，路由器地址，以及**DNS服务器的IP地址**。<br />![DHCP协议](https://cdn.nlark.com/yuque/0/2023/png/396745/1679034473625-65d58969-ec1b-4576-b1a8-0d91d46121d8.png#averageHue=%23e0e7ea&clientId=uc0a01572-cc45-4&from=paste&id=u2a24eac8&originHeight=291&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=u20bbd35b-382e-448e-b696-6b3c23319d3&title=DHCP%E5%8D%8F%E8%AE%AE "DHCP协议")<br />下面是mac机子，第二阶段DHCP Offer中的抓包截图。可以看到，这里面返回的信息里包含了**DNS服务器的IP**。<br />![offer阶段](https://cdn.nlark.com/yuque/0/2023/png/396745/1679034473878-f4baac94-6262-477d-9961-e35e60887795.png#averageHue=%23f3f2f2&clientId=uc0a01572-cc45-4&from=paste&id=u30b26113&originHeight=622&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=uecbeabcb-b0cd-409d-898b-3ffe22e6bb1&title=offer%E9%98%B6%E6%AE%B5 "offer阶段")<br />同时也可以在左上角的点左上角的苹果图标->系统表偏好设置->网络->高级->DNS中查看到DNS服务器的IP地址。<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1679034474166-60cad4b2-249b-4f9a-a4ca-4d0ac3a57a20.png#averageHue=%23f2f1f1&clientId=uc0a01572-cc45-4&from=paste&id=uccaa68d3&originHeight=916&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=uf5f6d166-6c00-45c2-8630-282bdbc096d&title=)<br />这里有个小细节，从上面的抓包图里可以看到**路由器地址和DNS服务器地址，以及DHCP服务器地址**，其实都是192.168.31.1，这个其实是这边的**家用路由器**的IP地址，也就是说一般家用路由器自带这几个功能。<br />而在某里云服务器里，DNS服务器也是一样，是通过dhcp协议获得。查看DNS服务器的IP地址也很方便，执行cat /etc/resolv.conf就好了。<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1679034474482-d5f4b0f5-2f1d-4270-a9a4-9386be29b6c7.png#averageHue=%23191b1c&clientId=uc0a01572-cc45-4&from=paste&id=u8f6510c0&originHeight=276&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u2c552433-9b98-4f8b-b288-6a53ee1d5de&title=)<br />这上面的nameserver中，可以看出有两台DNS服务器，机子会按照文件中出现的顺序来发起请求，如果第一台服务器没反应，就会去请求第二台。
<a name="hYAig"></a>
### 最近的DNS服务器怎么知道根域的IP是多少？
都知道根域，就是域名树的顶层，既然是顶层，那信息一般也就相对少一些。对应的IPV4地址只有13个，IPV6地址只有25个。<br />可以通过dig命令的+trace选项来查看一个域名的dns解析过程。<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1679034474815-b6180df2-4240-4d6f-b94e-e42daa12af41.png#averageHue=%2317191a&clientId=uc0a01572-cc45-4&from=paste&id=u88009740&originHeight=554&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=ub99a99c4-283c-4dd3-a832-15381224ed2&title=)<br />而前面提到的传说中的13个根域，从字母a-m，就都在上图中。<br />但这又引发了一个问题，上面看到的都是域名。<br />这。。。<br />**"我本来是想通过域名去找IP的，你又让我去找其他域名的IP？"**<br />听起来不科学，这不就**死循环**了吗。<br />是的，所以这些根域名对应的IP会以配置文件的形式，放在**每个**域名服务器中。<br />也就是说并不需要再去请求**根域名对应的IP**，直接在配置里能读出来就好了。<br />下面这个截图是域名服务器里的配置内容。<br />可以看到A开头的根域，它的IPV4地址是198.41.0.4。<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1679034476208-77cf7480-2ef2-46cd-82d8-a96f67438b46.png#averageHue=%23f1f0f0&clientId=uc0a01572-cc45-4&from=paste&id=u84472627&originHeight=832&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u82d9c4ce-e714-43b5-9f6a-1cdbf213250&title=)
<a name="zkBiR"></a>
## 加入多级缓存
对于高并发读多写少的场景，加入缓存几乎就是标配。<br />DNS也不例外，它加了缓存，而且不止一层。<br />从在浏览器的搜索框中输入URL。它会先后访问**浏览器缓存**、**操作系统的缓存**/etc/hosts、**最近的DNS服务器缓存**。如果都找不到，才是到根域，顶级（一级）域，二级域等DNS服务器进行查询请求。<br />![加入缓存后的DNS查询顺序](https://cdn.nlark.com/yuque/0/2023/png/396745/1679034477365-048c093f-9cec-47a9-a52e-072c5155f0de.png#averageHue=%23dee4e9&clientId=uc0a01572-cc45-4&from=paste&id=u4f079c24&originHeight=504&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=ub3b98b95-bbb3-4fbf-9032-40387835580&title=%E5%8A%A0%E5%85%A5%E7%BC%93%E5%AD%98%E5%90%8E%E7%9A%84DNS%E6%9F%A5%E8%AF%A2%E9%A1%BA%E5%BA%8F "加入缓存后的DNS查询顺序")<br />于是请求过程就成了下图这样。可以看到上面提到的好几有缓存的地方都加了个绿色的小文件图标，优先在缓存里做查询。<br />![加入缓存后的DNS查询过程](https://cdn.nlark.com/yuque/0/2023/png/396745/1679034478974-210ac0dd-82ea-40b0-8abc-3e8ba8727604.png#averageHue=%23e9edef&clientId=uc0a01572-cc45-4&from=paste&id=u2c0628c1&originHeight=605&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=ue0a42171-0b57-44ab-aa3c-bbe131f0245&title=%E5%8A%A0%E5%85%A5%E7%BC%93%E5%AD%98%E5%90%8E%E7%9A%84DNS%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B "加入缓存后的DNS查询过程")<br />由于缓存了上面树状结构的信息，最近的DNS服务器也不再需要每次都从**根域**开始查起。比如在缓存里能找到baidu.com的服务器IP，就直接跳到二级域服务器上做查找就好了。<br />正因为多级缓存的存在，每一层实际接收到的请求都大大减少了。并且每个人日常访问的网站也就那么几个，所以大部分时候都能命中缓存直接返回IP地址。<br />**简单小结下。**<br />DNS的设计中，**通过层次结构将服务进行拆分**，流量分散到多个服务器中。<br />又通过加入**多级缓存**，让每个层级实际接收到的请求大大减少，因此大大提高了系统的性能。<br />这**两点**，是做业务开发的过程中可以参考的优秀设计。<br />但**还有一点**，是大概率学不来的，叫**任播**，它也为DNS实现高并发处理能力提供了重要支持。
<a name="EA3kP"></a>
## 协议格式
DNS是个域名解析系统，而运行在这套系统上的协议，就叫**DNS协议**。<br />和HTTP类似，DNS协议也是个**应用层协议**。<br />![DNS是应用层协议](https://cdn.nlark.com/yuque/0/2023/png/396745/1679034479354-46ed4786-9d08-441b-8719-9b0a284a524c.png#averageHue=%23d5dee5&clientId=uc0a01572-cc45-4&from=paste&id=ufcc50628&originHeight=576&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=uec01681e-3e38-4e31-bbac-77e7af513d5&title=DNS%E6%98%AF%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE "DNS是应用层协议")<br />下图是它的报文格式。<br />![DNS报文](https://cdn.nlark.com/yuque/0/2023/png/396745/1679034481067-f658d3f9-6dcd-4bc2-ad3a-7138562fec85.png#averageHue=%23b3d2ce&clientId=uc0a01572-cc45-4&from=paste&id=u2528d715&originHeight=513&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=u98145733-b1e2-466a-9dda-c30099dcc0a&title=DNS%E6%8A%A5%E6%96%87 "DNS报文")<br />字段太多，很晕？这就对了。<br />就挑几个重点的说说。<br />**Transsaction ID**是事务ID，对于一次**请求**和这个请求对应的**应答**，他们的事务ID是一样的，类似于微服务系统中的log_id。<br />**flag字段**是指标志位，有2个Byte，16个bit，需要关注的是QR，OpCode, RCode。

- **QR**用来标志这是个查询还是响应报文，0是查询，1是响应。
- **OpCode**用来标志操作码，正常查询都是0，不管是域名查ip，还是ip查域名，都属于**正常查询**。可以粗暴的认为平时只会看到0。
- **RCode**是响应码，类似于HTTP里的404, 502 这样的status code。用来表示这次请求的结果是否正常。0是指一切正常。1是指报文格式错误，2服务域名服务器内部错误。

**Queries**字段，是指你实际查询的内容。这里其实包含三部分信息，Name, Type, Class。<br />![查询的内容分成三部分信息](https://cdn.nlark.com/yuque/0/2023/png/396745/1679034484299-01370251-4d06-4125-ace1-72ed1bbc2aef.png#averageHue=%23dbe7e7&clientId=uc0a01572-cc45-4&from=paste&id=ua2f5898b&originHeight=240&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=ud5ada6b9-bcdc-4fc8-9c6f-fd854d070bb&title=%E6%9F%A5%E8%AF%A2%E7%9A%84%E5%86%85%E5%AE%B9%E5%88%86%E6%88%90%E4%B8%89%E9%83%A8%E5%88%86%E4%BF%A1%E6%81%AF "查询的内容分成三部分信息")

- **Name**可以放域名或者IP。比如你要查的是baidu.com这个域名对应的IP，那里面放的就是**域名**，反过来通过IP查对应的域名，那Name字段里放的就是**IP**。
- **Type**是指你想查哪种信息，比如你想查这个域名对应的IP地址是什么，那就是填A（address），如果你想查这个域名有没有其他别名，就填CNAME（Canonical Name）。如果你想查 xiaobaidebug@gmail.com对应的邮箱服务器地址是什么（比如 gmail.com），那就填MX（Mail Exchanger）。除此之外还有很多类型，下面是常见的Type表格。

![](https://cdn.nlark.com/yuque/0/2023/png/396745/1679034485880-748e92f1-dc74-49c6-81cc-f52f8bee9736.png#averageHue=%23b1d79e&clientId=uc0a01572-cc45-4&from=paste&id=ub2616f1b&originHeight=617&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=uef5dc8bf-3a86-4056-a21f-43339240c04&title=)

- Class字段就比较有意思了，可以简单的认为，只会看到它填IN （Internet）。其实DNS协议本来设计出来是考虑到可能会有更多的应用场景的，比如这里还能填CH，HS。大家甚至都不需要知道它们是什么含义，因为随着时间的发展，这些都已经成化石了，知道这个字段的唯一作用，**可能**就是可以在面试的时候可以随意装个x，深藏功与名。

![](https://cdn.nlark.com/yuque/0/2023/png/396745/1679034486515-99bda531-1728-40ce-8fcc-c3575501e6cf.png#averageHue=%23dedada&clientId=uc0a01572-cc45-4&from=paste&id=u42cd25e8&originHeight=622&originWidth=928&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u89581cfa-ef4d-49fd-8401-69cbdb405f0&title=)<br />**Answers**字段，从名字可以看出，跟Queries对应，**一问一答**。作用是返回查询结果，比如通过域名查对应的IP地址，这个字段里就会放入具体的IP信息。<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1679034486660-5bbd097d-dbcd-4b2e-b93a-26af8341cec7.png#averageHue=%23efeeee&clientId=uc0a01572-cc45-4&from=paste&id=ud926c34a&originHeight=610&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u41a83ad7-8be1-488a-937b-010bd02c718&title=)
<a name="Aw1c4"></a>
## 抓包
原理看完了，来抓个包吧。<br />打开wireshark。然后执行
```bash
dig www.baidu.com
```
此时操作系统会发出DNS请求，查询 www.baidu.com对应的IP地址。<br />![DNS_Query](https://cdn.nlark.com/yuque/0/2023/png/396745/1679034486531-ebe36129-3a37-4c1f-b254-428015c53c48.png#averageHue=%23e9e4e4&clientId=uc0a01572-cc45-4&from=paste&id=u9bc70bd3&originHeight=614&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=u810ab80b-701d-4965-bb8d-be135a55ea7&title=DNS_Query "DNS_Query")<br />上面的图里是DNS查询（request）的内容，可以看到它是应用层的协议，传输层用的是**UDP协议**进行数据传输。截图里标红的部分，也就是上面提到的需要重点关注的报文字段内容。其中flag字段是按bit展示的，因此抓包里进行了分行展示。<br />接下来再看下响应（response）的数据包内容。<br />![DNS_Response](https://cdn.nlark.com/yuque/0/2023/png/396745/1679034486727-2834ced9-27d6-42e6-9626-2687be491b20.png#averageHue=%23ebe7e6&clientId=uc0a01572-cc45-4&from=paste&id=u56c8b74d&originHeight=842&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=u50e17fff-7af7-496d-b9dd-18eca6c4d56&title=DNS_Response "DNS_Response")<br />可以看到**事务ID**（Transaction ID）跟DNS**请求**报文是一致的。并且Answers字段里带有两个IP地址。试了下，两个IP地址都是可以正常访问的。<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1679034486775-4f84d00d-b72a-46e3-8ef7-84f423f8bbf4.png#averageHue=%23fcf4ef&clientId=uc0a01572-cc45-4&from=paste&id=u39967d85&originHeight=451&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u0f585c43-715a-45df-876d-23070465b3e&title=)<br />![](https://cdn.nlark.com/yuque/0/2023/png/396745/1679034487945-d06c4ff2-7412-466e-81d7-4ce8bd56bbde.png#averageHue=%23fcf3ed&clientId=uc0a01572-cc45-4&from=paste&id=u46e37cd6&originHeight=481&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=false&status=done&style=none&taskId=u96bd7693-2a3c-4169-b6c0-9c52c8ea696&title=)
<a name="ysrkp"></a>
## 总结

- DNS是非常优秀的高并发分布式系统，**通过层次结构将服务进行拆分**，流量分散到多个服务器中。又通过加入**多级缓存**，让每个层级实际接收到的缓存大大减小，因此大大提高了系统的性能。这两点在做业务开发的过程中是可以借鉴的。
- 插上网线通网时，本机通过DHCP协议获得DNS服务器的地址。
- 根域服务器的IP会以配置的形式加载到每一台DNS服务器当中。因此访问任意一台DNS服务器都能轻松找到根域对应的IP地址。
