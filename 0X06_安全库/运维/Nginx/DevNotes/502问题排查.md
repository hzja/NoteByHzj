刚工作那会，有一次，上游调用服务的老哥说，你的服务报"502错误了，快去看看是为什么吧"。<br />当时那个服务里正好有个**调用日志**，平时会记录各种200,4xx状态码的信息。于是跑到服务日志里去搜索了一下502这个数字，毫无发现。于是跟老哥说，"**服务日志里并没有502的记录**，是不是搞错啦？"<br />现在想来，多少有些不好意思。来看看502错误是什么？从状态码是什么开始聊起。
<a name="XYcuC"></a>
### HTTP状态码
平时在浏览器里逛的某宝和某度，其实都是一个个前端网页。<br />一般来说，前端并不存储太多数据，大部分时候都需要从后端服务器那获取数据。<br />于是前后端之间需要通过TCP协议去建立连接，然后在TCP的基础上传输数据。<br />而TCP是基于数据流的协议，传输数据时，并不会为每个消息加入数据边界，直接使用裸的TCP进行数据传输会有"粘包"问题。<br />因此需要用特地的协议格式去对数据进行解析。于是在此基础上设计了HTTP协议。<br />比如，想要看某个商品的具体信息，其实就是前端发的**HTTP请求**中传入**商品的id**，后端返回的**HTTP响应**中返回商品的价格，商店名，发货地址的信息等。<br />![通过id获取商品详情](https://cdn.nlark.com/yuque/0/2023/png/396745/1681568770961-e09dfb3e-ac9e-4879-8bd0-b7caf4be411d.png#averageHue=%23e5ebee&clientId=u10631945-5e05-4&from=paste&id=u6bfd5f77&originHeight=417&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=ub7b6a0ba-0712-4337-a06b-843ea617bba&title=%E9%80%9A%E8%BF%87id%E8%8E%B7%E5%8F%96%E5%95%86%E5%93%81%E8%AF%A6%E6%83%85 "通过id获取商品详情")<br />这样，表面上，是在刷着各种网页，实际上背后正有多次HTTP消息在不断进行收发。<br />![用户在网上浏览商品](https://cdn.nlark.com/yuque/0/2023/png/396745/1681568770977-db2e2170-fcf7-4203-8c12-bc1a370c608c.png#averageHue=%23e7ecee&clientId=u10631945-5e05-4&from=paste&id=u51b36721&originHeight=417&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=ua24cae14-3c6a-4448-914b-0b572220fab&title=%E7%94%A8%E6%88%B7%E5%9C%A8%E7%BD%91%E4%B8%8A%E6%B5%8F%E8%A7%88%E5%95%86%E5%93%81 "用户在网上浏览商品")<br />但问题就来了，上面提到的都是正常情况，如果有异常情况呢，比如前端发的数据，根本就不是个商品id，而是一张图片，这对于后端服务端来说是不可能给出正常响应的，于是就需要设计一套**HTTP状态码**，用来标识这次HTTP请求响应流程是否正常。通过这个可以影响浏览器的行为。<br />比方说**一切正常**，那服务端返回个200状态码，前端收到后，可以放心使用响应的数据。但如果服务端发现客户端发的东西异常，就响应个4xx状态码，意思是这是个**客户端的错误**，4xx里头的xx可以根据错误的类型，再细分成各种码，比如401是客户端没权限，404是客户端请求了一个根本不存在的网页。反过来，如果是**服务器有问题**，就返回5xx状态码。<br />![4xx和5xx的区别](https://cdn.nlark.com/yuque/0/2023/png/396745/1681568770986-ab7fec61-f595-42a7-ad57-b9515d9f294f.png#averageHue=%23e7ecee&clientId=u10631945-5e05-4&from=paste&id=ue0368ac7&originHeight=353&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=u44416854-2dd8-4592-a808-e1de831aa38&title=4xx%E5%92%8C5xx%E7%9A%84%E5%8C%BA%E5%88%AB "4xx和5xx的区别")<br />但问题就来了。<br />服务端都有问题了，搞严重点，**服务器可能直接就崩溃了，那它还怎么给你返回状态码？**<br />是的，这种情况，**服务端是不可能给客户端返回状态码的**。所以说，**一般情况下5xx的状态码其实并不是服务器返回给客户端的**。<br />它们是由网关返回的，常见的网关，比如Nginx。
<a name="uF5Jd"></a>
### Nginx的作用
回到前后端交互数据的话题上，如果前端用户少，那后端处理起请求来，游刃有余。但随着用户越来越多，后端服务器受**资源限制**，cpu或者内存都可能会严重不足，这时候解决方案也很简单，多搞几台一样的服务器，这样就能将这些前端请求均摊给几个服务器，从而提升处理能力。<br />但要实现这样的效果，前端就得知道后端具体有哪些个服务器，并一一跟他们建立TCP连接。<br />![前端与多个服务器之间建立连接](https://cdn.nlark.com/yuque/0/2023/png/396745/1681568770938-6660ce98-7788-4930-9d79-bd5e09071370.png#averageHue=%23e4ebed&clientId=u10631945-5e05-4&from=paste&id=ue8f866d4&originHeight=494&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=ufa277c84-697c-4de2-8251-26416788dec&title=%E5%89%8D%E7%AB%AF%E4%B8%8E%E5%A4%9A%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B9%8B%E9%97%B4%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5 "前端与多个服务器之间建立连接")<br />也不是不行，但就是麻烦。<br />但这时候如果能有个**中间层挡在它们中间**就好了，这样客户端只需要跟中间层连接，中间层再和服务器建立连接。<br />于是，这个中间层就成了这帮服务器的一个**代理人**一样，客户端有啥事都找代理人，只管发出自己的请求，再由代理人去找某个服务器去完成响应。整个过程下来，客户端只知道自己的请求被代理人帮忙搞定了，但代理人具体找了那个服务器去完成，客户端并不知道，也不需要知道。<br />像这种，**屏蔽掉具体有哪些服务器的代理方式就是所谓的反向代理**。<br />![反向代理](https://cdn.nlark.com/yuque/0/2023/png/396745/1681568770969-ee8b1559-0d03-44dc-8011-56842ae792de.png#averageHue=%23e1e9eb&clientId=u10631945-5e05-4&from=paste&id=u6f0bc83e&originHeight=494&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=u3a04ee07-3ec4-4120-b4d4-9c159539da6&title=%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86 "反向代理")<br />反过来，屏蔽掉具体有哪些客户端的代理方式，就是所谓的正向代理。<br />而这个中间层的角色，一般由Nginx这类网关来充当。<br />另外，由于背后的服务器可能**性能配置各不相同**，有些4核8G，有些2核4G，Nginx能为它们加上**不同的访问权重**，权重高的多转发点请求，通过这个方式实现不同的**负载均衡**策略。
<a name="tE7Sb"></a>
### Nginx返回5xx状态码
有了Nginx这一中间层后，客户端从直连服务端，变成**客户端直连Nginx，再由Nginx直连服务端**。从一个TCP连接变成两个TCP连接。<br />于是，当服务器发生异常时，Nginx发送给服务器的那条TCP连接就不能正常响应，Nginx在得到这一信息后，就会返回5xx错误码给客户端，也就是说5xx的报错，其实是由Nginx识别出来，并返回给客户端的，**服务端本身，并不会有5xx的日志信息**。所以才会出现文章开头的一幕，上游收到了服务的502报错，但在自己的服务日志里却搜索不到这一信息。
<a name="eHbE7"></a>
### 产生502的常见原因
在rfc7231中有关于502错误码的官方解释是
```
502 Bad Gateway
   The 502 (Bad Gateway) status code indicates that the server, while acting as a gateway or proxy, received an invalid response from an inbound server it accessed while attempting to fulfill the request.
```
翻译一下就是，502 (Bad Gateway) 状态代码表示服务器在充当网关或代理时，在尝试满足请求时从它访问的入站服务器接收到无效响应。<br />这对于大部分编程小白来说，不仅没解释到问题，反而只会冒出更多的问号。比如，这上面提到的**无效响应**到底指的是什么？<br />来解释下，它其实是说，502其实是由网关代理（Nginx）发出的，是因为网关代理把客户端的请求转发给了服务端，但服务端却发出了无效响应，而这里的无效响应，**一般**是指TCP的RST报文或四次挥手的FIN报文。<br />四次挥手估计大家背的很熟了，所以略过，来重点说下RST报文是什么。
<a name="KiC06"></a>
#### RST是什么？
都知道TCP正常情况下断开连接是用四次挥手，那是**正常时候**的优雅做法。<br />但**异常情况**下，收发双方都不一定正常，连挥手这件事本身都可能做不到，所以就需要一个机制去强行关闭连接。<br />**RST** 就是用于这种情况，一般用来**异常地**关闭一个连接。它是**TCP包头**中的一个**标志位**，在收到置这个标志位的数据包后，连接就会被关闭，此时接收到 RST的一方，在应用层会看到一个 connection reset 或  connection refused 的报错。<br />![TCP报头RST位](https://cdn.nlark.com/yuque/0/2023/png/396745/1681568771390-7573bbed-723a-49cd-a2ef-845a984eea12.png#averageHue=%2384bc9f&clientId=u10631945-5e05-4&from=paste&id=u60134400&originHeight=450&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=u1c9b3515-00b6-40ea-babb-d1a0c823057&title=TCP%E6%8A%A5%E5%A4%B4RST%E4%BD%8D "TCP报头RST位")<br />而之所以发出RST报文，一般有**两个常见原因**。
<a name="EOhFT"></a>
#### 服务端过早断开连接
Nginx与服务端之间有一条TCP连接，在Nginx将客户端请求转发给服务端时，他两之间按道理会一直保持这条连接，直到服务端将结果正常返回后，再断开连接。<br />但如果服务端**过早断开连接**，而Nginx却还继续发消息过去，Nginx就会收到服务端内核返回的RST报文或四次挥手的FIN报文，迫使Nginx那边的连接结束。<br />**过早断开连接**的原因常见的有**两个**。<br />**第一个**是，**服务端设置的超时时间过短**。不管是用的哪种编程语言，一般都有现成的HTTP库，服务端一般都会有几个timeout参数，比如golang的HTTP服务框架里有个写超时（WriteTimeout），假设设置了2s，那它的含义就是，服务端在收到请求后需要在2s内处理完并将结果写到响应中，如果等不到，就会将连接给断掉。<br />比如接口处理时间是5s，而WriteTimeout却只有2s，在没等到响应写完之前，HTTP框架就会主动将连接给断开。Nginx此时就有可能收到四次挥手的FIN报文（有些框架也可能发RST报文），然后断开连接，于是客户端就会收到一个502报错。<br />遇到这种问题，将WriteTimeout的时间调大一些就好了。<br />![FIN与502的关系](https://cdn.nlark.com/yuque/0/2023/png/396745/1681568771481-13215bf9-9100-41f3-973f-6d7a33694133.png#averageHue=%23d7e3e6&clientId=u10631945-5e05-4&from=paste&id=u51788586&originHeight=744&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=u5022d00d-e525-4f42-9318-1ed2575cc6b&title=FIN%E4%B8%8E502%E7%9A%84%E5%85%B3%E7%B3%BB "FIN与502的关系")<br />**第二个**原因，也是造成502状态码**最常见的原因**，就是**服务端应用进程崩了（crash）。**<br />服务端崩了，也就是当前没有一个进程在监听服务器端口，而此时却尝试**向一个不存在的端口发数据**，服务器的linux内核协议栈就会响应一个RST数据包。同样，这时候Nginx也会给客户端一个502。<br />![RST和502](https://cdn.nlark.com/yuque/0/2023/png/396745/1681568771480-614bcc82-ebe4-42d7-b0f9-4eb464adbba6.png#averageHue=%23dae4e7&clientId=u10631945-5e05-4&from=paste&id=uda50ffc0&originHeight=744&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=u24393e61-b6cd-4f0b-84ea-3dc3051d339&title=RST%E5%92%8C502 "RST和502")<br />在开发过程中，**这种情况是最常见的**。<br />现在大部分的服务器都会将挂掉的服务重启，因此需要**判断下服务是否曾经崩溃过**。<br />如果有对服务端的cpu或者内存做过监控，可以看下CPU或内存的监控图是否出现过**断崖式的突然下跌**。如果有，十有八九百，就是服务端应用程序曾经崩溃过。<br />![cpu突然暴跌](https://cdn.nlark.com/yuque/0/2023/png/396745/1681568771416-834a2022-f47f-4f94-9a50-bd669c090633.png#averageHue=%23f9f8f7&clientId=u10631945-5e05-4&from=paste&id=u31e012cf&originHeight=512&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=uaa38cb32-3bbb-4af7-afd8-b75670d94c2&title=cpu%E7%AA%81%E7%84%B6%E6%9A%B4%E8%B7%8C "cpu突然暴跌")<br />除此之外还可以通过下面的命令，看下**进程上次的启动时间**是什么时候。
```bash
ps -o lstart {pid}
```
比如要看的进程id是13515，命令就需要像下面这样。
```bash
# ps -o lstart 13515
                 STARTED
Wed Aug 31 14:28:53 2022
```
可以看到它上次的启动时间是8月31日，这个时间如果跟你印象中的操作时间有差距，那说明进程可能是崩了之后被重新拉起了。<br />遇到这种问题，**最重要的是找出崩溃的原因**，崩溃的原因就多种多样了，比如，**对未初始化的内存地址进行写操作**，或者**内存访问越界**（数组arr长度明明只有2，代码却读arr[3]）。<br />这种情况几乎都是程序有代码逻辑问题，崩溃一般也会留下**代码堆栈**，可以根据堆栈报错去排查问题，修复之后就好了。比如下面这张图是golang的报错堆栈信息，其他语言的也类似。<br />![报错堆栈](https://cdn.nlark.com/yuque/0/2023/png/396745/1681568771469-56d085c6-fc52-46fc-abea-3ca968528fb9.png#averageHue=%23171c1e&clientId=u10631945-5e05-4&from=paste&id=u8e4a0a46&originHeight=489&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=u0453c7e8-e8e1-47ee-b4da-8ec3aebf9b0&title=%E6%8A%A5%E9%94%99%E5%A0%86%E6%A0%88 "报错堆栈")
<a name="wmkms"></a>
#### 不打印堆栈的情况
但有一些情况，有时候根本**不留下堆栈**。<br />比如内存泄露导致进程占用内存越来越多，最后导致超过服务器的最大内存限制，触发OOM（out of memory），进程直接就被操作系统kill掉。<br />还有更隐蔽的，代码逻辑里隐藏了**主动退出进程**的操作。比如golang的日志打印里有个方法叫`log.Fatalln()`，打印完日志还会顺便执行`os.Exit()`直接退出进程，对源码不了解的新手很容易犯这个错。<br />![打印完顺便还退出进程](https://cdn.nlark.com/yuque/0/2023/png/396745/1681568771907-dd6e5326-823f-4b3c-beb7-8ebc1f013122.png#averageHue=%2316191a&clientId=u10631945-5e05-4&from=paste&id=u544ddabd&originHeight=283&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=u726a6593-866f-4251-b0d4-f76e0569070&title=%E6%89%93%E5%8D%B0%E5%AE%8C%E9%A1%BA%E4%BE%BF%E8%BF%98%E9%80%80%E5%87%BA%E8%BF%9B%E7%A8%8B "打印完顺便还退出进程")<br />如果很明确服务没有崩过。那继续往下看。
<a name="RObVY"></a>
#### 网关将请求打到了一个不存在的IP上
Nginx是通过配置的形式来代理多个服务器。这个配置一般是放在 /etc/nginx/nginx.conf 中。<br />打开它，可能会看到类似下面这样的信息。
```nginx
upstream sample.top {
  server 10.14.12.19:9235 weight=2;
  server 10.14.16.13:8145 weight=5;
  server 10.14.12.133:9702 weight=8;
  server 10.14.11.15:7035 weight=10;
}
```
上面**配置**的含义是，如果客户端访问sample.top域名，Nginx就会将客户端的请求转发到下面的4个服务器ip上，ip边上还有个weight权重，权重越高，被转发到的次数就越多。<br />可以看出，Nginx具有相当丰富的配置能力。但要注意的是，这些个文件是需要自己**手动配置**的。对于服务器少，且不怎么变化的情况，这当然没问题。<br />但现在已经是云原生时代了，很多公司内部都有自己的云产品，服务自然也会上云。一般来说每次更新服务，都可能会将服务部署到一台新的机器上。而这个ip也会随着改变，难道每发布一次服务，都需要手动去Nginx上改配置吗？这显然不现实。<br />如果能在服务启动时，让服务主动将自己的ip告诉Nginx，然后Nginx自己生成这样的一个配置并重新加载，那事情就简单多了。<br />为了实现这样一个**服务注册的功能**，不少公司都会基于Nginx进行二次开发。<br />但如果这个服务注册功能有问题，比方说服务启动后，新服务没注册上，但老服务已经被销毁了。这时候Nginx还将请求打到老服务的IP上，由于老服务所在的机器已经没有这个服务了，所以服务器内核就会响应RST，Nginx**收到RST后回复502给客户端**。<br />![实例已经销毁但配置没删IP](https://cdn.nlark.com/yuque/0/2023/png/396745/1681568771942-f15c51a4-4dbb-4513-811c-2f3a6698954a.png#averageHue=%23e1e8eb&clientId=u10631945-5e05-4&from=paste&id=u49e118f6&originHeight=525&originWidth=1080&originalType=url&ratio=2.5&rotation=0&showTitle=true&status=done&style=none&taskId=u59d5daaf-0dca-4af0-b50b-e05912b65ce&title=%E5%AE%9E%E4%BE%8B%E5%B7%B2%E7%BB%8F%E9%94%80%E6%AF%81%E4%BD%86%E9%85%8D%E7%BD%AE%E6%B2%A1%E5%88%A0IP "实例已经销毁但配置没删IP")<br />要排查这种问题也不难。<br />这个时候可以看下Nginx侧是否有打印相关的日志，看下转发的IP端口是否符合预期。<br />如果不符合预期，可以去找找做这个基础组件的同事，进行一波**友好的交流**。
<a name="R0Prf"></a>
### 总结

- HTTP状态码用来表示响应结果的状态，其中200是正常响应，4xx是客户端错误，5xx是服务端错误。
- 客户端和服务端之间加入Nginx，可以起到**反向代理和负载均衡**的作用，客户端只管向Nginx请求数据，并不关心这个请求具体由哪个服务器来处理。
- 后端服务端应用如果发生崩溃，Nginx在访问服务端时会收到服务端返回的RST报文，然后给客户端返回502报错。502并不是服务端应用发出的，而是Nginx发出的。因此发生502时，后端服务端很可能没有没有相关的502日志，需要在Nginx侧才能看到这条502日志。
- 如果发现502，优先通过监控排查服务端应用是否发生过崩溃重启，如果是的话，再看下是否留下过崩溃堆栈日志，如果没有日志，看下是否可能是oom或者是其他原因导致进程主动退出。如果进程也没崩溃过，去排查下Nginx的日志，看下是否将请求打到了某个不知名IP端口上。
