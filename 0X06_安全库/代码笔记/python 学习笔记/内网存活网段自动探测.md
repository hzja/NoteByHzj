有时候打内网，需要发现一些奇怪的网段，说不定就能发现更多的资产，所以探测内网需要一个脚本实现自动化。

<a name="6DMsp"></a>
## 思路
一般内网地址范围主要如下：<br />内网ip地址<br />A类地址：10.0.0.0--10.255.255.255<br />B类地址：172.16.0.0--172.31.255.255 <br />C类地址：192.168.0.0--192.168.255.255

一般情况下不同的网段是需要网关来实现网络互连，通常网关的地址都是.1，例如C类内网ip地址的某个网关地址就是192.168.1.1，所以探测网段存活，可以先尝试探测网关地址的存活。

<a name="eApee"></a>
## 脚本
考虑到A类地址有点大，一开始写出来的时候，直接把电脑CPU跑到100%了。所以利用多线程写了个B、C类的地址内网探测存活，凑合着先用着。
```python

import sys
import threading
import time
import re
import os

def c(i,a):
    global num
    command1 = ('ping -n 1 172.{}.{}.1'.format(i,a)) #windows是n, linux是c
    b = os.popen(command1).read()   
    c = re.findall(r"\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b", b)
    if 'TTL' in b:
        num = num +1
        #c = re.findall(r"\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b", b)
        print(c[0])
    else:
        pass
        #print(c[0],"不通")

def zhuji(i):
    global num
    command1 = ('ping -n 1 192.168.{}.1'.format(i))  #windows是n, linux是c
    b = os.popen(command1).read()
    c = re.findall(r"\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b", b)
    if 'TTL' in b:
        num = num +1
        #c = re.findall(r"\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b", b)
        print(c[0])
    else:
        pass
        #print(c[0],"不通")


def scan_thread():  # 线程函数
    print("开始运行**")
    threads = []    # 线程列表
    for i in range(0,256):
        threads.append(         # 添加线程
            threading.Thread(target=zhuji, args=(i,))
        )

    for thread in threads:      # 遍历列表 启动线程
        thread.start()

    for thread in threads:      # 遍历列表 等待结束线程
        thread.join()

def scan_thread1():  # 线程函数
    print("开始运行**")
    threads = []    # 线程列表
    for i in range(16,32):
        for a in range(0,256):
            threads.append(         # 添加线程
                threading.Thread(target=c, args=(i,a))
            )

    for thread in threads:      # 遍历列表 启动线程
        thread.start()

    for thread in threads:      # 遍历列表 等待结束线程
        thread.join()

def start(argv):
    try:
        if argv[1] == "-c":
            scan_thread()
            print("内网存活网段",num,"个",'\n',"内网存活网段探测完毕")
        elif argv[1] == "-b":
            scan_thread1()
            print("内网存活网段",num,"个",'\n',"内网存活网段探测完毕")
        elif argv[1] == "-h":
            print('''
              -h       #帮助
              -c       #C类地址(192.168.0.0--192.168.255.255)内网段存活探测
              -b       #B类地址(172.16.0.0--172.31.255.255)内网段存活探测 ''')
    except:
        print("输入有问题")
    

if __name__ == '__main__':
    global num
    num = 0
    #t1 = time.time()
    #scan_thread1()
    #print("运行所需要的时间：",(time.time()-t1))
    start(sys.argv[0:])
    #print("内网存活网段探测完毕")

```
<a name="2ilfk"></a>
## 效果图
![image.png](https://cdn.nlark.com/yuque/0/2021/png/1345801/1621616611618-cb8b65e3-0861-464f-a6f2-233136796560.png#align=left&display=inline&height=420&originHeight=560&originWidth=797&size=55854&status=done&style=none&width=598)<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/1345801/1621754924794-a049b9a7-5e9b-4e9f-9b0e-49cc102a5447.png#align=left&display=inline&height=376&originHeight=752&originWidth=410&size=42310&status=done&style=none&width=205)

<a name="D1acw"></a>
## 不足
B类地址有时候也会卡壳，可能是一些异常处理程序没写好，10段太大了，不知道怎么下手搞。

<a name="r8QZu"></a>
## 修改后
跑10段和172段不是问题。但是会出现一个奇怪的地方。
```python
import sys
import threading
import time
import re
import os
import queue

def work(q):
    global num
    while True:
        if q.empty():
            return
        else:
            t = q.get()
            try:
                #print(t)
                command1 = ('ping -n 1 {}'.format(t)) #windows是n, linux是c
                b = os.popen(command1).read()
                if 'TTL' in b:
                    c = re.findall(r"\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b", b)
                    num = num +1
                #c = re.findall(r"\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b", b)
                    print(c[0])
                else:
                    pass
            except:
                pass
def b():
    q = queue.Queue()
    for i in range(16,32):
        for a in range(0,256):
            q.put('172.{}.{}.1'.format(i,a))
    print("获取了",q.qsize(),"个目标")
    thread_num = 500
    threads = []
    for i in range(thread_num):
        t = threading.Thread(target=work, args=(q,))
        threads.append(t)
    # 创建5个线程
    for i in range(thread_num):
        threads[i].start()
    for i in range(thread_num):
        threads[i].join()

def c():
    q = queue.Queue()
    for i in range(0,256):
        for a in range(0,256):
            q.put('10.{}.{}.1'.format(i,a))
    print("获取了",q.qsize(),"个目标")
    thread_num = 500
    threads = []
    for i in range(thread_num):
        t = threading.Thread(target=work, args=(q,))
        threads.append(t)
    # 创建5个线程
    for i in range(thread_num):
        threads[i].start()
    for i in range(thread_num):
        threads[i].join()

def a(i):
    global num
    command1 = ('ping -n 1 192.168.{}.1'.format(i))  #windows是n, linux是c
    b = os.popen(command1).read()
    c = re.findall(r"\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b", b)
    if 'TTL' in b:
        num = num +1
        #c = re.findall(r"\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b", b)
        print(c[0])
    else:
        pass
        #print(c[0],"不通")


def scan_thread():  # 线程函数
    print("开始运行**")
    threads = []    # 线程列表
    for i in range(0,256):
        threads.append(         # 添加线程
            threading.Thread(target=a, args=(i,))
        )

    for thread in threads:      # 遍历列表 启动线程
        thread.start()

    for thread in threads:      # 遍历列表 等待结束线程
        thread.join()


def start(argv):
    try:
        if argv[1] == "-c":
            scan_thread()
            print("内网存活网段",num,"个",'\n',"内网存活网段探测完毕")
        elif argv[1] == "-b":
            b()
            print("内网存活网段",num,"个",'\n',"内网存活网段探测完毕")
        elif argv[1] == "-a":
            a()
            print("内网存活网段",num,"个",'\n',"内网存活网段探测完毕")
        elif argv[1] == "-h":
            print('''
              -h       #帮助
              -c       #C类地址(192.168.0.0--192.168.255.255)内网段存活探测
              -b       #B类地址(172.16.0.0--172.31.255.255)内网段存活探测 
              -a       #A类地址(10.0.0.0--10.255.255.255)内网段存活探测''')
    except:
        print("输入有问题")
    

if __name__ == '__main__':
    global num
    num = 0
    #t1 = time.time()
    #scan_thread1()
    #print("运行所需要的时间：",(time.time()-t1))
    start(sys.argv[0:])
```
程序会把cpu跑到100，到100的时候就会停顿一下，缓下来之后又继续不断输出。<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/1345801/1622342246431-ae06dbb6-aeb2-42ad-af9b-6b7e8556c0e3.png#align=left&display=inline&height=456&originHeight=912&originWidth=1483&size=173661&status=done&style=none&width=741.5)
<a name="4nRC9"></a>
## 修改后的不足
代码冗余有点多，仅仅完成了实现自动化功能点，cpu100的情况还没处理好。
