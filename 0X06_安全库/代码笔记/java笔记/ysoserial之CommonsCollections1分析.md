<a name="qD8WU"></a>
# java反射和cc链的关系
- java反射就是运行时检查、获取和操作类的信息，包括类名、字段、方法、构造函数
- commons-collections(cc链) 只是Apache 中的一个开发库
- Java反射和Commons Collections 是两个不同的概念，但它们可以在某些情况下一起使用，比如Commons Collections在特定版本下存在漏洞，攻击者可以会通过恶意构造的序列化数据触发远程代码执行漏洞

<a name="pV1l9"></a>
# 杂记
![图片.png](https://cdn.nlark.com/yuque/0/2021/png/1345801/1613290692049-42ed3c28-bc26-48de-b9d7-05cb4cd0e8e8.png#averageHue=%23ece9e6&height=128&id=hwPRP&originHeight=128&originWidth=1320&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12941&status=done&style=none&title=&width=1320)

代码看到如下两行的时候，不知道是什么意思<br />**final **Transformer transformerChain = **new **ChainedTransformer(<br />   **new **Transformer[]{ **new **ConstantTransformer(1) });<br />![图片.png](https://cdn.nlark.com/yuque/0/2021/png/1345801/1613575389214-4b5b8d3f-c0ae-4ee6-b99f-0b8b75f6c503.png#averageHue=%23faf6f4&height=214&id=AHf7P&originHeight=427&originWidth=1046&originalType=binary&ratio=1&rotation=0&showTitle=false&size=32205&status=done&style=none&title=&width=523)<br />Transformer接口中的transform在ChainedTransformer也是存在的，<br />![图片.png](https://cdn.nlark.com/yuque/0/2021/png/1345801/1613635536989-91b511fc-8f67-433e-bed7-cb56eda543f8.png#averageHue=%23fbf8f2&height=45&id=Zo7Uu&originHeight=90&originWidth=823&originalType=binary&ratio=1&rotation=0&showTitle=false&size=8613&status=done&style=none&title=&width=411.5)<br />Transformer是什么东西，ChainedTransformer是个什么类<br />Transformer是个接口，所以Transformer transformerChain其实就是创建个transformerChain对象<br />![图片.png](https://cdn.nlark.com/yuque/0/2021/png/1345801/1613574367357-1e475d4d-9f5a-4dbb-88bb-a223efe07324.png#averageHue=%23f7f4ed&height=157&id=kHQVK&originHeight=313&originWidth=482&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11904&status=done&style=none&title=&width=241)<br />ChainedTransformer是个类，并且这个类实现了Transformer和序列化的接口<br />![图片.png](https://cdn.nlark.com/yuque/0/2021/png/1345801/1613574460578-c671dd01-6a95-424c-a22e-6dae7e2c123b.png#averageHue=%23f9f7f3&height=293&id=EzC6O&originHeight=585&originWidth=817&originalType=binary&ratio=1&rotation=0&showTitle=false&size=33476&status=done&style=none&title=&width=408.5)<br />对**final **Transformer transformerChain = **new **ChainedTransformer(<br />   **new **Transformer[]{ **new **ConstantTransformer(1) }); <br />中的ConstantTransformer跟进，发现是返回iConstant，所以**new **Transformer[]{ **new **ConstantTransformer(1)的意思是返回的值存入Transformer数组<br />![图片.png](https://cdn.nlark.com/yuque/0/2021/png/1345801/1613576002399-2c41d8b4-caa5-4585-87e9-b8add5a781a4.png#averageHue=%23faf9f5&height=90&id=lWAFs&originHeight=180&originWidth=667&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9608&status=done&style=none&title=&width=333.5)<br />对对**final **Transformer transformerChain = **new **ChainedTransformer中的ChainedTransformer类跟进进行分析，传入的transformers是赋值给iTransformers的<br />然而这个iTransformers在transform方法中其实就是循环调用成员变量iTransformers数组的中的tranform方法，然后再返回<br />![图片.png](https://cdn.nlark.com/yuque/0/2021/png/1345801/1613578585368-1536a8f4-70cb-4396-a138-d5f9b466e703.png#averageHue=%23fbfaf8&height=313&id=WVJVP&originHeight=417&originWidth=688&originalType=binary&ratio=1&rotation=0&showTitle=false&size=18417&status=done&style=none&title=&width=516)<br />lazymap中的get方法，如果传入的key不存在，就执行**this**.factory.transform(key); 然而这个transform接口是实现命令执行的关键<br />![图片.png](https://cdn.nlark.com/yuque/0/2021/png/1345801/1614313390353-73266ff7-95b1-48f2-9728-bc4f96487f82.png#averageHue=%23f9f7f3&height=275&id=jq0bW&originHeight=549&originWidth=657&originalType=binary&ratio=1&rotation=0&showTitle=false&size=29164&status=done&style=none&title=&width=328.5)

-----------------------------------------------<br />以上太杂乱
<a name="U5onB"></a>
## 重新分析
其实在cc1中，有ChainedTransformer，ConstantTransformer，InvokerTransformer这三个类，就能达到命令执行的效果，这三个类都会实现Transformer接口，Transformer接口包含一个transform方法。<br />![图片.png](https://cdn.nlark.com/yuque/0/2021/png/1345801/1613658826200-3b6df726-d66d-40f5-b38e-90afff4e51a1.png#averageHue=%23f9f4f2&height=283&id=s9rGS&originHeight=565&originWidth=916&originalType=binary&ratio=1&rotation=0&showTitle=false&size=39879&status=done&style=none&title=&width=458)<br />Transformer[]数组里的一大段内容其实就是为了拼接成这个效果Runtime.getMthod().getRuntime().invoke().exec("execArgs")<br />如下poc，即可达到命令执行弹框计算器。
```java
package ysoserial.payloads;

import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.*;

public class test2 {

    public static void main(String[] args){
        ChainedTransformer transformerChain = new ChainedTransformer(new Transformer[] {
            new ConstantTransformer(Runtime.class),
            new InvokerTransformer("getMethod", new Class[] {
                String.class, Class[].class }, new Object[] {
                "getRuntime", new Class[0] }),
            new InvokerTransformer("invoke", new Class[] {
                Object.class, Object[].class }, new Object[] {
                null, new Object[0] }),
            new InvokerTransformer("exec",
                new Class[] { String.class }, new Object[]{"calc.exe"})});
        transformerChain.transform(1);
    }
}
```
**对这段poc进行代码调试分析，其实也相当于对cc1链后半段的利用链进行分析。**<br />在ChainedTransformer transformerChain = new ChainedTransformer中打下断点，开始调试。<br />![图片.png](https://cdn.nlark.com/yuque/0/2021/png/1345801/1613659105776-cfb03936-7ba8-471d-96ce-936a9b576147.png#averageHue=%23f9fbda&height=53&id=N1Qgl&originHeight=53&originWidth=985&originalType=binary&ratio=1&rotation=0&showTitle=false&size=4500&status=done&style=none&title=&width=985)<br />**对**ChainedTransformer进行跟进，会跳到ChainedTransformer类的ChainedTransformer方法，可以看到传入了4数组的值，并且transformers会赋值给iTransformers<br />![图片.png](https://cdn.nlark.com/yuque/0/2021/png/1345801/1613659306058-7ee51a83-044a-414d-94f4-5b8abce60dde.png#averageHue=%23f9f7f1&height=159&id=ayjFG&originHeight=317&originWidth=1013&originalType=binary&ratio=1&rotation=0&showTitle=false&size=18799&status=done&style=none&title=&width=506.5)<br />继续进行下一步的跟进，回到test2.java中的poc，会跳到transformerChain.transform(1);代码处，其实就是使用ChainedTransformer中的transform方法。因为transformerChain是ChainedTransformer实例对象。<br />![图片.png](https://cdn.nlark.com/yuque/0/2021/png/1345801/1613659481386-bd65363a-3333-4f79-ab88-9df3af74e8a2.png#averageHue=%23fbf9f7&height=190&id=zL81o&originHeight=380&originWidth=976&originalType=binary&ratio=1&rotation=0&showTitle=false&size=26640&status=done&style=none&title=&width=488)<br />至于为什么transformerChain.transform()括号中要有数值，是因为ChainedTransformer中的transform需要传入参数才能执行，否则会报错，所以随便传入数值就可以了<br />![图片.png](https://cdn.nlark.com/yuque/0/2021/png/1345801/1613919797917-eb88c14e-bca0-4f94-9c0a-bae656be7aad.png#averageHue=%23f9f7f5&height=370&id=uWyBB&originHeight=740&originWidth=1301&originalType=binary&ratio=1&rotation=0&showTitle=false&size=64886&status=done&style=none&title=&width=650.5)<br />进入方法体，继续跟进，来到了ChainedTransformer中的transform方法，是个循环语句，<br />![图片.png](https://cdn.nlark.com/yuque/0/2021/png/1345801/1613659622890-2f34257e-c9be-4c93-801a-ad86831177e0.png#averageHue=%23fcfbfb&height=97&id=kL5L7&originHeight=193&originWidth=974&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10870&status=done&style=none&title=&width=487)<br />继续跟进，会进入到ConstantTransformer类中的transform方法，这个方法会返回一开始transformerChain.transform(1)中的值<br />![图片.png](https://cdn.nlark.com/yuque/0/2021/png/1345801/1613659834790-0234418f-fe4f-419d-b5e1-ca7c6881124e.png#height=47&id=cBSPR&originHeight=94&originWidth=707&originalType=binary&ratio=1&rotation=0&showTitle=false&size=5569&status=done&style=none&title=&width=353.5)<br />继续对代码跟进，会返回来ChainedTransformer中的transform方法<br />![图片.png](https://cdn.nlark.com/yuque/0/2021/png/1345801/1613660263434-4ca2abef-f0d7-4588-a070-abb49d9095ea.png#height=56&id=s7iqV&originHeight=111&originWidth=1127&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9600&status=done&style=none&title=&width=563.5)<br />继续跟进，这个时候会传进来java.lang.Runtime这个类<br />![图片.png](https://cdn.nlark.com/yuque/0/2021/png/1345801/1613660327510-018a6f01-7298-47d3-a5ee-3a4f76577f8a.png#height=58&id=a19Wc&originHeight=116&originWidth=1047&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9911&status=done&style=none&title=&width=523.5)<br />继续跟进，java.lang.Runtime这个类会被传入InvokerTransformer中的transform方法，可以看到，这个方法里边如果输入的值不为空，就会调用到反射，<br />![图片.png](https://cdn.nlark.com/yuque/0/2021/png/1345801/1613660555845-fbb61e3d-dc8a-4176-a35b-5a064f438da6.png#height=118&id=lVtWT&originHeight=236&originWidth=1530&originalType=binary&ratio=1&rotation=0&showTitle=false&size=22516&status=done&style=none&title=&width=765)<br />继续跟进到下一步，会回到ChainedTransformer中的transform方法，这时候的object是上一个步骤中return返回的method.invoke值:java.lang.runtime<br />![图片.png](https://cdn.nlark.com/yuque/0/2021/png/1345801/1613661130617-b04469a3-980a-4649-a010-e97f14c5bad4.png#height=105&id=K6X7s&originHeight=210&originWidth=1338&originalType=binary&ratio=1&rotation=0&showTitle=false&size=14624&status=done&style=none&title=&width=669)<br />继续不断的跟进下一步，又会来到InvokerTransformer中transform的方法体，这个时候传入的**this**.iMethodName值已经是invoke了<br />![图片.png](https://cdn.nlark.com/yuque/0/2021/png/1345801/1613661908370-b1856010-024a-44bc-8dcc-a1cc384105ca.png#height=354&id=hi7I9&originHeight=708&originWidth=1515&originalType=binary&ratio=1&rotation=0&showTitle=false&size=65552&status=done&style=none&title=&width=757.5)<br />整个过程一直循环到exec方法，这个时候invoke执行完就会弹出计算器了<br />![图片.png](https://cdn.nlark.com/yuque/0/2021/png/1345801/1613662034330-9666d471-ec29-4be6-b137-da5217764f4f.png#height=359&id=lQynw&originHeight=718&originWidth=1522&originalType=binary&ratio=1&rotation=0&showTitle=false&size=69013&status=done&style=none&title=&width=761)<br />![图片.png](https://cdn.nlark.com/yuque/0/2021/png/1345801/1613662095994-ba3495bb-b019-4698-9619-d546ca10858b.png#height=352&id=n2IrB&originHeight=704&originWidth=968&originalType=binary&ratio=1&rotation=0&showTitle=false&size=171401&status=done&style=none&title=&width=484)

<a name="DEc0t"></a>
## 前半链

![图片.png](https://cdn.nlark.com/yuque/0/2021/png/1345801/1613925115317-8d36aed6-40a8-448c-98fc-2bba89428be1.png#height=288&id=OXZru&originHeight=575&originWidth=873&originalType=binary&ratio=1&rotation=0&showTitle=false&size=126857&status=done&style=none&title=&width=436.5)<br />lazymap.get通过反射构造的payload，后面还是得看动态代理。<br />![图片.png](https://cdn.nlark.com/yuque/0/2021/png/1345801/1613925085128-7e414acb-ba98-4599-a282-ab9f1f799b9f.png#height=348&id=Avbcx&originHeight=695&originWidth=1178&originalType=binary&ratio=1&rotation=0&showTitle=false&size=56967&status=done&style=none&title=&width=589)<br />lazyMap中的get方法也是会触发到transform<br />![图片.png](https://cdn.nlark.com/yuque/0/2021/png/1345801/1614493394495-65effad3-2fd7-4342-a673-ac640ad48fbc.png#height=235&id=NTnbN&originHeight=470&originWidth=609&originalType=binary&ratio=1&rotation=0&showTitle=false&size=25826&status=done&style=none&title=&width=304.5)<br />![图片.png](https://cdn.nlark.com/yuque/0/2021/png/1345801/1614499339244-141ad862-d834-4947-9f50-0a0c1cf5800c.png#height=361&id=VJFeU&originHeight=722&originWidth=1632&originalType=binary&ratio=1&rotation=0&showTitle=false&size=67765&status=done&style=none&title=&width=816)<br />InvocationHandler#invoke的78行代码中调用了this.memberValues#get，此时的this.memberValues为之前设置好的lazymap，所以这里调用的是lazymap#get，从而触发后边的rce链。<br />这里还是比较绕的，因为设置了两个handler，但是第一个handler是为了触发lazymap#get，而第二个handler实际上只是为了触发代理类所设置handler的invoke方法。<br />AnnotationInvocationHandler中的readObject方法<br />![图片.png](https://cdn.nlark.com/yuque/0/2021/png/1345801/1614501180404-fa29c317-abee-4b5a-85aa-67392c42b8ab.png#height=159&id=jT0WW&originHeight=318&originWidth=905&originalType=binary&ratio=1&rotation=0&showTitle=false&size=15462&status=done&style=none&title=&width=452.5)
<a name="LqCwJ"></a>
## 总结

所以经过这一轮的小分析，三大Tranformer接口的tranform方法的作用<br />1.ChainedTransformer：循环调用成员变量iTransformers数组的中的tranform方法。比如在cc1中，Transformer[]数组里的一大段内容其实就是为了拼接成这个效果Runtime.getMthod().getRuntime().invoke().exec("execArgs")<br />![图片.png](https://cdn.nlark.com/yuque/0/2021/png/1345801/1613662262194-9a406cc2-e37c-4d94-8eed-1d1803d160d5.png#height=162&id=MwuEA&originHeight=216&originWidth=648&originalType=binary&ratio=1&rotation=0&showTitle=false&size=7729&status=done&style=none&title=&width=486)<br />2.InvokerTransformer：通过反射的方法调用传入tranform方法中的inuput对象的方法（方法通过成员变量iMethodName设置，参数通过成员变量iParamTypes设置）<br />![图片.png](https://cdn.nlark.com/yuque/0/2021/png/1345801/1613662346305-0d146ea5-5685-40a0-89be-4b0dcc95ade5.png#height=265&id=bsJeD&originHeight=529&originWidth=1526&originalType=binary&ratio=1&rotation=0&showTitle=false&size=42512&status=done&style=none&title=&width=763)<br />3.ConstantTransformer：返回成员变量iConstant的值。


