TCP<br />平时，想要知道，自己的机器到目的机器之间，**网络通不通**，一般会执行**ping命令**。<br />一般对于状况良好的网络来说，能看到它对应的loss丢包率为0%，也就是所谓的**能ping通**。如果看到丢包率100%，也就是**ping不通**。<br />![ping正常](https://cdn.nlark.com/yuque/0/2022/png/396745/1662081328545-6305ed08-68ff-4d10-897e-2263e3b1be5c.png#clientId=u4f02e68b-ac86-4&from=paste&id=ucb99ec4b&originHeight=409&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=u4a7b7bc6-4269-4029-8b33-567ebe51165&title=ping%E6%AD%A3%E5%B8%B8 "ping正常")<br />![ping不通](https://cdn.nlark.com/yuque/0/2022/png/396745/1662081328565-50d3322b-2e08-4a19-a23b-dd94b3bab13d.png#clientId=u4f02e68b-ac86-4&from=paste&id=u268c89e8&originHeight=306&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=u42bafb1f-5b60-4de3-a620-8884d7fb376&title=ping%E4%B8%8D%E9%80%9A "ping不通")<br />那么问题来了，假设能**ping**通某台机器，那这时候如果改用**TCP协议**去发数据到目的机器，**也一定能通吗？**<br />或者换个问法，**ping和tcp协议走的网络路径是一样的吗？**<br />这时候第一反应就是**不一定**，因为ping完之后中间链路里的**某个路由器可能会挂了（断电了）**，再用TCP去连就会走别的路径。<br />也没错。但假设，**中间链路没发生任何变化呢？**<br />先直接说答案。<br />**不一定，走的网络路径还是有可能是不同的。**<br />**来看ping数据包和tcp数据包的区别**。<br />![ping和TCP发消息的区别](https://cdn.nlark.com/yuque/0/2022/png/396745/1662081328629-6bbf0021-65b9-4915-bbcc-d795b67becfe.png#clientId=u4f02e68b-ac86-4&from=paste&id=u750e7a06&originHeight=1144&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=ubd7d9b07-3ef8-4ad8-9a0e-c81930ca69c&title=ping%E5%92%8CTCP%E5%8F%91%E6%B6%88%E6%81%AF%E7%9A%84%E5%8C%BA%E5%88%AB "ping和TCP发消息的区别")<br />网络是分层的，每一层都有对应协议。<br />![五层网络协议对应的消息体变化分析](https://cdn.nlark.com/yuque/0/2022/png/396745/1662081328585-61dd5c6c-7304-4fab-b094-7c306b25b758.png#clientId=u4f02e68b-ac86-4&from=paste&id=ud788c687&originHeight=720&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=u00de31ba-35ed-4831-ae42-b8905ec5f09&title=%E4%BA%94%E5%B1%82%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%AF%B9%E5%BA%94%E7%9A%84%E6%B6%88%E6%81%AF%E4%BD%93%E5%8F%98%E5%8C%96%E5%88%86%E6%9E%90 "五层网络协议对应的消息体变化分析")<br />而这网络层就像搭积木一样，上层协议都是基于下层协议搭出来的。<br />**不管是ping（用了ICMP协议）还是tcp本质上都是基于网络层IP协议的数据包，而到了物理层，都是二进制01串，都走网卡发出去了。**<br />如果网络环境没发生变化，目的地又一样，那按道理说他们走的网络路径应该是一样的，什么情况下会不同呢？<br />就从**路由**这个话题聊起吧。
<a name="PcKCQ"></a>
## 网络路径
当在两台机器之间传输数据。本机和目的机器之间会建立一条连接，像**一条管道**一样，数据从这头到那头。这条管道其实是为了方便理解而抽象出来的概念。<br />实际上，将数据包从本地网卡发出之后，会经过各种**路由器（或者交换机）**，才能到达目的机器。<br />这些路由器数量众多，相互之间可以互连，连起来之后就像是一张大网，所以叫**"网络"**可以说是非常的形象。<br />![路由器构成的网络](https://cdn.nlark.com/yuque/0/2022/png/396745/1662081328639-f1addbd3-8c27-4e6f-bd27-4f4f16b748f0.png#clientId=u4f02e68b-ac86-4&from=paste&id=u082ae10d&originHeight=288&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=u441a7121-35f0-4196-a557-6cdfbbd39f1&title=%E8%B7%AF%E7%94%B1%E5%99%A8%E6%9E%84%E6%88%90%E7%9A%84%E7%BD%91%E7%BB%9C "路由器构成的网络")<br />考虑到交换机有的功能，路由器基本上都支持，所以这边只讨论路由器。<br />那么现在问题来了，**路由器收到数据后，怎么知道应该走哪条路径，传给哪个路由器？**
<a name="DXi7V"></a>
## 路径由什么决定？
在上面的那么大一张网络中，随便一个路由器都有可能走任何一个路径，将数据发到另外一个路由器上，<br />但路由和路由之间距离，带宽啥的可能都不同。<br />于是就很需要知道，**两点之间走哪条路才是最优路径**。<br />于是问题就变成了这样一个**图状结构**。每条边都带有**成本或权重**，算这上面**任意两点的最短距离**。<br />![路由器和Dijkstra](https://cdn.nlark.com/yuque/0/2022/png/396745/1662081329115-a1dfaae1-3029-4f20-84ae-1eb097c41699.png#clientId=u4f02e68b-ac86-4&from=paste&id=u1f5ff366&originHeight=432&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=uf852a5c4-97fc-420a-8005-4ac2bd74ae6&title=%E8%B7%AF%E7%94%B1%E5%99%A8%E5%92%8CDijkstra "路由器和Dijkstra")<br />这时候想必大家回忆压不住要上来了。<br />这题熟，这就是大学时候刷的**Dijkstra算法**。菊花厂的OJ笔试题集里也经常出现，现在终于明白为什么他们家的笔试题里图类题目比别的大厂貌似要多一些了吧，因为菊花厂就是搞通信的，做路由器的老玩家了。
<a name="l1UEb"></a>
### 路由表的生成
基于**Dijkstra算法**，封装出了一个新的协议，**OSPF协议**（**O**pen **S**hortest **P**ath **F**irst, 开放最短路径优先）。<br />有了OSPF，路由器就得到了网络图里自己到其他点之间的**最短距离**，于是就知道了**数据包要到某个点，该走哪条最优路径**。<br />将这些信息汇成一张表，也就是常说的**路由表**。<br />路由表里记录了到什么IP需要走什么端口，以及走这条路径的成本（metric）。<br />可以通过 route 命令查看到。<br />![route表](https://cdn.nlark.com/yuque/0/2022/png/396745/1662081329078-f956f233-f8f4-4fdc-9a1d-9d9333ba50d7.png#clientId=u4f02e68b-ac86-4&from=paste&id=ub0ae99d5&originHeight=286&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=u75f69cd0-ff59-4a14-bc2d-d521341f1bc&title=route%E8%A1%A8 "route表")
<a name="s2mds"></a>
### 路由表决定数据包路径
数据包在发送的过程中，会在**网络层**加入**目标地址IP**。<br />路由器会根据这个**IP**跟**路由表**去做匹配。<br />然后路由表，会告诉路由器，什么样的消息该转发到什么端口。<br />举个例子。<br />![通过路由表转发数据](https://cdn.nlark.com/yuque/0/2022/png/396745/1662081329106-ba9aaef8-fdbb-4629-9b4b-2170ecfe32fc.png#clientId=u4f02e68b-ac86-4&from=paste&id=u89e7d027&originHeight=667&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=u8d0391ae-de11-43a0-8731-d2f4a29f4b6&title=%E9%80%9A%E8%BF%87%E8%B7%AF%E7%94%B1%E8%A1%A8%E8%BD%AC%E5%8F%91%E6%95%B0%E6%8D%AE "通过路由表转发数据")<br />假设A要发消息到D。也就是192.168.0.105/24要发消息到192.168.1.11/24。<br />那么A会把消息经发到路由器。<br />路由器已知目的地IP192.168.1.11/24 ，去跟**路由表**做匹配，发现192.168.1.0/24, 就在e2端口，那么就会把消息从e2端口发出，（可能还会经过交换机）最后把消息打到目的机器。<br />当然，如果路由表里找不到，那就打到**默认网关**吧，也就是从e1口发出，发到IP192.0.2.1。**这个路由器的路由表不知道该去哪，说不定其他路由器知道**。
<a name="sprwq"></a>
### 路由表的匹配规则
上面的例子里，是只匹配上了路由表里的**一项**，所以只能是它了。<br />但是，条条大路通罗马。实际上能到目的地的路径肯定有很多。<br />**如果路由表里有很多项都被匹配上了，会怎么选？**<br />如果多个路由项都能到目的地，那就优先选**匹配长度更长**的那个。比如，还是目的地192.168.1.11，发现路由表里的**192.168.1**.0/**24** 和 **192.168**.0.0/**16**都能匹配上，但明显**前者匹配长度更长**，所以最后会走 **192.168.1**.0/**24**对应的转发端口。<br />**但如果两个表项的匹配长度都一样呢？**<br />那就会看生成这个路由表项的**协议**是啥，选优先级高的，优先级越高也就是所谓的**管理距离**（**AD**，**A**dministrative**D**istance）越小。比如说优先选**手动配**的静态（**static**）路由，次优选**OSPF**动态学习过来的表项。<br />如果还是相同，就看**度量值metrics**，其实也就是**路径成本cost**，成本越小，越容易被选中。<br />**路由器能选的路线有很多，但按道理，最优的只有"一条"，所以到这里为止，都可以认为，对于同一个目的地，ping和TCP走的路径是相同的。**<br />但是。<br />**如果连路径成本都一样呢？**也就是说有多条最优路径呢。<br />**那就都用**。<br />这也就是所谓的**等价多路径，ECMP**（**E**qual **C**ost **M**ulti**P**ath）。<br />可以通过`traceroute`看下链路是否存在等价多路径的情况。<br />![](https://cdn.nlark.com/yuque/0/2022/png/396745/1662081329152-b967f721-50f5-4773-9d03-d1536f3848c3.png#clientId=u4f02e68b-ac86-4&from=paste&id=u714016f5&originHeight=333&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u94f862ba-f60a-4749-bccf-f3ac3d13d58&title=)<br />可以看到，中间某几行，有**好几个IP**，也就是说这一跳里同时可以选好几个目的机器，说明这段路径**支持ECMP**。
<a name="XwFbI"></a>
### ECMP有什么用
利用等价多路径，**可以增加链路带宽**。<br />举个例子。<br />![没有ECMP时只能选择某一条路径](https://cdn.nlark.com/yuque/0/2022/png/396745/1662081329267-1dbe46d5-ff9d-4b7f-ad08-71afb785815b.png#clientId=u4f02e68b-ac86-4&from=paste&id=u7bd8b38b&originHeight=360&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=u9e92d575-291d-49d6-90a2-eff60a89026&title=%E6%B2%A1%E6%9C%89ECMP%E6%97%B6%E5%8F%AA%E8%83%BD%E9%80%89%E6%8B%A9%E6%9F%90%E4%B8%80%E6%9D%A1%E8%B7%AF%E5%BE%84 "没有ECMP时只能选择某一条路径")<br />从A点到B点，如果这两条路径成本不同，带宽都是1千兆。那数据包肯定就选成本低的那条路了，如果这条路出故障了，就走下面那条路。但不管怎么样，**同一时间，只用到了一条路径**。另外一条闲置就有些浪费了，有没有办法可以利用起来呢？<br />有，将它们两条路径的成本设置成一样，那它们就成了等价路由，然后中间的路由器开启**ECMP**特性，就可以同时利用这两条链路了。带宽就从原来的1千兆变成了2千兆。数据就可以在两条路径中随意选择了。<br />![利用ECMP可以同时使用两条链路](https://cdn.nlark.com/yuque/0/2022/png/396745/1662081329654-1e12e735-0a71-4e0b-8b12-9062710b0d47.png#clientId=u4f02e68b-ac86-4&from=paste&id=u3b4ca63c&originHeight=360&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=u4f85ae60-5bf0-4ebf-8258-425d6f78b40&title=%E5%88%A9%E7%94%A8ECMP%E5%8F%AF%E4%BB%A5%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8%E4%B8%A4%E6%9D%A1%E9%93%BE%E8%B7%AF "利用ECMP可以同时使用两条链路")<br />但这也带来了另外一个问题。**加剧了数据包乱序**。<br />原来只使用一条网络路径，数据依次发出，如无意外，也是依次到达。<br />现在两个数据包走两条路径，先发的数据包可能后到。这就乱序了。<br />那么问题又又来了。
<a name="eUkEe"></a>
### 乱序会有什么问题？
对于最最最常使用的TCP协议来说，它是个可靠性网络的协议，这里提到的**可靠**，不仅是保证数据要能送到目的地，还要保证**数据顺序**要跟原来发送端的一样。<br />实现也很简单，**TCP为每个数据包（segment）做上编号**。数据到了接收端后，根据**数据包编号**发现是**乱序数据包**，就会扔到**乱序队列**中对数据包进行排序。如果前面的数据包还没到，哪怕后面的数据包先到了，也得在乱序队列中一直等，到齐后才能被上层拿到。<br />举个例子，发送端发出三个数据包，编号1,2,3，假设在**传输层**2和3先到了，1还没到。那此时**应用层**是没办法拿到2和3的数据包的，必须得等1来了之后，**应用层才能一次性拿到这三个包**。因为这三个包原来可能表示的是一个完整的消息，少了1, 那么**消息就不完整**，应用层拿到了也毫无意义。<br />像这种，由于**前面的数据丢失**导致**后面的数据没办法及时给到应用层**的现象，就是常说的**TCP队头阻塞**。<br />![乱序队列等待数据包的到来](https://cdn.nlark.com/yuque/0/2022/png/396745/1662081329696-baa261f4-54c1-401d-890f-47ef57625d08.png#clientId=u4f02e68b-ac86-4&from=paste&id=u39214ef8&originHeight=360&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=ue63744a7-6304-42ae-bf3f-79b1ad696bf&title=%E4%B9%B1%E5%BA%8F%E9%98%9F%E5%88%97%E7%AD%89%E5%BE%85%E6%95%B0%E6%8D%AE%E5%8C%85%E7%9A%84%E5%88%B0%E6%9D%A5 "乱序队列等待数据包的到来")<br />乱序发生时2和3需要待在乱序队列中，而**乱序队列其实用的也是接收缓冲区的内存**，而**接收缓冲区是有大小限制的**。通过下面的命令可以看到接收缓冲区的大小。
```bash
# 查看接收缓冲区
$ sysctl net.ipv4.tcp_rmem
net.ipv4.tcp_rmem = 4096(min)    87380(default)  6291456(max)
# 缓冲区会在min和max之间动态调整
```
乱序的情况越多，接收缓冲区的内存就被占用的越多，对应的**接收窗口**就会变小，那正常能收的数据就变少了，**网络吞吐就变差**了，也就是性能变差了。<br />因此，需要尽量保证所有**同一个TCP连接下的所有TCP包都走相同路径，这样才能最大程度避免丢包**。
<a name="t1lrf"></a>
### ECMP的路径选择策略
**当初开启ECMP就是为了提升性能，现在反而加重了乱序，降低了TCP传输性能。**<br />这怎么能忍。<br />为了解决这个问题，需要有一个合理的路径选择策略。为了避免同一个连接里的数据包乱序，需要保证同一个连接里的数据包，都走同样的路径。<br />这好办。可以通过连接的**五元组**（发送方的**IP**和**端口**，接收方的**IP**和**端口**，以及通信**协议**）信息定位到唯一一条连接。<br />![五元组](https://cdn.nlark.com/yuque/0/2022/png/396745/1662081330004-bf07925c-fc39-4044-bb42-b9784e00c20a.png#clientId=u4f02e68b-ac86-4&from=paste&id=u18a91c46&originHeight=450&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=u639b31ce-3de6-449f-9939-91bf55a853d&title=%E4%BA%94%E5%85%83%E7%BB%84 "五元组")<br />然后对五元组信息生成哈希键，让同一个哈希键的数据走同一条路径，问题就完美解决了。<br />![五元组映射成hash键](https://cdn.nlark.com/yuque/0/2022/png/396745/1662081330006-1e11dc74-dbef-47f8-83b0-e3b360227ea5.png#clientId=u4f02e68b-ac86-4&from=paste&id=ue1a7ff61&originHeight=339&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=u26fbfc81-35a3-4035-9ade-9b7f4811dee&title=%E4%BA%94%E5%85%83%E7%BB%84%E6%98%A0%E5%B0%84%E6%88%90hash%E9%94%AE "五元组映射成hash键")<br />![根据五元组选择ECMP路径](https://cdn.nlark.com/yuque/0/2022/png/396745/1662081330046-78034d31-8d4e-44bd-96a1-266d2f7d54f2.png#clientId=u4f02e68b-ac86-4&from=paste&id=u43b1bec3&originHeight=376&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=ubd0344ca-3fa7-4e79-8349-a4a7cb6fe7c&title=%E6%A0%B9%E6%8D%AE%E4%BA%94%E5%85%83%E7%BB%84%E9%80%89%E6%8B%A9ECMP%E8%B7%AF%E5%BE%84 "根据五元组选择ECMP路径")
<a name="v1mn0"></a>
## TCP和Ping走的网络路径一样吗
现在回到开头的问题。<br />对于同样的发送端和接收端，**TCP和Ping走的网络路径一样吗？**<br />不一定一样，因为**五元组**里的信息里有一项是**通信协议**。ping用的是**ICMP协议**，跟**TCP协议**不同，并且ping不需要用到端口，所以五元组不同，生成的**哈希键不同**，通过ECMP选择到的路径也可能不同。<br />![TCP和ping的五元组差异](https://cdn.nlark.com/yuque/0/2022/png/396745/1662081330156-61778612-ea96-453d-9a24-f382e423670f.png#clientId=u4f02e68b-ac86-4&from=paste&id=u88c575bd&originHeight=338&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=u967017fa-b8fd-48d3-977a-7f70d629b65&title=TCP%E5%92%8Cping%E7%9A%84%E4%BA%94%E5%85%83%E7%BB%84%E5%B7%AE%E5%BC%82 "TCP和ping的五元组差异")
<a name="uuqt4"></a>
## 同样都用TCP协议，数据包走的网络路径一样吗
还是同样的发送端和接收端，同样是TCP协议，不同TCP连接走的网络路径是一样的吗？<br />跟上面的问题一样，其实**还是五元组的问题**，同样都是TCP协议，对于同样的发送端和接收端，他们的IP和接收端的端口肯定是一样的，但**发送方的端口是可以随时变化**的，因此通过ECMP走的路径也可能不同。<br />![不同TCP连接的五元组差异](https://cdn.nlark.com/yuque/0/2022/png/396745/1662081330319-22db3860-4031-4ed1-aa3d-545e37b42771.png#clientId=u4f02e68b-ac86-4&from=paste&id=u470f7920&originHeight=338&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=ud4792650-689f-4d7b-b143-6691f669242&title=%E4%B8%8D%E5%90%8CTCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%BA%94%E5%85%83%E7%BB%84%E5%B7%AE%E5%BC%82 "不同TCP连接的五元组差异")<br />但问题又来了。**知道这个有什么用呢？做业务开发，又没有设置网络路由的权限。**
<a name="UghbQ"></a>
## 利用这个知识点排查问题
对于业务开发，这绝对不是个没用的知识点。<br />如果某天，发现能ping通目的机器，但用TCP去连，却**偶尔连不上**目的机器。而且两端机器都挺空闲，没什么性能上的瓶颈。实在**走投无路**了。<br />就可以想想，会不会是网络中用到了ECMP，其中一条链路有问题导致的。<br />![ping能成功但部分TCP连接失败](https://cdn.nlark.com/yuque/0/2022/png/396745/1662081330430-0f6aac76-f926-42a6-99ce-8049d8408211.png#clientId=u4f02e68b-ac86-4&from=paste&id=u785497d0&originHeight=423&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=u8a599662-1394-43f1-8eb2-141b304e037&title=ping%E8%83%BD%E6%88%90%E5%8A%9F%E4%BD%86%E9%83%A8%E5%88%86TCP%E8%BF%9E%E6%8E%A5%E5%A4%B1%E8%B4%A5 "ping能成功但部分TCP连接失败")<br />排查方法也很简单。<br />知道本机的IP以及目的机器的IP和端口号的，也知道自己用的是TCP连接。<br />只要在**报错的时候打印下错误信息，就知道了发送端的端口号了。**<br />这样**五元组**是啥就知道了。<br />下一步就是**指定发送端的端口号重新发起TCP请求，同样的五元组，走同样的路径，按理说如果链路有问题，就肯定会复现。**<br />如果不想改自己的代码，可以用`**nc**`**命令指定客户端端口**看下能不能正常建立TCP连接。
```bash
nc -p 6666 baidu.com 80
```
`-p 6666`是指定发出请求的客户端端口是6666，后面跟着的是**连接的域名**和**80端口**。<br />![通过nc成功建立tcp连接](https://cdn.nlark.com/yuque/0/2022/png/396745/1662081330472-348da319-cecb-4c0a-aa33-d864845b327e.png#clientId=u4f02e68b-ac86-4&from=paste&id=u01b0bbe1&originHeight=148&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=true&status=done&style=none&taskId=u2669d0fe-7158-4a24-baa4-ab1ef795199&title=%E9%80%9A%E8%BF%87nc%E6%88%90%E5%8A%9F%E5%BB%BA%E7%AB%8Btcp%E8%BF%9E%E6%8E%A5 "通过nc成功建立tcp连接")<br />假设用了6666端口的五元组去连接**总是失败**，改用6667或其他端口**却能成功**，可以带着这个信息去找找负责网络的同事。
<a name="oVdfT"></a>
## 总结

- 路由器可以通过OSPF协议生成路由表，利用数据包里的IP地址去跟路由表做匹配，选择最优路径后进行转发。
- 当路由表一个都匹配不上时会走默认网关。当匹配上多个的时候，会先看**匹配长度**，如果一样就看**管理距离**，还一样就看**路径成本**。如果连路径成本都一样，那**等价路径**。如果路由开启了ECMP，那就可以同时利用这几条路径做传输。
- ECMP可以提高链路带宽，同时利用五元组做哈希键进行路径选择，保证了同一条连接的数据包走同一条路径，减少了乱序的情况。
- 可以通过traceroute命令查看到链路上是否有用到ECMP的情况。
- 开启了ECMP的网络链路中，TCP和ping命令可能走的路径不同，甚至同样是TCP，不同连接之间，走的路径也不同，因此出现了连接时好时坏的问题，实在是走投无路了，可以考虑下是不是跟ECMP有关。
- 当然，**遇到问题多怀疑自己，要相信绝大部分时候真的跟ECMP无关**。
