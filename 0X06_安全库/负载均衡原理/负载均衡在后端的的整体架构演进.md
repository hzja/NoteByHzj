网络 负载均衡<br />李大牛创业了，由于前期没啥流量，所以他只部署了一台 tomcat server，让客户端将请求直接打到这台 server 上<br />![2021-09-03-10-21-34-934422.jpeg](https://cdn.nlark.com/yuque/0/2021/jpeg/396745/1630635708664-5dfff393-0893-4bc9-82e6-8b9433605d48.jpeg#clientId=u7bb12925-10fc-4&from=ui&id=u05af8eea&originHeight=238&originWidth=562&originalType=binary&ratio=1&size=6165&status=done&style=shadow&taskId=u8b9b687e-6a07-440e-b8e7-606054f72fb)<br />这样部署一开始也没啥问题，因为业务量不是很大，单机足以扛住，但后来李大牛的业务踩中了风口，业务迅猛发展，于是单机的性能逐渐遇到了瓶颈，而且由于只部署了一台机器，这台机器挂掉了业务也就跌零了，这可不行，所以为了避免单机性能瓶颈与解决单点故障的隐患，李大牛决定多部署几台机器（假设为三台），这样可以让 client 随机打向其中的一台机器，这样就算其中一台机器挂了，另外的机器还存活，让 client 打向其它没有宕机的机器即可<br />![2021-09-03-10-21-34-996905.jpeg](https://cdn.nlark.com/yuque/0/2021/jpeg/396745/1630635708651-a88a6743-a549-4506-9382-e7f2c4944add.jpeg#clientId=u7bb12925-10fc-4&from=ui&id=RzGwO&originHeight=542&originWidth=562&originalType=binary&ratio=1&size=10345&status=done&style=shadow&taskId=u89962b93-c5b1-4df7-92b0-e31cc6b7fd5)<br />现在问题来了，client 到底该打向这三台机器的哪一台呢，如果让 client 来选择肯定不合适，因为如果让 client 来选择具体的 server，那么它必须知道有哪几台 server，然后再用轮询等方式随机连接其中一台机器，但如果其中某台 server 宕机了，client 是无法提前感知到的，那么很可能 client 会连接到这台挂掉的 server 上，所以选择哪台机器来连接的工作最好放在 server 中，具体怎么做呢，在架构设计中有个经典的共识：没有什么是加一层解决不了的，如果有那就再加一层，所以在 server 端再加一层，将其命名为 LB（Load Balance，负载均衡），由 LB 统一接收 client 的请求，然后再由它来决定具体与哪一个 server 通信，一般业界普遍使用 Nginx 作为 LB<br />![2021-09-03-10-21-35-059400.jpeg](https://cdn.nlark.com/yuque/0/2021/jpeg/396745/1630635708664-d26b8c91-8bbb-4894-a8a4-b4183392acd8.jpeg#clientId=u7bb12925-10fc-4&from=ui&id=kAnin&originHeight=542&originWidth=782&originalType=binary&ratio=1&size=20328&status=done&style=shadow&taskId=u5d6098e0-7e31-42a4-ad3e-2b073ae75c9)<br />采用这样的架构设计总算支撑了业务的快速增长，但随后不久李大牛发现这样的架构有点问题：所有的流量都能打到  server 上，这显然是有问题的，不太安全，那能不能在流量打到 server 前再做一层鉴权操作呢，鉴权通过了才让它打到 server 上，把这一层叫做网关（为了避免单点故障，网关也要以集群的形式存在）<br />![2021-09-03-10-21-35-121929.jpeg](https://cdn.nlark.com/yuque/0/2021/jpeg/396745/1630635735272-2127dada-0563-492c-ae11-3a08354d7de1.jpeg#clientId=u7bb12925-10fc-4&from=ui&id=ua2cbb9d7&originHeight=542&originWidth=942&originalType=binary&ratio=1&size=27218&status=done&style=shadow&taskId=u7dcad1f9-74f7-45af-9773-6099312a3be)<br />这样的话所有的流量在打到  server 前都要经过网关这一层，鉴权通过后才把流量转发到 server 中，否则就向 client 返回报错信息，除了鉴权外，网关还起到风控（防止羊毛党），协议转换（比如将 HTTP 转换成 Dubbo），流量控制等功能，以最大程度地保证转发给 server 的流量是安全的，可控的。<br />这样的设计持续了很长一段时间，但是后来李大牛发现这样的设计其实还是有问题，不管是动态请求，还是静态资源（如 js，css文件）请求都打到 tomcat 了，这样在流量大时会造成 tomcat 承受极大的压力，其实对于静态资源的处理 tomcat 不如 Nginx，tomcat 每次都要从磁盘加载文件比较影响性能，而 Nginx 有 proxy  cache 等功能可以极大提升对静态资源的处理能力。<br />画外音：所谓的 proxy cache 是指 nginx 从静态资源服务器上获取资源后会缓存在本地的内存+磁盘中，下次请求如果命中缓存就从 Nginx 本机的 Cache 中直接返回了<br />所以李大牛又作了如下优化：如果是动态请求，则经过 gateway 打到 tomcat，如果是 Nginx，则打到静态资源服务器上<br />![2021-09-03-10-21-35-199874.jpeg](https://cdn.nlark.com/yuque/0/2021/jpeg/396745/1630635735318-204ba53c-3f0f-4919-916f-c8fc4ebc40f9.jpeg#clientId=u7bb12925-10fc-4&from=ui&id=THBat&originHeight=722&originWidth=1016&originalType=binary&ratio=1&size=37943&status=done&style=shadow&taskId=u7a57cfa2-d4d3-45dc-9253-ee48ec6cd44)<br />这就是所说的动静分离，将静态请求与动态请求分开，这样 tomcat 就可以专注于处理其擅长的动态请求，而静态资源由于利用到了 Nginx 的  proxy cache 等功能，后端的处理能力又上了一个台阶。<br />另外需要注意的是并不是所有的动态请求都需要经过网关，像运营中心后台由于是内部员工使用的，所以它的鉴权与网关的 api 鉴权并不相同，所以直接部署了两台运营中心的 server ，直接让 Nginx 将运营中心的请求打到了这两台 server 上，绕过了网关。<br />![2021-09-03-10-21-35-277987.jpeg](https://cdn.nlark.com/yuque/0/2021/jpeg/396745/1630635735291-de520c73-d800-4514-9d33-df6e42e8a2a4.jpeg#clientId=u7bb12925-10fc-4&from=ui&id=buFP8&originHeight=842&originWidth=1044&originalType=binary&ratio=1&size=44125&status=done&style=shadow&taskId=u8a519449-2abe-4075-8ae2-e70afc058b9)<br />当然为了避免单点故障 Nginx 也需要部署至少两台机器，于是架构变成了下面这样，Nginx 部署两台，以主备的形式存在，备 Nginx 会通过 keepalived 机制（发送心跳包） 来及时感知到主 Nginx 的存活，发现宕机自己就顶上充当主 Nginx 的角色<br />![2021-09-03-10-21-35-371711.jpeg](https://cdn.nlark.com/yuque/0/2021/jpeg/396745/1630635761775-98d48568-8d1d-4b79-a486-33de85ffdc2d.jpeg#clientId=u7bb12925-10fc-4&from=ui&id=uc74ada90&originHeight=882&originWidth=822&originalType=binary&ratio=1&size=45597&status=done&style=shadow&taskId=ud2584716-2f17-4de9-9272-1765b3e9103)<br />看起来这样的架构确实不错，但要注意的是 Nginx 是七层（即应用 层）负载均衡器 ，这意味着如果它要转发流量首先得和 client 建立一个 TCP 连接，并且转发的时候也要与转发到的上游 server 建立一个 TCP 连接，建立 TCP 连接其实是需要耗费内存（TCP Socket，接收/发送缓存区等需要占用内存）的，客户端和上游服务器要发送数据都需要先发送暂存到到 Nginx 再经由另一端的 TCP 连接传给对方。<br />![2021-09-03-10-21-35-465466.jpeg](https://cdn.nlark.com/yuque/0/2021/jpeg/396745/1630635761772-371df76c-e8a8-4e16-b772-25c501d45bb5.jpeg#clientId=u7bb12925-10fc-4&from=ui&id=fh5Im&originHeight=162&originWidth=962&originalType=binary&ratio=1&size=15676&status=done&style=shadow&taskId=u27fe5251-3fe4-4e56-88ab-b09ae5a54be)<br />所以 Nginx 的负载能力受限于机器I/O，CPU内存等一系列配置，一旦连接很多（比如达到百万）的话，Nginx 抗负载能力就会急遽下降。<br />经过分析可知 Nginx 的负载能力较差主要是因为它是七层负载均衡器必须要在上下游分别建立两个 TCP 所致，那么是否能设计一个类似路由器那样的只负载转发包但不需要建立连接的负载均衡器呢，这样由于不需要建立连接，只负责转发包，不需要维护额外的 TCP 连接，它的负载能力必然大大提升，于是四层负载均衡器 LVS 就诞生了，简单对比下两者的区别<br />![2021-09-03-10-21-35-543639.jpeg](https://cdn.nlark.com/yuque/0/2021/jpeg/396745/1630635761785-62a6f5de-a2c6-4ddc-9229-3ae0258cf938.jpeg#clientId=u7bb12925-10fc-4&from=ui&id=tyA6m&originHeight=480&originWidth=1002&originalType=binary&ratio=1&size=35428&status=done&style=shadow&taskId=u24d34854-6e8d-495d-b040-98f829a0f31)<br />可以看到  LVS 只是单纯地转发包，不需要和上下游建立连接即可转发包，相比于 Nginx 它的抗负载能力强、性能高（能达到 F5 硬件的 60%），对内存和cpu资源消耗比较低<br />那么四层负载均衡器是如何工作的呢<br />负载均衡设备在接收到第一个来自客户端的SYN 请求时，即通过负载均衡算法选择一个最佳的服务器，并对报文中目标IP地址进行修改(改为后端服务器 IP ），直接转发给该服务器。TCP 的连接建立，即三次握手是客户端和服务器直接建立的，负载均衡设备只是起到一个类似路由器的转发动作。在某些部署情况下，为保证服务器回包可以正确返回给负载均衡设备，在转发报文的同时可能还会对报文原来的源地址进行修改。<br />综上所述，在 Nginx 上再加了一层 LVS，以让它来承接所有流量，当然为了保证 LVS 的可用性，也采用主备的方式部署 LVS，另外采用这种架构如果 Nginx 容量不够可以很方便地进行水平扩容，于是架构改进如下：<br />![2021-09-03-10-21-35-652974.jpeg](https://cdn.nlark.com/yuque/0/2021/jpeg/396745/1630635826224-b5eef30d-9b29-4d09-ad35-79d4588beacf.jpeg#clientId=u7bb12925-10fc-4&from=ui&id=u08cde31f&originHeight=1122&originWidth=1032&originalType=binary&ratio=1&size=59849&status=done&style=shadow&taskId=u0efd0af2-d992-4213-95de-f3c8d51004e)<br />当然只有一台 LVS 的话在流量很大的情况下也是扛不住的，怎么办，多加几台啊，使用 DNS 负载均衡，在 DNS 服务器解析域名的时候随机打到其中一台 LVS 不就行了<br />![2021-09-03-10-21-35-777966.jpeg](https://cdn.nlark.com/yuque/0/2021/jpeg/396745/1630635826229-99308867-fd18-460f-9059-bc2da70a48b0.jpeg#clientId=u7bb12925-10fc-4&from=ui&id=pUxho&originHeight=890&originWidth=846&originalType=binary&ratio=1&size=69250&status=done&style=shadow&taskId=u0be07dcf-bcd0-4622-a15d-208c792613f)<br />通过这样的方式终于可以让流量稳定流转了，有个点可能一些朋友会有疑问，下面一起来看看<br />既然 LVS 可以采用部署多台的形式来避免单点故障，那 Nginx 也可以啊，而且 Nginx 在 1.9 之后也开始支持四层负载均衡了，所以貌似 LVS 不是很有必要？<br />如果不用 LVS 则架构图是这样的<br />![2021-09-03-10-21-35-856116.jpeg](https://cdn.nlark.com/yuque/0/2021/jpeg/396745/1630635826232-c9875669-6e54-4380-972e-03c852edfafd.jpeg#clientId=u7bb12925-10fc-4&from=ui&id=ueW6U&originHeight=692&originWidth=840&originalType=binary&ratio=1&size=54503&status=done&style=shadow&taskId=u10f0dde9-10d8-491c-a2cc-46d8f39f83c)<br />通过部署多台 Nginx 的方式在流量不是那么大的时候确实是可行，但 LVS 是 Linux 的内核模块，工作在内核态，而 Nginx 工作在用户态，也相对比较重，所以在性能和稳定性上 Nginx 是不如 LVS 的，这就是为什么要采用 LVS + Nginx 的部署方式。<br />另外相信大家也注意到了，如果流量很大时，静态资源应该部署在 CDN 上， CDN 会自动选择离用户最近的节点返回给用户，所以最终的架构改进如下<br />![2021-09-03-10-21-35-934244.jpeg](https://cdn.nlark.com/yuque/0/2021/jpeg/396745/1630635851548-28d516a6-a946-4b9d-a37c-631ea85b9fe6.jpeg#clientId=u7bb12925-10fc-4&from=ui&id=u44216448&originHeight=1130&originWidth=894&originalType=binary&ratio=1&size=76569&status=done&style=shadow&taskId=u46c7be70-2623-4532-b0e4-6d1fab79088)
<a name="U0fkT"></a>
### 总结
架构一定要结合业务的实际情况来设计，脱离业务谈架构其实是耍流氓，可以看到上文每一个架构的衍化都与业务发展息息相关，对于中小型流量没有那么大的公司，其实用 Nginx 作为负载均衡足够，在流量迅猛增长后则考虑使用 lvs+nginx，当然像美团这样的巨量流量（数十 Gbps的流量、上千万的并发连接），lvs 也不管用了（实测虽然使用了 lvs 但依然出现了不少丢包的现象）所以它们开发出了自己的一套四层负载均衡器 MGW<br />另外看了本文相信大家对分层的概念应该有更透彻的理解，没有什么是分层解决不了的事，如果有，那就再多加一层，分层使每个模块各司其职，功能解藕，而且方便扩展，大家很熟悉的 TCP/IP 就是个很好的例子，每层只管负责自己的事，至于下层是什么实现的上层是不 care 的
<a name="JSIwG"></a>
### 关于一些疑问
先看下展示的架构图<br />![](https://cdn.nlark.com/yuque/0/2021/webp/396745/1630636148734-3b1094ed-d6c4-479c-8a66-13cd450c4882.webp#clientId=u5401aca0-bc04-4&from=paste&id=u7d81a890&originHeight=1130&originWidth=894&originalType=url&ratio=1&status=done&style=shadow&taskId=u8d778010-6433-497b-a85a-47159a84c17)<br />这里一些朋友的疑问点是 Nginx 是否多此一举，能否能直接从 LVS 打到站点层？即改成下面的架构<br />![](https://cdn.nlark.com/yuque/0/2021/webp/396745/1630636148944-a659f31a-267d-4132-8db3-fb13ac7c11f4.webp#clientId=u5401aca0-bc04-4&from=paste&id=uecbbf2d4&originHeight=1037&originWidth=834&originalType=url&ratio=1&status=done&style=shadow&taskId=u4dd5c7b1-ef12-4e6f-8394-0a11d41dd6f)<br />答案是不行，为什么？其实在上文中有提到一些点已经暗示了，只不过不那么明显而已，再单独把这些点拎出来

1. LVS 是四层负载均衡器
2. Nginx 是七层负载均衡器，可以根据 url 来转发流量

首先需要明白为什么根据 url 转发请求这么重要，假设现在有「营销」，「运营中心」这两个集群，使用 Nginx 的话很简单，根据 url 来决定到底将请求转发到哪个集群即可<br />![](https://cdn.nlark.com/yuque/0/2021/webp/396745/1630636148835-0dd751cd-b6cb-482b-8299-d68907caf41e.webp#clientId=u5401aca0-bc04-4&from=paste&id=ue47110a0&originHeight=662&originWidth=922&originalType=url&ratio=1&status=done&style=shadow&taskId=ucbb7b932-b8a0-4866-9fd3-e63f5ee5b5c)<br />由于 LVS 不能根据 url 转发，那么请问 LVS 收到请求后该转给谁<br />那么 LVS 为什么不能根据 url 来转发呢，因为它是四层负载均衡器，什么是四层和七层，这里就要简单复习下 ISO 七层参考模型了<br />![](https://cdn.nlark.com/yuque/0/2021/webp/396745/1630636148791-e48aabf5-267e-430f-9b02-962603c2b6af.webp#clientId=u5401aca0-bc04-4&from=paste&id=u60e993d8&originHeight=562&originWidth=362&originalType=url&ratio=1&status=done&style=shadow&taskId=u5e386423-73a9-45fb-aafd-8a39bc062ee)<br />由此可知，七层对应着应用层，四层对应着传输层，如果从应用层发起一个请求会在「传输层」,「网络层」,「数据链路层」分别加上各自层的包头，比如现在 A 电脑要发一个「I'm Deepon」数据给 B 电脑，则在各层的转化流程如下图所示<br />![](https://cdn.nlark.com/yuque/0/2021/webp/396745/1630636148870-2df43c0c-f0bb-45ca-943e-ec9f1c7f0823.webp#clientId=u5401aca0-bc04-4&from=paste&id=u0a61a6b6&originHeight=776&originWidth=772&originalType=url&ratio=1&status=done&style=shadow&taskId=u92f0c997-36e1-4fc4-a271-4b78bf67a09)<br />但最终在互联网上要传输的包（数据链路层传输的包叫祯，统称为包）是有大小限制的，如下图所示<br />![2021-09-03-10-30-38-295454.jpeg](https://cdn.nlark.com/yuque/0/2021/jpeg/396745/1630636252378-462a62d1-1a00-4ca2-b9cb-49e633f9695e.jpeg#clientId=u5401aca0-bc04-4&from=ui&id=uc2764266&originHeight=376&originWidth=1080&originalType=binary&ratio=1&size=27234&status=done&style=shadow&taskId=u85ef5b56-dfc2-47bb-95f0-73c1fb4153d)<br />在互联网上传输的包不能超过 14 + 20 + 20 + 1460 + 4 = 1518 byte，其中包含的应用层（即 payload）数据一次性不能超过 1460 个 byte,也就是说如果一个 HTTP 请求有 2000 byte，那么它必须分成两个包发送才能在网络上传输，再来看看 HTTP 的格式<br />![2021-09-03-10-30-38-420483.jpeg](https://cdn.nlark.com/yuque/0/2021/jpeg/396745/1630636252389-b155a1d9-a15a-40b4-954c-9571cc3d9e98.jpeg#clientId=u5401aca0-bc04-4&from=ui&id=FmGAr&originHeight=344&originWidth=749&originalType=binary&ratio=1&size=27772&status=done&style=shadow&taskId=ufdd296fe-e542-456d-ac0f-66663fd51bc)<br />如果一个 HTTP POST 请求很大，超过了 1460 byte（一个包 payload 的最大值），那么它必须分成两个包才能传输，也就意味着一个包可能包含 URI，另一个包不包含 URI，既然包都不包含 URI，那么请问 LVS 如何根据 URL 来转发给相应的集群呢，所以理解了 TCP/IP 的工作机制相信不难理解开头的问题：LVS 是四层负载均衡器，无法根据 URL 来转发请求。<br />其实最关键的原因是四层以下其实只负责包的转发，只要拿出包头查看一下 ip 地址就可知道该转发哪里，很高效，如果还要根据 url 来匹配那么需要拿到应用层数据根据正则等做匹配，显然会消耗更多的性能，所以专业的人做专业的事，应该由 LVS 来负责承载所有流量，Nginx 负责根据 url 来转发给对应的集群，因为它是七层负载均衡器，与上下游各建立了一个 TCP 链接<br />![2021-09-03-10-30-38-482979.jpeg](https://cdn.nlark.com/yuque/0/2021/jpeg/396745/1630636252396-9a3b9d7f-9d27-4c4e-a694-ee823865ec69.jpeg#clientId=u5401aca0-bc04-4&from=ui&id=HhZZP&originHeight=162&originWidth=962&originalType=binary&ratio=1&size=15676&status=done&style=shadow&taskId=ue66f7131-d0b3-4990-9d28-5fed91fd155)<br />所以如果有多个分包，由于 Nginx 与 client 建立了 TCP 连接，可以在 Nginx 先拿到 client 发出的所有的分包再组装成完整的报文， 然后根据 url 选择其中一台 server 与之建立 TCP 连接后将数据分批完整地传给上游 server<br />另外需要注意的是现在在大厂中如果只将 Nginx 作为转发之用是不够的，一般用的 OpenResty ，什么是 OpenResty 呢
> “OpenResty® 是一个基于 Nginx 与 Lua 的高性能 Web 平台，其内部集成了大量精良的 Lua 库、第三方模块以及大多数的依赖项。用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关。
> OpenResty® 的目标是让 Web 服务直接跑在 Nginx 服务内部，充分利用 Nginx 的非阻塞 I/O 模型，不仅仅对 HTTP 客户端请求,甚至于对远程后端诸如 MySQL、PostgreSQL、Memcached 以及 Redis 等都进行一致的高性能响应。”

注意上面一句「提供了与 MySQL ，Redis 等的交互能力」这一点非常关键，之前不是说 Nginx 可以根据 url 来决定打向哪个集群吗，假设现在有一个这样的场景：所有包含 operation 的请求都转发到运营中心的集群，则需要写死类似如下的配置
```nginx
upstream backend {
  server 192.168.1.10:8080
  server 192.168.1.11:8080
}

server {
  location /operation {
    proxy_pass http://backed
  }
}
```
在大集团中类似这样的规则非常多，难道要像上面这样把所有的规则都一个个写死在 Nginx 的配置文件里吗？显然不可行，更合理的方式是把这些规则（哪个 url 对应哪些集群）保存在 MySQL 中，然后 Nginx 在启动的时候将这些规则从 MySQL 中取出并保存在 Redis 及本地缓存中，然后 Nginx 要根据 url 匹配的时候从本地缓存（如果没有从 redis 拿，redis 过期从 MySQL 拿）里拿这些规则再根据匹配项转发到相应的集群，Nginx 没有这样的能力，而 OpenResty 由于集成了 Lua，引入了与 MySQL， Redis 等交互的模块，所以用它是可行的，所以最终架构如下（将 Nginx 换成 OpenResty）<br />![2021-09-03-10-30-38-639076.jpeg](https://cdn.nlark.com/yuque/0/2021/jpeg/396745/1630636252425-b448d423-f760-48fa-86e7-da90eba10511.jpeg#clientId=u5401aca0-bc04-4&from=ui&id=ctpZQ&originHeight=1130&originWidth=894&originalType=binary&ratio=1&size=78277&status=done&style=shadow&taskId=u6a1a4315-ebf6-4358-a3af-3d375ef48df)
